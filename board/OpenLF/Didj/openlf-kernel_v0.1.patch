diff -ruaN linux-2.6.31/arch/arm/boot/compressed/head.S linux-2.6/arch/arm/boot/compressed/head.S
--- linux-2.6.31/arch/arm/boot/compressed/head.S	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/boot/compressed/head.S	2011-01-04 13:50:21.000000000 -0800
@@ -162,6 +162,13 @@
 		.text
 		adr	r0, LC0
 		ldmia	r0, {r1, r2, r3, r4, r5, r6, ip, sp}
+
+#ifdef CONFIG_RUNTIME_PHYS_OFFSET
+		and	r10, pc, #0xf0000000	@ fix up zreladdr at runtime
+		and	r4, r4,  #0x0fffffff
+		add	r4, r4, r10
+#endif
+
 		subs	r0, r0, r1		@ calculate the delta offset
 
 						@ if delta is zero, we are
diff -ruaN linux-2.6.31/arch/arm/boot/compressed/Makefile linux-2.6/arch/arm/boot/compressed/Makefile
--- linux-2.6.31/arch/arm/boot/compressed/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/boot/compressed/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -74,16 +74,13 @@
 EXTRA_CFLAGS  := -fpic -fno-builtin
 EXTRA_AFLAGS  := -Wa,-march=all
 
-# Supply ZRELADDR, INITRD_PHYS and PARAMS_PHYS to the decompressor via
-# linker symbols.  We only define initrd_phys and params_phys if the
+# Suppy ZRELADDR and PARAMS_PHYS to the decompressor via
+# linker symbols.  We only define params_phys if the
 # machine class defined the corresponding makefile variable.
 LDFLAGS_vmlinux := --defsym zreladdr=$(ZRELADDR)
 ifeq ($(CONFIG_CPU_ENDIAN_BE8),y)
 LDFLAGS_vmlinux += --be8
 endif
-ifneq ($(INITRD_PHYS),)
-LDFLAGS_vmlinux += --defsym initrd_phys=$(INITRD_PHYS)
-endif
 ifneq ($(PARAMS_PHYS),)
 LDFLAGS_vmlinux += --defsym params_phys=$(PARAMS_PHYS)
 endif
diff -ruaN linux-2.6.31/arch/arm/boot/compressed/misc.c linux-2.6/arch/arm/boot/compressed/misc.c
--- linux-2.6.31/arch/arm/boot/compressed/misc.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/boot/compressed/misc.c	2011-01-27 15:13:43.000000000 -0800
@@ -16,6 +16,9 @@
  *  This allows for a much quicker boot time.
  */
 
+/* ignore runtime version of virt_to_phys() and phys_to_virt() routines */
+#undef CONFIG_RUNTIME_PHYS_OFFSET
+
 unsigned int __machine_arch_type;
 
 #include <linux/compiler.h>	/* for inline */
@@ -329,7 +332,45 @@
 
 	makecrc();
 	putstr("Uncompressing Linux...");
+	/* 1=Ping oscilloscope */
+	if (0)
+	{
+#define REG32(addr) *((volatile u32 *)(addr))
+#define BIT_SET(v,b)	(v |= (1<<(b)))
+#define BIT_CLR(v,b)	(v &= ~(1<<(b)))
+#define GPIO32(x)       REG32(LF1000_GPIO_BASE+x)
+#define GPIO_PORT_B 1
+#define GPIO_PIN8 8
+#define GPIO_GPIOFN 0
+#define GPIOAALTFN0		0x20
+#define GPIOAOUT		0x00
+#define GPIOAOUTENB		0x04
+		u32 reg, pin, tmp;
+		reg = GPIOAALTFN0 + GPIO_PORT_B*0x40;
+		pin = GPIO_PIN8*2;
+		tmp = GPIO32(reg);
+		tmp &= ~(3<<pin);
+		tmp |= ((GPIO_GPIOFN)<<pin);
+		GPIO32(reg) = tmp;
+		pin = GPIO_PIN8;
+		reg = GPIOAOUT + GPIO_PORT_B*0x40;
+		BIT_SET(GPIO32(reg), pin);
+		reg = GPIOAOUTENB + GPIO_PORT_B*0x40;
+		BIT_SET(GPIO32(reg), pin);
+		reg = GPIOAOUT + GPIO_PORT_B*0x40;
+		BIT_SET(GPIO32(reg), pin);
+	}
 	gunzip();
+	/* Ping oscilloscope */
+	if (0)
+	{
+		u32 reg, pin;
+		pin = GPIO_PIN8;
+		reg = GPIOAOUT + GPIO_PORT_B*0x40;
+		BIT_CLR(GPIO32(reg), pin);
+		reg = GPIOAOUT + GPIO_PORT_B*0x40;
+		BIT_SET(GPIO32(reg), pin);
+	}
 	putstr(" done, booting the kernel.\n");
 	return output_ptr;
 }
diff -ruaN linux-2.6.31/arch/arm/configs/lf1000_ts_defconfig linux-2.6/arch/arm/configs/lf1000_ts_defconfig
--- linux-2.6.31/arch/arm/configs/lf1000_ts_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/configs/lf1000_ts_defconfig	2011-08-01 18:29:09.000000000 -0700
@@ -0,0 +1,1543 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Mon Dec 13 14:19:49 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_RUNTIME_PHYS_OFFSET=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-leapfrog"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+CONFIG_ARCH_LF1000=y
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# LF1000 platform type
+#
+# CONFIG_MACH_ME_LF1000 is not set
+CONFIG_MACH_LF_LF1000=y
+# CONFIG_CPU_SPEED_385024000 is not set
+CONFIG_CPU_SPEED_393216000=y
+# CONFIG_CPU_SPEED_532480000 is not set
+CONFIG_LF1000_SCREEN=y
+CONFIG_LF1000_DMA_CONTROLLER=y
+CONFIG_LF1000_LFP100=y
+CONFIG_LF1000_GPIO=y
+# CONFIG_LF1000_GPIO_DEBUG is not set
+CONFIG_LF1000_ADC=y
+CONFIG_LF1000_SDRAM_TUNE=y
+CONFIG_LF1000_BOOT_PARAMS_ADDR=0x00003000
+# CONFIG_LF1000_OVERRIDE_BOARD_ID is not set
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID=y
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID_VALUE=7
+# CONFIG_LF1000_STRESS_TEST is not set
+CONFIG_PLAT_MES=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=16M root=31:04 rw rootflags=noatime rootfstype=jffs2 init=/sbin/init console=ttyS0,115200 ubi.mtd=Brio ubi.mtd=prg_Brio ubi.mtd=Cartridge ubi.mtd=EXT ubi.mtd=prg_EXT"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# LF1000 devices
+#
+CONFIG_LFCART=m
+# CONFIG_LF1000_DPC is not set
+# CONFIG_LF1000_MLC is not set
+CONFIG_LF1000_GA3D=y
+CONFIG_LF1000_IDCT=y
+# CONFIG_LF1000_ATAP is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_LF1000=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_LF1000=y
+CONFIG_MTD_NAND_LF1000_HOTSWAP=y
+CONFIG_MTD_OTP_SANDISK_PROGRAM=y
+CONFIG_MTD_NAND_LF1000_HWECC=y
+CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD=2
+# CONFIG_MTD_NAND_LF1000_PROF is not set
+CONFIG_MTD_NAND_LF1000_READ_DELAY=y
+CONFIG_MTD_NAND_LF1000_DEBUG=y
+# CONFIG_MTD_NAND_LF1000_TRACK_MLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TRACK_SLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TIMING_TESTS is not set
+CONFIG_NAND_LF1000_P0_SIZE=0x00100000
+CONFIG_NAND_LF1000_P1_SIZE=0x00100000
+CONFIG_NAND_LF1000_P2_SIZE=0x00800000
+CONFIG_NAND_LF1000_P3_SIZE=0x05600000
+CONFIG_NAND_LF1000_P4_SIZE=0x00000000
+CONFIG_NAND_LF1000_CART_SIZE=0x10000000
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=128
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_LF1000=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_LF1000=m
+CONFIG_TOUCHSCREEN_LF1000_PRESSURE=y
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+CONFIG_INPUT_LF1000_ACLMTR=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_LF1000=y
+CONFIG_I2C_LF1000_CHANNEL=0
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+CONFIG_SENSORS_LF1000=y
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_LF1000=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_LF1000_PWM=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LF1000_SOC=y
+# CONFIG_SND_LF1000_SOC_DEBUG is not set
+CONFIG_SND_LF1000_SOC_I2S=m
+CONFIG_SND_LF1000_SOC_DIDJ_CS43L22=m
+CONFIG_SND_LF1000_SOC_DIDJ_LFP100=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS43L22=m
+CONFIG_SND_SOC_LFP100=m
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_LF1000=y
+CONFIG_USB_LF1000=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_LF1000_DEBUG is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MES=y
+# CONFIG_MMC_MES_CHANNEL0 is not set
+CONFIG_MMC_MES_CHANNEL1=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_LF1000=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -ruaN linux-2.6.31/arch/arm/configs/lf1000_ts_fb_defconfig linux-2.6/arch/arm/configs/lf1000_ts_fb_defconfig
--- linux-2.6.31/arch/arm/configs/lf1000_ts_fb_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/configs/lf1000_ts_fb_defconfig	2011-01-04 15:07:10.000000000 -0800
@@ -0,0 +1,1562 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Wed Nov  3 15:53:07 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_RUNTIME_PHYS_OFFSET=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-leapfrog"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+CONFIG_ARCH_LF1000=y
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# LF1000 platform type
+#
+# CONFIG_MACH_ME_LF1000 is not set
+CONFIG_MACH_LF_LF1000=y
+# CONFIG_CPU_SPEED_385024000 is not set
+CONFIG_CPU_SPEED_393216000=y
+# CONFIG_CPU_SPEED_532480000 is not set
+CONFIG_LF1000_SCREEN=y
+CONFIG_LF1000_DMA_CONTROLLER=y
+CONFIG_LF1000_LFP100=y
+CONFIG_LF1000_GPIO=y
+# CONFIG_LF1000_GPIO_DEBUG is not set
+CONFIG_LF1000_ADC=y
+CONFIG_LF1000_SDRAM_TUNE=y
+CONFIG_LF1000_BOOT_PARAMS_ADDR=0x00003000
+# CONFIG_LF1000_OVERRIDE_BOARD_ID is not set
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID=y
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID_VALUE=7
+# CONFIG_LF1000_STRESS_TEST is not set
+CONFIG_PLAT_MES=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=16M root=31:04 rw rootflags=noatime rootfstype=jffs2 init=/sbin/init console=ttyS0,115200 ubi.mtd=Brio ubi.mtd=prg_Brio ubi.mtd=Cartridge ubi.mtd=EXT ubi.mtd=prg_EXT"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# LF1000 devices
+#
+CONFIG_LFCART=m
+# CONFIG_LF1000_DPC is not set
+# CONFIG_LF1000_MLC is not set
+CONFIG_LF1000_GA3D=y
+CONFIG_LF1000_IDCT=y
+# CONFIG_LF1000_ATAP is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_LF1000=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_LF1000=y
+CONFIG_MTD_NAND_LF1000_HOTSWAP=y
+CONFIG_MTD_OTP_SANDISK_PROGRAM=y
+CONFIG_MTD_NAND_LF1000_HWECC=y
+CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD=2
+# CONFIG_MTD_NAND_LF1000_PROF is not set
+CONFIG_MTD_NAND_LF1000_READ_DELAY=y
+CONFIG_MTD_NAND_LF1000_DEBUG=y
+# CONFIG_MTD_NAND_LF1000_TRACK_MLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TRACK_SLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TIMING_TESTS is not set
+CONFIG_NAND_LF1000_P0_SIZE=0x00100000
+CONFIG_NAND_LF1000_P1_SIZE=0x00100000
+CONFIG_NAND_LF1000_P2_SIZE=0x00800000
+CONFIG_NAND_LF1000_P3_SIZE=0x05600000
+CONFIG_NAND_LF1000_P4_SIZE=0x00000000
+CONFIG_NAND_LF1000_CART_SIZE=0x10000000
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=128
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_LF1000=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_LF1000=m
+CONFIG_TOUCHSCREEN_LF1000_PRESSURE=y
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_LF1000=y
+CONFIG_I2C_LF1000_CHANNEL=0
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+CONFIG_SENSORS_LF1000=y
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_LF1000=y
+CONFIG_FB_LF1000_START_ADDR=0x82E00000
+CONFIG_FB_LF1000_SIZE=0x01200000
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_LF1000_PWM=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+CONFIG_FONT_ACORN_8x8=y
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LF1000_SOC=y
+# CONFIG_SND_LF1000_SOC_DEBUG is not set
+CONFIG_SND_LF1000_SOC_I2S=m
+CONFIG_SND_LF1000_SOC_DIDJ_CS43L22=m
+CONFIG_SND_LF1000_SOC_DIDJ_LFP100=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS43L22=m
+CONFIG_SND_SOC_LFP100=m
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_LF1000=y
+CONFIG_USB_LF1000=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_LF1000_DEBUG is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MES=m
+CONFIG_MMC_MES_CHANNEL0=y
+# CONFIG_MMC_MES_CHANNEL1 is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_LF1000=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -ruaN linux-2.6.31/arch/arm/configs/lf1000_ts_surgeon_defconfig linux-2.6/arch/arm/configs/lf1000_ts_surgeon_defconfig
--- linux-2.6.31/arch/arm/configs/lf1000_ts_surgeon_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/configs/lf1000_ts_surgeon_defconfig	2011-08-01 18:29:09.000000000 -0700
@@ -0,0 +1,1554 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Fri Nov 12 18:05:51 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_RUNTIME_PHYS_OFFSET=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-leapfrog"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="${SURGEONFS}"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+CONFIG_ARCH_LF1000=y
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# LF1000 platform type
+#
+# CONFIG_MACH_ME_LF1000 is not set
+CONFIG_MACH_LF_LF1000=y
+# CONFIG_CPU_SPEED_385024000 is not set
+CONFIG_CPU_SPEED_393216000=y
+# CONFIG_CPU_SPEED_532480000 is not set
+CONFIG_LF1000_SCREEN=y
+CONFIG_LF1000_DMA_CONTROLLER=y
+CONFIG_LF1000_LFP100=y
+CONFIG_LF1000_GPIO=y
+# CONFIG_LF1000_GPIO_DEBUG is not set
+CONFIG_LF1000_ADC=y
+CONFIG_LF1000_SDRAM_TUNE=y
+CONFIG_LF1000_BOOT_PARAMS_ADDR=0x00003000
+# CONFIG_LF1000_OVERRIDE_BOARD_ID is not set
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID=y
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID_VALUE=7
+# CONFIG_LF1000_STRESS_TEST is not set
+CONFIG_PLAT_MES=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=16M root=31:04 rw rootflags=noatime rootfstype=jffs2 init=/sbin/init console=ttyS0,115200 ubi.mtd=Brio ubi.mtd=prg_Brio ubi.mtd=Cartridge ubi.mtd=EXT ubi.mtd=prg_EXT"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# LF1000 devices
+#
+CONFIG_LFCART=m
+# CONFIG_LF1000_DPC is not set
+# CONFIG_LF1000_MLC is not set
+CONFIG_LF1000_GA3D=y
+CONFIG_LF1000_IDCT=y
+# CONFIG_LF1000_ATAP is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_LF1000=y
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_LF1000=y
+CONFIG_MTD_NAND_LF1000_HOTSWAP=y
+CONFIG_MTD_OTP_SANDISK_PROGRAM=y
+CONFIG_MTD_NAND_LF1000_HWECC=y
+CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD=2
+# CONFIG_MTD_NAND_LF1000_PROF is not set
+CONFIG_MTD_NAND_LF1000_READ_DELAY=y
+CONFIG_MTD_NAND_LF1000_DEBUG=y
+# CONFIG_MTD_NAND_LF1000_TRACK_MLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TRACK_SLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TIMING_TESTS is not set
+CONFIG_NAND_LF1000_P0_SIZE=0x00100000
+CONFIG_NAND_LF1000_P1_SIZE=0x00100000
+CONFIG_NAND_LF1000_P2_SIZE=0x00800000
+CONFIG_NAND_LF1000_P3_SIZE=0x05600000
+CONFIG_NAND_LF1000_P4_SIZE=0x00000000
+CONFIG_NAND_LF1000_CART_SIZE=0x10000000
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=128
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_LF1000=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_LF1000=m
+CONFIG_TOUCHSCREEN_LF1000_PRESSURE=y
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+CONFIG_INPUT_LF1000_ACLMTR=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_LF1000=y
+CONFIG_I2C_LF1000_CHANNEL=0
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+CONFIG_SENSORS_LF1000=y
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=m
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC_INPUT_EVDEV is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_LF1000=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_LF1000_PWM=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LF1000_SOC=y
+# CONFIG_SND_LF1000_SOC_DEBUG is not set
+CONFIG_SND_LF1000_SOC_I2S=m
+CONFIG_SND_LF1000_SOC_DIDJ_CS43L22=m
+CONFIG_SND_LF1000_SOC_DIDJ_LFP100=m
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS43L22=m
+CONFIG_SND_SOC_LFP100=m
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_LF1000=y
+CONFIG_USB_LF1000=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_LF1000_DEBUG is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MES=y
+# CONFIG_MMC_MES_CHANNEL0 is not set
+CONFIG_MMC_MES_CHANNEL1=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_LF1000=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -ruaN linux-2.6.31/arch/arm/configs/openlf_didj_console_defconfig linux-2.6/arch/arm/configs/openlf_didj_console_defconfig
--- linux-2.6.31/arch/arm/configs/openlf_didj_console_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/configs/openlf_didj_console_defconfig	2012-11-19 22:38:43.000000000 -0800
@@ -0,0 +1,1387 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Fri Nov 16 19:06:17 2012
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_RUNTIME_PHYS_OFFSET=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-OpenLF"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_SHMEM is not set
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="deadline"
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+CONFIG_ARCH_LF1000=y
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# LF1000 platform type
+#
+# CONFIG_MACH_ME_LF1000 is not set
+CONFIG_MACH_LF_LF1000=y
+# CONFIG_CPU_SPEED_385024000 is not set
+CONFIG_CPU_SPEED_393216000=y
+# CONFIG_CPU_SPEED_532480000 is not set
+CONFIG_LF1000_SCREEN=y
+CONFIG_LF1000_DMA_CONTROLLER=y
+# CONFIG_LF1000_LFP100 is not set
+CONFIG_LF1000_GPIO=y
+# CONFIG_LF1000_GPIO_DEBUG is not set
+CONFIG_LF1000_ADC=y
+CONFIG_LF1000_SDRAM_TUNE=y
+CONFIG_LF1000_BOOT_PARAMS_ADDR=0x00003000
+# CONFIG_LF1000_OVERRIDE_BOARD_ID is not set
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID=y
+CONFIG_LF1000_OVERRIDE_CARTRIDGE_ID_VALUE=7
+# CONFIG_LF1000_STRESS_TEST is not set
+CONFIG_PLAT_MES=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=16M root=31:04 rw rootflags=noatime rootfstype=jffs2 init=/sbin/init console=ttyS0,115200 ubi.mtd=Brio ubi.mtd=prg_Brio ubi.mtd=Cartridge ubi.mtd=EXT ubi.mtd=prg_EXT"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=m
+# CONFIG_LIB80211_DEBUG is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# LF1000 devices
+#
+CONFIG_LFCART=m
+CONFIG_DIDJ_VOLUME=y
+CONFIG_GPSP_WARM=m
+# CONFIG_LF1000_DPC is not set
+# CONFIG_LF1000_MLC is not set
+# CONFIG_LF1000_GA3D is not set
+# CONFIG_LF1000_IDCT is not set
+# CONFIG_LF1000_ATAP is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/mdev"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_LF1000 is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_LF1000=y
+CONFIG_MTD_NAND_LF1000_HOTSWAP=y
+CONFIG_MTD_OTP_SANDISK_PROGRAM=y
+CONFIG_MTD_NAND_LF1000_HWECC=y
+CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD=2
+# CONFIG_MTD_NAND_LF1000_PROF is not set
+CONFIG_MTD_NAND_LF1000_READ_DELAY=y
+CONFIG_MTD_NAND_LF1000_DEBUG=y
+# CONFIG_MTD_NAND_LF1000_TRACK_MLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TRACK_SLC_ERRORS is not set
+# CONFIG_MTD_NAND_LF1000_TIMING_TESTS is not set
+CONFIG_NAND_LF1000_P0_SIZE=0x00100000
+CONFIG_NAND_LF1000_P1_SIZE=0x00500000
+CONFIG_NAND_LF1000_P2_SIZE=0x02800000
+CONFIG_NAND_LF1000_P3_SIZE=0x00000000
+CONFIG_NAND_LF1000_CART_SIZE=0x10000000
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=128
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_NETDEVICES is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_LF1000=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+CONFIG_I2C_LF1000=y
+CONFIG_I2C_LF1000_CHANNEL=0
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+CONFIG_SENSORS_LF1000=y
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=y
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_LF1000=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_LF1000_PWM=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LF1000_SOC=y
+# CONFIG_SND_LF1000_SOC_DEBUG is not set
+CONFIG_SND_LF1000_SOC_I2S=y
+CONFIG_SND_LF1000_SOC_DIDJ_CS43L22=y
+# CONFIG_SND_LF1000_SOC_DIDJ_LFP100 is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS43L22=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+CONFIG_USB_GADGET_LF1000=y
+CONFIG_USB_LF1000=m
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+# CONFIG_USB_LF1000_DEBUG is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+# CONFIG_USB_ETH_RNDIS is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_SM2683LT is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_MES=y
+CONFIG_MMC_MES_CHANNEL0=y
+# CONFIG_MMC_MES_CHANNEL1 is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_LF1000=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4DEV_COMPAT is not set
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_KMEMCHECK is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff -ruaN linux-2.6.31/arch/arm/include/asm/hardware/vic.h linux-2.6/arch/arm/include/asm/hardware/vic.h
--- linux-2.6.31/arch/arm/include/asm/hardware/vic.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/include/asm/hardware/vic.h	2011-01-04 13:50:21.000000000 -0800
@@ -41,7 +41,11 @@
 #define VIC_PL192_VECT_ADDR		0xF00
 
 #ifndef __ASSEMBLY__
+#ifndef	CONFIG_ARCH_LF1000
 void vic_init(void __iomem *base, unsigned int irq_start, u32 vic_sources, u32 resume_sources);
+#else
+void ic_init(void __iomem *base, unsigned int irq_start, u64 ic_sources);
+#endif
 #endif
 
 #endif
diff -ruaN linux-2.6.31/arch/arm/include/asm/memory.h linux-2.6/arch/arm/include/asm/memory.h
--- linux-2.6.31/arch/arm/include/asm/memory.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/include/asm/memory.h	2011-01-04 13:50:21.000000000 -0800
@@ -70,6 +70,14 @@
  */
 #define IOREMAP_MAX_ORDER	24
 
+/*
+ * PHYS_OFFSET determined at run time?
+ */
+#if defined(CONFIG_RUNTIME_PHYS_OFFSET) && !defined(__ASSEMBLY__)
+extern unsigned long phys_offset;
+#define PHYS_OFFSET		(phys_offset)
+#endif
+
 #else /* CONFIG_MMU */
 
 /*
diff -ruaN linux-2.6.31/arch/arm/include/asm/serial.h linux-2.6/arch/arm/include/asm/serial.h
--- linux-2.6.31/arch/arm/include/asm/serial.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/include/asm/serial.h	2011-01-04 13:50:21.000000000 -0800
@@ -14,6 +14,22 @@
 #ifndef __ASM_SERIAL_H
 #define __ASM_SERIAL_H
 
+#ifndef	CONFIG_ARCH_LF1000
 #define BASE_BAUD	(1843200 / 16)
+#else
+#define BASE_BAUD	LF1000_SYS_UART_BR
 
+#define STD_COM_FLAGS	( UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST | UPF_AUTO_IRQ | UART_CONFIG_TYPE)
+
+#define SERIAL_PORT_DFNS									\
+        { 0, LF1000_SYS_UART_BR, 0, LF1000_UART0_IRQ, STD_COM_FLAGS,				\
+	  0, UPIO_MEM, (unsigned char *)IO_ADDRESS( LF1000_UART0_BASE), 0 },     /* ttyS0 */	\
+        { 1, LF1000_SYS_UART_BR, 0, LF1000_UART1_IRQ, STD_COM_FLAGS,				\
+	  0, UPIO_MEM, (unsigned char *)IO_ADDRESS( LF1000_UART1_BASE), 0 },     /* ttyS1 */	\
+        { 2, LF1000_SYS_UART_BR, 0, LF1000_UART2_IRQ, STD_COM_FLAGS,				\
+	  0, UPIO_MEM, (unsigned char *)IO_ADDRESS( LF1000_UART2_BASE), 0 },     /* ttyS2 */	\
+        { 3, LF1000_SYS_UART_BR, 0, LF1000_UART3_IRQ, STD_COM_FLAGS,				\
+	  0, UPIO_MEM, (unsigned char *)IO_ADDRESS( LF1000_UART3_BASE), 0 },     /* ttyS3 */
+
+#endif
 #endif
diff -ruaN linux-2.6.31/arch/arm/include/asm/tlbflush.h linux-2.6/arch/arm/include/asm/tlbflush.h
--- linux-2.6.31/arch/arm/include/asm/tlbflush.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/include/asm/tlbflush.h	2011-01-04 13:50:21.000000000 -0800
@@ -326,10 +326,10 @@
 		asm("mcr p15, 0, %0, c6, c0, 0" : : "r" (zero) : "cc");
 	if (tlb_flag(TLB_V4_U_FULL | TLB_V6_U_FULL))
 		asm("mcr p15, 0, %0, c8, c7, 0" : : "r" (zero) : "cc");
-	if (tlb_flag(TLB_V4_D_FULL | TLB_V6_D_FULL))
-		asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
-	if (tlb_flag(TLB_V4_I_FULL | TLB_V6_I_FULL))
-		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+	//	if (tlb_flag(TLB_V4_D_FULL | TLB_V6_D_FULL))
+	//		asm("mcr p15, 0, %0, c8, c6, 0" : : "r" (zero) : "cc");
+	//	if (tlb_flag(TLB_V4_I_FULL | TLB_V6_I_FULL))
+	//		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
 	if (tlb_flag(TLB_V7_UIS_FULL))
 		asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
 
@@ -437,6 +437,8 @@
 		asm("mcr p15, 0, %0, c8, c5, 1" : : "r" (kaddr) : "cc");
 	if (!tlb_flag(TLB_V4_I_PAGE) && tlb_flag(TLB_V4_I_FULL))
 		asm("mcr p15, 0, %0, c8, c5, 0" : : "r" (zero) : "cc");
+	if (tlb_flag(TLB_V7_UIS_FULL))
+		asm("mcr p15, 0, %0, c8, c3, 0" : : "r" (zero) : "cc");
 
 	if (tlb_flag(TLB_V6_U_PAGE))
 		asm("mcr p15, 0, %0, c8, c7, 1" : : "r" (kaddr) : "cc");
diff -ruaN linux-2.6.31/arch/arm/Kconfig linux-2.6/arch/arm/Kconfig
--- linux-2.6.31/arch/arm/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/Kconfig	2011-01-04 14:47:37.000000000 -0800
@@ -182,6 +182,9 @@
 	help
 	  The base address of exception vectors.
 
+config RUNTIME_PHYS_OFFSET
+	bool
+
 source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
@@ -388,6 +391,15 @@
 	help
 	  Support for Intel's IXP4XX (XScale) family of processors.
 
+config ARCH_LF1000
+	bool "LeapFrog LF1000"
+	depends on MMU
+	select CPU_ARM926T
+	select RUNTIME_PHYS_OFFSET
+	select PLAT_MES
+	help
+	  This enables support for LeapFrog LF1000 family of processors.
+
 config ARCH_L7200
 	bool "LinkUp-L7200"
 	select CPU_ARM720T
@@ -661,6 +673,8 @@
 
 source "arch/arm/mach-ixp23xx/Kconfig"
 
+source "arch/arm/mach-lf1000/Kconfig"
+
 source "arch/arm/mach-loki/Kconfig"
 
 source "arch/arm/mach-mv78xx0/Kconfig"
@@ -743,6 +757,9 @@
 config PLAT_PXA
 	bool
 
+config PLAT_MES
+	bool
+
 source arch/arm/mm/Kconfig
 
 config IWMMXT
@@ -1378,6 +1395,9 @@
 source "net/Kconfig"
 
 menu "Device Drivers"
+if ARCH_LF1000
+source "drivers/lf1000/Kconfig"
+endif
 
 source "drivers/base/Kconfig"
 
diff -ruaN linux-2.6.31/arch/arm/kernel/head.S linux-2.6/arch/arm/kernel/head.S
--- linux-2.6.31/arch/arm/kernel/head.S	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/kernel/head.S	2011-01-04 13:50:21.000000000 -0800
@@ -22,9 +22,11 @@
 #include <asm/thread_info.h>
 #include <asm/system.h>
 
+#ifndef CONFIG_RUNTIME_PHYS_OFFSET
 #if (PHYS_OFFSET & 0x001fffff)
 #error "PHYS_OFFSET must be at an even 2MiB boundary!"
 #endif
+#endif
 
 #define KERNEL_RAM_VADDR	(PAGE_OFFSET + TEXT_OFFSET)
 #define KERNEL_RAM_PADDR	(PHYS_OFFSET + TEXT_OFFSET)
@@ -44,8 +46,8 @@
 	.globl	swapper_pg_dir
 	.equ	swapper_pg_dir, KERNEL_RAM_VADDR - 0x4000
 
-	.macro	pgtbl, rd
-	ldr	\rd, =(KERNEL_RAM_PADDR - 0x4000)
+	.macro	pgtbl, rd, phys_offset
+	add	\rd, \phys_offset, #(TEXT_OFFSET - 0x4000)
 	.endm
 
 #ifdef CONFIG_XIP_KERNEL
@@ -210,9 +212,26 @@
  * Returns:
  *  r0, r3, r6, r7 corrupted
  *  r4 = physical page table address
+ *  r5 = PHYS_OFFSET
  */
 __create_page_tables:
-	pgtbl	r4				@ page table address
+#ifdef CONFIG_RUNTIME_PHYS_OFFSET
+	adr	r5, stext
+	sub	r5, r5, #TEXT_OFFSET		@ r5 = phys_offset
+	ldr	r4, =0xfff00000
+	and	r5, r5, r4
+
+	ldr	r4, =(phys_offset - PAGE_OFFSET)
+	add	r4, r4, r5
+	str	r5, [r4]			@ save phys_offset
+#else
+	mov	r5, #(PHYS_OFFSET & 0xff000000)
+	.if	(PHYS_OFFSET & 0x00f00000)
+	orr	r5, r5, #(PHYS_OFFSET & 0x00f00000)
+	.endif
+#endif
+
+	pgtbl	r4, r5				@ r4 = page table address
 
 	/*
 	 * Clear the 16K level 1 swapper page table
@@ -257,10 +276,11 @@
 	/*
 	 * Map some ram to cover our .data and .bss areas.
 	 */
-	orr	r3, r7, #(KERNEL_RAM_PADDR & 0xff000000)
-	.if	(KERNEL_RAM_PADDR & 0x00f00000)
-	orr	r3, r3, #(KERNEL_RAM_PADDR & 0x00f00000)
+	add	r3, r5, #(TEXT_OFFSET & 0xff000000)	@ r5 = PHYS_OFFSET
+	.if	(TEXT_OFFSET & 0x00f00000)
+	add	r3, r3, #(TEXT_OFFSET & 0x00f00000)
 	.endif
+	orr	r3, r3, r7
 	add	r0, r4,  #(KERNEL_RAM_VADDR & 0xff000000) >> 18
 	str	r3, [r0, #(KERNEL_RAM_VADDR & 0x00f00000) >> 18]!
 	ldr	r6, =(_end - 1)
@@ -276,10 +296,7 @@
 	 * Then map first 1MB of ram in case it contains our boot params.
 	 */
 	add	r0, r4, #PAGE_OFFSET >> 18
-	orr	r6, r7, #(PHYS_OFFSET & 0xff000000)
-	.if	(PHYS_OFFSET & 0x00f00000)
-	orr	r6, r6, #(PHYS_OFFSET & 0x00f00000)
-	.endif
+	orr	r6, r7, r5
 	str	r6, [r0]
 
 #ifdef CONFIG_DEBUG_LL
diff -ruaN linux-2.6.31/arch/arm/kernel/setup.c linux-2.6/arch/arm/kernel/setup.c
--- linux-2.6.31/arch/arm/kernel/setup.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/kernel/setup.c	2011-01-04 13:50:21.000000000 -0800
@@ -64,6 +64,16 @@
 extern void paging_init(struct machine_desc *desc);
 extern void reboot_setup(char *str);
 
+#ifdef CONFIG_RUNTIME_PHYS_OFFSET
+/*
+ * The assignment is here solely to prevent this variable from ending
+ * up in bss.  As the early startup code writes to it, we don't want it
+ * to be zeroed again later.
+ */
+unsigned long phys_offset = 0xdeadbeef;
+EXPORT_SYMBOL(phys_offset);
+#endif
+
 unsigned int processor_id;
 EXPORT_SYMBOL(processor_id);
 unsigned int __machine_arch_type;
@@ -665,7 +675,7 @@
 	{ tag_size(tag_core), ATAG_CORE },
 	{ 1, PAGE_SIZE, 0xff },
 	{ tag_size(tag_mem32), ATAG_MEM },
-	{ MEM_SIZE, PHYS_OFFSET },
+	{ MEM_SIZE, 0 },
 	{ 0, ATAG_NONE }
 };
 
@@ -686,6 +696,8 @@
 	struct machine_desc *mdesc;
 	char *from = default_command_line;
 
+	init_tags.mem.start = PHYS_OFFSET;
+
 	unwind_init();
 
 	setup_processor();
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/adc.c linux-2.6/arch/arm/mach-lf1000/adc.c
--- linux-2.6.31/arch/arm/mach-lf1000/adc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/adc.c	2011-08-09 17:41:59.000000000 -0700
@@ -0,0 +1,391 @@
+/* 
+ * arch/arm/mach-lf100/adc.c
+ *
+ * LF1000 Analog to Digital Converter (ADC) Driver
+ *
+ * Copyright 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/gpio.h>
+#include <mach/adc.h>
+
+#define DRIVER_NAME	"lf1000-adc"
+
+#define RESSIZE(r)	((r->end - r->start) + 1)
+
+struct adc_device {
+	void __iomem *mem;
+	int irq;
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	wait_queue_head_t meas_busy;
+	bool busy;
+	bool conversion_finished;
+	uint show_sample;
+};
+
+extern int lf1000_CalcDivider(unsigned int rate_hz, unsigned int desired_mhz);
+
+static struct adc_device adc = {
+	.mem = NULL,
+	.irq = -1,
+	.lock = SPIN_LOCK_UNLOCKED,
+	.busy = 0,
+	.conversion_finished = 1,
+	.show_sample = 0,	/* toggle GPIO pin when ADC is sampled */
+};
+
+static int adc_available(void)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&adc.lock, flags);
+	ret = !adc.busy;
+	spin_unlock_irqrestore(&adc.lock, flags);
+
+	return ret;
+}
+
+/*********************
+ * ADC API Functions *
+ *********************/
+
+int adc_GetReading(u8 channel)
+{
+	unsigned long flags;
+	u16 tmp;
+	int show_sample;
+	int reading;
+
+	if (channel > LF1000_ADC_MAX_CHANNEL)
+		return -EINVAL;
+
+	show_sample = adc.show_sample; /* value could change during reading */
+	
+	/* wait for the ADC */
+	spin_lock_irqsave(&adc.lock, flags);
+	while (adc.busy) {
+		spin_unlock_irqrestore(&adc.lock, flags);
+		if (wait_event_interruptible(adc.wait, (adc_available())))
+			return -ERESTARTSYS;
+		spin_lock_irqsave(&adc.lock, flags);
+	}
+	adc.busy = 1;
+	spin_unlock_irqrestore(&adc.lock, flags);
+
+	/* Setup ADC */
+	tmp = readw(adc.mem + ADCCON);
+	tmp &= ~(0x7<<ASEL);
+	tmp |= (channel<<ASEL);
+	writew(tmp, adc.mem + ADCCON);
+	adc.conversion_finished = 0;
+	writew(1, adc.mem + ADCINTCLR);
+	writew((u16)(1), adc.mem + ADCINTENB);
+	tmp |= (1<<ADEN);
+
+	/* GPIO pin goes high showing sample started */
+	if (show_sample & (1 << channel))
+        	gpio_configure_pin(lf1000_l2p_port(DOCK_POWER),
+			lf1000_l2p_pin(DOCK_POWER), GPIO_GPIOFN, 1, 0, 1);	
+		
+	writew(tmp, adc.mem + ADCCON); /* start conversion */
+
+	/* wait for conversion to finish */
+	if (wait_event_interruptible(adc.meas_busy, adc.conversion_finished))
+		return -ERESTARTSYS;
+
+	/* release ADC */
+	spin_lock_irqsave(&adc.lock, flags);
+	reading = readw(adc.mem + ADCDAT);
+	/* GPIO pin goes low showing sample started */
+	if (show_sample & (1 << channel))
+        	gpio_configure_pin(lf1000_l2p_port(DOCK_POWER),
+			lf1000_l2p_pin(DOCK_POWER), GPIO_GPIOFN, 1, 0, 0);	
+		
+	adc.busy = 0;
+	spin_unlock_irqrestore(&adc.lock, flags);
+	wake_up_interruptible(&adc.wait);
+	return reading;
+}
+EXPORT_SYMBOL(adc_GetReading);
+
+/*
+ * sysfs Interface
+ */
+
+static ssize_t show_sample(struct device *dev, struct device_attribute *attr,
+                        char *buf)
+{
+        return sprintf(buf, "%d\n", adc.show_sample);
+}
+static ssize_t set_sample(struct device *dev, struct device_attribute *attr,
+                        const char *buf, size_t count)
+{
+        int temp;
+        if (sscanf(buf, "%i", &temp) != 1)
+                return -EINVAL;
+        adc.show_sample = 0xff & temp;		/* keep lower 8 bits */
+        return(count);
+}
+
+static DEVICE_ATTR(show_sample, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_sample, set_sample);
+
+static ssize_t get_channel(struct device *dev, struct device_attribute *attr,
+				char *buf, u8 channel)
+{
+	int reading = adc_GetReading(channel);
+
+	if (reading >= 0)
+		return sprintf(buf, "%d\n", reading);
+	return sprintf(buf, "ERROR: %d\n", reading);
+}
+
+static ssize_t show_channel0(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 0);
+}
+static DEVICE_ATTR(channel0, S_IRUSR|S_IRGRP, show_channel0, NULL);
+
+static ssize_t show_channel1(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 1);
+}
+static DEVICE_ATTR(channel1, S_IRUSR|S_IRGRP, show_channel1, NULL);
+
+static ssize_t show_channel2(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 2);
+}
+static DEVICE_ATTR(channel2, S_IRUSR|S_IRGRP, show_channel2, NULL);
+
+static ssize_t show_channel3(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 3);
+}
+static DEVICE_ATTR(channel3, S_IRUSR|S_IRGRP, show_channel3, NULL);
+
+static ssize_t show_channel4(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 4);
+}
+static DEVICE_ATTR(channel4, S_IRUSR|S_IRGRP, show_channel4, NULL);
+
+static ssize_t show_channel5(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 5);
+}
+static DEVICE_ATTR(channel5, S_IRUSR|S_IRGRP, show_channel5, NULL);
+
+static ssize_t show_channel6(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 6);
+}
+static DEVICE_ATTR(channel6, S_IRUSR|S_IRGRP, show_channel6, NULL);
+
+static ssize_t show_channel7(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	return get_channel(dev, attr, buf, 7);
+}
+static DEVICE_ATTR(channel7, S_IRUSR|S_IRGRP, show_channel7, NULL);
+
+static struct attribute *adc_attributes[] = {
+	&dev_attr_show_sample.attr,
+	&dev_attr_channel0.attr,
+	&dev_attr_channel1.attr,
+	&dev_attr_channel2.attr,
+	&dev_attr_channel3.attr,
+	&dev_attr_channel4.attr,
+	&dev_attr_channel5.attr,
+	&dev_attr_channel6.attr,
+	&dev_attr_channel7.attr,
+	NULL
+};
+
+static struct attribute_group adc_attr_group = {
+	.attrs = adc_attributes
+};
+
+/**********************
+ * interrupt handling *
+ **********************/
+
+static irqreturn_t adc_irq(int irq, void *dev_id)
+{
+	/* clear the pending interrupt */
+	writew(1, adc.mem + ADCINTCLR);
+	/* disable interrupt */
+	writew((u16)(0), adc.mem + ADCINTENB); 
+
+	adc.conversion_finished = 1;
+
+	wake_up_interruptible(&adc.meas_busy);
+	return IRQ_HANDLED;
+}
+
+static int lf1000_adc_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	sysfs_remove_group(&pdev->dev.kobj, &adc_attr_group);
+
+	if (adc.irq != -1)
+		free_irq(adc.irq, NULL);
+
+	if (adc.mem != NULL) {
+		writew(0, adc.mem + ADCCON); /* turn off ADC */
+		iounmap(adc.mem);
+		release_mem_region(res->start, RESSIZE(res));
+	}
+	return 0;
+}
+
+static int lf1000_adc_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int div;
+	u16 tmp;
+	struct resource *res;
+
+	div = lf1000_CalcDivider(get_pll_freq(PLL1), 1000000);
+	if (div < 0) {
+		dev_err(&pdev->dev, "failed to get a ADC divider\n");
+		return -EFAULT;
+	}
+	if (div > 0xFF) {
+		dev_info(&pdev->dev, "clipping ADC divider\n");
+		div = 0xFF;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if (!request_mem_region(res->start, RESSIZE(res), DRIVER_NAME)) {
+		dev_err(&pdev->dev, "failed to map ADC region\n");
+		return -EBUSY;
+	}
+	adc.mem = ioremap_nocache(res->start, RESSIZE(res));
+	if (!adc.mem) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		goto fail_remap;
+	}
+
+	adc.irq = platform_get_irq(pdev, 0);
+	if (adc.irq < 0) {
+		dev_err(&pdev->dev, "failed to get IRQ\n");
+		ret = adc.irq;
+		goto fail_irq;
+	}
+	ret = request_irq(adc.irq, adc_irq, IRQF_DISABLED|IRQF_SAMPLE_RANDOM,
+			DRIVER_NAME, NULL);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "requesting IRQ failed\n");
+		goto fail_irq;
+	}
+
+	init_waitqueue_head(&adc.wait);
+	init_waitqueue_head(&adc.meas_busy);
+
+	/* set up the hardware */
+
+	/* enable PCLK, its only allowed mode is 'always' */
+	writel((u32)(1<<3), adc.mem + ADCCLKENB);
+	/* power on the ADC */
+	tmp = readw(adc.mem + ADCCON);
+	tmp &= ~(1<<STBY);
+	writew(tmp, adc.mem + ADCCON);
+	/* disable converter */
+	tmp &= ~(1<<APEN);
+	writew(tmp, adc.mem + ADCCON);
+	/* remove old prescaler */
+	tmp &= ~(0xFF << APSV);
+	/* power is off, set prescaler */
+	tmp |= ((div-1)<<APSV);	/* Probably should be |=; also want (div-1) */
+	writew(tmp, adc.mem + ADCCON);
+	/* enable clock */
+	tmp |= (1<<APEN);
+	writew(tmp, adc.mem + ADCCON);
+
+	sysfs_create_group(&pdev->dev.kobj, &adc_attr_group);
+	return 0;
+
+fail_irq:
+	iounmap(adc.mem);
+fail_remap:
+	release_mem_region(res->start, RESSIZE(res));
+	
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_adc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int lf1000_adc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lf1000_adc_suspend	NULL
+#define lf1000_adc_resume	NULL
+#endif
+
+static struct platform_driver lf1000_adc_driver = {
+	.probe      = lf1000_adc_probe,
+	.remove     = lf1000_adc_remove,
+	.suspend    = lf1000_adc_suspend,
+	.resume     = lf1000_adc_resume,
+	.driver     = {
+		.name   = DRIVER_NAME,
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init adc_init(void)
+{
+	return platform_driver_register(&lf1000_adc_driver);
+}
+
+static void __exit adc_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_adc_driver);
+}
+
+module_init(adc_init);
+module_exit(adc_cleanup);
+
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1:2.0");
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/board_ids.h linux-2.6/arch/arm/mach-lf1000/board_ids.h
--- linux-2.6.31/arch/arm/mach-lf1000/board_ids.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/board_ids.h	2011-02-08 12:34:48.000000000 -0800
@@ -0,0 +1,86 @@
+/*
+ * arch/arm/mach-lf1000/board_ids.h
+ *
+ * LF1000 board definitions used solely by gpio.c
+ * Please use/expand 'include/mach/boards.h' etermine board qualities.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistributte it and/or modify
+ * it under the terms of the GNU Gneral Public License as published by
+ * the Free Software Foundation
+ */
+
+#ifndef LF1000_BOARD_IDS_H
+#define LF1000_BOARD_IDS_H
+
+/* This is a list of board types that can be detected at runtime to deal with
+ * hardware quirks. See gpio_get_board_config() for more information. */
+
+
+/* LF1000 Development boards and original Didj Form Factor (alpha) board. */
+#define LF1000_BOARD_DEV		0x00
+
+/* Original Didj 08 (Legacy Rev A) */
+#define LF1000_BOARD_DIDJ		0x03
+
+/* Didj 09, 2GB MLC Flash, 64KB Boot Flash */
+#define LF1000_BOARD_DIDJ_09		0x04
+
+/* Acorn, 8GB SLC Flash, 64MB SDRAM, 512KB Boot Flash, TV Out, RTC SuperCap */
+#define LF1000_BOARD_ACORN		0x05
+
+
+/*
+ * Emerald / Leapster3 Boards
+ */
+
+/* Leapster Explorer POP, 8GB SLC Flash, 64MB SDRAM,
+ * 512KB Boot Flash, TV Out, No RTC SuperCap */
+#define LF1000_BOARD_EMERALD_POP	0x01
+
+/* Leapster Explorer, 8GB SLC Flash, 64MB SDRAM,
+ * 512KB Boot Flash, No TV Out, No RTC SuperCap */
+#define LF1000_BOARD_EMERALD_NOTV_NOCAP	0x02
+
+/* Leapster Explorer, 8GB SLC Flash, 64MB SDRAM,
+ * 512KB Boot Flash, TV Out, No RTC SuperCap */
+#define LF1000_BOARD_EMERALD_TV_NOCAP	0x06
+
+/* Leapster Explorer, 8GB SLC Flash, 64MB SDRAM,
+ * 512KB Boot Flash, No TV Out, RTC SuperCap */
+#define LF1000_BOARD_EMERALD_NOTV_CAP	0x07
+
+/* Leapster Explorer 8GB SLC Flash, 64MB Samsung
+ * SDRAM, 512KB Boot Flash, No TV Out, No RTC SuperCap */
+#define LF1000_BOARD_EMERALD_SAMSUNG	0x0A
+
+
+/*
+ * K2 Boards
+ */
+
+/* K2 Base, 8GB SLC Flash, 64MB SDRAM, 512KB Boot Flash */
+#define	LF1000_BOARD_K2			0x10
+
+
+/*
+ * Madrid Boards
+ */
+
+/* Madrid, 5" LCD 2GB MLC Flash + SD Controller, 64MB SDRAM,
+ *512KB Boot Flash, No TV Out, No RTC SuperCap, Accelerometer,
+ * Vibration motor, USB Camera SDIO WIFI  */
+#define LF1000_BOARD_MADRID		0x0B
+
+/* Madrid, 5" LCD 2GB MLC Flash + SD Controller, 64MB SDRAM,
+ *512KB Boot Flash, TV Out, No RTC SuperCap, Accelerometer,
+ * Vibration motor, USB Camera SDIO WIFI  */
+#define LF1000_BOARD_MADRID_POP		0x0C
+
+/* Madrid, 5" LCD 2GB MLC Flash + SD Controller, 64MB SDRAM,
+ *512KB Boot Flash, No TV Out, No RTC SuperCap, Accelerometer,
+ * Vibration motor, USB Camera SDIO WIFI, LFP100  */
+#define LF1000_BOARD_MADRID_LFP100	0x0D
+
+#endif /* LF1000_BOARD_IDS_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/clock.c linux-2.6/arch/arm/mach-lf1000/clock.c
--- linux-2.6.31/arch/arm/mach-lf1000/clock.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/clock.c	2011-01-04 14:29:09.000000000 -0800
@@ -0,0 +1,219 @@
+/*
+ *  linux/arch/arm/mach-lf1000/clock.c
+ *
+ *	  Copyright (C) 2007 Kosta Demirev <kdemirev@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+
+#include <linux/semaphore.h>
+#include <mach/lf1000.h>
+
+#include <mach/platform.h>
+#include <mach/clkpwr.h>
+
+#include <mach/clock.h>
+#include <mach/common.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
+/*
+ * lf1000_oscvco_set(struct clk *clk) -- set pll frequency
+ * Adjust pll only if it is not already at this rate so devices, like
+ * video or audio do not glitch.
+ */
+#define CLK32(r)	REG32(LF1000_CLKPWR_BASE+r)
+
+static void lf1000_oscvco_set(struct clk *clk)
+{
+	u32 old_pll;
+	u32 new_pll;
+
+	/* XXX: don't actually change any PLLs aside from PLL0 */
+	if (clk->number > 0)
+		return;
+
+	old_pll = readl(&(clock_p->pllsetreg0) + clk->number); // old pll value
+	new_pll = get_pll_div(clk->number, clk->params->ref, clk->rate);
+
+	if (old_pll != new_pll) {
+		printk(KERN_INFO "%s.%d  changing pll %lu, old=0x%8.8X, new=0x%8.8X\n",
+			__FUNCTION__, __LINE__, clk->number, old_pll, new_pll);
+		writel(new_pll, (&(clock_p->pllsetreg0) + clk->number)); // set
+		/* set CHGPLL to tell hardware to apply settings, restabalize PLLs */
+		writel(readl(&clock_p->pwrmode)|(1<<CHGPLL), &clock_p->pwrmode);
+	
+		/* wait for PLLs to stabalize */
+		while(readl(&clock_p->pwrmode) & (1<<CHGPLL))
+			mb();	/* memory barrier */
+	} else {
+		printk(KERN_INFO "%s.%d pll %lu, not changed already set to 0x%8.8X\n",
+			__FUNCTION__, __LINE__, clk->number, old_pll);
+	}
+}
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+
+	mutex_lock(&clocks_mutex);
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			break;
+		}
+	}
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+EXPORT_SYMBOL(clk_get);
+
+void clk_put(struct clk *clk)
+{
+	module_put(clk->owner);
+}
+EXPORT_SYMBOL(clk_put);
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+/* clk_get_rate() - obtain the current clock rate in KHz */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return (get_pll_freq(clk->number)/1000);
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/* clk_set_rate() - set clock rate provided in KHz */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	clk->rate = rate * 1000;
+	clk->setvco(clk);
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+static const struct lf1000_params lf1000_pll0_params = {
+	.ref		= CRYSTAL_FREQ_HZ,
+	.vco_max	= MAX_VCOF_HZ(PLL0),
+	.md_min		= MIN_MDIV,
+	.md_max		= MAX_MDIV,
+	.pd_min		= MIN_PDIV,
+	.pd_max		= MAX_PDIV,
+};
+
+static struct clk pll0_clk = {
+	.name		= "PLL0 CLK",
+	.rate		= PLL0_OUT_HZ,
+	.number		= PLL0,
+	.params		= &lf1000_pll0_params,
+	.setvco		= lf1000_oscvco_set,
+};
+
+static const struct lf1000_params lf1000_pll1_params = {
+	.ref		= CRYSTAL_FREQ_HZ,
+	.vco_max	= MAX_VCOF_HZ(PLL1),
+	.md_min		= MIN_MDIV,
+	.md_max		= MAX_MDIV,
+	.pd_min		= MIN_PDIV,
+	.pd_max		= MAX_PDIV,
+};
+
+static struct clk pll1_clk = {
+	.name		= "PLL1 CLK",
+	.rate		= PLL1_OUT_HZ,
+	.number		= PLL1,
+	.params		= &lf1000_pll1_params,
+	.setvco 	= lf1000_oscvco_set,
+};
+
+int clk_register(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+	clk->setvco( clk);
+
+	printk("PLL%d=%3d.%03d MHz   ", (int)clk->number,
+					(int)get_pll_freq(clk->number)/1000000,
+					(int)get_pll_freq(clk->number)%1000000);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+void set_cpu_freq(unsigned int hertz)
+{
+	pll0_clk.rate = hertz;
+	lf1000_oscvco_set(&pll0_clk);	// set new speed
+}
+EXPORT_SYMBOL(set_cpu_freq);
+
+/* generate a suggested divider value from a PLL rate */
+int lf1000_CalcDivider(unsigned int pll_hz, unsigned int desired_hz)
+{
+	int div, rem;
+
+	if(pll_hz == 0 || desired_hz == 0 || desired_hz > pll_hz)
+		return -1;
+
+	div = pll_hz/desired_hz;
+	rem = pll_hz%desired_hz;
+
+	/*
+	 * if 'rem' is greater than (desired_hz / 2) round up
+	 * as 'div+1' is a more accurate divisor
+	 */
+	if ((desired_hz / 2) < rem)
+		div++;
+	
+	return(div);
+}
+EXPORT_SYMBOL(lf1000_CalcDivider);
+
+static struct clk * plla[] __initdata = {
+	&pll0_clk,
+	&pll1_clk,
+};
+
+int __init clk_init(void)
+{
+	int pll;
+
+	/* register clock sources */
+	for(pll = 0; pll < ARRAY_SIZE(plla); pll++)
+		clk_register(plla[pll]);
+
+	return 0;
+}
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/clock_dev.c linux-2.6/arch/arm/mach-lf1000/clock_dev.c
--- linux-2.6.31/arch/arm/mach-lf1000/clock_dev.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/clock_dev.c	2011-01-04 15:14:35.000000000 -0800
@@ -0,0 +1,234 @@
+/* LF1000 clock utilities
+ * 
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/sysfs.h>
+
+#include <mach/core.h>
+#include <mach/clkpwr.h>
+
+#define RESSIZE(res) (((res)->end - (res)->start)+1)
+
+struct lf1000_clk {
+	void __iomem *mem;
+	struct resource *res;
+};
+
+static ssize_t show_cpu_freq_in_hz(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = get_cpu_freq();
+	return sprintf(buf,"%u\n", tmp);
+}
+
+static ssize_t set_cpu_freq_in_hz(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (sscanf(buf, "%u", &value) != 1)
+		return -EINVAL;
+
+	set_cpu_freq(value);
+
+	return count;
+}
+static DEVICE_ATTR(cpu_freq_in_hz, S_IRUGO|S_IWUGO, show_cpu_freq_in_hz,
+		set_cpu_freq_in_hz);
+
+static int set_pll(struct lf1000_clk *clkdev, const char *buf, u8 pll)
+{
+	u32 val;
+	u32 p, m, s;
+	u8 reg;
+
+	if (pll > 1)
+		return -EINVAL;
+	reg = pll ? PLLSETREG1 : PLLSETREG0;
+
+	if (sscanf(buf, "%d,%d,%d", &p, &m, &s) != 3)
+		return -EINVAL;
+
+	val = ((p & 0x1F)<<PDIV_0) | ((m & 0x3FF)<<MDIV_0) | s;
+
+	/* don't do anything if there's no change */
+	if (readl(clkdev->mem + reg) == val)
+		return 0;
+
+	/* update the PLL settings and wait for it to re-lock */
+	writel(val, clkdev->mem + reg);
+	val = readl(clkdev->mem + PWRMODE);
+	writel(val | (1<<CHGPLL), clkdev->mem + PWRMODE);
+	while (readl(clkdev->mem + PWRMODE) & (1<<CHGPLL));
+
+	return 0;
+}
+
+static ssize_t show_pll1(struct device *pdev, struct device_attribute *attr,
+		char *buf)
+{
+	u32 reg;
+	struct lf1000_clk *clkdev = dev_get_drvdata(pdev);
+
+	reg = readl(clkdev->mem + PLLSETREG1);
+	return sprintf(buf, "%d,%d,%d\n", (reg>>PDIV_0) & 0x1F,
+			(reg>>MDIV_0) & 0x3FF, reg & 0xFF);
+}
+
+static ssize_t set_pll1(struct device *pdev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int ret;
+	struct lf1000_clk *clkdev = dev_get_drvdata(pdev);
+
+	ret = set_pll(clkdev, buf, 1);
+	if (ret)
+		return ret;
+
+	/* update linux system tick counter when freq changed */
+	lf1000_pll1_clock_changed();
+
+	return count;
+}
+
+static DEVICE_ATTR(pll1, S_IRUGO|S_IWUGO, show_pll1, set_pll1);
+
+static ssize_t show_pll0(struct device *pdev, struct device_attribute *attr,
+		char *buf)
+{
+	u32 reg;
+	struct lf1000_clk *clkdev = dev_get_drvdata(pdev);
+
+	reg = readl(clkdev->mem + PLLSETREG0);
+	return sprintf(buf, "%d,%d,%d\n", (reg>>PDIV_0) & 0x1F,
+			(reg>>MDIV_0) & 0x3FF, reg & 0xFF);
+}
+
+static ssize_t set_pll0(struct device *pdev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int ret;
+	struct lf1000_clk *clkdev = dev_get_drvdata(pdev);
+
+	ret = set_pll(clkdev, buf, 0);
+	if (ret)
+		return ret;
+	return count;
+}
+
+static DEVICE_ATTR(pll0, S_IRUGO|S_IWUGO, show_pll0, set_pll0);
+
+static struct attribute *clock_attributes[] = {
+	&dev_attr_pll0.attr,
+	&dev_attr_pll1.attr,
+	&dev_attr_cpu_freq_in_hz.attr,
+	NULL
+};
+
+static struct attribute_group clock_attr_group = {
+	.attrs = clock_attributes,
+};
+
+static int lf1000_clock_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct lf1000_clk *clkdev;
+
+	clkdev = kzalloc(sizeof(struct lf1000_clk), GFP_KERNEL);
+	if (!clkdev)
+		return -ENOMEM;
+
+	clkdev->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!clkdev->res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		ret = -ENXIO;
+		goto out_res;
+	}
+
+	if (!request_mem_region(clkdev->res->start, RESSIZE(clkdev->res),
+				"lf1000-clock")) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		ret = -EBUSY;
+		goto out_res;
+	}
+
+	clkdev->mem = ioremap_nocache(clkdev->res->start,
+			RESSIZE(clkdev->res));
+	if (!clkdev->mem) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		ret = -ENOMEM;
+		goto out_map;
+	}
+
+	platform_set_drvdata(pdev, clkdev);
+
+	sysfs_create_group(&pdev->dev.kobj, &clock_attr_group);
+
+	return 0;
+
+out_map:
+	release_mem_region(clkdev->res->start, RESSIZE(clkdev->res));
+out_res:
+	kfree(clkdev);
+	
+	return ret;
+
+}
+
+static int lf1000_clock_remove(struct platform_device* pdev)
+{
+	struct lf1000_clk *clkdev = platform_get_drvdata(pdev);
+
+	sysfs_remove_group(&pdev->dev.kobj, &clock_attr_group);
+	iounmap(clkdev->mem);
+	release_mem_region(clkdev->res->start, RESSIZE(clkdev->res));
+	kfree(clkdev);
+	
+	return 0;
+}
+
+static struct platform_driver lf1000_clock_drv = {
+	.probe		= lf1000_clock_probe,
+	.remove		= lf1000_clock_remove,
+	.suspend	= NULL,
+	.resume		= NULL,
+	.driver		= {
+		.name	= "lf1000-clock",
+		.owner	= THIS_MODULE,
+	},
+};
+
+int lf1000_clock_dev_init(void)
+{
+	return platform_driver_register(&lf1000_clock_drv);
+}
+EXPORT_SYMBOL_GPL(lf1000_clock_dev_init);
+
+void lf1000_clock_dev_exit(void)
+{
+	platform_driver_unregister(&lf1000_clock_drv);
+}
+EXPORT_SYMBOL_GPL(lf1000_clock_dev_exit);
+
+module_init(lf1000_clock_dev_init);
+module_exit(lf1000_clock_dev_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:clock");
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/core.c linux-2.6/arch/arm/mach-lf1000/core.c
--- linux-2.6.31/arch/arm/mach-lf1000/core.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/core.c	2012-11-16 18:13:09.000000000 -0800
@@ -0,0 +1,969 @@
+/*
+ * arch/arm/mach-lf1000/core.c
+ *
+ * Copyright LeapFrog Enterprises Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/libertas_spi.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/uart.h>
+#include <mach/nand.h>
+#include <mach/clkpwr.h>
+#include <mach/gpio.h>
+#include <mach/gpio_hal.h>
+#include <mach/gpio_map.h>
+#include <mach/timer.h>
+#include <mach/ic.h>
+#include <linux/cnt32_to_63.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/leds.h>
+#include <mach/lf1000.h>
+#include <asm/hardware/vic.h>
+#include <asm/mach-types.h>
+
+#include <plat/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+
+#include <mach/core.h>
+#include <mach/clock.h>
+#include <mach/screen.h>
+
+static u64 dma_mask_default = 0xffffffffUL;
+
+/*
+ * All IO addresses are mapped onto VA 0xFFFx.xxxx, where x.xxxx
+ * is the (PA >> 12).
+ *
+ * Setup a VA for the Lf1000 Vectored Interrupt Controller.  Note that INTMODEL
+ * is the start of the Interrupt Controller registers, LF1000_IC_BASE starts
+ * with a coupe of words that are reserved.
+ */
+
+static struct map_desc lf1000_io_desc[] __initdata = {
+	{	/* SHADOW bit fixup code assumes first entry has NAND info */
+		.virtual	=  IO_ADDRESS(LF1000_NAND_BASE_LOW),
+		.pfn		= __phys_to_pfn(LF1000_NAND_BASE_LOW),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	=  IO_ADDRESS(LF1000_SYS_BASE),
+		.pfn		= __phys_to_pfn(LF1000_SYS_BASE),
+		.length		= SZ_4K*32,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	=  IO_ADDRESS(LF1000_3DGE_BASE),
+		.pfn		= __phys_to_pfn(LF1000_3DGE_BASE),
+		.length		= SZ_4K*2,
+		.type		= MT_DEVICE
+	}, 
+#ifndef CONFIG_MACH_LF_LF1000
+	{
+		.virtual	=  IO_ADDRESS(LF1000_ETH_BASE),
+		.pfn		= __phys_to_pfn(LF1000_ETH_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+#endif
+};
+
+void __init lf1000_map_io(void)
+{
+	/* fixup NAND address based on SHADOW bit setting */
+	if (lf1000_is_shadow()) {
+		lf1000_io_desc[0].virtual = IO_ADDRESS(LF1000_NAND_BASE_HIGH);
+		lf1000_io_desc[0].pfn    = __phys_to_pfn(LF1000_NAND_BASE_HIGH);
+	} else {
+		lf1000_io_desc[0].virtual = IO_ADDRESS(LF1000_NAND_BASE_LOW);
+		lf1000_io_desc[0].pfn     = __phys_to_pfn(LF1000_NAND_BASE_LOW);
+	}
+
+	/* PAD_STRENGTH_BUS: reduce drive to LCD */
+	writel(0x00fc0000, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHBUS));
+	iotable_init(lf1000_io_desc, ARRAY_SIZE(lf1000_io_desc));
+	// need early clock initialization
+	lf1000_clock_init();
+
+}
+
+struct resource lf1000_audio_resources[] = {
+	[0] = {
+		.start		= LF1000_AUDIO_BASE,
+		.end		= LF1000_AUDIO_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_AUDIO_IRQ,
+		.end		= LF1000_AUDIO_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_audio_device = {
+	.name			= "lf1000-audio",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(lf1000_audio_resources),
+	.resource		= lf1000_audio_resources,
+};
+
+#if defined CONFIG_I2C_LF1000 || CONFIG_I2C_LF1000_MODULE
+struct resource lf1000_i2c0_resources[] = {
+	[0] = {
+		.start		= LF1000_I2C0_BASE,
+		.end		= LF1000_I2C0_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_I2C0_IRQ,
+		.end		= LF1000_I2C0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct resource lf1000_i2c1_resources[] = {
+	[0] = {
+		.start		= LF1000_I2C1_BASE,
+		.end		= LF1000_I2C1_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_I2C1_IRQ,
+		.end		= LF1000_I2C1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+/* supported I2C devices (boards) */
+
+static struct i2c_board_info __initdata lf1000_i2c_codec_cs43l22 = {
+	I2C_BOARD_INFO("CS43L22", 0x94),
+	.irq = 0,
+};
+
+/* supported I2C busses (channels) */
+
+struct platform_device lf1000_i2c_devices[] = {
+	[0] = {
+		.name			= "lf1000-i2c",
+		.id			= 0,
+		.resource		= lf1000_i2c0_resources,
+		.num_resources		= ARRAY_SIZE(lf1000_i2c0_resources),
+	},
+	[1] = {
+		.name			= "lf1000-i2c",
+		.id			= 1,
+		.resource		= lf1000_i2c1_resources,
+		.num_resources		= ARRAY_SIZE(lf1000_i2c1_resources),
+	}
+};
+#endif /* defined CONFIG_I2C_LF1000 || CONFIG_I2C_LF1000_MODULE */
+
+struct platform_device lf1000_asoc_device = {
+	.name				= "didj-asoc",
+	.id				= -1,
+	.resource			= NULL,
+	.num_resources			= 0,
+};
+
+#if defined CONFIG_MMC_MES || defined CONFIG_MMC_MES_MODULE
+
+#ifdef CONFIG_MMC_MES_CHANNEL0
+struct resource lf1000_sdhc0_resources[] = {
+	[0] = {
+		.start		= LF1000_SDIO0_BASE,
+		.end		= LF1000_SDIO0_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_SDIO0_IRQ,
+		.end		= LF1000_SDIO0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_sdhc0_device = {
+	.name			= "mes-sdhc",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(lf1000_sdhc0_resources),
+	.resource		= lf1000_sdhc0_resources,
+};
+#endif
+
+#ifdef CONFIG_MMC_MES_CHANNEL1
+struct resource lf1000_sdhc1_resources[] = {
+	[0] = {
+		.start		= LF1000_SDIO1_BASE,
+		.end		= LF1000_SDIO1_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_SDIO1_IRQ,
+		.end		= LF1000_SDIO1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_sdhc1_device = {
+	.name			= "mes-sdhc",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(lf1000_sdhc1_resources),
+	.resource		= lf1000_sdhc1_resources,
+};
+#endif
+#endif /* CONFIG_MMC_MES || CONFIG_MMC_MES_MODULE */
+
+struct resource lf1000_nand_resource = {
+	.start			= LF1000_NAND_BASE_LOW,
+	.end			= LF1000_NAND_BASE_LOW +
+				  LF1000_NAND_SIZE - 1,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_nand_device = {
+	.name			= "lf1000-nand",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_nand_resource,
+};
+
+struct platform_device lf1000_power_device = {
+	.name			= "lf1000-power",
+	.id			= -1,
+	.num_resources		= 0,
+};
+
+struct resource lf1000_rtc_resource = {
+	.start			= LF1000_RTC_BASE,
+	.end			= LF1000_RTC_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_rtc_device = {
+	.name			= "lf1000-rtc",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_rtc_resource,
+};
+
+#if defined CONFIG_FB_LF1000 || defined CONFIG_FB_LF1000_MODULE
+
+struct resource lf1000_fb_resources[] = {
+	[0] = {	/* frame buffer memory */
+		.start		= LF1000_FB_START_ADDR,
+		.end		= LF1000_FB_START_ADDR+LF1000_FB_SIZE,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = { /* MLC registers */
+		.start		= LF1000_MLC_BASE,
+		.end		= LF1000_MLC_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = { /* DPC VSYNC */
+		.start		= LF1000_DPC_IRQ,
+		.end		= LF1000_DPC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_fb_device = {
+	.name			= "lf1000-fb",
+	.id			= -1,
+	.dev = {
+		.dma_mask = (u64 *)~0,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources		= ARRAY_SIZE(lf1000_fb_resources),
+	.resource		= lf1000_fb_resources,
+};
+
+/* Get MLC FB address and size from mlc_fb=ADDR,SIZE kernel cmd line arg */
+static int __init mlc_fb_setup(char *str)
+{
+	char *s;
+	lf1000_fb_resources[0].start = simple_strtol(str, &s, 0);
+	if (*s == ',')
+		lf1000_fb_resources[0].end = simple_strtol(s+1, &s, 0);
+	lf1000_fb_resources[0].end += lf1000_fb_resources[0].start;
+	return 1;
+}
+
+__setup("mlc_fb=", mlc_fb_setup);
+
+#else /* old graphics framework */
+
+struct resource lf1000_mlc_resource = {
+	.start			= LF1000_MLC_BASE,
+	.end			= LF1000_MLC_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_mlc_device = {
+	.name			= "lf1000-mlc",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_mlc_resource,
+};
+#endif
+
+struct resource lf1000_dpc_resource = {
+	.start			= LF1000_DPC_BASE,
+	.end			= LF1000_DPC_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_dpc_device = {
+	.name			= "lf1000-dpc",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_dpc_resource,
+};
+
+#if defined(CONFIG_BACKLIGHT_LF1000_PWM) || defined (CONFIG_BACKLIGHT_LF1000_PWM_MODULE)
+struct platform_device lf1000_bl_device = {
+	.name			= "lf1000-bl",
+	.id			= -1,
+	.num_resources		= 0,
+	.resource		= NULL,
+};
+#endif
+
+struct resource lf1000_adc_resources[] = {
+	[0] = {
+		.start		= LF1000_ADC_BASE,
+		.end		= LF1000_ADC_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_ADC_IRQ,
+		.end		= LF1000_ADC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_adc_device = {
+	.name			= "lf1000-adc",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(lf1000_adc_resources),
+	.resource		= lf1000_adc_resources,
+};
+
+struct resource lf1000_gpio_resources[] = {
+	[0] = {
+		.start		= LF1000_GPIO_BASE,
+		.end		= LF1000_GPIO_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_GPIOCURRENT_BASE,
+		.end		= LF1000_GPIOCURRENT_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start		= LF1000_GPIO_IRQ,
+		.end		= LF1000_GPIO_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_gpio_device = {
+	.name			= "lf1000-gpio",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(lf1000_gpio_resources),
+	.resource		= lf1000_gpio_resources,
+};
+
+struct resource lf1000_alvgpio_resource = {
+	.start			= LF1000_ALIVE_BASE,
+	.end			= LF1000_ALIVE_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_alvgpio_device = {
+	.name			= "lf1000-alvgpio",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_alvgpio_resource,
+};
+
+#if defined CONFIG_KEYBOARD_LF1000 || defined CONFIG_KEYBOARD_LF1000_MODULE
+struct platform_device lf1000_kp_device = {
+	.name			= "lf1000-keypad",
+	.id			= -1,
+	.num_resources		= 0,
+};
+#endif
+
+#if defined CONFIG_INPUT_LF1000_ACLMTR || defined CONFIG_INPUT_LF1000_ACLMTR_MODULE
+struct platform_device lf1000_aclmtr_device = {
+	.name			= "lf1000-aclmtr",
+	.id			= -1,
+	.num_resources		= 0,
+};
+#endif
+
+struct resource lf1000_pwm_resource = {
+	.start			= LF1000_PWM_BASE,
+	.end			= LF1000_PWM_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_pwm_device = {
+	.name			= "lf1000-pwm",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_pwm_resource,
+};
+
+struct resource lf1000_ga3d_resource = {
+	.start			= LF1000_GA3D_BASE,
+	.end			= LF1000_GA3D_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_ga3d_device = {
+	.name			= "lf1000-ga3d",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_ga3d_resource,
+};
+
+struct resource lf1000_idct_resource = {
+	.start			= LF1000_IDCT_BASE,
+	.end			= LF1000_IDCT_END,
+	.flags			= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_idct_device = {
+	.name			= "lf1000-idct",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_idct_resource,
+};
+
+#if defined CONFIG_SPI_LF1000 || defined CONFIG_SPI_LF1000_MODULE
+#if defined CONFIG_SPI_LF1000_CHANNEL_0
+struct resource lf1000_spi0_resources[] = {
+	[0] = {
+		.start		= LF1000_SPI0_BASE,
+		.end		= LF1000_SPI0_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_SPI0_IRQ,
+		.end		= LF1000_SPI0_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+#endif
+
+#if defined CONFIG_SPI_LF1000_CHANNEL_1
+struct resource lf1000_spi1_resources[] = {
+	[0] = {
+		.start		= LF1000_SPI1_BASE,
+		.end		= LF1000_SPI1_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_SPI1_IRQ,
+		.end		= LF1000_SPI1_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+#endif
+
+#if defined CONFIG_SPI_LF1000_CHANNEL_2
+struct resource lf1000_spi2_resources[] = {
+	[0] = {
+		.start		= LF1000_SPI2_BASE,
+		.end		= LF1000_SPI2_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_SPI2_IRQ,
+		.end		= LF1000_SPI2_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+#endif
+
+#if defined CONFIG_SPI_LF1000_CHANNEL_0
+struct platform_device lf1000_spi_device_0 = {
+	.name		= "lf1000-spi",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(lf1000_spi0_resources),
+	.resource	= lf1000_spi0_resources,
+	.dev		= {
+				.dma_mask = &dma_mask_default,
+				.coherent_dma_mask	= ~0,
+	},
+};
+#endif
+
+#if defined CONFIG_SPI_LF1000_CHANNEL_1
+struct platform_device lf1000_spi_device_1 = {
+	.name		= "lf1000-spi",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(lf1000_spi1_resources),
+	.resource	= lf1000_spi1_resources,
+	.dev		= {
+				.dma_mask = &dma_mask_default,
+				.coherent_dma_mask	= ~0,
+	},
+};
+#endif
+
+#if defined CONFIG_SPI_LF1000_CHANNEL_2
+struct platform_device lf1000_spi_device_2 = {
+	.name		= "lf1000-spi",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(lf1000_spi2_resources),
+	.resource	= lf1000_spi2_resources,
+	.dev		= {
+				.dma_mask = &dma_mask_default,
+				.coherent_dma_mask	= ~0,
+	},
+};
+#endif
+#endif /* defined CONFIG_SPI_LF1000 || defined CONFIG_SPI_LF1000_MODULE */
+
+struct resource lf1000_dma_resources[] = {
+	[0] = {
+		.start		= LF1000_DMA_BASE,
+		.end		= LF1000_DMA_BASE + 8 * 0x80 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_DMA_IRQ,
+		.end		= LF1000_DMA_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+
+};
+
+struct platform_device lf1000_dma_device = {
+	.name			= "lf1000-dma",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(lf1000_dma_resources),
+	.resource		= lf1000_dma_resources,
+};
+
+struct resource lf1000_udc_resources[] = {
+	[0] = {
+		.start		= LF1000_UDC_BASE,
+		.end		= LF1000_UDC_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_UDC_IRQ,
+		.end		= LF1000_UDC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_udc_device = {
+	.name			= "lf1000-usbgadget",
+	.id			= -1,
+	.num_resources		= ARRAY_SIZE(lf1000_udc_resources),
+	.resource		= lf1000_udc_resources,
+};
+
+struct resource lf1000_uhc_resources[] = {
+	[0] = {
+		.start		= LF1000_UHC_BASE,
+		.end		= LF1000_UHC_END,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= LF1000_UHC_IRQ,
+		.end		= LF1000_UHC_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lf1000_uhc_device = {
+	.name			= "lf1000-ohci",
+	.id			= -1,
+	.dev             	= {   
+		.dma_mask = &dma_mask_default,
+		.coherent_dma_mask = 0xffffffffUL
+	},
+	.num_resources	= ARRAY_SIZE(lf1000_uhc_resources),
+	.resource		= lf1000_uhc_resources,
+};
+
+struct resource lf1000_clock_resource = {
+	.start		= LF1000_CLKPWR_BASE,
+	.end		= LF1000_CLKPWR_END,
+	.flags		= IORESOURCE_MEM,
+};
+
+struct platform_device lf1000_clock_device = {
+	.name			= "lf1000-clock",
+	.id			= -1,
+	.num_resources		= 1,
+	.resource		= &lf1000_clock_resource,
+};
+
+static struct platform_device *devices[] __initdata = {
+	&lf1000_gpio_device,
+	&lf1000_alvgpio_device,
+	&lf1000_dma_device,
+#if defined CONFIG_MMC_MES || defined CONFIG_MMC_MES_MODULE
+#ifdef CONFIG_MMC_MES_CHANNEL0
+	&lf1000_sdhc0_device,
+#endif
+#ifdef CONFIG_MMC_MES_CHANNEL1
+	&lf1000_sdhc1_device,
+#endif
+#endif
+	&lf1000_nand_device,
+	&lf1000_pwm_device,
+#if defined CONFIG_I2C_LF1000 || CONFIG_I2C_LF1000_MODULE
+	&lf1000_i2c_devices[0],
+	&lf1000_i2c_devices[1],
+#endif
+#if defined CONFIG_SPI_LF1000 || defined CONFIG_SPI_LF1000_MODULE
+#if defined CONFIG_SPI_LF1000_CHANNEL_0
+	&lf1000_spi_device_0,
+#endif
+#if defined CONFIG_SPI_LF1000_CHANNEL_1
+	&lf1000_spi_device_1,
+#endif
+#if defined CONFIG_SPI_LF1000_CHANNEL_2
+	&lf1000_spi_device_2,
+#endif
+#endif /* defined CONFIG_SPI_LF1000 || defined CONFIG_SPI_LF1000_MODULE */
+	&lf1000_adc_device,
+	&lf1000_dpc_device,
+#if defined CONFIG_FB_LF1000 || defined CONFIG_FB_LF1000_MODULE
+	&lf1000_fb_device,
+#else /* old graphics framework */
+	&lf1000_mlc_device,
+#endif
+#if defined(CONFIG_BACKLIGHT_LF1000_PWM) || defined (CONFIG_BACKLIGHT_LF1000_PWM_MODULE)
+	&lf1000_bl_device,
+#endif
+	&lf1000_udc_device,
+	&lf1000_uhc_device,
+	&lf1000_rtc_device,
+	&lf1000_audio_device,
+	&lf1000_asoc_device,
+	&lf1000_ga3d_device,
+	&lf1000_power_device,
+#if defined CONFIG_KEYBOARD_LF1000 || defined CONFIG_KEYBOARD_LF1000_MODULE
+	&lf1000_kp_device,
+#endif
+#if defined CONFIG_INPUT_LF1000_ACLMTR || defined CONFIG_INPUT_LF1000_ACLMTR_MODULE
+	&lf1000_aclmtr_device,
+#endif
+	&lf1000_idct_device,
+	&lf1000_clock_device,
+};
+
+/*
+ * Poweroff and Reset
+ */
+
+static void lf1000_poweroff(void)
+{
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN0, 0);      // nCOM1_ENA
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN1, 0);      // NAND_nWP
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN3, 0);      // USBH_PWR
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN4, 0);      // nDAC_ENA
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN5, 0);      // LCD_nRES
+	gpio_set_val(GPIO_PORT_ALV, GPIO_PIN6, 0);      // nDAC_RES
+
+	// power-down LED_PWM (PWMOUT[0]) and LED_BRIGHT (PWMOUT[1])
+	gpio_set_val(GPIO_PORT_A, GPIO_PIN30, 0);       // PWMOUT[0]
+	gpio_set_val(GPIO_PORT_A, GPIO_PIN31, 0);       // PWMPUT[1]
+
+	/* cut the power */
+	gpio_set_val(GPIO_PORT_ALV, VDDPWRONSET, 0);
+
+	arm_machine_restart('h', NULL);
+}
+
+static void lf1000_restart(char mode, const char *cmd)
+{
+	u32 tmp = REG32(IO_ADDRESS(LF1000_CLKPWR_BASE+PWRMODE));
+
+	BIT_SET(tmp, GPIOSWRSTENB);
+	BIT_CLR(tmp, SWRST);
+	REG32(IO_ADDRESS(LF1000_CLKPWR_BASE+PWRMODE)) = tmp;
+	BIT_SET(tmp, SWRST);
+	REG32(IO_ADDRESS(LF1000_CLKPWR_BASE+PWRMODE)) = tmp;
+
+	arm_machine_restart('h', cmd);
+}
+
+/*
+ * Machine Initialization
+ */
+
+void __init lf1000_init(void)
+{
+	pm_power_off = lf1000_poweroff;
+	arm_pm_restart = lf1000_restart;
+
+	/* set NOR flash and NAND addresses depending on boot mode */
+	if (lf1000_is_shadow()) {
+		lf1000_nand_resource.start = LF1000_NAND_BASE_HIGH;
+	} else {
+		lf1000_nand_resource.start = LF1000_NAND_BASE_LOW;
+	}
+
+	lf1000_nand_resource.end  = lf1000_nand_resource.start +
+				    LF1000_NAND_SIZE - 1;
+
+
+#if defined CONFIG_I2C_LF1000 || CONFIG_I2C_LF1000_MODULE
+	i2c_register_board_info(0, &lf1000_i2c_codec_cs43l22, 1);
+#endif
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+/* configure static bus timings as needed */
+static void __init lf1000_acc_time_init( void)
+{
+	volatile unsigned int test;
+	/* set NOR chip CS0 and CS1 selects to slowest settings */
+	SET_MRS(LF1000_TSACC0, 4, LF1000_MEMTIMESACCL_OFF, 0x0f);
+	SET_MRS(LF1000_TSACC1, 4, LF1000_MEMTIMESACCL_OFF, 0x0f);
+}
+
+//////////////////////////// UART setup ///////////////////////////////////////
+/* default settings for system UART */
+static int sys_uart	= LF1000_SYS_UART;
+static int sys_uart_br = LF1000_SYS_UART_BR;
+
+static void __init lf1000_console_setup( char* name, int idx, char* options)
+{
+	if(!strcmp(name, "ttyS")) {
+		if(idx < UART_MAX) {
+			sys_uart = idx;
+			sys_uart_br = simple_strtoul( options, NULL, 10);
+			set_uart_baud( sys_uart, sys_uart_br);
+		}
+	}
+}
+
+static int __init console_setup(char *str)
+{
+//	char name[sizeof(console_cmdline[0].name)];
+	char name[16];	// really is 8 bytes
+	char *s, *options;
+	int idx;
+
+	/*
+	 * Decode str into name, index, options.
+	 */
+	if (str[0] >= '0' && str[0] <= '9') {
+		strcpy(name, "ttyS");
+		strncpy(name + 4, str, sizeof(name) - 5);
+	} else {
+		strncpy(name, str, sizeof(name) - 1);
+	}
+	name[sizeof(name) - 1] = 0;
+	if ((options = strchr(str, ',')) != NULL)
+		*(options++) = 0;
+
+	for (s = name; *s; s++)
+		if ((*s >= '0' && *s <= '9') || *s == ',')
+			break;
+	idx = simple_strtoul(s, NULL, 10);
+	*s = 0;
+
+	lf1000_console_setup( name, idx, options);
+	add_preferred_console(name, idx, options);
+	return 1;
+}
+__setup("console=", console_setup);
+
+////////////////////////////// PLL setup /////////////////////////////////////
+extern int __init clk_init(void);
+
+void __init lf1000_clock_init( void)
+{
+	// early clock initialization
+	clk_init();
+	// ether/nand flash access time init
+	lf1000_acc_time_init();
+}
+
+#define LF1000_TIMER0_VA_BASE		IO_ADDRESS(LF1000_TIMER0_BASE)
+#define LF1000_TIMER1_VA_BASE		IO_ADDRESS(LF1000_TIMER1_BASE)
+#define LF1000_TIMER2_VA_BASE		IO_ADDRESS(LF1000_TIMER2_BASE)
+#define LF1000_TIMER3_VA_BASE		IO_ADDRESS(LF1000_TIMER3_BASE)
+
+/*
+ * Returns number of usecs since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ *
+ * Preserve tick resolution by scaling tick count up then dividing.
+ */
+
+static unsigned long lf1000_gettimeoffset(void)
+{
+	unsigned long ticks;
+
+	/*
+	 * Number of ticks since last interrupt.
+	 */
+	ticks = get_timer_cnt(LF1000_INTERTICK_TIMER);
+
+	/*
+	 * Convert the ticks to usecs.
+	 */
+
+	return ((ticks * LF1000_INTERVAL_IN_USEC) / TIMER_SYS_TICK);
+}
+
+/*
+ * PLL1 changed, adjust other dependent timers
+ *
+ * currently have only the Linux system timer
+ */
+void lf1000_pll1_clock_changed(void)
+{
+	struct lf1000_timer* timer_p = get_timer_pnt(LF1000_SYS_TIMER);
+
+	/* update Linux system timer */
+	iowrite32(TIMER_SYS_TICK, &timer_p->tmrmatch);
+	iowrite32(0, &timer_p->tmrcount);
+	printk(KERN_INFO "%s.%d TIMER_SYS_TICK=%ld\n",
+		__FUNCTION__, __LINE__, TIMER_SYS_TICK);
+}
+EXPORT_SYMBOL(lf1000_pll1_clock_changed);
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t lf1000_timer_interrupt(int irq, void *dev_id)
+{
+	unsigned int timer_control, intertick_control;
+	unsigned int timer_count, intertick_count;
+	struct lf1000_timer* timer_p = get_timer_pnt(LF1000_SYS_TIMER);
+	struct lf1000_timer* tick_p = get_timer_pnt(LF1000_INTERTICK_TIMER);
+	
+	// ...clear the interrupt
+	clear_timer_irq(irq);
+
+	/* setup for TIMER count read */
+	timer_control = ioread32(&timer_p->tmrcontrol);
+	timer_control &= ~(1<<INTPEND);    // do not clear pend
+	timer_control |=  (1<<LDCNT);      // latch count
+	iowrite32( timer_control, &timer_p->tmrcontrol);
+	timer_count = ioread32(&timer_p->tmrcount);
+
+	/* setup for TICK count read */
+	intertick_control = ioread32(&tick_p->tmrcontrol);
+	intertick_control &= ~(1<<INTPEND);	// do not clear pend
+	intertick_control |=  (1<<LDCNT);	// latch count
+
+	/* read current TICK count */
+	iowrite32(intertick_control, &tick_p->tmrcontrol);// snapshot tick count
+	intertick_count = ioread32(&tick_p->tmrcount);
+
+	/* update TICK count with TIMER count */	
+	iowrite32(timer_control, &timer_p->tmrcontrol); // snapshot timer count
+	timer_count = ioread32(&timer_p->tmrcount);
+	iowrite32(timer_count, &tick_p->tmrcount);	// catchup to SYS_TIMER
+	
+	/* 
+	 * have at least one timer tick, account for additional
+	 * ticks recorded by intertick timer
+	 */
+	do {
+		timer_tick();
+		if (intertick_count > TIMER_SYS_TICK)
+			intertick_count -= TIMER_SYS_TICK;
+	} while (intertick_count > TIMER_SYS_TICK);
+
+	// write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction lf1000_timer_irq = {
+	.name		= "Lf1000 Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= lf1000_timer_interrupt,
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+static void __init lf1000_timer_init(void)
+{
+	int i=0;
+	volatile struct lf1000_timer* timer_p;
+
+	while((timer_p = get_timer_pnt(i))) {
+		/* enable writes to timer module */
+		iowrite32((1<<TCLKMODE)|(1<<TCLKGENENB), &timer_p->tmrclkenb);	
+		// start from known values
+		iowrite32(0, &timer_p->tmrcount); /* TimerLoad */
+
+		iowrite32(ioread32(&timer_p->tmrcontrol) & ~SELTCLK_MASK,
+				&timer_p->tmrcontrol);
+		iowrite32(ioread32(&timer_p->tmrcontrol)|SELTCLK,
+				&timer_p->tmrcontrol);
+
+		iowrite32(ioread32(&timer_p->tmrclkgen)  & ~(0xff<<TCLKDIV),
+				&timer_p->tmrclkgen);
+		iowrite32(ioread32(&timer_p->tmrclkgen)|
+			((CLKDIVR<<TCLKDIV)|(TIMER_PLL<<TCLKSRCSEL)),
+			&timer_p->tmrclkgen);
+
+		/* 
+		 * Make IRQs happen for the system timer
+		 */
+		if(LF1000_SYS_TIMER == i) {
+			iowrite32(TIMER_SYS_TICK, &timer_p->tmrmatch);
+			setup_irq(get_timer_irq(i), &lf1000_timer_irq);
+			/* run timer with interrupts enabled */
+			iowrite32(ioread32(&timer_p->tmrcontrol)|
+				((1<<RUN)|(1<<INTPEND)|(1<<INTENB_T)),
+				&timer_p->tmrcontrol);
+		} else {
+			iowrite32(TIMER_FREE_RUN, &timer_p->tmrmatch);
+			iowrite32(ioread32(&timer_p->tmrcontrol)|
+				((1<<RUN)|(1<<INTPEND)),
+				&timer_p->tmrcontrol);
+		}
+		printk("TIM%d=%3d.%03d MHz   ", i, 
+				(get_timer_freq(i)/1000)/1000,
+				(get_timer_freq(i)/1000)%1000);
+		i++;
+	}
+	printk("\n");
+}
+
+struct sys_timer lf1000_timer = {
+	.init		= lf1000_timer_init,
+	.offset		= lf1000_gettimeoffset,
+};
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/dma.c linux-2.6/arch/arm/mach-lf1000/dma.c
--- linux-2.6.31/arch/arm/mach-lf1000/dma.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/dma.c	2011-05-11 17:38:02.000000000 -0700
@@ -0,0 +1,1192 @@
+/*
+ * Author:
+ *   Scott Esters <sesters@leapfrog.com>
+ *
+ * Description:
+ *   DMA engine driver for Magic Eyes LF1000 DMA controller
+ *   Adapted from CoreLogic Spica DMA Controller
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/list.h>
+#include <linux/scatterlist.h>
+#include <mach/dma.h>
+#include <mach/irqs.h>
+#include <mach/platform.h>
+
+#define DRIVER_NAME	"lf1000-dma"
+
+#ifdef LF1000_DMA_DEBUG
+#define DBG(x...) printk(KERN_ALERT DRIVER_NAME ": " x)
+#else
+#define DBG(x...)
+#endif
+
+#define USE_IOREMAP
+
+#define MAX_DMA_CHANNELS		8
+
+#define DEFAULT_MAX_NODE		32
+
+/* Register offset */
+#define DMASRCADDR			0x00
+#define DMADSTADDR			0x04
+#define DMALENGTH			0x08
+#define DMAREQID			0x0A
+#define DMAMODE				0x0C
+#define DMASRCADDR_WB			0x10
+#define DMADSTADDR_WB			0x14
+#define DMALENGTH_WB			0x18
+#define DMAREQID_WB			0x1A
+#define DMAMODE_WB			0x1C
+#define DMACMDWAIT			0x20
+#define DMACMDSTOP			0x24
+#define DMACMDBUSY			0x28
+#define DMACMDSPACE			0x2C
+
+/* Operation Mode */
+#define MODE_STOP			(1 << 20)
+#define MODE_RUN			(1 << 19)
+#define MODE_INTENB			(1 << 18)
+#define MODE_INTPEND			(1 << 17)
+#define MODE_BUSY			(1 << 16)
+#define MODE_DSTNOTREQCHK		(1 << 13)
+#define MODE_DSTNOTINC			(1 << 12)
+#define MODE_DSTIOMODE			(1 << 10)
+#define MODE_DSTIOSIZE_MASK		(3 << 8)
+#define MODE_SRCNOTREQCHK		(1 << 5)
+#define MODE_SRCNOTINC			(1 << 4)
+#define MODE_SRCIOMODE			(1 << 2)
+#define MODE_SRCIOSIZE_MASK		3
+
+#define set_dst_io_width(size)	((size >> 1) << 8)
+#define set_src_io_width(size)	(size >> 1)
+#define get_dst_io_width(mode)	(1 << ((mode & MODE_DSTIOSIZE_MASK) >> 8))
+#define get_src_io_width(mode)	(1 << (mode & MODE_SRCIOSIZE_MASK))
+
+enum dma_state {
+	DMAC_STOP 	= 0,
+	DMAC_RUN	= 1,
+};
+
+struct item_node {
+	struct list_head	link;
+	unsigned int 		src_addr;	// source address
+	unsigned int 		dst_addr;	// destination address
+	unsigned short		size;		// size of transfer - 1
+	unsigned short		req_id;
+	unsigned int 		op_mode;
+	unsigned int		int_flag;
+};
+
+struct dmachannel {
+	char			*device_id;
+	void __iomem		*reg;		// register of dma channel
+	enum dma_mem_io		mode;
+	enum dma_priority	priority;
+	enum dma_state		state;
+	irq_handler_t		handler;
+	void			*objdata;
+	spinlock_t 		lock;
+	struct list_head	active_nodes;	// active node list
+	struct list_head	free_nodes;	// free node list
+	struct item_node	*cur_node;	// indicates item_node of
+						// current dma transfer
+	int			num_node;	// transfer count
+};
+
+struct dma_info {
+	void __iomem		*reg;
+	unsigned int		num_active_channel;
+	struct dmachannel	dmach[MAX_DMA_CHANNELS];
+};
+
+static struct dma_info	*dmadev = NULL;
+
+/*******************************************************************************
+  * Function Name       : dma_irq_handler
+  * Input Parameter(s)  : int irq
+  			  void *dev_id
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
+{
+	unsigned int dma;
+	irqreturn_t ret;
+	struct item_node *node = NULL;
+	struct dmachannel *dmach;
+
+	if (!dmadev)
+		return IRQ_NONE;
+
+	dma = irq_to_dma(irq);
+
+	if (dma >= MAX_DMA_CHANNELS)
+		return IRQ_NONE;
+
+	dmach = &dmadev->dmach[dma];
+	if (!dmach->device_id)
+		return IRQ_NONE;
+
+#if 0
+	// process interrupt
+	if (dmach->handler && dmach->cur_node->int_flag)
+		ret = dmach->handler((int)dmach, dmach->objdata);
+
+	// check DMA is stopped ( dma_stop() )
+	if (dmach->state == DMAC_STOP) {
+		return IRQ_HANDLED;
+	}
+
+	// transfer next node
+	if (list_is_last((struct list_head*)dmach->cur_node, &dmach->active_nodes)) {
+		if (dmach->mode == DMA_MEM_IO) {
+			// transfer complete.
+			dmach->state = DMAC_STOP;
+			return IRQ_HANDLED;
+		} else {
+			// ring buffer..
+			node = (struct item_node*)list_first_entry(&dmach->active_nodes, struct item_node, link);
+		}
+	} else {
+		// get next node
+		node = (struct item_node*)dmach->cur_node->link.next;
+	}
+
+	dmach->cur_node = node;
+
+	writel(node->src_addr, dmach->reg + DMASRCADDR);
+	writel(node->dst_addr, dmach->reg + DMADSTADDR);
+	writew(node->size, dmach->reg + DMALENGTH);
+	writew(node->req_id, dmach->reg + DMAREQID);
+	node->op_mode |= MODE_RUN;
+	writel(node->op_mode, dmach->reg + DMAMODE);
+#else
+	// check DMA is stopped ( dma_stop() )
+	if (dmach->state == DMAC_STOP) {
+		goto irq_exit;
+	}
+
+	// transfer next node
+	if (list_is_last((struct list_head*)dmach->cur_node,
+		&dmach->active_nodes)) {
+		if (dmach->mode == DMA_MEM_IO) {
+			// transfer complete.
+			dmach->state = DMAC_STOP;
+			goto irq_exit;
+		} else {
+			// ring buffer..
+			node = (struct item_node*)
+				list_first_entry(&dmach->active_nodes,
+				struct item_node, link);
+		}
+	} else {
+		// get next node
+		node = (struct item_node*)dmach->cur_node->link.next;
+	}
+
+	dmach->cur_node = node;
+
+	writel(node->src_addr, dmach->reg + DMASRCADDR);
+	writel(node->dst_addr, dmach->reg + DMADSTADDR);
+	writew(node->size, dmach->reg + DMALENGTH);
+	writew(node->req_id, dmach->reg + DMAREQID);
+	node->op_mode |= MODE_RUN;
+	writel(node->op_mode, dmach->reg + DMAMODE);
+
+irq_exit:
+	// process interrupt
+	if (dmach->handler && dmach->cur_node->int_flag)
+		ret = dmach->handler((int)dmach, dmach->objdata);
+
+#endif
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+  * Function Name       : dma_get_free_node
+  * Input Parameter(s)  : struct dmachannel *dmach
+  * Output Parameter(s) : 
+  * Return Value        : node address. NULL is error
+  * Description         : 
+  *****************************************************************************/
+static struct item_node *dma_get_free_node(struct dmachannel *dmach)
+{
+	struct item_node *node = NULL;
+
+	if(list_empty(&dmach->free_nodes)) {
+		node = (struct item_node*)kzalloc(sizeof(struct item_node),
+			GFP_KERNEL);
+		DBG("alloc new item_node - %p\n", node);
+	} else {
+		node = list_first_entry(&dmach->free_nodes,
+			struct item_node, link);
+		list_del((struct list_head*)node); // remove node from free list
+	}
+	
+	return node;
+}
+
+unsigned int dma_get_base_address(int channel)
+{
+  return ((LF1000_DMA_BASE) + (0x80 * channel));
+}
+
+/*******************************************************************************
+  * Function Name       : dma_request
+  * Input Parameter(s)  : char *name
+			  dma_priority priority
+  			  irq_handler_t handler
+  			  void *objdata
+  * Output Parameter(s) : unsigned int *ch
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_request (char *name, enum dma_priority priority, irq_handler_t handler, void *objdata, unsigned int *ch)
+{
+	unsigned long flags;
+	struct item_node *node;
+	int i, cnt;
+
+	if (!dmadev)
+		return (-ENODEV);
+
+	local_irq_save(flags);
+
+	for(i = MAX_DMA_CHANNELS - 1; i >= 0 ; i--) {
+	//for(i = 0; i < MAX_DMA_CHANNELS ; i++) {
+		if(!dmadev->dmach[i].device_id &&
+			(dmadev->dmach[i].priority & priority)) {
+
+			dmadev->dmach[i].device_id = kzalloc(strlen(name) + 1,
+				GFP_KERNEL);
+			if(!dmadev->dmach[i].device_id) {
+				local_irq_restore(flags);
+				return (-ENOMEM);
+			}
+
+			strcpy(dmadev->dmach[i].device_id, (const char*)name);
+			dmadev->dmach[i].handler = handler;
+			dmadev->dmach[i].objdata = objdata;
+			dmadev->dmach[i].mode = DMA_MEM_IO;	// default mode
+			dmadev->dmach[i].state = DMAC_STOP;
+
+			INIT_LIST_HEAD(&dmadev->dmach[i].active_nodes);
+			INIT_LIST_HEAD(&dmadev->dmach[i].free_nodes);
+
+			for (cnt = 0; cnt < DEFAULT_MAX_NODE; cnt++) {
+				node = kzalloc(sizeof(struct item_node),
+					GFP_KERNEL);
+				if (!node)
+					goto error;
+				list_add_tail((struct list_head*)node,
+					&dmadev->dmach[i].free_nodes);
+			}
+
+			*ch = (unsigned int)&dmadev->dmach[i];
+
+			local_irq_restore(flags);
+
+			return 0;
+		}
+	}
+	
+	local_irq_restore(flags);
+
+	return (-EBUSY);
+error:
+	while(!list_empty(&dmadev->dmach[i].free_nodes)) {
+		node = (struct item_node*)
+			list_first_entry(&dmadev->dmach[i].free_nodes,
+			struct item_node, link);
+		list_del(&node->link);
+		kfree(node);
+	}
+
+	if(dmadev->dmach[i].device_id) {
+		kfree(dmadev->dmach[i].device_id);
+		dmadev->dmach[i].device_id = NULL;
+	}
+
+	local_irq_restore(flags);
+
+	return (-ENOMEM);
+}
+EXPORT_SYMBOL(dma_request);
+
+/*******************************************************************************
+  * Function Name       : dma_release
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_release(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned long flags;
+	int i;
+
+	if (!dmadev)
+		return (-ENODEV);
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	dma_stop(ch);
+	dma_reset(ch);
+	
+	// check valid
+	for(i = 0; i < MAX_DMA_CHANNELS; i++) {
+		if (dmadev->dmach[i].device_id) {
+			if (!strncmp(dmach->device_id,
+				dmadev->dmach[i].device_id, 32))
+				goto release;
+		}
+	}
+
+	DBG("not found opened DMA channel %u", ch);
+
+	return (-EINVAL);
+
+release:
+	local_irq_save(flags);
+
+	kfree(dmach->device_id);
+	while(!list_empty(&dmach->free_nodes)) {
+		node = (struct item_node*)list_first_entry(&dmach->free_nodes,
+			struct item_node, link);
+		list_del(&node->link);
+		kfree(node);
+	}
+
+	dmach->device_id = NULL;
+	dmach->handler = NULL;
+	dmach->objdata = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_release);
+
+/*******************************************************************************
+  * Function Name       : dma_start
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_start(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node;
+	unsigned long flags;
+
+	DBG("Entered %s - 0x%p\n", __func__, ch);
+
+	if (list_empty(&dmach->active_nodes))
+		return -1;
+
+	if (dma_is_enabled(ch))
+		return (-EBUSY);
+	
+	local_irq_save(flags);
+
+	dmach->cur_node = node = list_first_entry(&dmach->active_nodes,
+		struct item_node, link);
+	
+	writel(node->src_addr, dmach->reg + DMASRCADDR);
+	writel(node->dst_addr, dmach->reg + DMADSTADDR);
+	writew(node->size, dmach->reg + DMALENGTH);
+	writew(node->req_id, dmach->reg + DMAREQID);
+	node->op_mode |= MODE_RUN;
+	writel(node->op_mode, dmach->reg + DMAMODE);
+	dmach->state = DMAC_RUN;
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_start);
+
+/*******************************************************************************
+  * Function Name       : dma_stop
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_stop(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+//	struct item_node *node;
+	unsigned int regs;
+	unsigned long flags;
+	unsigned int loop;
+	
+	DBG("Entered %s - 0x%p\n", __func__, ch);
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	local_irq_save(flags);
+
+	// change state to STOP
+	dmach->state = DMAC_STOP;
+	
+	regs = readl(dmach->reg + DMAMODE);
+	//regs &= ~MODE_RUN;
+	regs |= MODE_STOP;
+	writel(regs, dmach->reg + DMAMODE);
+
+	// check RUN bit to decide DMA channel is safety stopped.
+	loop = 100;
+	while (((regs = readl(dmach->reg + DMAMODE)) & MODE_RUN) &&
+		(loop-- > 0)) {
+		msleep(1);
+	}
+
+	// clear STOP bit
+	writel(regs & ~MODE_STOP, dmach->reg + DMAMODE);
+
+/*
+	// move active_nodes to free_nodes
+	while(!list_empty(&dmach->active_nodes)) {
+		node = (struct item_node*)list_first_entry(&dmach->active_nodes, struct item_node, link);
+		list_move_tail((struct list_head*)node, &dmach->free_nodes);
+	}
+*/
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_stop);
+
+/*******************************************************************************
+  * Function Name       : dma_reset
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_reset(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node;
+	unsigned int regs;
+	unsigned long flags;
+	//unsigned int loop;
+	
+	DBG("Entered %s - 0x%p\n", __func__, ch);
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	local_irq_save(flags);
+
+	// change state to STOP
+	dmach->state = DMAC_STOP;
+
+	// forced stop
+	regs = readl(dmach->reg + DMAMODE);
+	regs &= ~MODE_RUN;
+	//regs |= MODE_STOP;
+	writel(regs, dmach->reg + DMAMODE);
+
+/*
+	// check RUN bit to decide DMA channel is safety stopped.
+	loop = 100;
+	while (((regs = readl(dmach->reg + DMAMODE)) & MODE_RUN) && (loop-- > 0)) {
+		msleep(1);
+	}
+
+	// clear STOP bit
+	writel(regs & ~MODE_STOP, dmach->reg + DMAMODE);
+*/
+	// move active_nodes to free_nodes
+	while(!list_empty(&dmach->active_nodes)) {
+		node = (struct item_node*)
+			list_first_entry(&dmach->active_nodes,
+			struct item_node, link);
+		list_move_tail((struct list_head*)node, &dmach->free_nodes);
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
+EXPORT_SYMBOL(dma_reset);
+
+/*******************************************************************************
+  * Function Name       : dma_is_active
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 if inactive
+  * Description         : 
+  *****************************************************************************/
+int dma_is_active(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+
+	return (readl(dmach->reg + DMAMODE) & MODE_BUSY);
+}
+EXPORT_SYMBOL(dma_is_active);
+
+/*******************************************************************************
+  * Function Name       : dma_is_enabled
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_is_enabled(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	unsigned int regs;
+
+	regs = readl(dmach->reg + DMAMODE);
+	if( (regs & MODE_RUN) || (dmach->state == DMAC_RUN))
+		return 1;
+	else 
+		return 0;
+}
+EXPORT_SYMBOL(dma_is_enabled);
+
+/*******************************************************************************
+  * Function Name       : dma_get_write_addr
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+unsigned int dma_get_write_addr(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+
+	return readl(dmach->reg + DMASRCADDR);
+}
+EXPORT_SYMBOL(dma_get_write_addr);
+
+/*******************************************************************************
+  * Function Name       : dma_get_read_addr
+  * Input Parameter(s)  : unsigned int ch
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+unsigned int dma_get_read_addr(unsigned int ch)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+
+	return readl(dmach->reg + DMADSTADDR);
+}
+EXPORT_SYMBOL(dma_get_read_addr);
+
+/*******************************************************************************
+  * Function Name       : dma_transfer_init
+  * Input Parameter(s)  : unsigned int ch
+  			  dma_mem_io mem_mode
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_transfer_init(unsigned int ch, enum dma_mem_io mem_mode)
+{
+	struct dmachannel *dmach = (struct dmachannel*)ch;
+	struct item_node *node;
+	unsigned long flags;
+
+	if(!dmach->device_id)
+		return (-EINVAL);
+
+	if(dma_is_enabled(ch))
+		return (-EBUSY);
+
+	local_irq_save(flags);
+
+	// move node from active list to free list
+	while(!list_empty(&dmach->active_nodes)) {
+		node = (struct item_node*)list_first_entry(&dmach->active_nodes,
+			struct item_node, link);
+		list_move_tail((struct list_head*)node, &dmach->free_nodes);
+	}
+
+	dmach->mode = mem_mode;
+	dmach->num_node = 0;
+	dmach->cur_node = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_transfer_init);
+
+/*******************************************************************************
+  * Function Name       : dma_transfer_insert
+  * Input Parameter(s)  : unsigned int ch
+  			  unsigned int src
+  			  unsigned int dest
+  			  unsigned int size
+  			  dma_control ctrl
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_transfer_insert(unsigned int ch, unsigned int src, unsigned int dest,
+	unsigned int size, struct dma_control *ctrl)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned long flags;
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	node = dma_get_free_node(dmach);
+	if(!node) {
+		return (-ENOMEM);
+	}
+
+	node->src_addr = src;
+	node->dst_addr = dest;
+	node->req_id = ctrl->request_id;
+	node->size = size - 1;
+
+	switch(ctrl->interrupt) {
+	case DMA_INT_DISABLE:
+		node->int_flag = 0;
+		break;
+	default:
+		node->int_flag = 1;
+	}
+
+	switch(ctrl->transfer) {
+	case DMA_MEM_TO_MEM:
+		node->op_mode = MODE_INTENB | MODE_SRCNOTREQCHK |
+			MODE_DSTNOTREQCHK;
+		break;
+	case DMA_MEM_TO_IO:
+		node->op_mode = MODE_INTENB | MODE_SRCNOTREQCHK |
+			MODE_DSTIOMODE | MODE_DSTNOTINC |
+			set_dst_io_width(ctrl->dest_width);
+		break;
+	case DMA_IO_TO_MEM:
+		node->op_mode = MODE_INTENB | MODE_SRCIOMODE | MODE_SRCNOTINC |
+			set_src_io_width(ctrl->src_width) | MODE_DSTNOTREQCHK;
+		break;
+	default:
+		return (-EINVAL);
+	}
+
+	local_irq_save(flags);
+	list_add_tail((struct list_head *)node, &dmach->active_nodes);
+	dmach->num_node++;
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_transfer_insert);
+
+/*******************************************************************************
+  * Function Name       : dma_sg_write
+  * Input Parameter(s)  : unsigned int ch
+  			  struct scatterlist *sg
+  			  unsigned int dest
+  			  int count
+  			  dma_control ctrl
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_sg_write(unsigned int ch, struct scatterlist *sg, unsigned int dest,
+	int count, struct dma_control *ctrl)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned int int_flag, i, op_mode;
+	unsigned long flags;
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	switch(ctrl->interrupt) {
+	case DMA_INT_DISABLE:
+	case DMA_INT_LAST_BLOCK:
+		int_flag = 0;
+		break;
+	default:
+		int_flag = 1;
+	}
+
+	switch(ctrl->transfer) {
+	case DMA_MEM_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTNOTREQCHK;
+		break;
+	case DMA_MEM_TO_IO:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTIOMODE |
+			MODE_DSTNOTINC | set_dst_io_width(ctrl->dest_width);
+		break;
+	case DMA_IO_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCIOMODE | MODE_SRCNOTINC |
+			set_src_io_width(ctrl->src_width) | MODE_DSTNOTREQCHK;
+		break;
+	default:
+		return (-EINVAL);
+	}
+
+	local_irq_save(flags);
+	
+	dmach->num_node = 0;
+	
+	for (i = 0; i < count; i++) {
+		node = dma_get_free_node(dmach);
+		if(!node) {
+			return (-ENOMEM);
+		}
+		
+		node->src_addr = sg_phys(&sg[i]);
+		node->dst_addr = dest;
+		node->req_id = ctrl->request_id;
+		node->size = sg[i].length - 1;
+		node->op_mode = op_mode;
+		node->int_flag = int_flag;
+		
+		++dmach->num_node;
+		list_add_tail((struct list_head *)node, &dmach->active_nodes);
+	}
+
+	if (ctrl->interrupt == DMA_INT_LAST_BLOCK)
+		node->int_flag = 1;
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_sg_write);
+
+/*******************************************************************************
+  * Function Name       : dma_sg_read
+  * Input Parameter(s)  : unsigned int ch
+  			  unsigned int src
+  			  struct scatterlist *sg
+  			  int count
+  			  dma_control ctrl
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_sg_read(unsigned int ch, unsigned int src, struct scatterlist *sg,
+	int count, struct dma_control *ctrl)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned int int_flag, i, op_mode;
+	unsigned long flags;
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	switch(ctrl->interrupt) {
+	case DMA_INT_DISABLE:
+	case DMA_INT_LAST_BLOCK:
+		int_flag = 0;
+		break;
+	default:
+		int_flag = 1;
+	}
+
+	switch(ctrl->transfer) {
+	case DMA_MEM_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTNOTREQCHK;
+		break;
+	case DMA_MEM_TO_IO:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTIOMODE |
+			MODE_DSTNOTINC | set_dst_io_width(ctrl->dest_width);
+		break;
+	case DMA_IO_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCIOMODE | MODE_SRCNOTINC |
+			set_src_io_width(ctrl->src_width) | MODE_DSTNOTREQCHK;
+		break;
+	default:
+		return (-EINVAL);
+	}
+
+	local_irq_save(flags);
+
+	dmach->num_node = 0;
+	
+	for (i = 0; i < count; i++) {
+		node = dma_get_free_node(dmach);
+		if(!node) {
+			return (-ENOMEM);
+		}
+
+		node->src_addr = src;
+		node->dst_addr = sg_phys(&sg[i]);
+		node->req_id = ctrl->request_id;
+		node->size = sg[i].length - 1;
+		node->op_mode = op_mode;
+		node->int_flag = int_flag;
+		
+		++dmach->num_node;
+		list_add_tail((struct list_head *)node, &dmach->active_nodes);
+	}
+
+	if (ctrl->interrupt == DMA_INT_LAST_BLOCK)
+		node->int_flag = 1;
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_sg_read);
+
+/*******************************************************************************
+  * Function Name       : dma_circ_write
+  * Input Parameter(s)  : struct platform_device *pdev
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_circ_write(unsigned int ch, unsigned int *src_list, unsigned int dest,
+	int count, unsigned int block_size, struct dma_control *ctrl)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned int int_flag, i, op_mode;
+	unsigned long flags;
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	switch(ctrl->interrupt) {
+	case DMA_INT_DISABLE:
+	case DMA_INT_LAST_BLOCK:
+		int_flag = 0;
+		break;
+	default:
+		int_flag = 1;
+	}
+
+	switch(ctrl->transfer) {
+	case DMA_MEM_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTNOTREQCHK;
+		break;
+	case DMA_MEM_TO_IO:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTIOMODE |
+			MODE_DSTNOTINC | set_dst_io_width(ctrl->dest_width);
+		break;
+	case DMA_IO_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCIOMODE | MODE_SRCNOTINC |
+			set_src_io_width(ctrl->src_width) | MODE_DSTNOTREQCHK;
+		break;
+	default:
+		return (-EINVAL);
+	}
+
+	//DBG("opmode:%x, req_id:%d, size:%d\n", op_mode, ctrl->request_id, block_size);
+
+	local_irq_save(flags);
+
+	// Circular DMA Memory mapped operation..
+	dmach->mode = DMA_MEM_MAPPED;
+	dmach->num_node = 0;
+
+	for (i = 0; i < count; i++) {
+		node = dma_get_free_node(dmach);
+		if(!node) {
+			return (-ENOMEM);
+		}
+
+		node->src_addr = src_list[i];
+		node->dst_addr = dest;
+		node->req_id = ctrl->request_id;
+		node->size = block_size - 1;
+		node->op_mode = op_mode;
+		node->int_flag = int_flag;
+		
+		++dmach->num_node;
+		list_add_tail((struct list_head *)node, &dmach->active_nodes);
+	}
+
+	if (ctrl->interrupt == DMA_INT_LAST_BLOCK)
+		node->int_flag = 1;
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_circ_write);
+
+/*******************************************************************************
+  * Function Name       : dma_circ_read
+  * Input Parameter(s)  : unsigned int ch
+  			  unsigned int src
+  			  unsigned int *dest_list
+  			  int count
+  			  unsigned int block_size
+  			  dma_control ctrl
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+int dma_circ_read(unsigned int ch, unsigned int src, unsigned int *dest_list, int count, unsigned int block_size, struct dma_control *ctrl)
+{
+	struct dmachannel *dmach = (struct dmachannel *)ch;
+	struct item_node *node = NULL;
+	unsigned int int_flag, i, op_mode;
+	unsigned long flags;
+
+	if (!dmach->device_id)
+		return (-EINVAL);
+
+	switch(ctrl->interrupt) {
+	case DMA_INT_DISABLE:
+	case DMA_INT_LAST_BLOCK:
+		int_flag = 0;
+		break;
+	default:
+		int_flag = 1;
+	}
+
+	switch(ctrl->transfer) {
+	case DMA_MEM_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTNOTREQCHK;
+		break;
+	case DMA_MEM_TO_IO:
+		op_mode = MODE_INTENB | MODE_SRCNOTREQCHK | MODE_DSTIOMODE |
+			MODE_DSTNOTINC | set_dst_io_width(ctrl->dest_width);
+		break;
+	case DMA_IO_TO_MEM:
+		op_mode = MODE_INTENB | MODE_SRCIOMODE | MODE_SRCNOTINC |
+			set_src_io_width(ctrl->src_width) | MODE_DSTNOTREQCHK;
+		break;
+	default:
+		return (-EINVAL);
+	}
+
+	local_irq_save(flags);
+
+	// Circular DMA Memory mapped operation..
+	dmach->mode = DMA_MEM_MAPPED;
+	dmach->num_node = 0;
+
+	for (i = 0; i < count; i++) {
+		node = dma_get_free_node(dmach);
+		if(!node) {
+			return (-ENOMEM);
+		}
+
+		node->src_addr = src;
+		node->dst_addr = dest_list[i];
+		node->req_id = ctrl->request_id;
+		node->size = block_size - 1;
+		node->op_mode = op_mode;
+		node->int_flag = int_flag;
+		
+		++dmach->num_node;
+		list_add_tail((struct list_head *)node, &dmach->active_nodes);
+	}
+
+	if (ctrl->interrupt == DMA_INT_LAST_BLOCK)
+		node->int_flag = 1;
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(dma_circ_read);
+
+/*******************************************************************************
+  * Function Name       : lf1000_dma_remove
+  * Input Parameter(s)  : struct platform_device *pdev
+  * Output Parameter(s) : NIL
+  * Return Value        : int - 0 success else failure
+  * Description         : 
+  *****************************************************************************/
+static int __devexit lf1000_dma_remove(struct platform_device *pdev)
+{
+	struct resource *res, *mem;
+	struct list_head *node = NULL;
+	int i;
+
+	dmadev = dev_get_drvdata(&(pdev->dev));
+	if(!dmadev)
+		return 0;
+
+	for(i = 0; i < MAX_DMA_CHANNELS; i++) {
+
+		if (dma_is_enabled((unsigned int)&dmadev->dmach[i]))
+			dma_stop((unsigned int)&dmadev->dmach[i]);
+		
+		free_irq(dma_to_irq(i), NULL);
+		if(dmadev->dmach[i].device_id){
+			kfree(dmadev->dmach[i].device_id);
+			while(!list_empty(&dmadev->dmach[i].free_nodes)) {
+				node = (struct list_head*)
+				list_first_entry(&dmadev->dmach[i].free_nodes,
+					struct item_node, link);
+				list_del(node);
+				kfree(node);
+			}
+		}
+	}
+#ifdef USE_IOREMAP
+	iounmap(dmadev->reg);
+#endif
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(res) {
+		mem = request_mem_region(res->start, res->end - res->start + 1,
+					pdev->name);
+		if (mem)
+			release_resource(mem);
+	}
+
+	kfree(dmadev);
+	dmadev = NULL;
+	
+	return 0;
+}
+ 
+ /******************************************************************************
+   * Function Name	 : lf1000_dma_probe
+   * Input Parameter(s)  : struct platform_device *pdev
+   * Output Parameter(s) : NIL
+   * Return Value		 : int - 0 success else failure
+   * Description		 : 
+   ****************************************************************************/
+static int __devinit lf1000_dma_probe(struct platform_device *pdev)
+{
+	struct resource *res, *mem = NULL;
+	int ret = 0, i;
+	unsigned int offset;
+
+	DBG("Probing LF1000 DMA Controller...\n");
+
+	/* allocate dma controllor information */
+	dmadev = kzalloc(sizeof(struct dma_info), __GFP_ZERO);
+	if(!dmadev) {
+		DBG("DMA kzalloc error!\n");
+		return -ENOMEM;
+	}
+
+	DBG("dmadev (%p)\n", dmadev);
+#ifdef USE_IOREMAP
+	/* reserve static register mappings */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		DBG("DMA platform_get_resource error!\n");
+		ret = -ENOENT;
+		goto err;
+	}
+
+	mem = request_mem_region(res->start, res->end - res->start + 1,
+		pdev->name);
+	if (mem == NULL) {
+		DBG("DMA request_mem_region error!\n");
+		ret = -ENOENT;
+		goto err;
+	}
+
+	dmadev->reg = ioremap(res->start, res->end - res->start + 1);
+	if (!dmadev->reg) {
+		DBG("DMA ioremap error!\n");
+		ret = -ENOENT;
+		goto err;
+	}
+#else
+	dmadev->reg = (void __iomem *)IO_ADDRESS(LF1000_DMA_BASE);
+#endif
+	DBG("register mapping (%p)\n", dmadev->reg);
+
+	offset = 0;
+
+	for (i = 0; i < MAX_DMA_CHANNELS; i++, offset+=0x80) {
+		dmadev->dmach[i].reg = (void __iomem *)(dmadev->reg + offset);
+		dmadev->dmach[i].priority = 1 << ((i & 0xC) >> 2);
+		INIT_LIST_HEAD(&dmadev->dmach[i].active_nodes);
+		INIT_LIST_HEAD(&dmadev->dmach[i].free_nodes);
+		dmadev->dmach[i].state = DMAC_STOP;
+
+		DBG("DMA channel(%d) - base: 0x%p, prio: %d\n", i,
+			dmadev->reg + offset, dmadev->dmach[i].priority >> 1);
+
+		ret = request_irq(dma_to_irq(i), dma_irq_handler,
+			IRQF_DISABLED, DRIVER_NAME, NULL);
+		if (ret) {
+			DBG("DMAC : Register IRQ Error!\n");                                                         			ret = -EBUSY;
+			goto err;
+		}
+
+		spin_lock_init(&dmadev->dmach[i].lock);
+	}
+
+	dev_set_drvdata(&(pdev->dev), dmadev);
+
+	return 0;	
+err:
+	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+		free_irq(dma_to_irq(i), NULL);
+	}
+
+#ifdef USE_IOREMAP
+	if (dmadev->reg)
+		iounmap(dmadev->reg);
+#endif
+
+	if (mem)
+		release_resource(mem);
+
+	kfree(dmadev);
+	dmadev = NULL;
+	return ret;
+}
+
+static struct platform_driver lf1000_dma_driver = {
+	.probe 		= lf1000_dma_probe,
+	.remove		= lf1000_dma_remove,
+	.driver		= {
+		.owner  = THIS_MODULE,
+		.name	= DRIVER_NAME,
+	},
+};
+ 
+ /******************************************************************************
+   * Function Name		 : lf1000_dma_init
+   * Input Parameter(s)  : iNIL
+   * Output Parameter(s) : NIL
+   * Return Value		 : int - 0 success else failure
+   * Description		 : 
+   ****************************************************************************/
+static int __init lf1000_dma_init (void)
+{
+	return platform_driver_register(&lf1000_dma_driver);
+}
+
+arch_initcall(lf1000_dma_init);
+ 
+MODULE_AUTHOR("Scott Esters / Corelogic");
+MODULE_DESCRIPTION("LF1000 DMA Engine Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:dma");
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/gpio.c linux-2.6/arch/arm/mach-lf1000/gpio.c
--- linux-2.6.31/arch/arm/mach-lf1000/gpio.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/gpio.c	2011-02-08 12:37:24.000000000 -0800
@@ -0,0 +1,906 @@
+/* 
+ * arch/arm/mach-lf1000/gpio.c
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * LF1000 General-Purpose IO (GPIO) API, see also 
+ * include/asm/arch-lf1000/gpio.h
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Brian Cavagnolo <brian@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <mach/gpio_priv.h>
+#include <mach/gpio.h>
+#include <mach/common.h>
+#include <mach/gpio_hal.h>
+#include "board_ids.h"
+
+#define IS_GPIO_PORT(p)	(p >= GPIO_PORT_A && p <= GPIO_PORT_ALV)
+
+extern struct gpio_device gpio;
+
+spinlock_t gpio_handlers_lock = SPIN_LOCK_UNLOCKED;
+struct gpio_handler gpio_handlers[GPIO_PORT_ALV+1][GPIO_PIN31+1];
+
+/* Set the pin function. */
+int gpio_set_fn(enum gpio_port port, enum gpio_pin pin,
+		 enum gpio_function f)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(!gpio.mem || !IS_GPIO_PORT(port) || pin >= 32)
+		return -EINVAL;
+   	reg = gpio.mem + GPIOAALTFN0 + port*0x40;
+
+	if(pin >= 16) { /* use GPIOnALTFN1 */
+		reg += 4;
+		pin -= 16;
+	}
+
+	pin *= 2; /* setting two bits per pin */
+	tmp = readl(reg);
+	tmp &= ~(3<<pin);
+	tmp |= (f<<pin);
+	writel(tmp, reg);
+
+	return 0;
+}
+
+/* Get the pin function */
+int gpio_get_fn(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+
+	if(!gpio.mem || !IS_GPIO_PORT(port) || pin >= 32)
+		return -EINVAL;
+	reg = gpio.mem + GPIOAALTFN0 + port*0x40;
+
+	if(pin >= 16) { /* use GPIOnALTFN1 */
+		reg +=4;
+		pin -= 16;
+	}
+
+	/* getting two bits per pin */
+	return ((readl(reg) >> (pin*2)) & 0x3);
+}
+
+/* set or clear output enable.  Clearing output enable means this pin is an
+ * input.
+ */
+int gpio_set_out_en(enum gpio_port port, enum gpio_pin pin, unsigned char en)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		if(!en)
+			printk(KERN_WARNING
+			       "gpio: LF1000 ALIVE pins are outputs only!\n");
+		return -EINVAL;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAOUTENB + port*0x40;
+	else
+		return -EINVAL;
+	tmp = readl(reg);
+
+	en ? BIT_SET(tmp, pin) : BIT_CLR(tmp, pin);
+	writel(tmp, reg);
+
+	return 0;
+}
+
+/* get output enable value */
+int gpio_get_out_en(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+	if (port == GPIO_PORT_ALV) {
+		return -EINVAL;	/* LF1000 ALIVE pins don't have direction */
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAOUTENB + port*0x40;
+	else
+		return -EINVAL;
+
+	return(int)((readl(reg) >> pin) & 0x1);
+}
+
+/* set or clear the pull-up enable */
+void gpio_set_pu(enum gpio_port port, enum gpio_pin pin, unsigned char en)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(pin >= 32)
+		return;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAPUENB + port*0x40;
+	else
+		return;
+   	tmp = readl(reg);
+
+	en ? BIT_SET(tmp, pin) : BIT_CLR(tmp, pin);
+	writel(tmp, reg);
+}
+
+/* get the input value of the pin */
+int gpio_get_pu(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+
+	if(pin >= 32)
+		return -EINVAL;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		return -EINVAL; /* LF1000 ALIVE pins don't have pullups */
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAPUENB + port*0x40;
+	else
+		return -EINVAL;
+
+	return (int)((readl(reg) >> pin) & 0x1);
+}
+
+/* set the output value of the pin */
+int gpio_set_val(enum gpio_port port, enum gpio_pin pin, unsigned char en)
+{
+	void __iomem *reg;
+	void __iomem *set_reg;
+	void __iomem *clr_reg;
+	unsigned long tmp;
+
+	if(pin >= 32)
+		return -EINVAL;
+
+	if(port == GPIO_PORT_ALV) {
+		if(gpio.amem == NULL)
+			return -EINVAL;
+
+		/* On the LF1000, we're operating an SR flip-flop, not a GPIO
+		 * pin.
+		 */
+
+		/* enable writing to GPIO ALIVE registers */
+		writel(1 << NPOWERGATING, gpio.amem + ALIVEPWRGATEREG);
+		
+		if (en) { /* set R/S bit */
+			set_reg = gpio.amem + ALIVEGPIOSETREG;
+			clr_reg = gpio.amem + ALIVEGPIORSTREG;
+		} else {  /* clear R/S bit */
+			clr_reg = gpio.amem + ALIVEGPIOSETREG;
+			set_reg = gpio.amem + ALIVEGPIORSTREG;
+		}
+
+		tmp = readl(clr_reg); /* clear bit first */
+		BIT_CLR(tmp,pin);
+		writel(tmp,clr_reg);
+		tmp = readl(set_reg); /* then set bit */
+		BIT_SET(tmp,pin);
+		writel(tmp,set_reg);
+	
+		/* disable writing to GPIO ALIVE registers */
+		writel(0 << NPOWERGATING, gpio.amem + ALIVEPWRGATEREG);
+		return 0;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAOUT + port*0x40;
+	else
+		return - EINVAL;
+	
+	tmp = readl(reg);
+	en ? BIT_SET(tmp, pin) : BIT_CLR(tmp, pin);
+	writel(tmp, reg);
+
+	return 0;
+}
+
+/* get the input value of the pin */
+int gpio_get_val(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(pin >= 32)
+		return -EINVAL;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		/* LF1000 ALIVE pins are only outputs, but we can still read
+		 * them.
+		 */
+		reg = gpio.amem + ALIVEGPIOREADREG;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAPAD + port*0x40;
+	else
+		return -EINVAL;
+   	tmp = readl(reg);
+
+	return (int)((readl(reg) >> pin) & 0x1);
+}
+
+/* request an interrupt handler for a given pin. Returns -EBUSY if that pin
+ * already has a handler.
+ */
+int gpio_request_irq(enum gpio_port port, enum gpio_pin pin,
+		     gpio_irq_handler_t handler, void *priv)
+{
+	unsigned long flags;
+	struct gpio_handler *gh;
+	int ret;
+
+	if(pin >= 32)
+		return -EBUSY;
+	if(!IS_GPIO_PORT(port))
+		return - EBUSY;
+
+	spin_lock_irqsave(&gpio_handlers_lock, flags);
+	gh = &gpio_handlers[port][pin];
+	if(gh->handler.handler != NULL)
+		ret = -EBUSY;
+	else {
+		gh->handler.gpio_handler = handler;
+		gh->priv = priv;
+		gh->mode_gpio = 1;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&gpio_handlers_lock, flags);
+	return ret;
+}
+
+int gpio_request_normal_irq(enum gpio_port port, enum gpio_pin pin,
+		irq_handler_t handler, void *priv)
+{
+	unsigned long flags;
+	struct gpio_handler *gh;
+	int ret;
+
+	if(pin >= 32)
+		return -EBUSY;
+
+	if(!IS_GPIO_PORT(port))
+		return -EBUSY;
+
+	spin_lock_irqsave(&gpio_handlers_lock, flags);
+	gh = &gpio_handlers[port][pin];
+	if(gh->handler.handler != NULL)
+		ret = -EBUSY;
+	else {
+		gh->handler.normal_handler = handler;
+		gh->priv = priv;
+		gh->mode_gpio = 0;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&gpio_handlers_lock, flags);
+	return ret;
+}
+
+/* free the irq requested using gpio_request_irq.  To prevent accidental
+ * freeing of somebody else's gpio irq, the handler must match the one that was
+ * passed to gpio_request_irq.
+ */
+void gpio_free_irq(enum gpio_port port, enum gpio_pin pin,
+		   gpio_irq_handler_t handler)
+{
+	unsigned long flags;
+	struct gpio_handler *gh;
+
+	if(pin >= 32)
+		return;
+	if(!IS_GPIO_PORT(port))
+		return;
+
+	spin_lock_irqsave(&gpio_handlers_lock, flags);
+	gh = &gpio_handlers[port][pin];
+	if(gh->handler.handler == handler) {
+		gh->handler.handler = NULL;
+		gh->priv = NULL;
+	}
+	spin_unlock_irqrestore(&gpio_handlers_lock, flags);
+}
+
+/* get the interrupt mode for a given pin */
+enum gpio_interrupt_mode gpio_get_int_mode(enum gpio_port port,
+					   enum gpio_pin pin)
+{
+	void __iomem *reg;
+
+	if (port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_get_int_mode\n");
+		return 0;
+	} else if (gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32) {
+		reg = gpio.mem + port*0x40;
+		if(pin < 16) {
+			reg += GPIOADETMODE0;
+		} else {
+			reg += GPIOADETMODE1;
+			pin -= 16;
+		}
+	}
+	else
+		return 0; /*XXX*/
+	return (enum gpio_interrupt_mode)((readl(reg) >> (pin<<1)) & 0x3);
+}
+
+/* set the interrupt mode for a given pin */
+void gpio_set_int_mode(enum gpio_port port, enum gpio_pin pin,
+		       enum gpio_interrupt_mode mode)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_set_int_mode\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32) {
+		reg = gpio.mem + port*0x40;
+		if(pin < 16) {
+			reg += GPIOADETMODE0;
+		} else {
+			reg += GPIOADETMODE1;
+			pin -= 16;
+		}
+	}
+	else
+		return;
+
+	tmp = readl(reg);
+	tmp &= ~(0x3 << (pin<<1));
+	tmp |= (mode << (pin<<1));
+	writel(tmp, reg);
+}
+
+/* toggle the interrupt mode for a pin.  If the mode is currently
+ * IMODE_RISING_EDGE it becmoes IMODE_FALLING_EDGE and vice versa.  If the mode
+ * is IMODE_HIGH_LEVEL it becomes IMODE_LOW_LEVEL
+ */
+void gpio_toggle_int_mode(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_toggle_int_mode\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32) {
+		reg = gpio.mem + port*0x40;
+		if(pin < 16) {
+			reg += GPIOADETMODE0;
+		} else {
+			reg += GPIOADETMODE1;
+			pin -= 16;
+		}
+	}
+	else
+		return;
+
+	tmp = readl(reg);
+	tmp ^= (0x1 << (pin<<1));
+	writel(tmp, reg);
+}
+
+/* enable or disable interrupt for a given pin */
+void gpio_set_int(enum gpio_port port, enum gpio_pin pin, unsigned char en)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_set_int\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32) {
+		reg = gpio.mem + GPIOAINTENB + port*0x40;
+	}
+	else {
+		printk(KERN_WARNING "gpio: gpio_set_int when uninitialized\n");
+		return;
+	}
+
+	tmp = readl(reg);
+	en ? BIT_SET(tmp, pin) : BIT_CLR(tmp, pin);
+	writel(tmp, reg);
+
+}
+
+/* get the interrupt enable bit for a given pin */
+unsigned char gpio_get_int(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_get_int\n");
+		return 0;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32)
+		reg = gpio.mem + GPIOAINTENB + port*0x40;
+	else
+		return 0; /*XXX*/
+
+	return (unsigned char)((readl(reg) >> pin) & 0x1);
+}
+
+/* get interrupt enable bits for all 32 pins in a given port */
+unsigned long gpio_get_int32(enum gpio_port port)
+{
+	void __iomem *reg;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_get_int32\n");
+		return 0;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAINTENB + port*0x40;
+	else
+		return 0; /*XXX*/
+
+	return readl(reg);
+}
+
+/* set the interrupt enable bits for all 32 pins in a given port.  Use this
+ * function in conjunction with gpio_get_int32 to enable or disable
+ * interrupts on many pins at a time.
+ */
+void gpio_set_int32(enum gpio_port port, unsigned long en)
+{
+	void __iomem *reg;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_set_int32\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOAINTENB + port*0x40;
+	else
+		return;
+
+	writel(en, reg);
+}
+
+/* clear the interrupt pending bit for a given pin */
+void gpio_clear_pend(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_clear_pend\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32)
+		reg = gpio.mem + GPIOADET + port*0x40;
+	else
+		return;
+	
+	writel(1<<pin, reg);
+}
+
+/* get the interrupt pending bit for a given pin */
+unsigned char gpio_get_pend(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_get_pend\n");
+		return 0;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port) && pin < 32)
+		reg = gpio.mem + GPIOADET + port*0x40;
+	else
+		return 0; /*XXX*/
+
+	return (unsigned char)((readl(reg) >> pin) & 0x1);
+}
+
+/* get the interrupt pending bits for all pins in a given port */
+unsigned long gpio_get_pend32(enum gpio_port port)
+{
+	void __iomem *reg;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_clear_pend32\n");
+		return 0;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOADET + port*0x40;
+	else
+		return 0; /*XXX*/
+
+	return readl(reg);
+}
+
+/* clear the interrupt pending bits for all pins in a given port.  Use this
+ * function in conjunction with gpio_get_pend32 to clear all pending interrupts
+ * at once.
+ */
+void gpio_clear_pend32(enum gpio_port port, unsigned long flag)
+{
+	void __iomem *reg;
+
+	if(port == GPIO_PORT_ALV && gpio.amem != NULL) {
+		printk(KERN_ALERT "gpio: ALV in gpio_clear_pend32\n");
+		return;
+	}
+	else if(gpio.mem != NULL && IS_GPIO_PORT(port))
+		reg = gpio.mem + GPIOADET + port*0x40;
+	else
+		return;
+
+	writel(flag, reg);
+}
+
+
+/* get gpio pin drive current setting */
+unsigned long gpio_get_cur(enum gpio_port port, enum gpio_pin pin)
+{
+	void __iomem *reg;
+
+	if((port == GPIO_PORT_ALV) ||
+	    ((port == GPIO_PORT_C) && (pin > GPIO_PIN19))) {
+		/* We can't set current for GPIO ALIVE block or for GPIOC pins
+		 * above 19 
+		 */
+		return 0;
+	} else if(gpio.mem_cur != NULL && IS_GPIO_PORT(port) && pin <= 32) {
+		reg = gpio.mem_cur + port*8;
+		if(pin < 16) {
+			reg += GPIOPADSTRENGTHGPIOAL;
+		} else {
+			reg += GPIOPADSTRENGTHGPIOAH;
+			pin -= 16;
+		}
+	}
+	else
+		return 0; /*XXX*/
+	return ((readl(reg) >> (pin<<1)) & 0x3);
+}
+
+/* set the drive current for the gpio pin */
+void gpio_set_cur(enum gpio_port port, enum gpio_pin pin, enum gpio_current cur)
+{
+	void __iomem *reg;
+	unsigned long tmp;
+
+	if( (port == GPIO_PORT_ALV) ||
+	    ((port == GPIO_PORT_C) && (pin > GPIO_PIN19)) ) {
+		/* We can't set current for GPIO ALIVE block or for GPIOC pins
+		 * above 19 
+		 */
+		return;
+	} else if(gpio.mem_cur != NULL && IS_GPIO_PORT(port) && pin < 32) {
+		reg = gpio.mem_cur + port*8;
+		if(pin < 16) {
+			reg += GPIOPADSTRENGTHGPIOAL;
+		} else {
+			reg += GPIOPADSTRENGTHGPIOAH;
+			pin -= 16;
+		}
+	}
+	else
+		return;
+
+	tmp = readl(reg);
+	tmp &= ~(0x3 << (pin<<1));
+	tmp |= (cur << (pin<<1));
+	writel(tmp, reg);
+
+}
+
+/* gpio_get_scratch() -- get ALIVE scratch register value */
+unsigned long gpio_get_scratch(void)
+{
+	return(readl(gpio.amem + ALIVESCRATCHREADREG));
+}
+
+/* gpio_set_scratch() -- set ALIVE scratch register value */
+void gpio_set_scratch(unsigned long value)
+{
+	unsigned int reg32 = 0;
+
+	if(gpio.amem == NULL)
+		return;
+
+	/* enable writing to GPIO ALIVE registers */
+	reg32 = readl(gpio.amem + ALIVEPWRGATEREG);
+	BIT_SET(reg32, NPOWERGATING);	
+	writel(reg32, gpio.amem + ALIVEPWRGATEREG);
+
+	writel(0, gpio.amem + ALIVESCRATCHRSTREG);
+	writel(0, gpio.amem + ALIVESCRATCHSETREG);
+
+	writel(~value, gpio.amem + ALIVESCRATCHRSTREG);
+	writel(value, gpio.amem + ALIVESCRATCHSETREG);
+
+	writel(0, gpio.amem + ALIVESCRATCHRSTREG);	
+	writel(0, gpio.amem + ALIVESCRATCHSETREG);
+	
+	/* disable writing to GPIO ALIVE registers */
+	reg32 = readl(gpio.amem + ALIVEPWRGATEREG);
+	BIT_CLR(reg32, NPOWERGATING);	
+	writel(reg32, gpio.amem + ALIVEPWRGATEREG);
+}
+
+/* gpio_get_power_config() -- get power bits of register */
+u8 gpio_get_power_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_POWER_POS) & 
+			BIT_MASK_ONES(SCRATCH_POWER_SIZE));
+}
+
+/* gpio_get_shutdown_config() -- get shutdown bits of register */
+enum scratch_shutdown gpio_get_shutdown_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_SHUTDOWN_POS) & 
+			BIT_MASK_ONES(SCRATCH_SHUTDOWN_SIZE));
+}
+
+/* gpio_set_shutdown_config() -- set shutdown bits of register */
+void gpio_set_shutdown_config(enum scratch_shutdown value)
+{
+	ulong scratch = gpio_get_scratch();	// get bits
+						// remove bits
+	scratch &=
+		~(BIT_MASK_ONES(SCRATCH_SHUTDOWN_SIZE) << SCRATCH_SHUTDOWN_POS);
+	scratch |= (value << SCRATCH_SHUTDOWN_POS);
+	gpio_set_scratch(scratch);
+}
+
+/* gpio_get_request_config() -- get request boot bits of register */
+enum scratch_request gpio_get_request_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_REQUEST_POS) & 
+			BIT_MASK_ONES(SCRATCH_REQUEST_SIZE));
+}
+
+/* gpio_set_request_config() -- set request boot bits of register */
+void gpio_set_request_config(enum scratch_request value)
+{
+	ulong scratch = gpio_get_scratch();	// get bits
+						// remove bits
+	scratch &=
+		~(BIT_MASK_ONES(SCRATCH_REQUEST_SIZE)
+			<< SCRATCH_REQUEST_POS);
+	scratch |= (value << SCRATCH_REQUEST_POS);
+	gpio_set_scratch(scratch);
+}
+
+/* gpio_get_boot_image_config() -- get actual boot bits of register */
+enum scratch_boot_image gpio_get_boot_image_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_BOOT_IMAGE_POS) & 
+			BIT_MASK_ONES(SCRATCH_BOOT_IMAGE_SIZE));
+}
+
+/* gpio_set_boot_image_config() -- set actual boot bits of register */
+void gpio_set_boot_image_config(enum scratch_boot_image value)
+{
+	ulong scratch = gpio_get_scratch();	// get bits
+						// remove bits
+	scratch &=
+	  ~(BIT_MASK_ONES(SCRATCH_BOOT_IMAGE_SIZE) << SCRATCH_BOOT_IMAGE_POS);
+	scratch |= (value << SCRATCH_BOOT_IMAGE_POS);
+	gpio_set_scratch(scratch);
+}
+
+/* gpio_get_boot_source_config() -- get boot source bits of register */
+enum scratch_boot_source gpio_get_boot_source_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_BOOT_SOURCE_POS) & 
+			BIT_MASK_ONES(SCRATCH_BOOT_SOURCE_SIZE));
+}
+
+/* gpio_get_panic_config() -- get panic boot bits of register */
+int gpio_get_panic_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_PANIC_POS) & 
+			BIT_MASK_ONES(SCRATCH_PANIC_SIZE));
+}
+
+/* gpio_set_panic_config() -- set panic boot bits of register */
+void gpio_set_panic_config(int value)
+{
+	ulong scratch = gpio_get_scratch();	// get bits
+						// remove bits
+	scratch &=
+		~(BIT_MASK_ONES(SCRATCH_PANIC_SIZE)
+			<< SCRATCH_PANIC_POS);
+	scratch |= (value << SCRATCH_PANIC_POS);
+	gpio_set_scratch(scratch);
+}
+
+void gpio_configure_pin(enum gpio_port port, enum gpio_pin pin, 
+		enum gpio_function f, unsigned char out_en, 
+		unsigned char pu_en, unsigned char val)
+{
+	gpio_set_fn(port, pin, f);
+	gpio_set_out_en(port, pin, out_en);
+	gpio_set_pu(port, pin, pu_en);
+	gpio_set_val(port, pin, val);
+}
+
+/*
+ * Volume control is either volume slider (Didj) or up/down buttons (Emerald).
+ * Assume if there is a touchscreen then we have up/down buttons
+ */
+
+int gpio_have_volume_buttons(void)
+{
+	return(gpio.touchscreen);
+}
+
+/*
+ * Touchscreen test is down during modprobe.
+ */
+
+int gpio_have_touchscreen(void)
+{
+	return(gpio.touchscreen);
+}
+
+/*
+ * Get board ID from circuit board.
+ * Use this as last resort on figuring out hardware configuration.
+ */
+
+u8 gpio_get_board_config(void)
+{
+#ifndef CONFIG_LF1000_OVERRIDE_BOARD_ID
+	return ((gpio_get_scratch() >> SCRATCH_BOARD_ID_POS) & 
+			BIT_MASK_ONES(SCRATCH_BOARD_ID_SIZE));
+#else
+	return CONFIG_LF1000_OVERRIDE_BOARD_ID_VALUE;
+#endif
+
+}
+
+/*
+ * Board ID helper functions
+ */
+
+int gpio_have_gpio_acorn(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_ACORN:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_gpio_dev(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_DEV:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_gpio_didj(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_DIDJ:
+	case LF1000_BOARD_DIDJ_09:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_gpio_emerald(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_EMERALD_POP:
+	case LF1000_BOARD_EMERALD_NOTV_NOCAP:
+	case LF1000_BOARD_EMERALD_TV_NOCAP:
+	case LF1000_BOARD_EMERALD_NOTV_CAP:
+	case LF1000_BOARD_EMERALD_SAMSUNG:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_gpio_k2(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_K2:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_gpio_madrid(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_MADRID:
+	case LF1000_BOARD_MADRID_LFP100:
+	case LF1000_BOARD_MADRID_POP:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_supercap(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_ACORN:
+	case LF1000_BOARD_EMERALD_NOTV_CAP:
+		return(1);
+	}
+	return(0);
+}
+
+int gpio_have_tvout(void)
+{
+	switch(gpio_get_board_config()) {
+	case LF1000_BOARD_ACORN:
+	case LF1000_BOARD_EMERALD_POP:
+	case LF1000_BOARD_EMERALD_TV_NOCAP:
+	case LF1000_BOARD_MADRID_POP:
+		return(1);
+	}
+	return(0);
+}
+
+/* gpio_get_boot_image_config() -- get actual boot bits of register */
+u32 gpio_get_user_0_config(void)
+{
+	return ((gpio_get_scratch() >> SCRATCH_USER_0_POS) & 
+			BIT_MASK_ONES(SCRATCH_USER_0_SIZE));
+}
+
+/* gpio_set_boot_image_config() -- set actual boot bits of register */
+void gpio_set_user_0_config(u32 value)
+{
+	ulong scratch = gpio_get_scratch();	// get bits
+						// remove bits
+	scratch &= ~(BIT_MASK_ONES(SCRATCH_USER_0_SIZE) 
+		     << SCRATCH_USER_0_POS);
+	scratch |= ((value & BIT_MASK_ONES(SCRATCH_USER_0_SIZE))
+		     << SCRATCH_USER_0_POS);
+	gpio_set_scratch(scratch);
+}
+
+EXPORT_SYMBOL(gpio_set_fn);
+EXPORT_SYMBOL(gpio_get_fn);
+EXPORT_SYMBOL(gpio_set_out_en);
+EXPORT_SYMBOL(gpio_get_out_en);
+EXPORT_SYMBOL(gpio_get_pu);
+EXPORT_SYMBOL(gpio_set_pu);
+EXPORT_SYMBOL(gpio_set_val);
+EXPORT_SYMBOL(gpio_get_val);
+EXPORT_SYMBOL(gpio_request_irq);
+EXPORT_SYMBOL(gpio_request_normal_irq);
+EXPORT_SYMBOL(gpio_free_irq);
+EXPORT_SYMBOL(gpio_get_int_mode);
+EXPORT_SYMBOL(gpio_set_int_mode);
+EXPORT_SYMBOL(gpio_toggle_int_mode);
+EXPORT_SYMBOL(gpio_set_int);
+EXPORT_SYMBOL(gpio_get_int);
+EXPORT_SYMBOL(gpio_get_int32);
+EXPORT_SYMBOL(gpio_set_int32);
+EXPORT_SYMBOL(gpio_get_pend);
+EXPORT_SYMBOL(gpio_clear_pend);
+EXPORT_SYMBOL(gpio_get_pend32);
+EXPORT_SYMBOL(gpio_clear_pend32);
+EXPORT_SYMBOL(gpio_configure_pin);
+EXPORT_SYMBOL(gpio_get_board_config);
+EXPORT_SYMBOL(gpio_get_cur);
+EXPORT_SYMBOL(gpio_set_cur);
+EXPORT_SYMBOL(gpio_have_supercap);
+EXPORT_SYMBOL(gpio_have_gpio_acorn);
+EXPORT_SYMBOL(gpio_have_gpio_dev);
+EXPORT_SYMBOL(gpio_have_gpio_didj);
+EXPORT_SYMBOL(gpio_have_gpio_emerald);
+EXPORT_SYMBOL(gpio_have_gpio_madrid);
+EXPORT_SYMBOL(gpio_have_tvout);
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/gpio_l2p.c linux-2.6/arch/arm/mach-lf1000/gpio_l2p.c
--- linux-2.6.31/arch/arm/mach-lf1000/gpio_l2p.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/gpio_l2p.c	2012-11-16 20:20:48.000000000 -0800
@@ -0,0 +1,441 @@
+/* 
+ * arch/arm/mach-lf1000/gpio_l2p.h
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * LF1000 map logical gpio names to physical port/pin addresses
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <mach/gpio.h>
+#include <mach/gpio_map.h>
+
+#define	GPIO_PIN	0
+#define GPIO_PORT	1
+
+/* logical to physical mapping table */
+static s8 l2p_gpio_port_map[GPIO_NUMBER_VALUES][2];
+
+/* logical resource string names
+ * FIXME:keep in sync with enum gpio_resource{} in include/mach/gpio.h
+ */
+
+
+static char *resource_name[] = {
+	"HEADPHONE_JACK",
+	"LED_ENA",
+	"LCD_RESET",
+	"AUDIO_POWER",
+	"DPAD_UP",
+	"DPAD_DOWN",
+	"DPAD_RIGHT",
+	"DPAD_LEFT",
+	"BUTTON_A",
+	"BUTTON_B",
+	"SHOULDER_LEFT",
+	"SHOULDER_RIGHT",
+	"BUTTON_HOME",
+	"BUTTON_HINT",
+	"BUTTON_PAUSE",
+	"BUTTON_BRIGHTNESS",
+	"BUTTON_VOLUMEUP",
+	"BUTTON_VOLUMEDOWN",
+	"CARTRIDGE_DETECT",
+	"TOUCHSCREEN_X1",
+	"TOUCHSCREEN_Y1",
+	"TOUCHSCREEN_X2",
+	"TOUCHSCREEN_Y2",
+	"BUTTON_RED",
+	"EXT POWER",
+	"BUTTON_ESC",
+	"DOCK_POWER",
+	"BATTERY_PACK",
+	"SD1_POWER",
+	"LFP100_INT",
+};
+
+/*
+ * Initialize the logical to physical GPIO map based on board type.
+ * Translate only those GPIO pins that differ between boards.
+ */
+
+static void init_dev(void)
+{
+	l2p_gpio_port_map[LCD_RESET]		[GPIO_PORT] = DEV_LCD_RESET_PORT;
+	l2p_gpio_port_map[LCD_RESET]		[GPIO_PIN]  = DEV_LCD_RESET_PIN;
+	l2p_gpio_port_map[AUDIO_POWER]		[GPIO_PORT] = DEV_AUDIO_POWER_PORT;
+	l2p_gpio_port_map[AUDIO_POWER]		[GPIO_PIN]  = DEV_AUDIO_POWER_PIN;
+
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PORT] = DEV_CARTRIDGE_DETECT_PORT;
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PIN]  = DEV_CARTRIDGE_DETECT_PIN;
+	
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PORT] = DEV_LED_ENA_PORT;
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PIN]  = DEV_LED_ENA_PIN;
+
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PORT] = DEV_TOUCHSCREEN_X1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PIN]  = DEV_TOUCHSCREEN_X1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PORT] = DEV_TOUCHSCREEN_Y1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PIN]  = DEV_TOUCHSCREEN_Y1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PORT] = DEV_TOUCHSCREEN_X2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PIN]  = DEV_TOUCHSCREEN_X2_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PORT] = DEV_TOUCHSCREEN_Y2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PIN]  = DEV_TOUCHSCREEN_Y2_PIN;
+	
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = DEV_EXT_POWER_PORT;
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = DEV_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = DEV_HEADPHONE_JACK_PORT;
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = DEV_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = DEV_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = DEV_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = DEV_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = DEV_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = DEV_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = DEV_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = DEV_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = DEV_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PORT] = DEV_SHOULDER_RIGHT_PORT;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PIN]  = DEV_SHOULDER_RIGHT_PIN;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PORT] = DEV_SHOULDER_LEFT_PORT;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PIN]  = DEV_SHOULDER_LEFT_PIN;
+
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PORT] = DEV_BUTTON_A_PORT;
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PIN]  = DEV_BUTTON_A_PIN;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PORT] = DEV_BUTTON_B_PORT;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PIN]  = DEV_BUTTON_B_PIN;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PORT] = DEV_BUTTON_HOME_PORT;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PIN]  = DEV_BUTTON_HOME_PIN;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PORT] = DEV_BUTTON_HINT_PORT;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PIN]  = DEV_BUTTON_HINT_PIN;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PORT] = DEV_BUTTON_PAUSE_PORT;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PIN]  = DEV_BUTTON_PAUSE_PIN;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PORT] = DEV_BUTTON_BRIGHTNESS_PORT;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PIN]  = DEV_BUTTON_BRIGHTNESS_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = DEV_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = DEV_BATTERY_PACK_PIN;
+}
+
+static void init_didj(void)
+{
+	l2p_gpio_port_map[LCD_RESET]		[GPIO_PORT] = DIDJ_LCD_RESET_PORT;
+	l2p_gpio_port_map[LCD_RESET]		[GPIO_PIN]  = DIDJ_LCD_RESET_PIN;
+	l2p_gpio_port_map[AUDIO_POWER]		[GPIO_PORT] = DIDJ_AUDIO_POWER_PORT;
+	l2p_gpio_port_map[AUDIO_POWER]		[GPIO_PIN]  = DIDJ_AUDIO_POWER_PIN;
+
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PORT] = DIDJ_CARTRIDGE_DETECT_PORT;
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PIN]  = DIDJ_CARTRIDGE_DETECT_PIN;
+
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PORT] = DIDJ_LED_ENA_PORT;
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PIN]  = DIDJ_LED_ENA_PIN;
+	
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = DIDJ_EXT_POWER_PORT;
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = DIDJ_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = DIDJ_HEADPHONE_JACK_PORT;
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = DIDJ_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = DIDJ_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = DIDJ_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = DIDJ_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = DIDJ_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = DIDJ_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = DIDJ_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = DIDJ_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = DIDJ_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PORT] = DIDJ_SHOULDER_LEFT_PORT;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PIN]  = DIDJ_SHOULDER_LEFT_PIN;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PORT] = DIDJ_SHOULDER_RIGHT_PORT;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PIN]  = DIDJ_SHOULDER_RIGHT_PIN;
+
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PORT] = DIDJ_BUTTON_A_PORT;
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PIN]  = DIDJ_BUTTON_A_PIN;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PORT] = DIDJ_BUTTON_B_PORT;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PIN]  = DIDJ_BUTTON_B_PIN;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PORT] = DIDJ_BUTTON_HOME_PORT;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PIN]  = DIDJ_BUTTON_HOME_PIN;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PORT] = DIDJ_BUTTON_HINT_PORT;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PIN]  = DIDJ_BUTTON_HINT_PIN;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PORT] = DIDJ_BUTTON_PAUSE_PORT;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PIN]  = DIDJ_BUTTON_PAUSE_PIN;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PORT] = DIDJ_BUTTON_BRIGHTNESS_PORT;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PIN]  = DIDJ_BUTTON_BRIGHTNESS_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = DIDJ_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = DIDJ_BATTERY_PACK_PIN;
+}
+
+static void init_acorn(void)
+{
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PORT] = ACORN_CARTRIDGE_DETECT_PORT;
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PIN]  = ACORN_CARTRIDGE_DETECT_PIN;
+
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PORT] = ACORN_LED_ENA_PORT;
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PIN]  = ACORN_LED_ENA_PIN;
+
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PORT] = ACORN_TOUCHSCREEN_X1_PORT; 
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PIN]  = ACORN_TOUCHSCREEN_X1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PORT] = ACORN_TOUCHSCREEN_Y1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PIN]  = ACORN_TOUCHSCREEN_Y1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PORT] = ACORN_TOUCHSCREEN_X2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PIN]  = ACORN_TOUCHSCREEN_X2_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PORT] = ACORN_TOUCHSCREEN_Y2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PIN]  = ACORN_TOUCHSCREEN_Y2_PIN;
+
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = ACORN_EXT_POWER_PORT;
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = ACORN_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = ACORN_HEADPHONE_JACK_PORT;
+ 	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = ACORN_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = ACORN_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = ACORN_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = ACORN_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = ACORN_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = ACORN_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = ACORN_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = ACORN_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = ACORN_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PORT] = ACORN_SHOULDER_LEFT_PORT;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PIN]  = ACORN_SHOULDER_LEFT_PIN;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PORT] = ACORN_SHOULDER_RIGHT_PORT;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PIN]  = ACORN_SHOULDER_RIGHT_PIN;
+
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PORT] = ACORN_BUTTON_A_PORT;
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PIN]  = ACORN_BUTTON_A_PIN;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PORT] = ACORN_BUTTON_B_PORT;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PIN]  = ACORN_BUTTON_B_PIN;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PORT] = ACORN_BUTTON_HOME_PORT;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PIN]  = ACORN_BUTTON_HOME_PIN;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PORT] = ACORN_BUTTON_HINT_PORT;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PIN]  = ACORN_BUTTON_HINT_PIN;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PORT] = ACORN_BUTTON_PAUSE_PORT;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PIN]  = ACORN_BUTTON_PAUSE_PIN;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PORT] = ACORN_BUTTON_BRIGHTNESS_PORT;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PIN]  = ACORN_BUTTON_BRIGHTNESS_PIN;
+
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PORT] = ACORN_DOCK_POWER_PORT;
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PIN]  = ACORN_DOCK_POWER_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = ACORN_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = ACORN_BATTERY_PACK_PIN;
+}
+
+static void init_emerald(void)
+{
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PORT] = EMERALD_CARTRIDGE_DETECT_PORT;
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PIN]  = EMERALD_CARTRIDGE_DETECT_PIN;
+
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PORT] = EMERALD_LED_ENA_PORT;
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PIN]  = EMERALD_LED_ENA_PIN;
+
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PORT] = EMERALD_TOUCHSCREEN_X1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PIN]  = EMERALD_TOUCHSCREEN_X1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PORT] = EMERALD_TOUCHSCREEN_Y1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PIN]  = EMERALD_TOUCHSCREEN_Y1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PORT] = EMERALD_TOUCHSCREEN_X2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PIN]  = EMERALD_TOUCHSCREEN_X2_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PORT] = EMERALD_TOUCHSCREEN_Y2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PIN]  = EMERALD_TOUCHSCREEN_Y2_PIN;
+
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = EMERALD_EXT_POWER_PORT;
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = EMERALD_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = EMERALD_HEADPHONE_JACK_PORT;
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = EMERALD_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = EMERALD_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = EMERALD_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = EMERALD_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = EMERALD_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = EMERALD_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = EMERALD_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = EMERALD_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = EMERALD_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PORT] = EMERALD_SHOULDER_LEFT_PORT;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PIN]  = EMERALD_SHOULDER_LEFT_PIN;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PORT] = EMERALD_SHOULDER_RIGHT_PORT;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PIN]  = EMERALD_SHOULDER_RIGHT_PIN;
+
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PORT] = EMERALD_BUTTON_A_PORT;
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PIN]  = EMERALD_BUTTON_A_PIN;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PORT] = EMERALD_BUTTON_B_PORT;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PIN]  = EMERALD_BUTTON_B_PIN;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PORT] = EMERALD_BUTTON_HOME_PORT;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PIN]  = EMERALD_BUTTON_HOME_PIN;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PORT] = EMERALD_BUTTON_HINT_PORT;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PIN]  = EMERALD_BUTTON_HINT_PIN;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PORT] = EMERALD_BUTTON_PAUSE_PORT;
+	l2p_gpio_port_map[BUTTON_PAUSE]		[GPIO_PIN]  = EMERALD_BUTTON_PAUSE_PIN;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PORT] = EMERALD_BUTTON_BRIGHTNESS_PORT;
+	l2p_gpio_port_map[BUTTON_BRIGHTNESS]	[GPIO_PIN]  = EMERALD_BUTTON_BRIGHTNESS_PIN;
+
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PORT] = EMERALD_DOCK_POWER_PORT;
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PIN]  = EMERALD_DOCK_POWER_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = EMERALD_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = EMERALD_BATTERY_PACK_PIN;
+
+	l2p_gpio_port_map[LFP100_INT]		[GPIO_PORT] = EMERALD_LFP100_INT_PORT;
+	l2p_gpio_port_map[LFP100_INT]		[GPIO_PIN]  = EMERALD_LFP100_INT_PIN;
+}
+
+static void init_k2(void)
+{
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PORT] = K2_LED_ENA_PORT;
+	l2p_gpio_port_map[LED_ENA]		[GPIO_PIN]  = K2_LED_ENA_PIN;
+
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PORT] = K2_TOUCHSCREEN_X1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PIN]  = K2_TOUCHSCREEN_X1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PORT] = K2_TOUCHSCREEN_Y1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PIN]  = K2_TOUCHSCREEN_Y1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PORT] = K2_TOUCHSCREEN_X2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PIN]  = K2_TOUCHSCREEN_X2_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PORT] = K2_TOUCHSCREEN_Y2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PIN]  = K2_TOUCHSCREEN_Y2_PIN;
+
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = K2_EXT_POWER_PORT;
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = K2_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = K2_HEADPHONE_JACK_PORT;
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = K2_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = K2_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = K2_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = K2_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = K2_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = K2_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = K2_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = K2_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = K2_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PORT] = K2_SHOULDER_LEFT_PORT;
+	l2p_gpio_port_map[SHOULDER_LEFT]	[GPIO_PIN]  = K2_SHOULDER_LEFT_PIN;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PORT] = K2_SHOULDER_RIGHT_PORT;
+	l2p_gpio_port_map[SHOULDER_RIGHT]	[GPIO_PIN]  = K2_SHOULDER_RIGHT_PIN;
+
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PORT] = K2_BUTTON_A_PORT;
+	l2p_gpio_port_map[BUTTON_A]		[GPIO_PIN]  = K2_BUTTON_A_PIN;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PORT] = K2_BUTTON_B_PORT;
+	l2p_gpio_port_map[BUTTON_B]		[GPIO_PIN]  = K2_BUTTON_B_PIN;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PORT] = K2_BUTTON_HOME_PORT;
+	l2p_gpio_port_map[BUTTON_HOME]		[GPIO_PIN]  = K2_BUTTON_HOME_PIN;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PORT] = K2_BUTTON_HINT_PORT;
+	l2p_gpio_port_map[BUTTON_HINT]		[GPIO_PIN]  = K2_BUTTON_HINT_PIN;
+
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PORT] = K2_DOCK_POWER_PORT;
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PIN]  = K2_DOCK_POWER_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = K2_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = K2_BATTERY_PACK_PIN;
+}
+
+static void init_madrid(void)
+{
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PORT] = MADRID_CARTRIDGE_DETECT_PORT;
+	l2p_gpio_port_map[CARTRIDGE_DETECT]	[GPIO_PIN]  = MADRID_CARTRIDGE_DETECT_PIN;
+
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PORT] = MADRID_TOUCHSCREEN_X1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X1]	[GPIO_PIN]  = MADRID_TOUCHSCREEN_X1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PORT] = MADRID_TOUCHSCREEN_Y1_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y1]	[GPIO_PIN]  = MADRID_TOUCHSCREEN_Y1_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PORT] = MADRID_TOUCHSCREEN_X2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_X2]	[GPIO_PIN]  = MADRID_TOUCHSCREEN_X2_PIN;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PORT] = MADRID_TOUCHSCREEN_Y2_PORT;
+	l2p_gpio_port_map[TOUCHSCREEN_Y2]	[GPIO_PIN]  = MADRID_TOUCHSCREEN_Y2_PIN;
+
+	l2p_gpio_port_map[EXT_POWER]		[GPIO_PORT] = MADRID_EXT_POWER_PORT;
+ 	l2p_gpio_port_map[EXT_POWER]		[GPIO_PIN]  = MADRID_EXT_POWER_PIN;
+
+	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PORT] = MADRID_HEADPHONE_JACK_PORT;
+ 	l2p_gpio_port_map[HEADPHONE_JACK]	[GPIO_PIN]  = MADRID_HEADPHONE_JACK_PIN;
+
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PORT] = MADRID_DPAD_LEFT_PORT;
+	l2p_gpio_port_map[DPAD_LEFT]		[GPIO_PIN]  = MADRID_DPAD_LEFT_PIN;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PORT] = MADRID_DPAD_RIGHT_PORT;
+	l2p_gpio_port_map[DPAD_RIGHT]		[GPIO_PIN]  = MADRID_DPAD_RIGHT_PIN;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PORT] = MADRID_DPAD_UP_PORT;
+	l2p_gpio_port_map[DPAD_UP]		[GPIO_PIN]  = MADRID_DPAD_UP_PIN;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PORT] = MADRID_DPAD_DOWN_PORT;
+	l2p_gpio_port_map[DPAD_DOWN]		[GPIO_PIN]  = MADRID_DPAD_DOWN_PIN;
+
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PORT] = MADRID_DOCK_POWER_PORT;
+	l2p_gpio_port_map[DOCK_POWER]		[GPIO_PIN]  = MADRID_DOCK_POWER_PIN;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PORT] = MADRID_BATTERY_PACK_PORT;
+	l2p_gpio_port_map[BATTERY_PACK]		[GPIO_PIN]  = MADRID_BATTERY_PACK_PIN;
+
+	l2p_gpio_port_map[SD1_POWER]		[GPIO_PORT] = MADRID_SD1_POWER_PORT;
+	l2p_gpio_port_map[SD1_POWER]		[GPIO_PIN]  = MADRID_SD1_POWER_PIN;
+	l2p_gpio_port_map[LFP100_INT]		[GPIO_PORT] = MADRID_LFP100_INT_PORT;
+	l2p_gpio_port_map[LFP100_INT]		[GPIO_PIN]  = MADRID_LFP100_INT_PIN;
+}
+
+
+static void lf1000_l2p_init(void)
+{
+	static int isInited = 0;
+
+	if (isInited) return;	// table is initialized
+
+	/* mark all translations as invalid */
+	memset(l2p_gpio_port_map, -1, sizeof(l2p_gpio_port_map));
+
+	/* put most recent board at top of list */
+	if      (gpio_have_gpio_madrid())  init_madrid();
+	else if (gpio_have_gpio_k2())      init_k2();
+	else if (gpio_have_gpio_emerald()) init_emerald();
+	else if (gpio_have_gpio_didj())    init_didj();
+	else if (gpio_have_gpio_acorn())   init_acorn();
+	else if (gpio_have_gpio_dev())     init_dev();
+	else {
+		printk(KERN_ERR "%s.%d:%s() unknown board type (0x%2.2x)\n",
+			__FILE__, __LINE__, __FUNCTION__,
+			gpio_get_board_config());
+	}
+	
+	isInited = 1;	// finished initializing table
+}
+
+
+int lf1000_l2p_port(enum gpio_resource logical_value)
+{
+	lf1000_l2p_init();	// initialize translation table if needed
+
+	if (0 <= logical_value && logical_value < GPIO_NUMBER_VALUES) {
+		if (l2p_gpio_port_map[logical_value][GPIO_PORT] == -1) {
+			printk(KERN_INFO "resource %s (%d) port is undefined (-1)\n",
+				resource_name[logical_value], logical_value);
+		}
+		return(l2p_gpio_port_map[logical_value][GPIO_PORT]);
+	} else {
+		printk(KERN_INFO "Resource '%d' is out of defined range.",
+			logical_value);
+		return -1;
+	}
+}
+EXPORT_SYMBOL(lf1000_l2p_port);
+
+int lf1000_l2p_pin(enum gpio_resource logical_value)
+{
+	lf1000_l2p_init();	// initialize translation table if needed
+
+	if (0 <= logical_value && logical_value < GPIO_NUMBER_VALUES) {
+		if (l2p_gpio_port_map[logical_value][GPIO_PORT] == -1) {
+			printk(KERN_INFO "resource %s (%d) pin is undefined (-1)\n",
+				resource_name[logical_value], logical_value);
+		}
+		return(l2p_gpio_port_map[logical_value][GPIO_PIN]);
+	} else {
+		printk(KERN_INFO "Resource '%d' is out of defined range.",
+			logical_value);
+		return -1;
+	}
+}
+EXPORT_SYMBOL(lf1000_l2p_pin);
+ 
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/gpio_main.c linux-2.6/arch/arm/mach-lf1000/gpio_main.c
--- linux-2.6.31/arch/arm/mach-lf1000/gpio_main.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/gpio_main.c	2012-11-16 18:07:17.000000000 -0800
@@ -0,0 +1,1483 @@
+/* 
+ * arch/arm/mach-lf1000/gpio_main.c
+ *
+ * LF1000 General-Purpose IO (GPIO) Driver 
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/gpio_priv.h>
+#include <mach/gpio.h>
+#include <mach/common.h>
+#include <mach/platform.h>
+#include <mach/mem_controller.h>
+#include <mach/gpio_hal.h>
+#include <linux/lf1000/gpio_ioctl.h>
+
+/***********************
+ * device private data *
+ ***********************/
+
+struct gpio_device gpio = {
+	.mem = NULL,
+	.mem_cur = NULL,
+	.amem = NULL,
+	.irq = -1,
+	.touchscreen = 0,
+};
+
+/*******************
+ * sysfs interface *
+ *******************/
+
+#ifdef CONFIG_LF1000_SDRAM_TUNE
+/*
+ * expose SDRAM timing registers
+ */
+
+static ssize_t show_memcfg(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMCFG));
+	return sprintf(buf,"MEMCFG = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memcfg(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMCFG));
+	return count;
+}
+static DEVICE_ATTR(memcfg, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memcfg, set_memcfg);
+
+static ssize_t show_memtime0(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMTIME0));
+	return sprintf(buf,"MEMTIME0 = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memtime0(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMTIME0));
+	return count;
+}
+static DEVICE_ATTR(memtime0, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memtime0, set_memtime0);
+
+static ssize_t show_memtime1(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMTIME1));
+	return sprintf(buf,"MEMTIME1 = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memtime1(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMTIME1));
+	return count;
+}
+static DEVICE_ATTR(memtime1, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memtime1, set_memtime1);
+
+static ssize_t show_pad_strength_gpio_a_low(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOAL));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_a_low(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOAL));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_a_low,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_a_low, set_pad_strength_gpio_a_low);
+
+
+static ssize_t show_pad_strength_gpio_a_high(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOAH));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_a_high(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOAH));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_a_high,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_a_high, set_pad_strength_gpio_a_high);
+
+
+static ssize_t show_pad_strength_gpio_b_low(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOBL));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_b_low(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOBL));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_b_low,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_b_low, set_pad_strength_gpio_b_low);
+
+
+static ssize_t show_pad_strength_gpio_b_high(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOBH));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_b_high(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOBH));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_b_high,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_b_high, set_pad_strength_gpio_b_high);
+
+
+static ssize_t show_pad_strength_gpio_c_low(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOCL));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_c_low(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOCL));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_c_low,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_c_low, set_pad_strength_gpio_c_low);
+
+
+static ssize_t show_pad_strength_gpio_c_high(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOCH));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_gpio_c_high(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHGPIOCH));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_gpio_c_high,
+	S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_gpio_c_high, set_pad_strength_gpio_c_high);
+
+static ssize_t show_pad_strength_bus(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHBUS));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pad_strength_bus(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIOCURRENT_BASE + GPIOPADSTRENGTHBUS));
+	return count;
+}
+static DEVICE_ATTR(pad_strength_bus, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pad_strength_bus, set_pad_strength_bus);
+
+static ssize_t show_pullup_enable_gpio_a(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIO_BASE + GPIOAPUENB));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pullup_enable_gpio_a(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIO_BASE + GPIOAPUENB));
+	return count;
+}
+static DEVICE_ATTR(pullup_enable_gpio_a, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pullup_enable_gpio_a, set_pullup_enable_gpio_a);
+
+static ssize_t show_pullup_enable_gpio_b(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIO_BASE + GPIOBPUENB));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pullup_enable_gpio_b(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIO_BASE + GPIOBPUENB));
+	return count;
+}
+static DEVICE_ATTR(pullup_enable_gpio_b, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pullup_enable_gpio_b, set_pullup_enable_gpio_b);
+
+static ssize_t show_pullup_enable_gpio_c(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readl(IO_ADDRESS(LF1000_GPIO_BASE + GPIOCPUENB));
+	return sprintf(buf,"0x%8.8x\n", tmp);
+}
+
+static ssize_t set_pullup_enable_gpio_c(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writel(value, IO_ADDRESS(LF1000_GPIO_BASE + GPIOCPUENB));
+	return count;
+}
+static DEVICE_ATTR(pullup_enable_gpio_c, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_pullup_enable_gpio_c, set_pullup_enable_gpio_c);
+
+static ssize_t show_memrefresh(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMREFRESH));
+	return sprintf(buf,"MEMREFRESH = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memrefresh(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMREFRESH));
+	return count;
+}
+static DEVICE_ATTR(memrefresh, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memrefresh, set_memrefresh);
+
+static ssize_t show_memcontrol(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMCONTROL));
+	return sprintf(buf,"MEMCONTROL = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memcontrol(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMCONTROL));
+	return count;
+}
+static DEVICE_ATTR(memcontrol, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memcontrol, set_memcontrol);
+
+static ssize_t show_memclkdelay(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMCLKDELAY));
+	return sprintf(buf,"MEMCLKDELAY = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memclkdelay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMCLKDELAY));
+	return count;
+}
+static DEVICE_ATTR(memclkdelay, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memclkdelay, set_memclkdelay);
+
+static ssize_t show_memdqsoutdelay(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMDQSOUTDELAY));
+	return sprintf(buf,"MEMDQSOUTDELAY = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memdqsoutdelay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMDQSOUTDELAY));
+	return count;
+}
+static DEVICE_ATTR(memdqsoutdelay, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+	show_memdqsoutdelay, set_memdqsoutdelay);
+
+static ssize_t show_memdqsindelay(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = readw(IO_ADDRESS(LF1000_MCU_Y_BASE + LF1000_MEMDQSINDELAY));
+	return sprintf(buf,"MEMDQSINDELAY = 0x%4.4x\n", tmp);
+}
+
+static ssize_t set_memdqsindelay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	writew(value, IO_ADDRESS(LF1000_MCU_Y_BASE + MEMDQSINDELAY));
+	return count;
+}
+static DEVICE_ATTR(memdqsindelay, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		show_memdqsindelay, set_memdqsindelay);
+#endif
+ 
+static ssize_t show_scratchpad(struct device *dev, 
+		struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%08X\n", (unsigned int)gpio_get_scratch());
+}
+
+static ssize_t set_scratchpad(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	unsigned int x;
+
+	if(sscanf(buf, "%x", &x) != 1)
+		return -EINVAL;
+	gpio_set_scratch (x);
+	return count;		// read all chars
+}
+static DEVICE_ATTR(scratchpad, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH, 
+		   show_scratchpad, set_scratchpad);
+
+static ssize_t show_board_id(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	// Don't change this format: packages/mfgdata and libMfgData.cpp
+	// depend on parsing this
+	return sprintf(buf, "%X\n", gpio_get_board_config());
+}
+static DEVICE_ATTR(board_id, S_IRUSR|S_IRGRP|S_IROTH, show_board_id, NULL);
+
+static ssize_t show_touchscreen(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", (gpio.touchscreen) ? "YES" : "NO");
+}
+static DEVICE_ATTR(touchscreen, S_IRUSR|S_IRGRP|S_IROTH, show_touchscreen, NULL);
+
+static ssize_t show_power(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n",
+	(gpio_get_power_config() == SCRATCH_POWER_WARMBOOT) ? "WARM" : 
+	 (gpio_get_power_config() == SCRATCH_POWER_COLDBOOT) ? "COLD" : 
+		       "FIRST");
+}
+static DEVICE_ATTR(power, S_IRUSR|S_IRGRP|S_IROTH, show_power, NULL);
+
+static ssize_t show_shutdown(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n",
+		(gpio_get_shutdown_config() == SCRATCH_SHUTDOWN_DIRTY) ?
+			"DIRTY" : "CLEAN");
+}
+
+static ssize_t set_shutdown(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	if (!strcasecmp(buf, "DIRTY\n"))
+		gpio_set_shutdown_config(SCRATCH_SHUTDOWN_DIRTY);
+	else if (!strcasecmp(buf, "CLEAN\n"))
+		gpio_set_shutdown_config(SCRATCH_SHUTDOWN_CLEAN);
+	else
+		return -EINVAL;	// invalid string
+	
+	return count;		// read all chars
+}
+static DEVICE_ATTR(shutdown, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_shutdown, set_shutdown);
+
+static ssize_t show_request(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	switch(gpio_get_request_config()) {
+	case SCRATCH_REQUEST_PLAY:       return(sprintf(buf, "PLAY\n"));
+	case SCRATCH_REQUEST_RETURN:     return(sprintf(buf, "RETURN\n"));
+	case SCRATCH_REQUEST_UPDATE:     return(sprintf(buf, "UPDATE\n"));
+	case SCRATCH_REQUEST_BATTERY:    return(sprintf(buf, "BATTERY\n"));
+	case SCRATCH_REQUEST_UNCLEAN:    return(sprintf(buf, "UNCLEAN\n"));
+	case SCRATCH_REQUEST_FAILED:     return(sprintf(buf, "FAILED\n"));
+	case SCRATCH_REQUEST_SHORT:      return(sprintf(buf, "SHORT\n"));
+	case SCRATCH_REQUEST_TRAPDOOR:   return(sprintf(buf, "TRAPDOOR\n"));
+	}
+	return(sprintf(buf, "UNKNOWN\n"));  // unexpected
+}
+
+static ssize_t set_request(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (!strcasecmp(buf, "PLAY\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_PLAY);
+	else if (!strcasecmp(buf, "RETURN\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_RETURN);
+	else if (!strcasecmp(buf, "UPDATE\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_UPDATE);
+	else if (!strcasecmp(buf, "BATTERY\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_BATTERY);
+	else if (!strcasecmp(buf, "UNCLEAN\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_UNCLEAN);
+	else if (!strcasecmp(buf, "FAILED\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_FAILED);
+	else if (!strcasecmp(buf, "SHORT\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_SHORT);
+	else if (!strcasecmp(buf, "TRAPDOOR\n"))
+		gpio_set_request_config(SCRATCH_REQUEST_TRAPDOOR);
+	else
+		return -EINVAL;	// invalid string
+	return (count);		// read all chars
+}
+static DEVICE_ATTR(request, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_request, set_request);
+
+static ssize_t show_boot_image(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	switch(gpio_get_boot_image_config()) {
+	case SCRATCH_BOOT_IMAGE_RECOVERY: return(sprintf(buf, "RECOVERY\n"));
+	case SCRATCH_BOOT_IMAGE_PLAY:     return(sprintf(buf, "PLAY\n"));
+	case SCRATCH_BOOT_IMAGE_2:        return(sprintf(buf, "IMAGE_2\n"));
+	case SCRATCH_BOOT_IMAGE_3:        return(sprintf(buf, "IMAGE_3\n"));
+	}
+	return(sprintf(buf, "UNKNOWN\n"));  // unexpected
+}
+
+static ssize_t set_boot_image(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (!strcasecmp(buf, "RECOVERY\n"))
+		gpio_set_boot_image_config(SCRATCH_BOOT_IMAGE_RECOVERY);
+	else if (!strcasecmp(buf, "PLAY\n"))
+		gpio_set_boot_image_config(SCRATCH_BOOT_IMAGE_PLAY);
+	else if (!strcasecmp(buf, "IMAGE_2\n"))
+		gpio_set_boot_image_config(SCRATCH_BOOT_IMAGE_2);
+	else if (!strcasecmp(buf, "IMAGE_3\n"))
+		gpio_set_boot_image_config(SCRATCH_BOOT_IMAGE_3);
+	else
+		return -EINVAL;	// invalid string
+	return (count);		// read all chars
+}
+static DEVICE_ATTR(boot_image, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_boot_image, set_boot_image);
+
+static ssize_t show_boot_source(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	switch(gpio_get_boot_source_config()) {
+	case SCRATCH_BOOT_SOURCE_NOR:  return(sprintf(buf, "NOR\n"));
+	case SCRATCH_BOOT_SOURCE_NAND: return(sprintf(buf, "NAND\n"));
+	case SCRATCH_BOOT_SOURCE_UART: return(sprintf(buf, "UART\n"));
+	case SCRATCH_BOOT_SOURCE_USB:  return(sprintf(buf, "USB\n"));
+	case SCRATCH_BOOT_SOURCE_UNKNOWN:
+		return(sprintf(buf, "UNKNOWN\n"));
+	}
+	return(sprintf(buf, "UNKNOWN\n"));  // unexpected
+}
+
+static DEVICE_ATTR(boot_source, S_IRUSR|S_IRGRP|S_IROTH, show_boot_source, NULL);
+
+static ssize_t show_panic(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf (buf, "%d\n", gpio_get_panic_config());
+}
+
+static ssize_t set_panic(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if(sscanf(buf, "%d", &value) != 1)
+		return -EINVAL;
+	gpio_set_panic_config(value);
+	return count;		// read all chars
+}
+static DEVICE_ATTR(panic, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_panic, set_panic);
+
+static ssize_t show_user_0(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	u32 val = gpio_get_user_0_config();
+	return(sprintf(buf, "%X\n", val));
+}
+
+static ssize_t set_user_0(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int x;
+
+	if(sscanf(buf, "%X", &x) != 1)
+		return -EINVAL;
+	gpio_set_user_0_config (x);
+	return (count);		// read all chars
+}
+static DEVICE_ATTR(user_0, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_user_0, set_user_0);
+
+#ifdef CONFIG_LF1000_GPIO_DEBUG
+static int get_port(u8 port, char *buf)
+{
+	int len = 0;
+	int reg = port*0x40;
+	char x = 'A'+port;
+	void *base = gpio.mem;
+
+	len += sprintf(buf+len,"GPIO%cOUT      = 0x%08X\n", x,
+				   ioread32(base+GPIOAOUT+reg));
+	len += sprintf(buf+len,"GPIO%cOUTENB   = 0x%08X\n", x,
+				   ioread32(base+GPIOAOUTENB+reg));
+	len += sprintf(buf+len,"GPIO%cDETMODE0 = 0x%08X\n", x,
+				   ioread32(base+GPIOADETMODE0+reg));
+	len += sprintf(buf+len,"GPIO%cDETMODE1 = 0x%08X\n", x,
+				   ioread32(base+GPIOADETMODE1+reg));
+	len += sprintf(buf+len,"GPIO%cINTENB   = 0x%08X\n", x,
+				   ioread32(base+GPIOAINTENB+reg));
+	len += sprintf(buf+len,"GPIO%cDET      = 0x%08X\n", x,
+				   ioread32(base+GPIOADET+reg));
+	len += sprintf(buf+len,"GPIO%cPAD      = 0x%08X\n", x,
+				   ioread32(base+GPIOAPAD+reg));
+	len += sprintf(buf+len,"GPIO%cPUENB    = 0x%08X\n", x,
+				   ioread32(base+GPIOAPUENB+reg));
+	len += sprintf(buf+len,"GPIO%cALTFN0   = 0x%08X\n", x,
+				   ioread32(base+GPIOAALTFN0+reg));
+	len += sprintf(buf+len,"GPIO%cALTFN1   = 0x%08X\n", x,
+				   ioread32(base+GPIOAALTFN1+reg));
+
+	return len;
+}
+
+static ssize_t show_portA(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return get_port(0, buf);
+}
+static DEVICE_ATTR(port_A, S_IRUSR|S_IRGRP|S_IROTH, show_portA, NULL);
+
+static ssize_t show_portB(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return get_port(1, buf);
+}
+static DEVICE_ATTR(port_B, S_IRUSR|S_IRGRP|S_IROTH, show_portB, NULL);
+
+static ssize_t show_portC(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return get_port(2, buf);
+}
+static DEVICE_ATTR(port_C, S_IRUSR|S_IRGRP|S_IROTH, show_portC, NULL);
+
+static ssize_t show_alive(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	int len = 0;
+
+	len += sprintf(buf+len, "ALIVEPWRGATEREG     = 0x%08X\n",
+			ioread32(gpio.amem+ALIVEPWRGATEREG));
+	len += sprintf(buf+len, "ALIVEGPIORSTREG     = 0x%08X\n",
+			ioread32(gpio.amem+ALIVEGPIORSTREG));
+	len += sprintf(buf+len, "ALIVEGPIOSETREG     = 0x%08X\n",
+			ioread32(gpio.amem+ALIVEGPIOSETREG));
+	len += sprintf(buf+len, "ALIVEGPIOREADREG    = 0x%08X\n",
+			ioread32(gpio.amem+ALIVEGPIOREADREG));
+	len += sprintf(buf+len, "ALIVESCRATCHRSTREG  = 0x%08X\n",
+			ioread32(gpio.amem+ALIVESCRATCHRSTREG));
+	len += sprintf(buf+len, "ALIVESCRATCHSETREG  = 0x%08X\n",
+			ioread32(gpio.amem+ALIVESCRATCHSETREG));
+	len += sprintf(buf+len, "ALIVESCRATCHREADREG = 0x%08X\n",
+			ioread32(gpio.amem+ALIVESCRATCHREADREG));
+	return len;
+}
+static DEVICE_ATTR(port_alive, S_IRUSR|S_IRGRP|S_IROTH, show_alive, NULL);
+#endif /* CONFIG_LF1000_GPIO_DEBUG */
+
+static struct attribute *gpio_attributes[] = {
+#ifdef CONFIG_LF1000_SDRAM_TUNE
+	&dev_attr_memcfg.attr,
+	&dev_attr_pad_strength_gpio_a_low.attr,
+	&dev_attr_pad_strength_gpio_a_high.attr,
+	&dev_attr_pad_strength_gpio_b_low.attr,
+	&dev_attr_pad_strength_gpio_b_high.attr,
+	&dev_attr_pad_strength_gpio_c_low.attr,
+	&dev_attr_pad_strength_gpio_c_high.attr,
+	&dev_attr_pad_strength_bus.attr,
+	&dev_attr_memtime0.attr,
+	&dev_attr_memtime1.attr,
+	&dev_attr_pullup_enable_gpio_a.attr,
+	&dev_attr_pullup_enable_gpio_b.attr,
+	&dev_attr_pullup_enable_gpio_c.attr,
+	&dev_attr_memrefresh.attr,
+	&dev_attr_memcontrol.attr,
+	&dev_attr_memclkdelay.attr,
+	&dev_attr_memdqsoutdelay.attr,
+	&dev_attr_memdqsindelay.attr,
+#endif
+	&dev_attr_board_id.attr,
+	&dev_attr_touchscreen.attr,
+	&dev_attr_shutdown.attr,
+	&dev_attr_request.attr,
+	&dev_attr_boot_image.attr,
+	&dev_attr_boot_source.attr,
+	&dev_attr_power.attr,
+	&dev_attr_panic.attr,
+	&dev_attr_user_0.attr,
+#ifdef CONFIG_LF1000_GPIO_DEBUG
+	&dev_attr_port_A.attr,
+	&dev_attr_port_B.attr,
+	&dev_attr_port_C.attr,
+#endif /* CONFIG_LF1000_GPIO_DEBUG */
+	NULL
+};
+
+static struct attribute_group gpio_attr_group = {
+	.attrs = gpio_attributes
+};
+
+#ifdef CONFIG_LF1000_STRESS_TEST
+
+static enum gpio_port accy_port, cart_port, power_port, usb_port;
+static enum gpio_pin accy_pin, cart_pin, power_pin, usb_pin;
+
+static ssize_t show_port(struct device *dev, struct device_attribute *attr,
+			char *buf, const enum gpio_port port)
+{
+	char port_name = 'A' + port - GPIO_PORT_A;
+	return(sprintf(buf, "PORT %c\n", port_name));
+}
+
+static ssize_t set_port(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count, enum gpio_port *port)
+{
+	unsigned char value;
+
+	if(sscanf(buf, "%c", &value) != 1)
+		return -EINVAL;
+
+	value = toupper(value);
+	value = GPIO_PORT_A + value - 'A';
+
+	if(value > (unsigned char)GPIO_PORT_ALV)
+		return -EINVAL;
+
+	*port = value;
+
+	return count;
+}
+
+static ssize_t show_pin(struct device *dev, struct device_attribute *attr,
+			char *buf, const enum gpio_pin pin)
+{
+	return(sprintf(buf, "%d\n", (int)pin));
+}
+
+static ssize_t set_pin(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count, enum gpio_pin *pin)
+{
+	int ret, value;
+
+	ret = get_option(&buf, &value);
+
+	if(ret != 1)
+		return -EINVAL;
+
+	if((value < (int)GPIO_PIN0) || (value > (int)GPIO_PIN31))
+		return -EINVAL;
+
+	*pin = value;
+
+	return count;
+}
+
+static ssize_t show_accy_port(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_port(dev, attr, buf, accy_port);
+}
+
+static ssize_t set_accy_port(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_port(dev, attr, buf, count, &accy_port);
+}
+
+static DEVICE_ATTR(accy_port, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_accy_port, set_accy_port);
+
+static ssize_t show_accy_pin(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_pin(dev, attr, buf, accy_pin);
+}
+
+static ssize_t set_accy_pin(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_pin(dev, attr, buf, count, &accy_pin);
+}
+
+static DEVICE_ATTR(accy_pin, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_accy_pin, set_accy_pin);
+
+static ssize_t show_cart_port(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_port(dev, attr, buf, cart_port);
+}
+
+static ssize_t set_cart_port(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_port(dev, attr, buf, count, &cart_port);
+}
+
+static DEVICE_ATTR(cart_port, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_cart_port, set_cart_port);
+
+static ssize_t show_cart_pin(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_pin(dev, attr, buf, cart_pin);
+}
+
+static ssize_t set_cart_pin(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_pin(dev, attr, buf, count, &cart_pin);
+}
+
+static DEVICE_ATTR(cart_pin, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_cart_pin, set_cart_pin);
+
+static ssize_t show_power_port(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_port(dev, attr, buf, power_port);
+}
+
+static ssize_t set_power_port(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_port(dev, attr, buf, count, &power_port);
+}
+
+static DEVICE_ATTR(power_port, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_power_port, set_power_port);
+
+static ssize_t show_power_pin(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_pin(dev, attr, buf, power_pin);
+}
+
+static ssize_t set_power_pin(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_pin(dev, attr, buf, count, &power_pin);
+}
+
+static DEVICE_ATTR(power_pin, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_power_pin, set_power_pin);
+
+static ssize_t show_usb_port(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_port(dev, attr, buf, usb_port);
+}
+
+static ssize_t set_usb_port(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_port(dev, attr, buf, count, &usb_port);
+}
+
+static DEVICE_ATTR(usb_port, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_usb_port, set_usb_port);
+
+static ssize_t show_usb_pin(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return show_pin(dev, attr, buf, usb_pin);
+}
+
+static ssize_t set_usb_pin(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return set_pin(dev, attr, buf, count, &usb_pin);
+}
+
+static DEVICE_ATTR(usb_pin, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+			show_usb_pin, set_usb_pin);
+
+static struct attribute *stress_attributes[] = {
+	&dev_attr_accy_port.attr,
+	&dev_attr_accy_pin.attr,
+	&dev_attr_cart_port.attr,
+	&dev_attr_cart_pin.attr,
+	&dev_attr_power_port.attr,
+	&dev_attr_power_pin.attr,
+	&dev_attr_usb_port.attr,
+	&dev_attr_usb_pin.attr,
+	NULL
+};
+
+static struct attribute_group stress_attr_group = {
+	.name = "stress",
+	.attrs = stress_attributes
+};
+
+/*
+ * In order to make power cut as fast as possible, pre-configure trigger pin
+ * so all that must be done at cut-time is toggle the output value.
+ */
+void stress_config_power(void)
+{
+	gpio_set_pu(power_port, power_pin, 0);
+	gpio_set_val(power_port, power_pin, 0);
+	gpio_set_out_en(power_port, power_pin, 1);
+	gpio_set_fn(power_port, power_pin, GPIO_GPIOFN);
+}
+
+EXPORT_SYMBOL(stress_config_power);
+
+void stress_cut_power(void)
+{
+	//gpio_set_val(GPIO_PORT_ALV, VDDPWRONSET, 0);
+	gpio_set_val(power_port, power_pin, 1);
+}
+
+EXPORT_SYMBOL(stress_cut_power);
+
+void stress_cut_cart(int cut)
+{
+	gpio_configure_pin(cart_port, cart_pin, 
+		GPIO_GPIOFN, 1, 0, cut);
+}
+
+EXPORT_SYMBOL(stress_cut_cart);
+
+#endif	/* CONFIG_LF1000_STRESS_TEST */
+
+static struct attribute *alive_attributes[] = {
+#ifdef CONFIG_LF1000_GPIO_DEBUG
+	&dev_attr_port_alive.attr,
+#endif /* CONFIG_LF1000_GPIO_DEBUG */
+	&dev_attr_scratchpad.attr,
+	NULL,
+};
+
+static struct attribute_group alive_attr_group = {
+	.attrs = alive_attributes
+};
+
+/*******************************
+ * character device operations *
+ *******************************/
+
+int gpio_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	int retval = 0;
+	void __user *argp = (void __user *)arg;
+	union gpio_cmd c;
+
+	switch(cmd) {
+		case GPIO_IOCSOUTVAL:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, 
+				sizeof(struct outvalue_cmd)))
+			return -EFAULT;
+		retval = gpio_set_val(c.outvalue.port, c.outvalue.pin, 
+					c.outvalue.value);
+		if(retval)
+			retval = -EFAULT;
+		break;
+
+		case GPIO_IOCSOUTENB:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct outenb_cmd)))
+			return -EFAULT;
+		retval = gpio_set_out_en(c.outenb.port, c.outenb.pin, 
+				c.outenb.value);
+		if(retval)
+			retval = -EFAULT;
+		break;
+
+		case GPIO_IOCXOUTENB:
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = gpio_get_out_en(c.func.port, c.func.pin);
+		if(retval < 0)
+			return -EFAULT;
+		c.func.func = (char)retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = 0;
+		break;
+
+		case GPIO_IOCXINVAL:
+		if(copy_from_user((void *)&c, argp, sizeof(struct invalue_cmd)))
+			return -EFAULT;
+		c.invalue.value = gpio_get_val(c.invalue.port, c.invalue.pin);
+		if(copy_to_user(argp, (void *)&c, sizeof(struct invalue_cmd)))
+			return -EFAULT;
+		retval = 0;
+		break;
+
+		case GPIO_IOCSFUNC:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = gpio_set_fn(c.func.port, c.func.pin, c.func.func);
+		if(retval)
+			retval = -EFAULT;
+		retval = 0;
+		break;
+
+		case GPIO_IOCXFUNC:
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = gpio_get_fn(c.func.port, c.func.pin);
+		if(retval < 0)
+			return -EFAULT;
+		c.func.func = retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = 0;
+		break;
+
+		case GPIO_IOCSDRIVE:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		gpio_set_cur(c.func.port, c.func.pin, c.func.func);
+		retval = 0;
+		break;
+
+		case GPIO_IOCXDRIVE:
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = gpio_get_cur(c.func.port, c.func.pin);
+		if(retval < 0)
+			return -EFAULT;
+		c.func.func = retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = 0;
+		break;
+
+		case GPIO_IOCSPULLUP:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		gpio_set_pu(c.func.port, c.func.pin, c.func.func);
+		retval = 0;
+		break;
+
+		case GPIO_IOCXPULLUP:
+		if(copy_from_user((void *)&c, argp, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = gpio_get_pu(c.func.port, c.func.pin);
+		if(retval < 0)
+			return -EFAULT;
+		c.func.func = retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct func_cmd)))
+			return -EFAULT;
+		retval = 0;
+		break;
+
+		default: /* unknown command */
+		return -ENOTTY;
+	}
+	return retval;
+}
+
+struct file_operations gpio_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = gpio_ioctl,
+};
+
+/*************************
+ * interrupt hanlding    *
+ *************************/
+static irqreturn_t gpio_irq(int irq, void *dev_id)
+{
+	enum gpio_pin pin;
+	enum gpio_port port;
+	unsigned int pins;
+	irqreturn_t ret = IRQ_NONE;
+	unsigned long flags;
+	struct gpio_handler *gh;
+
+	/* Scan through all of the pins.  When you find the source, invoke the
+	 * handler.  Return after handling one interrupt.  If others are
+	 * pending, we'll be invoked again. 
+	 */
+	for( port = GPIO_PORT_A; port <= GPIO_PORT_C; port++) {
+		pins = gpio_get_pend32(port);
+		for( pin = GPIO_PIN0; pin <= GPIO_PIN31; pin++) {
+			if(!gpio_get_int(port, pin))
+				continue;
+			if(pins & (0x1<<pin)) {
+				spin_lock_irqsave(&gpio_handlers_lock, flags);
+				gh = &gpio_handlers[port][pin];
+				if(!gh->handler.handler) {
+					/* Avoid spurious interrupts */
+					gpio_clear_pend(port, pin);
+					ret = IRQ_HANDLED;
+				} else if(gh->mode_gpio) {
+					ret = gh->handler.gpio_handler(port, 
+								 pin, 
+								 gh->priv);
+				} else {
+					ret = gh->handler.normal_handler(irq, 
+								   gh->priv);
+				}
+				spin_unlock_irqrestore(&gpio_handlers_lock,
+						       flags);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+/*************************
+ * device initialization *
+ *************************/
+
+static int lf1000_alvgpio_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	sysfs_remove_group(&pdev->dev.kobj, &alive_attr_group);
+
+	if(gpio.amem != NULL) {
+		iounmap(gpio.amem);
+		release_mem_region(res->start, (res->end - res->start) + 1);
+	}
+	return 0;
+}
+
+static int lf1000_gpio_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+
+#ifdef CONFIG_LF1000_STRESS_TEST
+	sysfs_remove_group(&pdev->dev.kobj, &stress_attr_group);
+#endif
+
+	sysfs_remove_group(&pdev->dev.kobj, &gpio_attr_group);
+
+	if(gpio.irq != -1) {
+		free_irq(gpio.irq, NULL);
+		gpio.irq = -1;
+	}
+
+	cdev_del(&gpio.cdev);
+
+	if(gpio.mem_cur != NULL) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		iounmap(gpio.mem_cur);
+		release_mem_region(res->start, (res->end - res->start) + 1);
+	}
+
+	if(gpio.mem != NULL) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		iounmap(gpio.mem);
+		release_mem_region(res->start, (res->end - res->start) + 1);
+	}
+
+	return 0;
+}
+
+
+static int lf1000_gpio_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	struct resource *res_cur;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk(KERN_ERR "gpio: failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1, 
+			"lf1000_gpio")) {
+		printk(KERN_ERR "gpio: failed to get region\n");
+		return -EBUSY;
+	}
+
+	gpio.mem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(gpio.mem == NULL) {
+		printk(KERN_ERR "gpio: failed to remap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	res_cur = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if(!res_cur) {
+		printk(KERN_ERR "gpio: failed to get resource\n");
+		ret = -ENXIO;
+		goto fail_remap;
+	}
+
+	if(!request_mem_region(res_cur->start,
+			       (res_cur->end - res_cur->start) + 1, 
+			       "lf1000_gpio_cur")) {
+		printk(KERN_ERR "gpio: failed to get region\n");
+		ret = -EBUSY;
+		goto fail_remap;
+	}
+
+	gpio.mem_cur = ioremap_nocache(res_cur->start,
+				       (res_cur->end - res_cur->start) + 1);
+	if(gpio.mem_cur == NULL) {
+		printk(KERN_ERR "gpio: failed to remap\n");
+		ret = -ENOMEM;
+		goto fail_remap_cur;
+	}
+
+	/* turn off GPIO interrupts */
+	gpio_set_int32(GPIO_PORT_A, 0);
+	gpio_set_int32(GPIO_PORT_B, 0);
+	gpio_set_int32(GPIO_PORT_C, 0);
+
+	gpio.devnum = MKDEV(GPIO_MAJOR, 0);
+	cdev_init(&gpio.cdev, &gpio_fops);
+	gpio.cdev.owner = THIS_MODULE;
+	gpio.cdev.ops = &gpio_fops;
+	ret = cdev_add(&gpio.cdev, gpio.devnum, 1);
+	if(ret) {
+		printk(KERN_ALERT "gpio: failed to get a device\n");
+		goto fail_dev;
+	}
+
+	gpio.irq = platform_get_irq(pdev, 0);
+	if(gpio.irq < 0) {
+		printk(KERN_INFO "gpio: failed to get IRQ\n");
+		ret = gpio.irq;
+		goto fail_irq;
+	}
+	ret = request_irq(gpio.irq, gpio_irq, IRQF_DISABLED,
+			"gpio", NULL);
+	if(ret) {
+		printk(KERN_ERR "gpio: requesting IRQ failed\n");
+		goto fail_irq;
+	}
+
+	/* put board ID in flight recorder */
+	printk(KERN_INFO "Reading Board ID =  0x%2.2x\n", gpio_get_board_config());
+	
+	sysfs_create_group(&pdev->dev.kobj, &gpio_attr_group);
+
+#ifdef CONFIG_LF1000_STRESS_TEST
+	sysfs_create_group(&pdev->dev.kobj, &stress_attr_group);
+#endif
+
+	return 0;
+
+fail_irq:
+	cdev_del(&gpio.cdev);
+fail_dev:
+	iounmap(gpio.mem);
+
+fail_remap_cur:
+	release_mem_region(res_cur->start, (res_cur->end - res_cur->start) + 1);
+
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	
+	return ret;
+}
+
+static int lf1000_alvgpio_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk(KERN_ERR "alvgpio: failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1, 
+			"Alive GPIO")) {
+		printk(KERN_ERR "alvgpio: failed to get region\n");
+		return -EBUSY;
+	}
+	gpio.amem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(!gpio.amem) {
+		printk(KERN_ERR "alvgpio: failed to remap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	/*
+	 * When ALIVEPWRGATEREG is 1, software can write ALV bits.  Otherwise,
+	 * last written values are held in flip flops.  This should be power
+	 * down/up function of gpio driver, transparent to the user of this API.
+	 * Perhaps in suspend/resume?
+	 */
+
+	/* init ALIVE S/R input registers to reset value */
+	writel(1 << NPOWERGATING, gpio.amem + ALIVEPWRGATEREG);
+	writel(0, gpio.amem + ALIVEGPIOSETREG);
+	writel(0, gpio.amem + ALIVEGPIORSTREG);
+	writel(0 << NPOWERGATING, gpio.amem + ALIVEPWRGATEREG);
+	
+	/* clear out all handlers */
+	memset(gpio_handlers, 0,
+	       sizeof(struct gpio_handler)*(GPIO_PORT_ALV+1)*(GPIO_PIN31+1));
+
+	sysfs_create_group(&pdev->dev.kobj, &alive_attr_group);
+	return 0;
+
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_gpio_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int lf1000_gpio_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int lf1000_alvgpio_suspend(struct platform_device *pdev, 
+				  pm_message_t mesg)
+{
+	return 0;
+}
+
+static int lf1000_alvgpio_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lf1000_gpio_suspend	NULL
+#define lf1000_gpio_resume	NULL
+#define lf1000_alvgpio_suspend	NULL
+#define lf1000_alvgpio_resume	NULL
+#endif
+
+static struct platform_driver lf1000_gpio_driver = {
+	.probe      = lf1000_gpio_probe,
+	.remove     = lf1000_gpio_remove,
+	.suspend    = lf1000_gpio_suspend,
+	.resume     = lf1000_gpio_resume,
+	.driver     = {
+		.name   = "lf1000-gpio",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static struct platform_driver lf1000_alvgpio_driver = {
+	.probe      = lf1000_alvgpio_probe,
+	.remove     = lf1000_alvgpio_remove,
+	.suspend    = lf1000_alvgpio_suspend,
+	.resume     = lf1000_alvgpio_resume,
+	.driver     = {
+		.name   = "lf1000-alvgpio",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init gpio_init(void)
+{
+	int ret = platform_driver_register(&lf1000_alvgpio_driver);
+	if(ret != 0)
+		return ret;
+	return platform_driver_register(&lf1000_gpio_driver);
+}
+
+static void __exit gpio_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_gpio_driver);
+	platform_driver_unregister(&lf1000_alvgpio_driver);
+}
+
+module_init(gpio_init);
+module_exit(gpio_cleanup);
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_VERSION("1:2.0");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/adc.h linux-2.6/arch/arm/mach-lf1000/include/mach/adc.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/adc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/adc.h	2011-02-01 18:00:41.000000000 -0800
@@ -0,0 +1,59 @@
+/* LF1000 Analog to Digital Converter (ADC) Driver
+ *
+ * mach-lf1000/include/mach/adc.h -- ADC settings and hardware abstrcation.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef LF1000_ADC_H
+#define LF1000_ADC_H
+
+/*
+ * Multiplexor Settings
+ */
+	#define LF1000_ADC_VBATSENSE	2
+	#define LF1000_ADC_LEDVSENSE	0
+	#define LF1000_ADC_VOLUMESENSE	1
+	#define LF1000_ADC_BATT_TEMP	3
+	#define LF1000_ADC_MAX_CHANNEL	7
+
+/*
+ * ADC Registers (offsets from LF1000_ADC_BASE) 
+ */
+#define ADCCON			0x00
+#define ADCDAT			0x04
+#define ADCINTENB		0x08
+#define ADCINTCLR		0x0C
+#define ADCCLKENB		0x40
+
+/* ADC control register (ADCCON) */
+#define APEN			14
+#define APSV			6
+#define ASEL			3
+#define STBY			2
+#define ADEN			0
+
+/*
+ * model ADC as a line:
+ * milliVolts = ((ADC_SLOPE * 256) * READING) / 256 + ADC_CONSTANT
+ */
+
+#define ADC_SLOPE_256_ME_LF1000 2322    /* ADC slope * 256              */
+#define ADC_CONSTANT_ME_LF1000  1267    /* ADC constant                 */
+#define ADC_SLOPE_256_LF_LF1000 2012    /* ADC slope * 256              */
+#define ADC_CONSTANT_LF_LF1000     0    /* ADC constant                 */
+
+/* ADC-to-millivolts, as per above */
+#if defined (CONFIG_MACH_ME_LF1000)
+#define ADC_TO_MV(r)    (((ADC_SLOPE_256_ME_LF1000*r)/256)+ADC_CONSTANT_ME_LF1000)
+#elif defined (CONFIG_MACH_LF_LF1000)
+#define ADC_TO_MV(r)    (((ADC_SLOPE_256_LF_LF1000*r)/256)+ADC_CONSTANT_LF_LF1000)
+#else /* undefined */
+#error NO Platform Selected
+#endif
+
+/*
+ * Driver API
+ */
+int adc_GetReading(u8 channel);
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/clkpwr.h linux-2.6/arch/arm/mach-lf1000/include/mach/clkpwr.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/clkpwr.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/clkpwr.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,65 @@
+/* mach-lf1000/include/mach/clkpwr.h -- LF1000 Clock & Power Management Hardware 
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ */
+
+#ifndef _LF1000_CLKPWR
+#define _LF1000_CLKPWR
+
+#include <mach/platform.h> /* for CPU variant */
+
+#define NUM_PLLS	2
+
+/* Clock and Power Control Registers (offsets from LF1000_CLKPWR_BASE) */
+#define CLKMODEREG		0x000
+#define PLLSETREG0		0x004
+#define PLLSETREG1		0x008
+#define GPIOWAKEUPENB		0x040
+#define RTCWAKEUPENB		0x044
+#define GPIOWAKEUPRISEENB	0x048
+#define GPIOWAKEUPFALLENB	0x04C
+#define GPIOPEND		0x050
+#define INTPENDSPAD		0x058
+#define PWRRSTSTATUS		0x05C
+#define INTENB			0x060
+#define PWRMODE			0x07C
+#define PADSTRENGTHGPIOAL	0x100
+#define PADSTRENGTHGPIOAH	0x104
+#define PADSTRENGTHGPIOBL	0x108
+#define PADSTRENGTHGPIOBH	0x10C
+#define PADSTRENGTHGPIOCL	0x110
+#define PADSTRENGTHGPIOCH	0x114
+#define PADSTRENGTHBUS		0x118
+
+/* Clock Mode Register (CLKMODEREG) */
+#define PLLPWDN1	30
+#define CLKSELBCLK	24
+#define CLKDIV1BCLK	20
+#define CLKDIV2CPU0	6
+#define CLKSELCPU0	4
+#define CLKDIVCPU0	0
+
+/* PLL0 Setting Register (PLLSETREG0) */
+#define PDIV_0		18
+#define MDIV_0		8
+#define SDIV_0		0
+
+/* PLL1 Setting Register (PLLSETREG1) */
+#define PDIV_1		18
+#define MDIV_1		8
+#define SDIV_1		0
+
+/* Power Mode Control Register (PWRMODE) */
+#define CHGPLL		15
+#define GPIOSWRSTENB	13
+#define SWRST		12
+#define LASTPWRMODE	4
+#define CURPWRMODE	0
+
+/* Interrupt Pending & Scratch Pad Register (INTPENDSPAD) */
+#define BATFW		14
+#define GPIORESETW	13
+#define WATCHDOGRSTW	12
+#define POWERONRSTW	11
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/clock.h linux-2.6/arch/arm/mach-lf1000/include/mach/clock.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/clock.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/clock.h	2011-01-04 15:00:24.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ *  mach-lf1000/include/mach/clock.h
+ *
+ *      Copyright (C) 2007 Kosta Demirev <kdemirev@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef CLK_LF1000_H
+#define CLK_LF1000_H
+
+struct module;
+struct lf1000_params;
+
+struct clk {
+	struct list_head		node;
+	unsigned long			rate;
+	unsigned long			number;
+	struct module			*owner;
+	const char			*name;
+	const struct lf1000_params	*params;
+	void				*data;
+	void				(*setvco)(struct clk *);
+};
+
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+int lf1000_clock_dev_init(void);
+void lf1000_clock_dev_exit(void);
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/common.h linux-2.6/arch/arm/mach-lf1000/include/mach/common.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/common.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/common.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,39 @@
+/* Common helper macros for the drivers.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef LF1000_COMMON_H
+#define LF1000_COMMON_H
+
+/* bit masking */
+#define BIT_SET(v,b)	(v |= (1<<(b)))
+#define BIT_CLR(v,b)	(v &= ~(1<<(b)))
+#define IS_SET(v,b)	(v & (1<<(b)))
+#define IS_CLR(v,b)	!(v & (1<<(b)))
+#define BIT_MASK_ONES(b) ((1<<(b))-1)
+
+/*
+ * make sure bootloaders have basic kernel-style types
+ */
+#ifndef u8
+#define u8	unsigned char
+#endif
+#ifndef u16
+#define u16     unsigned short
+#endif
+#ifndef u32
+#define u32     unsigned int
+#endif
+
+#ifndef NULL
+#define NULL	0
+#endif
+
+/* 
+ * register helpers for bootloaders and the like
+ */
+#define REG8(addr)  *((volatile u8 *)(addr))
+#define REG16(addr) *((volatile u16 *)(addr))
+#define REG32(addr) *((volatile u32 *)(addr))
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/core.h linux-2.6/arch/arm/mach-lf1000/include/mach/core.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/core.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/core.h	2011-01-04 15:14:35.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ *  mach-lf1000/include/mach/core.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_LF1000_H
+#define __ASM_ARCH_LF1000_H
+
+extern void __init lf1000_init(void);
+extern void __init lf1000_map_io(void);
+extern struct sys_timer lf1000_timer;
+
+void lf1000_pll1_clock_changed(void);
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/debug-lf1000.S linux-2.6/arch/arm/mach-lf1000/include/mach/debug-lf1000.S
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/debug-lf1000.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/debug-lf1000.S	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,28 @@
+/*
+ * mach-lf1000/include/mach/debug-lf1000.S
+ *
+ *  Copyright (C) 1994-1999 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <mach/uart.h>
+
+	.macro  senduart,rd,rx
+	strb    \rd, [\rx, #THB]		@ Write Transmitter Holding Register
+	.endm
+
+        .macro  busyuart,rd,rx
+1001:   ldr	\rd, [\rx, #TRSTATUS]		@ get TRANSMIT STATUS reg
+        tst     \rd, #(1<<TRANSMITTER_EMPTY)	@ = 1 when tx complete
+        beq	1001b
+        .endm
+
+	.macro  waituart,rd,rx
+#ifdef FLOW_CONTROL
+1001:	ldr     \rd, [\rx, #FSTATUS]		@ Read Status Register
+        tst     \rd, #(1<<TX_FIFO_FULL)		@ TX_FIFO_FULL = 1 when ready to transmit
+        beq     1001b
+#endif
+        .endm
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/debug-macro.S linux-2.6/arch/arm/mach-lf1000/include/mach/debug-macro.S
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/debug-macro.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/debug-macro.S	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,35 @@
+/* mach-lf1000/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include	<mach/platform.h>
+#include	<mach/uart.h>
+
+	.macro  addruart,rx
+	mrc     p15, 0, \rx, c1, c0
+	tst     \rx, #1				@ MMU enabled?
+	ldreq   \rx, =LF1000_UART0_BASE		@ System peripherals (phys address)
+	ldrne   \rx, =IO_ADDRESS(LF1000_UART0_BASE) @ System peripherals (virt address)
+	.endm
+
+	.macro  senduart,rd,rx
+	strb    \rd, [\rx, #THB]		@ Write Transmitter Holding Register
+	.endm
+
+        .macro  busyuart,rd,rx
+1001:   ldr	\rd, [\rx, #TRSTATUS]		@ get TRANSMIT STATUS reg
+        tst     \rd, #(1<<TRANSMITTER_EMPTY)	@ = 1 when tx complete
+        beq	1001b
+        .endm
+
+	.macro  waituart,rd,rx
+1001:   ldr	\rd, [\rx, #TRSTATUS]		@ get TRANSMIT STATUS reg
+        tst     \rd, #(1<<TRANSMITTER_EMPTY)	@ = 1 when tx complete
+        beq	1001b
+        .endm
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/development.h linux-2.6/arch/arm/mach-lf1000/include/mach/development.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/development.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/development.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,68 @@
+/*
+ * mach-lf1000/include/mach/development.h
+ */
+#ifndef	_DEVELOPMENT_H
+#define	_DEVELOPMENT_H
+#include <mach/uart.h>
+
+#define	VIRT
+
+#ifdef	VIRT
+#define DBG_LF1000_UART_FCR	((( struct lf1000_uart*)IO_ADDRESS( LF1000_SYS_UART_BASE))->fcon)
+#define DBG_LF1000_UART_SR	((( struct lf1000_uart*)IO_ADDRESS( LF1000_SYS_UART_BASE))->trstatus)
+#define DBG_LF1000_UART_FR	((( struct lf1000_uart*)IO_ADDRESS( LF1000_SYS_UART_BASE))->fstatus)
+#define DBG_LF1000_UART_TR	((( struct lf1000_uart*)IO_ADDRESS( LF1000_SYS_UART_BASE))->thb)
+#else
+#define	DBG_LF1000_UART_FCR	(*(unsigned short*)LF1000_UART_FCR)
+#define	DBG_LF1000_UART_FR	(*(unsigned short*)LF1000_UART_FR )
+#define	DBG_LF1000_UART_SR	(*(unsigned short*)LF1000_UART_SR )
+#define	DBG_LF1000_UART_TR	(*(unsigned short*)LF1000_UART_TR )
+#endif
+
+static inline void flush(void)
+{
+    if( DBG_LF1000_UART_FCR & 0x01) {	// if   FIFO  enabled
+	while (  DBG_LF1000_UART_FR & 0x0200 ) barrier();
+    } else {				// else FIFO disabled
+	while (!(DBG_LF1000_UART_SR & 0x0002)) barrier();
+    }
+}
+
+static inline void putc(int c)
+{
+    flush();
+    DBG_LF1000_UART_TR = c;
+    if( c == '\n') {
+	flush();
+	DBG_LF1000_UART_TR = '\r';
+    }
+}
+
+static inline void putstr(const char *ptr)
+{
+	char c;
+
+	while ((c = *ptr++) != '\0') {
+		if (c == '\n')
+			putc('\r');
+		putc(c);
+	}
+
+	flush();
+}
+
+static inline void puth( unsigned long val)
+{
+int i;
+char hex[] = {	'0', '1', '2', '3', '4', '5', '6', '7',
+		'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
+    putc('0');
+    putc('x');
+
+    for( i=0; i<8; i++) {
+	putc( hex[ (val>>((7-i)*4))&0x0f]);
+    }
+}
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/dma.h linux-2.6/arch/arm/mach-lf1000/include/mach/dma.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/dma.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/dma.h	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,115 @@
+/*
+ * LF1000 DMA Engine support
+ * adapted from Corelogic CLX7000 DMA Engine support
+ *
+ * Copyright (C) 2009 Corelogic, Inc. All rights reserved.
+ *
+ * Author:
+ *   Scott Esters <sesters@leapfrog.com>
+ *
+ * Description:
+ *   DMA engine driver for LF1000 DMA controller
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __ASM_MACH_DMA_H
+#define __ASM_MACH_DMA_H
+
+/* DMA operation mode (for circular DMA) */
+enum dma_mem_io {
+	DMA_MEM_IO		= 0x00,	// Data I/O with DMA API
+	DMA_MEM_MAPPED		= 0x01, // DMA Buffer is mapped and direct access
+};
+
+/* DMA Channel  */
+enum dma_priority {
+	DMA_PRIORITY_LV0	= 0x01,
+	DMA_PRIORITY_LV1	= 0x02,
+	DMA_PRIORITY_LV2	= 0x04,
+	DMA_PRIORITY_LV3	= 0x08,
+	DMA_PRIORITY_ANY	= 0x0F,
+};
+
+/* interrupt type */
+enum dma_interrupt_type {
+	DMA_INT_DISABLE		= 0,
+	DMA_INT_BLOCK		= 1,
+	DMA_INT_EVERY_BLOCK	= 2,
+	DMA_INT_LAST_BLOCK	= 3,
+};
+
+enum dma_transfer_type {
+	DMA_MEM_TO_MEM		= 0,
+	DMA_MEM_TO_IO		= 1,
+	DMA_IO_TO_MEM		= 2,
+};
+
+enum dma_request_id {
+	DMA_PERI_UART0TX	= 0,
+	DMA_PERI_UART0RX	= 1,
+	DMA_PERI_UART1TX	= 2,
+	DMA_PERI_UART1RX	= 3,
+	DMA_PERI_UART2TX	= 4,
+	DMA_PERI_UART2RX	= 5,
+	DMA_PERI_UART3TX	= 6,
+	DMA_PERI_UART3RX	= 7,
+
+	DMA_PERI_USBEP1		= 12,
+	DMA_PERI_USBEP2		= 13,
+
+	DMA_PERI_SD0RW		= 16,
+
+	DMA_PERI_SPI0TX		= 18,
+	DMA_PERI_SPI0RX		= 19,
+	DMA_PERI_SPI1TX		= 20,
+	DMA_PERI_SPI1RX		= 21,
+	DMA_PERI_SPI2TX		= 22,
+	DMA_PERI_SPI2RX		= 23,
+	DMA_PERI_PCMOUT		= 24,
+
+	DMA_PERI_PCMIN		= 26,
+
+	DMA_PERI_SD1RW		= 30,
+};
+
+struct dma_control {
+	enum dma_transfer_type	transfer;
+	enum dma_interrupt_type	interrupt;
+	enum dma_request_id	request_id;
+	unsigned int		io_addr_inc;	// 1: inc, 0:not inc
+	unsigned int		src_width;	// 1, 2, 4 bytes
+	unsigned int		dest_width;	// 1, 2, 4 bytes
+};
+
+unsigned int dma_get_base_address(int channel);
+int dma_request (char *name, enum dma_priority priority, irq_handler_t handler,
+	void *objdata, unsigned int *ch);
+int dma_release(unsigned int ch);
+int dma_start(unsigned int ch);
+int dma_stop(unsigned int ch);
+int dma_reset(unsigned int ch);
+int dma_is_active(unsigned int ch);
+int dma_is_enabled(unsigned int ch);
+unsigned int dma_get_write_addr(unsigned int ch);
+unsigned int dma_get_read_addr(unsigned int ch);
+
+int dma_transfer_init(unsigned int ch, enum dma_mem_io mem_mode);
+int dma_transfer_insert(unsigned int ch, unsigned int src, unsigned int dest,
+	unsigned int size, struct dma_control *ctrl);
+
+int dma_sg_write(unsigned int ch, struct scatterlist *sg, unsigned int dest,
+	int count, struct dma_control *ctrl);
+int dma_sg_read(unsigned int ch, unsigned int src, struct scatterlist *sg,
+	int count, struct dma_control *ctrl);
+
+int dma_circ_write(unsigned int ch, unsigned int *src_list, unsigned int dest,
+	int count, unsigned int block_size, struct dma_control *ctrl);
+int dma_circ_read(unsigned int ch, unsigned int src, unsigned int *dest_list,
+	int count, unsigned int block_size, struct dma_control *ctrl);
+
+#endif
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/entry-macro.S linux-2.6/arch/arm/mach-lf1000/include/mach/entry-macro.S
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/entry-macro.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/entry-macro.S	2011-01-04 15:11:15.000000000 -0800
@@ -0,0 +1,47 @@
+/*
+ * arch/arm/mach-lf1000/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for LF1000 platforms
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <mach/hardware.h>
+#include <asm/hardware/vic.h>
+#include <mach/ic.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =IO_ADDRESS(LF1000_IC_BASE)
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqpend, base, tmp
+
+		mov	\irqnr, #0x0
+		ldr	\irqpend, [\base, #INTPENDL]	@ get masked status
+		cmp	\irqpend, #0x0
+		bne	1001f				@ low irq pending, calc irq number
+
+		ldr	\irqpend, [\base, #INTPENDH]	@ check if high irq pending
+		cmp	\irqpend, #0x0
+		beq	1003f				@ oops, there is no irq pending.
+		movne	\irqnr, #32
+
+1001:		/* get irq number */
+		and	\tmp, \irqpend, #0x1
+		cmp	\tmp, #0x1
+		addne	\irqnr, \irqnr, #1
+		movne	\irqpend, \irqpend, LSR #1
+		bne	1001b
+
+1003:
+		cmp 	\irqpend, #0x0
+		.endm
+
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio.h linux-2.6/arch/arm/mach-lf1000/include/mach/gpio.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/gpio.h	2012-11-14 10:00:32.000000000 -0800
@@ -0,0 +1,398 @@
+/* mach-lf1000/include/mach/gpio.h -- General-Purpose IO (GPIO) API
+ *
+ * gpio.h -- GPIO control.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Brian Cavagnolo <brian@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef LF1000_GPIO_H
+#define LF1000_GPIO_H
+
+#define GPIO_NUM_PORTS 3
+enum gpio_port {
+	GPIO_PORT_A	= 0x0,
+	GPIO_PORT_B,
+	GPIO_PORT_C,
+	GPIO_PORT_ALV,
+};
+
+/*
+ * Pins for Board Configuration resistors.  These will be configured as input
+ * pins and read to generate a board ID when gpio_get_board_config() is called.
+ */
+#define GPIO_CFG_PORT	GPIO_PORT_B
+#define GPIO_CFG_LOW	27
+#define GPIO_CFG_HIGH	31
+
+/*
+ * Pins for Cart Configuration resistors.  These will be configured as input
+ * pins and read to generate a cart ID when gpio_get_cart_config() is called.
+ */
+#define GPIO_CART_CFG_PORT	GPIO_PORT_B
+#define GPIO_CART_CFG_LOW	2
+#define GPIO_CART_CFG_HIGH	5
+
+/* Each pin can take one of three different functions */
+enum gpio_function {
+	GPIO_GPIOFN	= 0,
+	GPIO_ALT1,
+	GPIO_ALT2,
+	GPIO_RESERVED,
+};
+
+/* Each port has 32 pins */
+enum gpio_pin {
+	GPIO_PIN0 = 0, GPIO_PIN1, GPIO_PIN2, GPIO_PIN3, GPIO_PIN4, GPIO_PIN5,
+	GPIO_PIN6, GPIO_PIN7, GPIO_PIN8, GPIO_PIN9, GPIO_PIN10, GPIO_PIN11,
+	GPIO_PIN12, GPIO_PIN13, GPIO_PIN14, GPIO_PIN15, GPIO_PIN16, GPIO_PIN17,
+	GPIO_PIN18, GPIO_PIN19, GPIO_PIN20, GPIO_PIN21, GPIO_PIN22, GPIO_PIN23,
+	GPIO_PIN24, GPIO_PIN25, GPIO_PIN26, GPIO_PIN27, GPIO_PIN28, GPIO_PIN29,
+	GPIO_PIN30, GPIO_PIN31,
+};
+
+/* Each pin can interrupt on one of four different events */
+enum gpio_interrupt_mode {
+	GPIO_IMODE_LOW_LEVEL		= 0x0,
+	GPIO_IMODE_HIGH_LEVEL		= 0x1,
+	GPIO_IMODE_FALLING_EDGE		= 0x2,
+	GPIO_IMODE_RISING_EDGE		= 0x3,
+};
+
+/* Each pin can drive with configurable current */
+enum gpio_current {
+	GPIO_CURRENT_2MA		= 0x0,
+	GPIO_CURRENT_4MA		= 0x1,
+	GPIO_CURRENT_6MA		= 0x2,
+	GPIO_CURRENT_8MA		= 0x3,
+};
+
+/* virtual name for each gpio port/pin function */
+enum gpio_resource {
+	HEADPHONE_JACK			= 0,
+	LED_ENA				= 1,
+	LCD_RESET			= 2,
+	AUDIO_POWER			= 3,
+	DPAD_UP				= 4,
+	DPAD_DOWN			= 5,
+	DPAD_RIGHT			= 6,
+	DPAD_LEFT			= 7,
+	BUTTON_A			= 8,
+	BUTTON_B			= 9,
+	SHOULDER_LEFT			= 10,
+	SHOULDER_RIGHT			= 11,
+	BUTTON_HOME			= 12,
+	BUTTON_HINT			= 13,
+	BUTTON_PAUSE			= 14,
+	BUTTON_BRIGHTNESS		= 15,
+	CARTRIDGE_DETECT		= 16,
+	TOUCHSCREEN_X1			= 17,
+	TOUCHSCREEN_Y1			= 18,
+	TOUCHSCREEN_X2			= 19,
+	TOUCHSCREEN_Y2			= 20,
+	EXT_POWER			= 21,
+	DOCK_POWER			= 22,
+	BATTERY_PACK			= 23,
+	SD1_POWER			= 24,
+	LFP100_INT			= 25,
+	GPIO_NUMBER_VALUES		= 26,
+};
+
+/*
+ * Scratchpad Register usage
+ */
+
+#define SCRATCH_POWER_POS          0
+#define SCRATCH_POWER_SIZE         2
+
+#define SCRATCH_SHUTDOWN_POS       2
+#define SCRATCH_SHUTDOWN_SIZE      1
+
+#define SCRATCH_REQUEST_POS 	   3
+#define SCRATCH_REQUEST_SIZE  	   3
+
+#define SCRATCH_BOOT_IMAGE_POS     6
+#define SCRATCH_BOOT_IMAGE_SIZE    2
+
+#define SCRATCH_BOARD_ID_POS       8
+#define SCRATCH_BOARD_ID_SIZE      5
+
+#define SCRATCH_CART_ID_POS       13
+#define SCRATCH_CART_ID_SIZE       4
+
+#define SCRATCH_BOOT_SOURCE_POS   17
+#define SCRATCH_BOOT_SOURCE_SIZE   3
+
+#define SCRATCH_PANIC_POS	  20
+#define SCRATCH_PANIC_SIZE         2
+
+#define SCRATCH_USER_0_POS        22
+#define SCRATCH_USER_0_SIZE       (32-SCRATCH_USER_0_POS)
+
+/*
+ * SCRATCHPAD Enums
+ * Note that scratchpad register is cleared to zero on first power up
+ */
+
+/* Track power state */
+enum scratch_power {                 // set by bootstrap, read by others
+        SCRATCH_POWER_FIRSTBOOT = 0, // only seen in bootstrap
+        SCRATCH_POWER_COLDBOOT  = 1, // batteries replaced
+        SCRATCH_POWER_WARMBOOT  = 2, // second and subsequent boots
+};
+
+/* Shutdown semaphore.  Set by Linux shutdown to signal clean system shutdown */
+enum scratch_shutdown {
+        SCRATCH_SHUTDOWN_CLEAN = 0,  // set by Linux at clean shutdown
+        SCRATCH_SHUTDOWN_DIRTY = 1,  // cleared by bootstrap at boot
+};
+
+/* Choose boot partition.  Used by REQUEST_BOOT and ACTUAL_BOOT bits to
+ * indicate the preferred boot partition and the partition booted
+ */
+enum scratch_boot_image {
+        SCRATCH_BOOT_IMAGE_RECOVERY = 0,   // boot recovery image
+        SCRATCH_BOOT_IMAGE_PLAY     = 1,   // normal boot
+        SCRATCH_BOOT_IMAGE_2        = 2,   // unused
+        SCRATCH_BOOT_IMAGE_3        = 3,   // unused
+};
+
+/* Choose boot partition.  Used by REQUEST_BOOT and ACTUAL_BOOT bits to
+ * indicate the preferred boot partition and the partition booted
+ */
+enum scratch_boot_source {
+        SCRATCH_BOOT_SOURCE_UNKNOWN = 0,   // 
+        SCRATCH_BOOT_SOURCE_NOR     = 1,   // 
+        SCRATCH_BOOT_SOURCE_NAND    = 2,   // 
+        SCRATCH_BOOT_SOURCE_UART    = 3,   // 
+        SCRATCH_BOOT_SOURCE_USB     = 4,   // 
+};
+
+/* save boot source. */
+enum scratch_request {
+	SCRATCH_REQUEST_PLAY    = 0,  // Launch Play if possible
+	SCRATCH_REQUEST_RETURN  = 1,  // Return to Play if possible
+	SCRATCH_REQUEST_UPDATE  = 2,  // Enter recovery in update mode
+	SCRATCH_REQUEST_BATTERY = 3,  // Enter play: battery failed
+	SCRATCH_REQUEST_UNCLEAN = 4,  // Enter play: dirty shutdown
+	SCRATCH_REQUEST_FAILED  = 5,  // Enter recovery in update mode: boot failed
+	SCRATCH_REQUEST_SHORT   = 6,  // Enter play in short-circuit mode
+	SCRATCH_REQUEST_TRAPDOOR= 7,  // Enter recovery in trapdoor mode
+};
+
+// Priority: _TRAPDOOR, _SHORT, _FAILED, _UNCLEAN, _BATTERY, _UPDATE, _RETURN, _PLAY
+
+/* Configure a GPIO pin */
+
+void gpio_configure_pin(enum gpio_port port, enum gpio_pin pin,
+		enum gpio_function f, unsigned char out_en,
+		unsigned char pu_en, unsigned char val);
+
+/* Set the pin function. */
+int gpio_set_fn(enum gpio_port port, enum gpio_pin pin,
+		 enum gpio_function f);
+
+/* get the input value of the pin */
+int gpio_get_val(enum gpio_port port, enum gpio_pin pin);
+
+/* get the pullup resistor setting */
+int gpio_get_pu(enum gpio_port port, enum gpio_pin pin);
+
+#include <linux/interrupt.h>
+
+/* Interrupt handler type for gpio interrupts.  Both the gpio_port and gpio_pin
+ * are passed to the handler when the interrupt occurs.  The handler is
+ * expected, at minimum, to handle the interrupt, clear the interrupt pending
+ * bit, and return IRQ_HANDLED.  Drivers who handle multiple gpio pins are
+ * permitted to inspect the gpio registers freely and handle any simultaneous
+ * interrupts.  priv is passed to handler when an interrupt occurs.  It is
+ * opaque to the gpio system.
+ */
+typedef irqreturn_t (*gpio_irq_handler_t)(enum gpio_port, enum gpio_pin,
+					  void *);
+
+/* Get the pin function */
+int gpio_get_fn(enum gpio_port port, enum gpio_pin pin);
+
+/* set or clear output enable.  Clearing output enable means this pin is an
+ * input.
+ */
+int gpio_set_out_en(enum gpio_port port, enum gpio_pin pin, unsigned char en);
+
+/* Get the output enable setting */
+int gpio_get_out_en(enum gpio_port port, enum gpio_pin);
+
+/* set or clear the pull-up enable */
+void gpio_set_pu(enum gpio_port port, enum gpio_pin pin, unsigned char en);
+
+/* set the output value of the pin */
+int gpio_set_val(enum gpio_port port, enum gpio_pin pin, unsigned char en);
+
+/* request an interrupt handler for a given pin. Returns -EBUSY if that pin
+ * already has a handler.
+ */
+int gpio_request_irq(enum gpio_port port, enum gpio_pin pin,
+		     gpio_irq_handler_t handler, void *priv);
+
+/* request an interrupt handler for a given pin, with a normal irq_handler_t
+ * routine called as a result.  Returns -EBUSY if that pin already has a 
+ * handler. */
+int gpio_request_normal_irq(enum gpio_port port, enum gpio_pin pin,
+		irq_handler_t handler, void *priv);
+
+/* free the irq requested using gpio_request_irq.  To prevent accidental
+ * freeing of somebody else's gpio irq, the handler must match the one that was
+ * passed to gpio_request_irq.
+ */
+void gpio_free_irq(enum gpio_port port, enum gpio_pin pin,
+		   gpio_irq_handler_t handler);
+
+/* get the interrupt mode for a given pin */
+enum gpio_interrupt_mode gpio_get_int_mode(enum gpio_port port,
+					   enum gpio_pin pin);
+
+/* set the interrupt mode for a given pin */
+void gpio_set_int_mode(enum gpio_port port, enum gpio_pin pin,
+		       enum gpio_interrupt_mode mode);
+
+/* toggle the interrupt mode for a pin.  If the mode is currently
+ * IMODE_RISING_EDGE it becmoes IMODE_FALLING_EDGE and vice versa.  If the mode
+ * is IMODE_HIGH_LEVEL it becomes IMODE_LOW_LEVEL
+ */
+void gpio_toggle_int_mode(enum gpio_port port, enum gpio_pin pin);
+
+/* enable or disable interrupt for a given pin */
+void gpio_set_int(enum gpio_port port, enum gpio_pin pin, unsigned char en);
+
+/* get the interrupt enable bit for a given pin */
+unsigned char gpio_get_int(enum gpio_port port, enum gpio_pin pin);
+
+/* get interrupt enable bits for all 32 pins in a given port */
+unsigned long gpio_get_int32(enum gpio_port port);
+
+/* set the interrupt enable bits for all 32 pins in a given port.  Use this
+ * function in conjunction with gpio_get_int32 to enable or disable
+ * interrupts on many pins at a time.
+ */
+void gpio_set_int32(enum gpio_port port, unsigned long en);
+
+/* clear the interrupt pending bit for a given pin */
+void gpio_clear_pend(enum gpio_port port, enum gpio_pin pin);
+
+/* get the interrupt pending bit for a given pin */
+unsigned char gpio_get_pend(enum gpio_port port, enum gpio_pin pin);
+
+/* get the interrupt pending bits for all pins in a given port */
+unsigned long gpio_get_pend32(enum gpio_port port);
+
+/* clear the interrupt pending bits for all pins in a given port.  Use this
+ * function in conjunction with gpio_get_pend32 to clear all pending interrupts
+ * at once.
+ */
+void gpio_clear_pend32(enum gpio_port port, unsigned long flag);
+
+/* get power bits of scratch register */
+u8 gpio_get_power_config(void);
+
+/* get shutdown bits of scratch register */
+enum scratch_shutdown gpio_get_shutdown_config(void);
+
+/* set shutdown bits of scratch register */
+void gpio_set_shutdown_config(enum scratch_shutdown);
+
+/* get requested bits of scratch register */
+enum scratch_request gpio_get_request_config(void);
+
+/* set requested bits of scratch register */
+void gpio_set_request_config(enum scratch_request);
+
+/* get actual boot partition bits of scratch register */
+enum scratch_boot_image gpio_get_boot_image_config(void);
+
+/* set actual boot partition bits of scratch register */
+void gpio_set_boot_image_config(enum scratch_boot_image);
+
+/* get boot mode bits of scratch register */
+enum scratch_boot_source gpio_get_boot_source_config(void);
+
+/* get panic bits of scratch register */
+int gpio_get_panic_config(void);
+
+/* set panic bits of scratch register */
+void gpio_set_panic_config(int);
+
+/* have supercap? 1=yes */
+int gpio_have_supercap(void);
+
+/* have acorn board gpio layout? 1=yes */
+int gpio_have_gpio_acorn(void);
+
+/* have dev board gpio layout? 1=yes */
+int gpio_have_gpio_dev(void);
+
+/* have didj board gpio layout? 1=yes */
+int gpio_have_gpio_didj(void);
+
+/* have emerald board gpio layout? 1=yes */
+int gpio_have_gpio_emerald(void);
+
+/* have k2 board gpio layout? 1=yes */
+int gpio_have_gpio_k2(void);
+
+/* have madrid board gpio layout? 1=yes */
+int gpio_have_gpio_madrid(void);
+
+/* have tvout? 1=yes */
+int gpio_have_tvout(void);
+
+/* does system use up/down volume buttons? 1=yes */
+int gpio_have_volume_buttons(void);
+
+/* does system have a touchscreen? 1=yes */
+int gpio_have_touchscreen(void);
+
+/* read the Board Configuration resistors and return a Board ID.  Calling this
+ * function will cause the Board Configuration pins to be configured as GPIO
+ * input pins. */
+u8 gpio_get_board_config(void);
+
+/* get actual boot partition bits of scratch register */
+u32 gpio_get_user_0_config(void);
+
+/* set actual boot partition bits of scratch register */
+void gpio_set_user_0_config(u32);
+
+/* get gpio pin drive current setting */
+unsigned long gpio_get_cur(enum gpio_port port, enum gpio_pin pin);
+
+/* set the drive current for the gpio pin */
+void gpio_set_cur(enum gpio_port port, enum gpio_pin pin, enum gpio_current cur);
+
+
+/* get Power-down reason from ALIVE power scratch register value */
+unsigned long gpio_get_scratch_power(void);
+
+/* set Power-down reason in ALIVE power scratch register value */
+void gpio_set_scratch_power(unsigned long value);
+
+/* translate GPIO port for different boards */
+int lf1000_l2p_port(enum gpio_resource logical_value);
+
+/* translate GPIO pin for different boards */
+int lf1000_l2p_pin(enum gpio_resource logical_value);
+
+unsigned long gpio_get_scratch(void);
+void gpio_set_scratch(unsigned long value);
+
+#ifdef CONFIG_LF1000_STRESS_TEST
+#define POWER_ERASE     0
+#define POWER_WRITE     1
+#define CART_READ       2
+
+void stress_config_power(void);
+void stress_cut_power(void);
+void stress_cut_cart(int cut);
+#endif /* CONFIG_LF1000_STRESS_TEST */
+
+#endif /* LF1000_GPIO_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_hal.h linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_hal.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_hal.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_hal.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,78 @@
+/* mach-lf1000/include/mach/gpio_hal.h -- LF1000 General-Purpose IO (GPIO) HAL
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Brian Cavagnolo <brian@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef LF1000_GPIO_HAL_H
+#define LF1000_GPIO_HAL_H
+
+#include <mach/platform.h> /* for CPU variant */
+
+/*
+ * GPIO registers (offsets from LF1000_GPIO_BASE)
+ */
+#define GPIOAOUT		0x00
+#define GPIOAOUTENB		0x04
+#define GPIOADETMODE0		0x08
+#define GPIOADETMODE1		0x0C
+#define GPIOAINTENB		0x10
+#define GPIOADET		0x14
+#define GPIOAPAD		0x18
+#define GPIOAPUENB		0x1C
+#define GPIOAALTFN0		0x20
+#define GPIOAALTFN1		0x24
+
+#define GPIOBOUT		0x40
+#define GPIOBOUTENB		0x44
+#define GPIOBDETMODE0		0x48
+#define GPIOBDETMODE1		0x4C
+#define GPIOBINTENB		0x50
+#define GPIOBDET		0x54
+#define GPIOBPAD		0x58
+#define GPIOBPUENB		0x5C
+#define GPIOBALTFN0		0x60
+#define GPIOBALTFN1		0x64
+
+#define GPIOCOUT		0x80
+#define GPIOCOUTENB		0x84
+#define GPIOCDETMODE0		0x88
+#define GPIOCDETMODE1		0x8C
+#define GPIOCINTENB		0x90
+#define GPIOCDET		0x94
+#define GPIOCPAD		0x98
+#define GPIOCPUENB		0x9C
+#define GPIOCALTFN0		0xA0
+#define GPIOCALTFN1		0xA4
+
+/* LF1000 GPIO Alive Registers (offsets from LF1000_ALIVE_BASE) */
+#define ALIVEPWRGATEREG		0x00
+#define ALIVEGPIORSTREG		0x04
+#define ALIVEGPIOSETREG		0x08
+#define ALIVEGPIOREADREG	0x0C
+#define ALIVESCRATCHRSTREG	0x10
+#define ALIVESCRATCHSETREG	0x14
+#define ALIVESCRATCHREADREG	0x18
+
+/* Alive GPIO Gate Register (ALIVEGPIOGATEREG) */
+#define NPOWERGATING		0
+
+/* Alive GPIO Register bit names
+ * same for ALIVEGPIORSTREG, ALIVEGPIOSETREG and ALIVEGPIOREADREG
+ */
+#define VDDPWRONSET		7
+
+/* Alive GPIO Read Register (ALIVEGPIOREADREG) */
+#define VDDPWRTOGGLE		8
+
+/* Current settings (offsets from LF1000_GPIOCURRENT_BASE) */
+#define GPIOPADSTRENGTHGPIOAL	0x00
+#define GPIOPADSTRENGTHGPIOAH	0x04
+#define GPIOPADSTRENGTHGPIOBL	0x08
+#define GPIOPADSTRENGTHGPIOBH	0x0C
+#define GPIOPADSTRENGTHGPIOCL	0x10
+#define GPIOPADSTRENGTHGPIOCH	0x14
+#define GPIOPADSTRENGTHBUS	0x18
+
+#endif /* LF1000_GPIO_HAL_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_map.h linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_map.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_map.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_map.h	2012-11-13 17:46:54.000000000 -0800
@@ -0,0 +1,403 @@
+/* 
+ * arch/arm/mach-lf1000/gpio_map.h
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * LF1000 logical gpio names.  Shared by Linux and Bootstrap code.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef LF1000_GPIO_MAP_H
+#define LF1000_GPIO_MAP_H
+
+#include <mach/gpio.h>
+
+/*
+ * DEV BOARD DEFINES
+ */
+#define DEV_LCD_RESET_PORT		GPIO_PORT_ALV
+#define DEV_LCD_RESET_PIN		GPIO_PIN5
+#define DEV_AUDIO_POWER_PORT		GPIO_PORT_ALV
+#define DEV_AUDIO_POWER_PIN		GPIO_PIN6
+
+#define DEV_BATTERY_PACK_PORT		GPIO_PORT_A
+#define DEV_BATTERY_PACK_PIN		GPIO_PIN17
+
+#define DEV_CARTRIDGE_DETECT_PORT	GPIO_PORT_A
+#define DEV_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+#define DEV_LED_ENA_PORT		GPIO_PORT_A
+#define DEV_LED_ENA_PIN			GPIO_PIN30
+
+#define DEV_TOUCHSCREEN_X1_PORT		GPIO_PORT_B
+#define DEV_TOUCHSCREEN_X1_PIN		GPIO_PIN2
+#define DEV_TOUCHSCREEN_Y1_PORT		GPIO_PORT_B
+#define DEV_TOUCHSCREEN_Y1_PIN		GPIO_PIN3
+#define DEV_TOUCHSCREEN_X2_PORT		GPIO_PORT_B
+#define DEV_TOUCHSCREEN_X2_PIN		GPIO_PIN4
+#define DEV_TOUCHSCREEN_Y2_PORT		GPIO_PORT_B
+#define DEV_TOUCHSCREEN_Y2_PIN		GPIO_PIN5
+
+#define DEV_HEADPHONE_JACK_PORT		GPIO_PORT_B
+#define DEV_HEADPHONE_JACK_PIN		GPIO_PIN10
+
+#define DEV_DPAD_LEFT_PORT		GPIO_PORT_C
+#define DEV_DPAD_LEFT_PIN		GPIO_PIN0
+#define DEV_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define DEV_DPAD_RIGHT_PIN		GPIO_PIN1
+#define DEV_DPAD_UP_PORT		GPIO_PORT_C
+#define DEV_DPAD_UP_PIN			GPIO_PIN2
+#define DEV_DPAD_DOWN_PORT		GPIO_PORT_C
+#define DEV_DPAD_DOWN_PIN		GPIO_PIN3
+#define DEV_SHOULDER_RIGHT_PORT		GPIO_PORT_C
+#define DEV_SHOULDER_RIGHT_PIN		GPIO_PIN4
+
+#define DEV_SHOULDER_LEFT_PORT		GPIO_PORT_C
+#define DEV_SHOULDER_LEFT_PIN		GPIO_PIN7
+#define DEV_BUTTON_A_PORT		GPIO_PORT_C
+#define DEV_BUTTON_A_PIN		GPIO_PIN8
+#define DEV_BUTTON_B_PORT		GPIO_PORT_C
+#define DEV_BUTTON_B_PIN		GPIO_PIN9
+#define DEV_BUTTON_HOME_PORT		GPIO_PORT_C
+#define DEV_BUTTON_HOME_PIN		GPIO_PIN10
+#define DEV_BUTTON_HINT_PORT		GPIO_PORT_C
+#define DEV_BUTTON_HINT_PIN		GPIO_PIN11
+#define DEV_BUTTON_PAUSE_PORT		GPIO_PORT_C
+#define DEV_BUTTON_PAUSE_PIN		GPIO_PIN12
+#define DEV_BUTTON_BRIGHTNESS_PORT	GPIO_PORT_C
+#define DEV_BUTTON_BRIGHTNESS_PIN	GPIO_PIN13
+
+#define DEV_EXT_POWER_PORT		GPIO_PORT_C
+#define DEV_EXT_POWER_PIN		GPIO_PIN14
+
+
+/*
+ * DIDJ BOARD DEFINES
+ */
+#define DIDJ_LCD_RESET_PORT		GPIO_PORT_ALV
+#define DIDJ_LCD_RESET_PIN		GPIO_PIN5
+#define DIDJ_AUDIO_POWER_PORT		GPIO_PORT_ALV
+#define DIDJ_AUDIO_POWER_PIN		GPIO_PIN6
+
+#define DIDJ_BATTERY_PACK_PORT		GPIO_PORT_A
+#define DIDJ_BATTERY_PACK_PIN		GPIO_PIN17
+
+#define DIDJ_CARTRIDGE_DETECT_PORT	GPIO_PORT_A
+#define DIDJ_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+#define DIDJ_LED_ENA_PORT		GPIO_PORT_A
+#define DIDJ_LED_ENA_PIN		GPIO_PIN30
+
+#define DIDJ_TOUCHSCREEN_X1_PORT	GPIO_PORT_B
+#define DIDJ_TOUCHSCREEN_X1_PIN		GPIO_PIN2
+#define DIDJ_TOUCHSCREEN_Y1_PORT	GPIO_PORT_B
+#define DIDJ_TOUCHSCREEN_Y1_PIN		GPIO_PIN3
+#define DIDJ_TOUCHSCREEN_X2_PORT	GPIO_PORT_B
+#define DIDJ_TOUCHSCREEN_X2_PIN		GPIO_PIN4
+#define DIDJ_TOUCHSCREEN_Y2_PORT	GPIO_PORT_B
+#define DIDJ_TOUCHSCREEN_Y2_PIN		GPIO_PIN5
+
+#define DIDJ_HEADPHONE_JACK_PORT	GPIO_PORT_B
+#define DIDJ_HEADPHONE_JACK_PIN		GPIO_PIN10
+
+#define DIDJ_DPAD_LEFT_PORT		GPIO_PORT_C
+#define DIDJ_DPAD_LEFT_PIN		GPIO_PIN0
+#define DIDJ_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define DIDJ_DPAD_RIGHT_PIN		GPIO_PIN1
+#define DIDJ_DPAD_UP_PORT		GPIO_PORT_C
+#define DIDJ_DPAD_UP_PIN		GPIO_PIN2
+#define DIDJ_DPAD_DOWN_PORT		GPIO_PORT_C
+#define DIDJ_DPAD_DOWN_PIN		GPIO_PIN3
+#define DIDJ_SHOULDER_LEFT_PORT		GPIO_PORT_C
+#define DIDJ_SHOULDER_LEFT_PIN		GPIO_PIN4
+
+#define DIDJ_SHOULDER_RIGHT_PORT	GPIO_PORT_C
+#define DIDJ_SHOULDER_RIGHT_PIN		GPIO_PIN7
+#define DIDJ_BUTTON_A_PORT		GPIO_PORT_C
+#define DIDJ_BUTTON_A_PIN		GPIO_PIN8
+#define DIDJ_BUTTON_B_PORT		GPIO_PORT_C
+#define DIDJ_BUTTON_B_PIN		GPIO_PIN9
+#define DIDJ_BUTTON_HOME_PORT		GPIO_PORT_C
+#define DIDJ_BUTTON_HOME_PIN		GPIO_PIN10
+#define DIDJ_BUTTON_HINT_PORT		GPIO_PORT_C
+#define DIDJ_BUTTON_HINT_PIN		GPIO_PIN11
+#define DIDJ_BUTTON_PAUSE_PORT		GPIO_PORT_C
+#define DIDJ_BUTTON_PAUSE_PIN		GPIO_PIN12
+#define DIDJ_BUTTON_BRIGHTNESS_PORT	GPIO_PORT_C
+#define DIDJ_BUTTON_BRIGHTNESS_PIN	GPIO_PIN13
+
+#define DIDJ_EXT_POWER_PORT		GPIO_PORT_C
+#define DIDJ_EXT_POWER_PIN		GPIO_PIN14
+
+
+/*
+ * ACORN BOARD DEFINES
+ */
+#define ACORN_TOUCHSCREEN_X1_PORT	GPIO_PORT_A
+#define ACORN_TOUCHSCREEN_X1_PIN	GPIO_PIN11
+#define ACORN_TOUCHSCREEN_Y1_PORT	GPIO_PORT_A
+#define ACORN_TOUCHSCREEN_Y1_PIN	GPIO_PIN12
+#define ACORN_TOUCHSCREEN_X2_PORT	GPIO_PORT_A
+#define ACORN_TOUCHSCREEN_X2_PIN	GPIO_PIN13
+#define ACORN_TOUCHSCREEN_Y2_PORT	GPIO_PORT_A
+#define ACORN_TOUCHSCREEN_Y2_PIN	GPIO_PIN14
+
+#define ACORN_BATTERY_PACK_PORT		GPIO_PORT_A
+#define ACORN_BATTERY_PACK_PIN		GPIO_PIN17
+
+#define ACORN_CARTRIDGE_DETECT_PORT	GPIO_PORT_A
+#define ACORN_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+#define ACORN_LED_ENA_PORT		GPIO_PORT_A
+#define ACORN_LED_ENA_PIN		GPIO_PIN30
+
+#define ACORN_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define ACORN_DPAD_RIGHT_PIN		GPIO_PIN0
+#define ACORN_DPAD_DOWN_PORT		GPIO_PORT_C
+#define ACORN_DPAD_DOWN_PIN		GPIO_PIN1
+#define ACORN_BUTTON_HINT_PORT		GPIO_PORT_C
+#define ACORN_BUTTON_HINT_PIN		GPIO_PIN2
+#define ACORN_BUTTON_VOLUMEUP_PORT	GPIO_PORT_C
+#define ACORN_BUTTON_VOLUMEUP_PIN	GPIO_PIN3
+#define ACORN_BUTTON_VOLUMEDOWN_PORT	GPIO_PORT_C
+#define ACORN_BUTTON_VOLUMEDOWN_PIN	GPIO_PIN4
+#define ACORN_SHOULDER_RIGHT_PORT	GPIO_PORT_C
+#define ACORN_SHOULDER_RIGHT_PIN	GPIO_PIN5
+#define ACORN_BUTTON_B_PORT		GPIO_PORT_C
+#define ACORN_BUTTON_B_PIN		GPIO_PIN6
+#define ACORN_BUTTON_A_PORT		GPIO_PORT_C
+#define ACORN_BUTTON_A_PIN		GPIO_PIN7
+#define ACORN_BUTTON_BRIGHTNESS_PORT	GPIO_PORT_C
+#define ACORN_BUTTON_BRIGHTNESS_PIN	GPIO_PIN8
+#define ACORN_DPAD_LEFT_PORT		GPIO_PORT_C
+#define ACORN_DPAD_LEFT_PIN		GPIO_PIN9
+#define ACORN_SHOULDER_LEFT_PORT	GPIO_PORT_C
+#define ACORN_SHOULDER_LEFT_PIN		GPIO_PIN10
+#define ACORN_DPAD_UP_PORT		GPIO_PORT_C
+#define ACORN_DPAD_UP_PIN		GPIO_PIN11
+#define ACORN_BUTTON_PAUSE_PORT		GPIO_PORT_C
+#define ACORN_BUTTON_PAUSE_PIN		GPIO_PIN12
+#define ACORN_BUTTON_HOME_PORT		GPIO_PORT_C
+#define ACORN_BUTTON_HOME_PIN		GPIO_PIN13
+
+#define ACORN_EXT_POWER_PORT		GPIO_PORT_C
+#define ACORN_EXT_POWER_PIN		GPIO_PIN14
+
+#define ACORN_HEADPHONE_JACK_PORT	GPIO_PORT_C
+#define ACORN_HEADPHONE_JACK_PIN	GPIO_PIN18
+
+#define ACORN_DOCK_POWER_PORT		GPIO_PORT_A
+#define ACORN_DOCK_POWER_PIN		GPIO_PIN9
+
+/*
+ * EMERALD BOARD DEFINES
+ */
+#define EMERALD_TOUCHSCREEN_X1_PORT	GPIO_PORT_A
+#define EMERALD_TOUCHSCREEN_X1_PIN	GPIO_PIN11
+#define EMERALD_TOUCHSCREEN_Y1_PORT	GPIO_PORT_A
+#define EMERALD_TOUCHSCREEN_Y1_PIN	GPIO_PIN12
+#define EMERALD_TOUCHSCREEN_X2_PORT	GPIO_PORT_A
+#define EMERALD_TOUCHSCREEN_X2_PIN	GPIO_PIN13
+#define EMERALD_TOUCHSCREEN_Y2_PORT	GPIO_PORT_A
+#define EMERALD_TOUCHSCREEN_Y2_PIN	GPIO_PIN14
+
+#define EMERALD_BATTERY_PACK_PORT	GPIO_PORT_A
+#define EMERALD_BATTERY_PACK_PIN	GPIO_PIN17
+
+#define EMERALD_CARTRIDGE_DETECT_PORT	GPIO_PORT_A
+#define EMERALD_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+#define EMERALD_LED_ENA_PORT		GPIO_PORT_A
+#define EMERALD_LED_ENA_PIN		GPIO_PIN30
+
+#define EMERALD_DPAD_DOWN_PORT		GPIO_PORT_C
+#define EMERALD_DPAD_DOWN_PIN		GPIO_PIN0
+#define EMERALD_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define EMERALD_DPAD_RIGHT_PIN		GPIO_PIN1
+#define EMERALD_BUTTON_VOLUMEDOWN_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_VOLUMEDOWN_PIN	GPIO_PIN2
+#define EMERALD_BUTTON_A_PORT		GPIO_PORT_C
+#define EMERALD_BUTTON_A_PIN		GPIO_PIN3
+#define EMERALD_BUTTON_PAUSE_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_PAUSE_PIN	GPIO_PIN4
+#define EMERALD_BUTTON_HINT_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_HINT_PIN		GPIO_PIN5
+#define EMERALD_SHOULDER_RIGHT_PORT	GPIO_PORT_C
+#define EMERALD_SHOULDER_RIGHT_PIN	GPIO_PIN6
+#define EMERALD_BUTTON_VOLUMEUP_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_VOLUMEUP_PIN	GPIO_PIN7
+#define EMERALD_DPAD_LEFT_PORT		GPIO_PORT_C
+#define EMERALD_DPAD_LEFT_PIN		GPIO_PIN8
+#define EMERALD_DPAD_UP_PORT		GPIO_PORT_C
+#define EMERALD_DPAD_UP_PIN		GPIO_PIN9
+#define EMERALD_BUTTON_BRIGHTNESS_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_BRIGHTNESS_PIN	GPIO_PIN10
+#define EMERALD_BUTTON_B_PORT		GPIO_PORT_C
+#define EMERALD_BUTTON_B_PIN		GPIO_PIN11
+#define EMERALD_BUTTON_HOME_PORT	GPIO_PORT_C
+#define EMERALD_BUTTON_HOME_PIN		GPIO_PIN12
+#define EMERALD_SHOULDER_LEFT_PORT	GPIO_PORT_C
+#define EMERALD_SHOULDER_LEFT_PIN	GPIO_PIN13
+
+#define EMERALD_EXT_POWER_PORT		GPIO_PORT_C
+#define EMERALD_EXT_POWER_PIN		GPIO_PIN14
+#define EMERALD_LFP100_INT_PORT		GPIO_PORT_C
+#define EMERALD_LFP100_INT_PIN		GPIO_PIN14
+
+#define EMERALD_HEADPHONE_JACK_PORT	GPIO_PORT_C
+#define EMERALD_HEADPHONE_JACK_PIN	GPIO_PIN18
+
+#define EMERALD_DOCK_POWER_PORT		GPIO_PORT_A
+#define EMERALD_DOCK_POWER_PIN		GPIO_PIN9
+
+/*
+ * K2 BOARD DEFINES
+ */
+#define K2_TOUCHSCREEN_X1_PORT		GPIO_PORT_A
+#define K2_TOUCHSCREEN_X1_PIN		GPIO_PIN11
+#define K2_TOUCHSCREEN_Y1_PORT		GPIO_PORT_A
+#define K2_TOUCHSCREEN_Y1_PIN		GPIO_PIN12
+#define K2_TOUCHSCREEN_X2_PORT		GPIO_PORT_A
+#define K2_TOUCHSCREEN_X2_PIN		GPIO_PIN13
+#define K2_TOUCHSCREEN_Y2_PORT		GPIO_PORT_A
+#define K2_TOUCHSCREEN_Y2_PIN		GPIO_PIN14
+
+#define K2_BATTERY_PACK_PORT		GPIO_PORT_A
+#define K2_BATTERY_PACK_PIN		GPIO_PIN17
+
+//#define K2_CARTRIDGE_DETECT_PORT	GPIO_PORT_A	/* no cartridge */
+//#define K2_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+#define K2_LED_ENA_PORT			GPIO_PORT_A
+#define K2_LED_ENA_PIN			GPIO_PIN30
+
+#define K2_DPAD_DOWN_PORT		GPIO_PORT_C
+#define K2_DPAD_DOWN_PIN		GPIO_PIN0
+#define K2_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define K2_DPAD_RIGHT_PIN		GPIO_PIN1
+
+#define K2_BUTTON_A_PORT		GPIO_PORT_C
+#define K2_BUTTON_A_PIN			GPIO_PIN3
+
+#define K2_BUTTON_HINT_PORT		GPIO_PORT_C
+#define K2_BUTTON_HINT_PIN		GPIO_PIN5
+#define K2_SHOULDER_RIGHT_PORT		GPIO_PORT_C
+#define K2_SHOULDER_RIGHT_PIN		GPIO_PIN6
+
+#define K2_DPAD_LEFT_PORT		GPIO_PORT_C
+#define K2_DPAD_LEFT_PIN		GPIO_PIN8
+#define K2_DPAD_UP_PORT			GPIO_PORT_C
+#define K2_DPAD_UP_PIN			GPIO_PIN9
+
+#define K2_BUTTON_B_PORT		GPIO_PORT_C
+#define K2_BUTTON_B_PIN			GPIO_PIN11
+#define K2_BUTTON_HOME_PORT		GPIO_PORT_C
+#define K2_BUTTON_HOME_PIN		GPIO_PIN12
+#define K2_SHOULDER_LEFT_PORT		GPIO_PORT_C
+#define K2_SHOULDER_LEFT_PIN		GPIO_PIN13
+
+#define K2_EXT_POWER_PORT		GPIO_PORT_C
+#define K2_EXT_POWER_PIN		GPIO_PIN14
+
+#define K2_HEADPHONE_JACK_PORT		GPIO_PORT_C
+#define K2_HEADPHONE_JACK_PIN		GPIO_PIN18
+
+#define K2_DOCK_POWER_PORT		GPIO_PORT_A
+#define K2_DOCK_POWER_PIN		GPIO_PIN9
+
+/*
+ * MADRID BOARD DEFINES
+ */
+#define MADRID_TOUCHSCREEN_X1_PORT	GPIO_PORT_A
+#define MADRID_TOUCHSCREEN_X1_PIN	GPIO_PIN11
+#define MADRID_TOUCHSCREEN_Y1_PORT	GPIO_PORT_A
+#define MADRID_TOUCHSCREEN_Y1_PIN	GPIO_PIN12
+#define MADRID_TOUCHSCREEN_X2_PORT	GPIO_PORT_A
+#define MADRID_TOUCHSCREEN_X2_PIN	GPIO_PIN13
+#define MADRID_TOUCHSCREEN_Y2_PORT	GPIO_PORT_A
+#define MADRID_TOUCHSCREEN_Y2_PIN	GPIO_PIN14
+
+#define MADRID_BATTERY_PACK_PORT	GPIO_PORT_A
+#define MADRID_BATTERY_PACK_PIN		GPIO_PIN17
+
+#define MADRID_CARTRIDGE_DETECT_PORT	GPIO_PORT_A
+#define MADRID_CARTRIDGE_DETECT_PIN	GPIO_PIN18
+
+/* NO backlight enable pin */
+//#define MADRID_LED_ENA_PORT		GPIO_PORT_A
+//#define MADRID_LED_ENA_PIN		GPIO_PIN30
+
+#define MADRID_VIBRATE_PORT		GPIO_PORT_A
+#define MADRID_VIBRATE_PIN		GPIO_PIN30
+
+#define MADRID_DPAD_DOWN_PORT		GPIO_PORT_A
+#define MADRID_DPAD_DOWN_PIN		GPIO_PIN29
+
+#define MADRID_DPAD_RIGHT_PORT		GPIO_PORT_C
+#define MADRID_DPAD_RIGHT_PIN		GPIO_PIN3
+#define MADRID_BUTTON_VOLUMEDOWN_PORT	GPIO_PORT_C
+#define MADRID_BUTTON_VOLUMEDOWN_PIN	GPIO_PIN14
+
+/* NO 'A', 'Pause', or 'Hint' button */
+//#define MADRID_BUTTON_A_PORT		GPIO_PORT_C
+//#define MADRID_BUTTON_A_PIN		GPIO_PIN3
+//#define MADRID_BUTTON_PAUSE_PORT	GPIO_PORT_C
+//#define MADRID_BUTTON_PAUSE_PIN	GPIO_PIN4
+//#define MADRID_BUTTON_HINT_PORT	GPIO_PORT_C
+//#define MADRID_BUTTON_HINT_PIN	GPIO_PIN5
+
+/* No 'right shoulder' button */
+//#define MADRID_SHOULDER_RIGHT_PORT	GPIO_PORT_C
+//#define MADRID_SHOULDER_RIGHT_PIN	GPIO_PIN6
+
+
+#define MADRID_BUTTON_VOLUMEUP_PORT	GPIO_PORT_C
+#define MADRID_BUTTON_VOLUMEUP_PIN	GPIO_PIN2
+
+#define MADRID_DPAD_LEFT_PORT		GPIO_PORT_A
+#define MADRID_DPAD_LEFT_PIN		GPIO_PIN28
+
+#define MADRID_DPAD_UP_PORT		GPIO_PORT_C
+#define MADRID_DPAD_UP_PIN		GPIO_PIN4
+
+/* No 'brightness' or 'B' button */
+//#define MADRID_BUTTON_BRIGHTNESS_PORT	GPIO_PORT_C
+//#define MADRID_BUTTON_BRIGHTNESS_PIN	GPIO_PIN10
+//#define MADRID_BUTTON_B_PORT		GPIO_PORT_C
+//#define MADRID_BUTTON_B_PIN		GPIO_PIN11
+//#define MADRID_BUTTON_HOME_PORT	GPIO_PORT_C
+//#define MADRID_BUTTON_HOME_PIN	GPIO_PIN6
+
+/* No 'left shoulder' button */
+//#define MADRID_SHOULDER_LEFT_PORT	GPIO_PORT_C
+//#define MADRID_SHOULDER_LEFT_PIN	GPIO_PIN13
+
+#define MADRID_HEADPHONE_JACK_PORT	GPIO_PORT_C
+#define MADRID_HEADPHONE_JACK_PIN	GPIO_PIN10
+
+#define MADRID_EXT_POWER_PORT		GPIO_PORT_C
+#define MADRID_EXT_POWER_PIN		GPIO_PIN12
+#define MADRID_LFP100_INT_PORT		GPIO_PORT_C
+#define MADRID_LFP100_INT_PIN		GPIO_PIN12
+
+#define MADRID_DOCK_POWER_PORT		GPIO_PORT_C
+#define MADRID_DOCK_POWER_PIN		GPIO_PIN0
+
+#define MADRID_SD1_POWER_PORT		GPIO_PORT_C
+#define MADRID_SD1_POWER_PIN		GPIO_PIN5
+
+/*
+ * Cartridge Board defines
+ */
+#define LIBERTAS_SPI_INTERRUPT_PORT	GPIO_PORT_B
+#define LIBERTAS_SPI_INTERRUPT_PIN	GPIO_PIN4
+
+#define LIBERTAS_SPI_RESET_PORT		GPIO_PORT_B
+#define LIBERTAS_SPI_RESET_PIN		GPIO_PIN3
+
+#endif	/* LF1000_GPIO_MAP_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_priv.h linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_priv.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/gpio_priv.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/gpio_priv.h	2011-01-04 14:52:41.000000000 -0800
@@ -0,0 +1,62 @@
+/* LF1000 General-Purpose IO (GPIO) Driver 
+ *
+ * gpio.h -- GPIO control.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Brian Cavagnolo <brian@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef GPIO_H
+#define GPIO_H
+
+#include <linux/cdev.h>
+#include <mach/gpio.h>
+
+/* module-related definitions */
+
+#define GPIO_MAJOR		246
+
+struct gpio_device {
+	void __iomem *mem;
+	void __iomem *mem_cur;
+	void __iomem *amem;
+	struct cdev cdev;
+	dev_t dev;
+	int devnum;
+	int irq;
+	u8 board_id;
+	u8 cart_id;
+	u8 touchscreen;
+};
+
+/* There's one gpio_handler per pin.  This is where the handlers are stored. */
+struct gpio_handler {
+	union {
+		gpio_irq_handler_t gpio_handler;
+		irq_handler_t normal_handler;
+		void *handler;
+	} handler;
+	char mode_gpio;
+	void *priv;
+};
+
+/* Use this spin lock to access the gpio_handlers array! */
+extern spinlock_t gpio_handlers_lock;
+extern struct gpio_handler gpio_handlers[GPIO_PORT_ALV+1][GPIO_PIN31+1];
+
+enum PAD_STATUS {
+	PAD_GPIOIN	       		= 1<<0,
+	PAD_GPIOIN_PULLUP		= 1<<1,
+	PAD_GPIOOUT	       	 	= 1<<2,
+	PAD_GPIOOUT_PULLUP	  	= 1<<3,
+	PAD_ALT1	       		= 1<<4,
+	PAD_ALT1_PULLUP		 	= 1<<5,
+	PAD_ALT2	       		= 1<<6,
+	PAD_ALT2_PULLUP		 	= 1<<7,
+	PAD_NOTUSED	       	 	= 1<<8,
+	PAD_NOTEXIST			= 1<<9,
+};
+
+#endif
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/hardware.h linux-2.6/arch/arm/mach-lf1000/include/mach/hardware.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/hardware.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,25 @@
+/*
+ *  mach-lf1000/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the LF1000 boards.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <mach/platform.h>
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/i2c.h linux-2.6/arch/arm/mach-lf1000/include/mach/i2c.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/i2c.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/i2c.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,47 @@
+/* LF1000 I2C registers and hardware definitions */
+
+#ifndef LF1000_I2C_H
+#define LF1000_I2C_H
+
+/* registers, as offsets from I2C_BASE */
+#define ICCR			0x000
+#define ICSR			0x004
+#define IAR			0x008
+#define IDSR			0x00C
+#define QCNT_MAX		0x010
+#define BURST_CTRL		0x014
+#define BYTE_COUNT		0x018
+#define BURST_STATUS		0x01C
+#define BURST_INTERVAL		0x020
+#define IRQ_PEND		0x024
+#define I2C_CLKENB		0x100
+
+/* I2C Control Register (ICCR) */
+#define ACK_GEN				7
+#define CLK_SRC				6
+#define IRQ_ENB				5
+#define EXT_IRQ_ENB			4
+#define CLK_SCALER			0
+
+/* I2C Status Register (ICSR) */
+#define ST_ENB				12
+#define BURST_FIN			11
+#define SLAVE_MATCH_OCCUR		10
+#define GENERAL_CALL_OCCUR		9
+#define SLV_RX_STOP			8
+#define MASTER_SLV			7
+#define TX_RX				6
+#define ST_BUSY				5
+#define TXRX_ENB			4
+#define ARBIT_FAIL			3
+#define ACK_STATUS			0
+
+/* QCNT_MAX */
+#define CNT_MAX				0
+
+/* IRQ Pending (IRQ_PEND) */
+#define OP_HOLD				1
+#define PEND				0
+
+#endif
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/i2s.h linux-2.6/arch/arm/mach-lf1000/include/mach/i2s.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/i2s.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/i2s.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,26 @@
+/* LF1000 Audio Driver
+ *
+ * i2s.h -- AUDIO control.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef I2S_H
+#define I2S_H
+
+/* module-related definitions */
+#define I2S_MAJOR     241
+
+/* audio control */
+
+enum volume_setting {
+	AUDIO_VOLUME_DOWN = 0,
+	AUDIO_VOLUME_UP
+};
+
+void audio_set_volume(enum volume_setting volume);
+uint audio_get_volumeDownCount(void);
+uint audio_get_volumeUpCount(void);
+#endif
+
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/ic.h linux-2.6/arch/arm/mach-lf1000/include/mach/ic.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/ic.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/ic.h	2011-01-04 14:47:34.000000000 -0800
@@ -0,0 +1,17 @@
+/* register definitions for the LF1000 Interrupt Controller
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ */
+#ifndef _LF1000_IC_
+#define _LF1000_IC_
+
+/* offsets from LF1000_IC_BASE */
+#define INTMODEL	0x08
+#define INTMODEH	0x0C
+#define INTMASKL	0x10
+#define INTMASKH	0x14
+#define PRIORDER	0x18
+#define INTPENDL	0x20
+#define INTPENDH	0x24
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/io.h linux-2.6/arch/arm/mach-lf1000/include/mach/io.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/io.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/io.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,32 @@
+/*
+ *  mach-lf1000/include/mach/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+static inline void __iomem *__io(unsigned long addr)
+{
+	return (void __iomem *)addr;
+}
+#define __io(a)	__io(a)
+#define __mem_pci(a)		(a)
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/irqs.h linux-2.6/arch/arm/mach-lf1000/include/mach/irqs.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/irqs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/irqs.h	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,74 @@
+/*
+ *  mach-lf1000/include/mach/irqs.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/platform.h>
+
+/* 
+ *  IRQ interrupts definitions are the same the INT definitions
+ *  held within platform.h
+ */
+
+#define	IRQ_PDISPLAY		0
+#define	IRQ_SDIPLAY		1
+
+#define	IRQ_DMA			3
+#define IRQ_TIMER0		4
+#define	IRQ_SYSCTRL		5
+
+#define	IRQ_UART0		10
+#define	IRQ_TIMER1		11
+#define IRQ_SPI0		12
+#define	IRQ_GPIO		13
+#define	IRQ_SDMMC0		14
+#define IRQ_TIMER2		15
+
+#define IRQ_UDC			20
+#define IRQ_TIMER3		21
+
+#define IRQ_AUDIOIF		24
+#define IRQ_ADC			25
+#define IRQ_MCUSTATIC		26
+#define IRQ_GRP3D		27
+#define IRQ_UHC			28
+
+#define IRQ_RTC			31
+#define IRQ_I2C0		32
+#define IRQ_I2C1		33
+#define IRQ_UART1		34
+#define IRQ_UART2		35
+#define IRQ_UART3		36
+
+#define IRQ_SPI1		39
+#define IRQ_SPI2		40
+#define IRQ_CSC			41
+#define IRQ_SDMMC1		42
+#define IRQ_TIMER4		43
+
+#define NR_HW_IRQS		64
+
+#define NR_GPIO_IRQS		(32 * 4)
+#define NR_DMA_IRQS		8
+#define NR_ALIVE_IRQS		8
+#define NR_IRQS			256
+
+#define dma_to_irq(x)           (x + NR_HW_IRQS + NR_GPIO_IRQS + NR_ALIVE_IRQS)
+#define irq_to_dma(x)           (x - NR_HW_IRQS - NR_GPIO_IRQS - NR_ALIVE_IRQS)
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/lf1000.h linux-2.6/arch/arm/mach-lf1000/include/mach/lf1000.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/lf1000.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/lf1000.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ *  mach-lf1000/include/mach/lf1000.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef PLL_HARDWARE_LF1000_H
+#define PLL_HARDWARE_LF1000_H
+
+struct lf1000_params {
+	unsigned long	ref;
+	unsigned long	vco_max;	/* inclusive */
+	unsigned short	md_min;		/* inclusive */
+	unsigned short	md_max;		/* inclusive */
+	unsigned char	pd_min;		/* inclusive */
+	unsigned char	pd_max;		/* inclusive */
+};
+
+struct lf1000_vco {
+	unsigned short	m;
+	unsigned char	p;
+	unsigned char	s;
+};
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/lfp100.h linux-2.6/arch/arm/mach-lf1000/include/mach/lfp100.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/lfp100.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/lfp100.h	2011-02-24 10:18:27.000000000 -0800
@@ -0,0 +1,119 @@
+/*
+ *
+ * lfp100.h -- LFP100 chip support
+ *     access the lfp100 via getter / setter functions.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ */
+
+#ifndef LFP100_H
+#define LFP100_H
+
+/*
+ * LFP100 definitions
+ */
+
+#define LFP100_I2C_ADAPTER	0
+
+/*
+ * support first silicon from fab, remove when chips are gone
+ */
+
+#define LFP100_ADDR	0xCC
+#define LFP100_NAME	"lfp100-chip"
+
+/* calculate the password unlock value */
+#define LFP100_UNLOCK(x) ( 0x7D ^ x )
+
+/* LFP100 register list.  Names ending with _PW are password protected */
+#define LFP100_CHIPID		0x00
+#define LFP100_CONTROL		0x01
+#define LFP100_CONTROL_STANDBY	(1 << 3)
+
+#define LFP100_STATUS1		0x02
+#define LFP100_STATUS1_SOURCE	    (0x3 << 3)
+#define LFP100_STATUS1_SOURCE_AC    (0x3 << 3)
+#define LFP100_STATUS1_SOURCE_USB   (0x2 << 3)
+#define LFP100_STATUS1_SOURCE_BAT   (0x1 << 3)
+#define LFP100_STATUS1_SOURCE_UNDEF (0x0 << 3)
+#define LFP100_STATUS1_PB	    (0x1 << 5)
+
+#define	LFP100_STATUS2		0x03
+#define LFP100_STATUS2_HP	    (0x1 << 0)
+#define LFP100_STATUS2_ABUSY	    (0x1 << 1)
+
+#define LFP100_INT1		0x04
+#define LFP100_INT2		0x05
+#define LFP100_INT2_BP		(1 << 3)
+
+#define LFP100_INT3		0x06
+#define LFP100_MASK1		0x07
+#define LFP100_MASK2		0x08
+#define LFP100_MASK2_USBM	(1 << 5)
+#define LFP100_MASK2_ACM	(1 << 4)
+#define LFP100_MASK2_PBM	(1 << 3)
+
+#define LFP100_MASK3		0x09
+#define LFP100_MASK3_HP		(1 << 0)
+
+#define LFP100_WLED		0x0A
+#define LFP100_PPATH		0x0B
+#define LFP100_IO		0x0C
+#define LFP100_PASSWORD		0x0D
+#define LFP100_P_ENABLE		0x0E
+#define LFP100_P_ENABLE_WLED_EN	(1 << 5)
+
+#define LFP100_DCDC1_PW		0x0F
+#define LFP100_DCDC2_PW		0x10
+#define LFP100_SLEW_PW		0x11
+#define LFP100_LDO1_PW		0x12
+#define LFP100_LDO2_PW		0x13
+#define LFP100_LDO3_PW		0x14
+#define LFP100_PG_PW		0x15
+#define LFP100_UVLO_PW		0x16
+#define LFP100_SEQ1_PW		0x17
+#define LFP100_SEQ2_PW		0x18
+#define LFP100_SEQ3_PW		0x19
+#define LFP100_SEQ4_PW		0x1A
+#define LFP100_SEQ5_PW		0x1B
+#define LFP100_FORMAT_PW	0x1C
+#define LFP100_FILTER		0x1D
+#define LFP100_A_APOP_PW	0x1E
+#define LFP100_A_CONTROL	0x1F
+#define LFP100_A_CONTROL_MIC_EN		(1 << 0)
+#define LFP100_A_CONTROL_HP_EN		(1 << 1)
+#define LFP100_A_CONTROL_SPK_EN		(1 << 2)
+#define LFP100_A_CONTROL_AUTO_MASK	(3 << 3)
+#define LFP100_A_CONTROL_AUTO_MUTE	(1 << 3)
+#define LFP100_A_CONTROL_AUTO_ROUTE	(2 << 3)
+#define LFP100_A_CONTROL_DAC_EN		(1 << 6)
+#define LFP100_A_CONTROL_DAC_SW		(1 << 7)
+
+#define LFP100_GAINSL		0x20
+#define LFP100_GAINADJ_PW	0x21
+#define LFP100_MGAIN		0x22
+#define LFP100_MGAIN_AMUTE		(1 << 7)
+
+#define LFP100_VOLUME		0x23
+#define LFP100_VOLUME_MUTE		(1 << 6)
+
+#define LFP100_VLIMIT_PW	0x24
+#define LFP100_MICGAIN		0x25
+
+#define LFP100_LASTREG		LFP100_MICGAIN
+
+#define LFP100_FIRSTREG		LFP100_CHIPID
+#define	LFP100_NUMREGS	(LFP100_LASTREG - LFP100_FIRSTREG + 1)
+
+int  lfp100_get_power_button(void);
+int  lfp100_have_lfp100(void);
+int  lfp100_is_battery(void);
+int  lfp100_read_reg(unsigned int reg);
+void lfp100_set_power_button_callback(void (*callback)(void));
+void lfp100_set_power_standby(void);
+void  lfp100_mute_hp_sp(void);
+void  lfp100_unmute_hp_sp(void);
+int  lfp100_write_reg(unsigned int reg, unsigned int value);
+
+#endif /* LFP100_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/mem_controller.h linux-2.6/arch/arm/mach-lf1000/include/mach/mem_controller.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/mem_controller.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/mem_controller.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,68 @@
+/* mach-lf1000/include/mach/mem_controller.h -- LF1000 Memory Controller HAL 
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ */
+
+#ifndef _LF1000_MEM_CONTROLLER_H
+#define _LF1000_MEM_CONTROLLER_H
+
+#include <mach/platform.h>
+
+/* static memory bus */
+#define LF1000_STATIC_BASE_NOSHADOW	0x00000000 /* shadow mode disabled */
+#define LF1000_STATIC_BASE_SHADOW	0x80000000 /* shadow mode */
+#define LF1000_STATIC_BASE	LF1000_STATIC_BASE_NOSHADOW /* not shadow */
+#define LF1000_STATIC0_BASE	0x00000000
+#define LF1000_STATIC1_BASE	0x04000000
+#define LF1000_STATIC2_BASE	0x08000000
+#define LF1000_STATIC3_BASE	0x0C000000
+#define LF1000_STATIC4_BASE	0x10000000
+#define LF1000_STATIC5_BASE	0x14000000
+#define LF1000_STATIC6_BASE	0x18000000
+#define LF1000_STATIC7_BASE	0x1C000000
+#ifdef CPU_LF1000
+#define LF1000_STATIC8_BASE	0x20000000
+#define LF1000_STATIC9_BASE	0x24000000
+/* (reserved) */
+#define LF1000_STATIC11_BASE_LOW	0x2C000000
+#define LF1000_STATIC11_BASE_HIGH	0xAC000000
+#endif
+
+/* MCU-Y Memory Controller Registers (as offsets from LF1000_MCU_Y_BASE) */
+#define MEMCFG		0x00
+#define MEMTIME0	0x02
+#define MEMTIME1	0x04
+//RESERVED		0x06
+#define MEMREFRESH	0x08
+#define MEMCONRTROL	0x0A
+#define MEMCLKDELAY	0x0C
+#define MEMDQSOUTDELAY	0x0E
+#define MEMDQSINDELAY	0x10
+
+/* MEMCFG register SDRCAP */
+#define	SDRCAP		0
+#define SDRCAP_64MBIT	0
+#define SDRCAP_128MBIT	1
+#define SDRCAP_256MBIT  2
+#define SDRCAP_512MBIT  3
+
+
+/* MCU-S Memory Controller Registers (as offsets from LF1000_MCU_S_BASE) */
+#define MEMBW		0x00
+#define MEMTIMEACS	0x04
+#define MEMTIMECOS	0x08
+#define MEMTIMEACCL	0x0C
+#define MEMTIMEACCH	0x10
+#define MEMTIMESACCL	0x14
+#define MEMTIMESACCH	0x18
+#ifdef CPU_LF1000
+#define MEMTIMESACCWL	0x1C /* (reserved) */
+#define MEMTIMESACCWH	0x20 /* (reserved) */
+#endif
+#define MEMTIMECOH	0x24
+#define MEMTIMECAH	0x28
+#define MEMBURSTL	0x2C
+#define MEMBURSTH	0x30
+#define MEMWAIT		0x34
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/memory.h linux-2.6/arch/arm/mach-lf1000/include/mach/memory.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/memory.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/memory.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ *  mach-lf1000/include/mach/memory.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/*
+ * Physical DRAM offset.
+ */
+
+/* NAND / UART BOOT */
+#define PHYS_OFFSET_SHADOW	UL(0x00000000)
+/* NOR BOOT */
+#define PHYS_OFFSET_NO_SHADOW	UL(0x80000000)
+
+#ifndef CONFIG_RUNTIME_PHYS_OFFSET
+#define PHYS_OFFSET	PHYS_OFFSET_SHADOW
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	((x) - PAGE_OFFSET)
+#define __bus_to_virt(x)	((x) + PAGE_OFFSET)
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/mlc.h linux-2.6/arch/arm/mach-lf1000/include/mach/mlc.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/mlc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/mlc.h	2011-01-04 15:04:47.000000000 -0800
@@ -0,0 +1,218 @@
+/* LF1000 Multi-Layer Controller Driver
+ *
+ * mach-lf1000/include/mach/mlc.h -- MLC configuration, driver-side API, and useful 
+ * 			     macros.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+#ifndef LF1000_MLC_H
+#define LF1000_MLC_H
+
+#include <mach/platform.h>
+#include <linux/types.h>
+
+/* screen resolution (also used to calculate frame buffer size) */
+#define X_RESOLUTION		320
+#define Y_RESOLUTION		240
+
+/* MLC "top" layer defaults */
+#define DISPLAY_VID_LAYER_PRIORITY	VID_PRIORITY_FIRST
+#define DISPLAY_VID_RGB_FORMAT		VID_RGBFMT_R5G6B5
+
+/* 
+ * devfs-related definitions 
+ */
+#define MLC_MAJOR		247
+#define MLC_LAYER_MAJOR		245
+
+/* the LF1000 has three layers:
+ * layer 0 -- RGB Layer (3D capable)
+ * layer 1 -- RGB Layer (3D capable)
+ * layer 2 -- Video Lyaer */
+#define MLC_NUM_LAYERS		3
+
+/* video layer number: typically this is the last layer, change it if that's
+ * not the case! */
+#define MLC_VIDEO_LAYER		(MLC_NUM_LAYERS-1)
+
+/* hardware-related definitions */
+
+enum {
+	PCLKMODE_ONLYWHENCPUACCESS	= 0, /* Operate When CPU Acces */
+	PCLKMODE_ALWAYS			= 1, /* Operate Always */
+};
+
+enum {   
+	BCLKMODE_DISABLE		= 0, /* Bus Clock Disable */
+	BCLKMODE_DYNAMIC		= 2, /* Dynamically Controlled by MLC */
+	BCLKMODE_ALWAYS			= 3, /* Operate Always */
+};
+
+enum {
+	VID_PRIORITY_FIRST	= 0,   /* video  > Cursor > Window > 3D */
+	VID_PRIORITY_SECOND	= 1,   /* Cursor > video  > Window > 3D */
+	VID_PRIORITY_THIRD	= 2,   /* Cursor > Window > video  > 3D */
+	VID_PRIORITY_INVALID	= 3,
+};
+
+enum RGBFMT
+{
+	VID_RGBFMT_R5G6B5	= 0x4432,   /* 16bpp { R5, G6, B5 }. */
+	VID_RGBFMT_B5G6R5	= 0xC432,   /* 16bpp { B5, G6, R5 }. */
+
+	VID_RGBFMT_X1R5G5B5	= 0x4342,   /* 16bpp { X1, R5, G5, B5 }. */
+	VID_RGBFMT_X1B5G5R5	= 0xC342,   /* 16bpp { X1, B5, G5, R5 }. */
+	VID_RGBFMT_X4R4G4B4	= 0x4211,   /* 16bpp { X4, R4, G4, B4 }. */
+	VID_RGBFMT_X4B4G4R4	= 0xC211,   /* 16bpp { X4, B4, G4, R4 }. */
+	VID_RGBFMT_X8R3G3B2	= 0x4120,   /* 16bpp { X8, R3, G3, B2 }. */
+	VID_RGBFMT_X8B3G3R2	= 0xC120,   /* 16bpp { X8, B3, G3, R2 }. */
+
+	VID_RGBFMT_A1R5G5B5	= 0x3342,   /* 16bpp { A1, R5, G5, B5 }. */
+	VID_RGBFMT_A1B5G5R5	= 0xB342,   /* 16bpp { A1, B5, G5, R5 }. */
+	VID_RGBFMT_A4R4G4B4	= 0x2211,   /* 16bpp { A4, R4, G4, B4 }. */
+	VID_RGBFMT_A4B4G4R4	= 0xA211,   /* 16bpp { A4, B4, G4, R4 }. */
+	VID_RGBFMT_A8R3G3B2	= 0x1120,   /* 16bpp { A8, R3, G3, B2 }. */
+	VID_RGBFMT_A8B3G3R2	= 0x9120,   /* 16bpp { A8, B3, G3, R2 }. */
+
+	VID_RGBFMT_G8R8_G8B8	= 0x4ED3,   /* 16bpp { G8, R8, G8, B8 }. */
+	VID_RGBFMT_R8G8_B8G8	= 0x4F84,   /* 16bpp { R8, G8, B8, G8 }. */
+	VID_RGBFMT_G8B8_G8R8	= 0xCED3,   /* 16bpp { G8, B8, G8, R8 }. */
+	VID_RGBFMT_B8G8_R8G8	= 0xCF84,   /* 16bpp { B8, G8, R8, G8 }. */
+	VID_RGBFMT_X8L8		= 0x4003,   /* 16bpp { X8, L8 }. */
+	VID_RGBFMT_A8L8		= 0x1003,   /* 16bpp { A8, L8 }. */
+	VID_RGBFMT_L16		= 0x4554,   /* 16bpp { L16 }. */
+
+	VID_RGBFMT_R8G8B8	= 0x4653,   /* 24bpp { R8, G8, B8 }. */
+	VID_RGBFMT_B8G8R8	= 0xC653,   /* 24bpp { B8, G8, R8 }. */
+
+	VID_RGBFMT_X8R8G8B8	= 0x4653,   /* 32bpp { X8, R8, G8, B8 }. */
+	VID_RGBFMT_X8B8G8R8	= 0xC653,   /* 32bpp { X8, B8, G8, R8 }. */
+	VID_RGBFMT_A8R8G8B8	= 0x0653,   /* 32bpp { A8, R8, G8, B8 }. */
+	VID_RGBFMT_A8B8G8R8	= 0x8653,   /* 32bpp { A8, B8, G8, R8 }. */
+};
+
+
+struct mlc_layer_position {
+	u32 top;
+	u32 left;
+	u32 right;
+	u32 bottom;
+};
+
+struct mlc_screen_size {
+	u32 width;
+	u32 height;
+};
+
+struct mlc_overlay_size {
+	u32 srcwidth;
+	u32 srcheight;
+	u32 dstwidth;
+	u32 dstheight;
+};
+
+/** Turn the MLC on or off.
+ *
+ *  \param[in] en 0 to disable, not 0 to enable. */
+void mlc_SetMLCEnable(u8 en);
+
+/** Set screen resolution.
+ *
+ *  The screen width and height cannot exceed 4095.
+ *
+ *  \param[in] width Screen horizontal resolution.
+ *  \param[in] height Screen vertical resolution. 
+ *
+ *  \retval int 0 on success, -EINVAL if width or height were not valid. */
+int mlc_SetScreenSize(u32 width, u32 height);
+
+void mlc_GetScreenSize(struct mlc_screen_size *size);
+
+/** Set the screen background color.
+ *
+ *  The background color is displayed in any part of the screen that is not
+ *  covered by a layer.  It is specififed in 24-bit RGB format, ie: 0xRRGGBB.
+ *  This function will 'clip' the color parameter at 24 bits.  The color change
+ *  is not applied until the Top Dirty Bit is set by calling 
+ *  mlc_SetTopDirtyBit().
+ *
+ *  \param[in] color Color to set for the screen background. */
+void mlc_SetBackground(u32 color);
+
+u32 mlc_GetBackground(void);
+
+void mlc_SetClockMode(u8 pclk, u8 bclk);
+void mlc_SetFieldEnable(u8 en);
+int mlc_SetLayerPriority(u32 priority);
+u32 mlc_GetLayerPriority(void);
+void mlc_SetTopDirtyFlag(void);
+
+int mlc_SetLayerEnable(u8 layer, u8 en);
+int mlc_GetLayerEnable(u8 layer);
+int mlc_SetAddress(u8 layer, u32 addr);
+int mlc_SetAddressCb(u8 layer, u32 addr);
+int mlc_SetAddressCr(u8 layer, u32 addr);
+int mlc_GetAddress(u8 layer, int *addr);
+int mlc_SetLockSize(u8 layer, u32 locksize);
+int mlc_GetLockSize(u8 layer, int *locksize);
+
+/** Set the horizonal stride for a layer.
+ *
+ *  The horizonal stride determines how many bytes are read by the MLC as a
+ *  pixel.  Thus for 24-bit color, the horizonal stride should be set to 3 and
+ *  for 8-bit color it should be set to 2.
+ *
+ *  \note The horizonal stride is not applicable for the video layer.
+ *
+ *  \param[in] layer Layer number, 0 through 2.
+ *  \param[in] hstride Horizonal stride.
+ *  \retval int 0 on success, -EINVAL on invalid layer number. */
+int mlc_SetHStride(u8 layer, u32 hstride);
+
+int mlc_GetHStride(u8 layer);
+
+/** Set the vertical stride for a layer.
+ *
+ *  The vertical stride for an RGB layer should be set to the number of bytes
+ *  per pixel (horizonal stride) multiplied by the layer's horizonal 
+ *  resolution.  For the video and 3D mode layers, the vertical stride should
+ *  instead be set as 4096.
+ *
+ *  \param[in] layer Layer number, 0 through 3.
+ *  \param[in] vstride Vertical stride.
+ *  \retval int 0 on success, -EINVAL on invalid layer number. */
+int mlc_SetVStride(u8 layer, u32 vstride);
+
+int mlc_GetVStride(u8 layer);
+
+int mlc_Set3DEnable(u8 layer, u8 en);
+int mlc_Get3DEnable(u8 layer, int *en);
+int mlc_SetFormat(u8 layer, enum RGBFMT format);
+int mlc_GetFormat(u8 layer, int *format);
+int mlc_SetPosition(u8 layer, s32 top, s32 left, s32 right, s32 bottom);
+int mlc_GetPosition(u8 layer, struct mlc_layer_position *p);
+int mlc_SetTransparencyColor(u8 layer, u32 color);
+int mlc_GetTransparencyColor(u8 layer, int *color);
+int mlc_SetTransparencyAlpha(u8 layer, u8 alpha);
+int mlc_GetTransparencyAlpha(u8 layer);
+int mlc_SetBlendEnable(u8 layer, u8 en);
+int mlc_GetBlendEnable(u8 layer, int *en);
+int mlc_SetTransparencyEnable(u8 layer, u8 en);
+int mlc_GetTransparencyEnable(u8 layer, int *en);
+int mlc_SetInvertEnable(u8 layer, u8 en);
+int mlc_GetInvertEnable(u8 layer, int *en);
+int mlc_SetInvertColor(u8 layer, u32 color);
+int mlc_GetInvertColor(u8 layer, int *color);
+int mlc_SetDirtyFlag(u8 layer);
+int mlc_GetDirtyFlag(u8 layer);
+
+int mlc_SetOverlaySize(u8 layer, u32 srcwidth, u32 srcheight, u32 dstwidth, u32 dstheight);
+int mlc_GetOverlaySize(u8 layer, struct mlc_overlay_size *psize);
+
+int mlc_SetLayerInvisibleAreaEnable(u8 layer, u8 en);
+int mlc_GetLayerInvisibleAreaEnable(u8 layer);
+int mlc_SetLayerInvisibleArea(u8 layer, s32 top, s32 left, s32 right, s32 bottom);
+int mlc_GetLayerInvisibleArea(u8 layer, struct mlc_layer_position *p);
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/nand.h linux-2.6/arch/arm/mach-lf1000/include/mach/nand.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/nand.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/nand.h	2011-01-04 14:58:39.000000000 -0800
@@ -0,0 +1,116 @@
+/* LF1000 NAND Flash Controller Driver
+ *
+ * mach-lf1000/include/mach/nand.h -- hardware abstraction
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef LF1000_NAND_H
+#define LF1000_HAND_H
+
+#include <mach/platform.h>
+#include <mach/mem_controller.h>
+#include <mach/gpio.h>
+
+/* 
+ * location of NAND Controller base for NFDATA, NFCMD, and NFADDR registers 
+ */
+#define LF1000_NAND_BASE	    LF1000_STATIC11_BASE_HIGH
+#define LF1000_NAND_BASE_LOW	LF1000_STATIC11_BASE_LOW
+#define LF1000_NAND_BASE_HIGH	LF1000_STATIC11_BASE_HIGH
+#define LF1000_NAND_SIZE	    0x18
+
+/* NAND Controller Registers
+ *
+ * (offsets from LF1000_MCU_S_BASE) */
+#define NFCONTROL		0x74
+#define NFECCL			0x78	
+#define NFECCH			0x7C
+#define NFORGECCL		0x80
+#define NFORGECCH		0x84
+#define NFCNT			0x88
+#define NFECCSTATUS		0x8C
+#define NFSYNDRONE31	0x90
+#define NFSYNDRONE75	0x94
+
+/* (offsets from LF1000_NAND_BASE) */
+#define NFDATA			0x00
+#define NFCMD			0x10
+#define NFADDR			0x18
+
+/* NAND Flash Control Register (NFCONTROL) */
+#define IRQPEND			15
+#define ECCRST			11
+#define RnB			    9
+#define IRQENB			8
+#define NFBOOTENB		5
+#define NFTYPE			3
+#define NFBANK			0
+
+/* NFTYPE bits in NFCONTROL */
+#define NFTYPE_LBLOCK	4	/* large block Flash */
+#define NFTYPE_EADDR	3	/* extra address Flash */
+
+/* Masks for NFCONTROL register fields */
+#define NFC_ECCRST_MASK (1 << ECCRST)
+#define NFC_NFTYPE_MASK (3 << NFTYPE)
+#define NFC_NFBANK_MASK (1 << NFBANK)
+
+/* NAND Flash Data Count Register (NFCNT) */
+#define NFWRCNT			16
+#define NFRDCNT			0
+
+/* NAND FLASH ECC STATUS REGISTER (NFECCSTATUS) */
+#define NFCHECKERROR	2
+#define NFECCDECDONE	1	/* (reading done) */
+#define NFECCENCDONE	0	/* (writing done) */
+
+/* NAND FLASH ECC SYNDROME VALUE31 REGISTER (NFSYNDRONE31) */
+#define SYNDROM3		13
+#define SYNDROM1		0
+
+/* NAND FLASH ECC SYNDROME VALUE75 REGISTER (NFSYNDRONE75) */
+#define SYNDROM7		13
+#define SYNDROM5		0
+
+/* GPIO settings for Write Protect control */
+#define NAND_WP_PORT	        GPIO_PORT_ALV
+#define NAND_WP_BASE	        LF1000_ALIVE_BASE
+#define NAND_WP_OUT		        GPIOALVOUT
+#define NAND_WP_OUT_ENB	        GPIOALVOUTENB
+#define NAND_WP_PIN		        1
+#define NAND_WP_LEVEL	        0	/* level for "on" */
+
+/* GPIO settings for cartridge detection */
+#define NAND_CART_DETECT_PORT	GPIO_PORT_A
+#define NAND_CART_DETECT_PIN	18
+#define NAND_CART_DETECT_LEVEL	0	/* level for "detected" */
+
+/*
+ * Cartridge Type Detection
+ */
+#define NAND_CART_TYPE_PORT	    GPIO_PORT_B
+#define NAND_CART_TYPE_LOW	    2
+#define NAND_CART_TYPE_EMERALD	4
+#define NAND_CART_TYPE_HIGH	    5
+#define NAND_CART_DEVELOPMENT	0xF	/* 1111: Development: writable NAND ECC on*/
+#define NAND_CART_MANUFACTURING	0xB	/* 1011 */
+#define NAND_CART_PRODUCTION	0x7	/* 0111: Production: OTP, ECC off */
+/*
+ * The following are defined for non-MTD applications such as uniboot 
+ */
+
+/* NAND Flash Commands */
+#define CMD_READ                0x00
+#define CMD_READ_CONFIRM        0x30    /* (large block Flash chips only) */
+#define CMD_READ_STATUS         0x70
+
+/* NAND status codes */
+#define NAND_STATUS_ERROR_SH    0
+#define NAND_STATUS_READY_SH    6
+
+/* NAND flags */
+#define NAND_LARGE_BLOCK_SH     0
+#define NAND_EXTRA_ADDRESS_SH   1
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/platform.h linux-2.6/arch/arm/mach-lf1000/include/mach/platform.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/platform.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/platform.h	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,452 @@
+/*
+ * mach-lf1000/include/mach/platform.h
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef _LF1000_PLATFORM_H
+#define _LF1000_PLATFORM_H
+
+/* macro to get at IO space when running virtually */
+#define	IO_ADDRESS_OFF		0xf0000000
+#define IO_ADDRESS(x)		(((x) & 0x00ffffff) + (((x) >> 4) & 0x0ff00000) + IO_ADDRESS_OFF)
+
+/*
+ * Platform CPU Selection
+ */
+
+#if	defined	CONFIG_MACH_ME_LF1000
+	#define	CPU_LF1000
+#elif	defined	CONFIG_MACH_LF_LF1000
+	#define	CPU_LF1000
+#else
+	#error NO Platform Selected
+#endif
+
+/* ------------------------------------------------------------------------
+ *  Lf1000 Registers
+ * ------------------------------------------------------------------------
+ * FIXME: these shoudn't be needed, clean up this file accordingly?
+ */
+#define LF1000_SYS_IO				0xc0000000
+#define LF1000_SYS_BASE				0xc0000000
+#define LF1000_ETH_BASE				0x88000000
+
+/////////////////////////////////  PLL  //////////////////////////////////////////////
+
+#ifndef	__ASSEMBLY__
+struct bpsr {
+    volatile unsigned int	reserved:8;
+    volatile unsigned int	pdiv:8;
+    volatile unsigned int	mdiv:8;
+    volatile unsigned int	sdiv:8;
+};
+
+union pllsetreg {
+    struct bpsr	bits __attribute__((packed));
+    unsigned int		word;
+};
+
+struct lf1000_clock {
+    volatile unsigned int	clkmodereg;
+    volatile unsigned int	pllsetreg0;
+    volatile unsigned int	pllsetreg1;
+    volatile unsigned int	reserved0;
+    volatile unsigned int	reserved1[0xc];
+    volatile unsigned int	gpiowakeupenb;
+    volatile unsigned int	rtcwakeupenb;
+    volatile unsigned int	gpiowakeupriseenb;
+    volatile unsigned int	gpiowakeupfallenb;
+    volatile unsigned int	gpiopend;
+    volatile unsigned int	reserved2;
+    volatile unsigned int	intpendspad;
+    volatile unsigned int	pwrrststatus;
+    volatile unsigned int	intenb;
+    volatile unsigned int	reserved3[0x6];
+    volatile unsigned int	pwrmode;
+};
+
+#endif
+
+//------------- SET ONLY THIS DEFINITIONS -------------//
+
+#define	CRYSTAL_FREQ_HZ	27000000	/* 27 MHz hardware installed in Hz */
+
+/*
+ * Choose CPU speed to match Audio requirements.  Audio base rate is 32KHz
+ * times the i2s oversampling rate of 256.  So CPU rate is a multiple of
+ * of 32,000 Hz * 256 i2s rate, or 8,192,000 Hz.  Development rates have
+ * been 8.192 Mhz * 47 = 385.024 Mhz and 8.192 Mhz * 48 = 393.216 Mhz.
+ * Also 532.480 Mhz (8.192 Mhz * 65) is supported experimentally with a
+ * higher CPU core voltage.
+ */
+
+// only one CPU_SPEED should be defined
+#if defined CONFIG_CPU_SPEED_385024000
+#define PLL0_OUT_HZ	385024000	/* desired PLL freq in Hz*/
+#elif defined CONFIG_CPU_SPEED_393216000
+#define PLL0_OUT_HZ	393216000	/* desired PLL freq in Hz*/
+#elif defined CONFIG_CPU_SPEED_532480000
+#define PLL0_OUT_HZ	532480000	/* desired PLL freq in Hz*/
+#else
+#error CPU SPEED not defined
+#endif
+
+#define PLL1_OUT_HZ	144000000	/* desired PLL frequency in Hz	*/
+
+//------------- SET ONLY THIS DEFINITIONS -------------//
+
+#define LF1000_CLOCK_BASE	(LF1000_SYS_IO+0xf000)	/* clock controller */
+
+
+#define	PLL0		0
+#define	PLL1		1
+
+#define	MAX_PDIV	63
+#define	MIN_PDIV	1
+#define	MAX_MDIV	1023
+#define	MIN_MDIV	56
+#define	MAX_SDIV	5
+#define	MIN_SDIV	0
+
+#define	PLL_MUL( n)	( 1)
+
+#define  MAX_VCOF_HZ(n)((n==PLL0)?600000000:  \
+			 (n==PLL1)?600000000:0)
+
+// choose PLL post-scaler based on output frequency
+#define	SDIV_HZ( n, f)	(((f) > (MAX_VCOF_HZ(n)/ 2))?0:	\
+			 ((f) > (MAX_VCOF_HZ(n)/ 4))?1:	\
+			 ((f) > (MAX_VCOF_HZ(n)/ 8))?2:	\
+			 ((f) > (MAX_VCOF_HZ(n)/16))?3:0)
+
+#define clock_p		((struct lf1000_clock*)(IO_ADDRESS( LF1000_CLOCK_BASE)))
+
+/////////////////////// CPU, SDRAM, BCLK & PCLK //////////////////////////////////////
+#define	CPU_PLL		PLL0
+#define CPU_DIV		1
+#define HCLK_DIV	3
+#define	SDRAM_PLL	PLL1
+#define BCLK_PLL	PLL0
+#define BCLK_DIV	3
+#define	PCLK_PLL	BCLK_PLL
+
+/*
+ * Memory Controller Settings
+ */
+#define	LF1000_SYS_IO_VIRT		IO_ADDRESS(LF1000_SYS_IO)
+#define LF1000_TSACC0			0	/* bits 3:0 */
+#define LF1000_TSACC1			1	/* bits 7:4 */
+#define LF1000_NAND			11
+#define	LF1000_ETH			2
+
+/* TODO: replace with mem_controller.h */
+#define	LF1000_MEMBW_OFF		0x00015800
+#define	LF1000_MEMBW_SR1BW	(1<<LF1000_ETH) /*XXX*/
+#define	LF1000_MEMTIMEACS_OFF		0x00015804
+#define	LF1000_MEMTIMECOS_OFF		0x00015808
+#define	LF1000_MEMTIMEACCL_OFF		0x0001580c
+#define	LF1000_MEMTIMEACCH_OFF		0x00015810
+#define	LF1000_MEMTIMESACCL_OFF		0x00015814
+#define	LF1000_MEMTIMECOH_OFF		0x00015824
+#define	LF1000_MEMTIMECAH_OFF		0x00015828
+#define	LF1000_MEMTIMEBURSTL_OFF	0x0001582c
+#define	LF1000_MEMWAIT_OFF		0x00015834
+
+#define	mrs_read(off)		(*((ulong*)(LF1000_SYS_IO_VIRT+(off))))
+#define	mrs_write(off, val)	(*((ulong*)(LF1000_SYS_IO_VIRT+(off))) = (val))
+
+#define	MASK_MRS(size)			((1<<size)-1)
+
+// set Memory Register Static
+#define	SET_MRS( num, size, off, val)				\
+	    mrs_write( off, test = (mrs_read( off) &		\
+		(     ~(MASK_MRS( size)<<(size*num)))) |	\
+		((val & MASK_MRS( size))<<(size*num)));
+
+/*****************************************************************************
+ * LF1000 Devices Memory Map and IRQ Assignments                             *
+ *****************************************************************************/
+
+/*
+ * NOR Flash -- Note boot depends on ATAP switch settings:
+ *
+ *Didj|Acorn|      |                |                |            |   |
+ * SW2|SW16 |Mode  |Didj            |Acorn/Emerald   |Signal      |J13|TP
+ * S1 |     |Open  |Onboard NAND/NOR|Cartridge NAND  |CfgSELCS    |  1|30
+ *    |     |Closed|Cartridge NAND  |Onboard NAND/NOR|            |   |
+ * S2 | S2  |Open  |not used        |Onboard NOR     |CfgBOOTMODE1|  2|31
+ *    |     |Closed|Boot NAND/UART  |Boot NAND/UART  |            |   |
+ * S3 | S1  |Open  |Boot from NAND  |Boot from NAND  |CfgBOOTMODE0|  3|32
+ *    |     |Closed|Boot from UART  |Boot from UART  |            |   |
+ * S4 | S3  |Open  |unused keep Open|Boot NAND/UART  |CfgSHADOW   |  4|33
+ *    |     |Closed|not used        |Boot from NOR   |            |   |
+ *
+ * Acorn/Emerald UART BOOT -- SW16 S1=ON  S2=ON  S3=OFF
+ *               NAND BOOT -- SW16 S1=OFF S2=ON  S3=OFF
+ *               NOR  BOOT -- SW16 S1=ON  S2=OFF S3=ON
+ */
+
+
+#define LF1000_NOR_FLASH_BASE_LOW	0x00000000
+#define	LF1000_NOR_FLASH_BASE_HIGH0	0x80000000
+#define	LF1000_NOR_FLASH_BASE_HIGH1	0x84000000
+
+#define LF1000_NOR_FLASH_SIZE		( 512 * 1024 )
+#define LF1000_NOR_MFGDATA_SIZE		( 4096 )
+#define LF1000_NOR_BOOT_SIZE ( LF1000_NOR_FLASH_SIZE - 2*LF1000_NOR_MFGDATA_SIZE )
+
+/* Framebuffer address defaults (prior to kernel command line options) */
+#define LF1000_FB_START_ADDR	0x82E00000
+#define LF1000_FB_SIZE		0x01200000
+
+/* DMA Controller */
+#define LF1000_DMA_BASE		0xC0000000
+#define LF1000_DMA_IRQ		3
+
+/* Interrupt controller */
+#define LF1000_IC_BASE		0xC0000800	
+
+/* Timers */
+#define LF1000_TIMER0_BASE	0xC0001800
+#define LF1000_TIMER0_IRQ	4
+#define LF1000_TIMER1_BASE	0xC0001880
+#define LF1000_TIMER1_IRQ	11
+#define LF1000_TIMER2_BASE	0xC0001900
+#define LF1000_TIMER2_IRQ	15
+#define LF1000_TIMER3_BASE	0xC0001980
+#define LF1000_TIMER3_IRQ	21
+#define LF1000_TIMER4_BASE	0xC0001A00
+#define LF1000_TIMER4_IRQ	43
+
+/* Display Controller (DPC) */
+#define LF1000_DPC_BASE		0xC0003000
+#define LF1000_DPC_END		0xC00035CF
+#define LF1000_DPC_IRQ		0
+
+/* Multi-Layer Controller (MLC) */
+#define LF1000_MLC_BASE		0xC0004000
+#define LF1000_MLC_END		0xC00047CF
+
+/* Analog to Digital Converter (ADC) */
+#define LF1000_ADC_BASE		0xC0005000
+#define LF1000_ADC_END		0xC0005040
+#define LF1000_ADC_IRQ		25
+
+/* Serial Peripheral Interface (SPI) */
+#define LF1000_SPI0_BASE	0xC0007800
+#define LF1000_SPI0_END		0xC0007844
+#define LF1000_SPI0_IRQ		12
+#define LF1000_SPI1_BASE	0xC0008000
+#define LF1000_SPI1_END		0xC0008044
+#define LF1000_SPI1_IRQ		39
+#define LF1000_SPI2_BASE	0xC0008800
+#define LF1000_SPI2_END		0xC0008844
+#define LF1000_SPI2_IRQ		40
+
+/* SD/MMC Controller */
+#define LF1000_SDIO0_BASE	0xC0009800
+#define LF1000_SDIO0_END	0xC0009FC4
+#define LF1000_SDIO0_IRQ	14
+#define LF1000_SDIO1_BASE	0xC000C800
+#define LF1000_SDIO1_END	0xC000CFC4
+#define LF1000_SDIO1_IRQ	42
+
+/* GPIO */
+#define LF1000_GPIO_BASE	0xC000A000
+#define LF1000_GPIO_END		0xC000A0E4
+#define LF1000_GPIO_IRQ		13
+
+/* Pulse Width Modulator (PWM) */
+#define LF1000_PWM_BASE		0xC000C000
+#define LF1000_PWM_END		0xC000C044
+
+/* AC97 and I2S (audio) */
+#define LF1000_AUDIO_BASE	0xC000D800
+#define LF1000_AUDIO_END	0xC000DBC8
+#define LF1000_AUDIO_IRQ	24
+
+/* I2C */
+#define LF1000_I2C0_BASE	0xC000E000
+#define LF1000_I2C0_END		0xC000E104
+#define LF1000_I2C0_IRQ		32
+#define LF1000_I2C1_BASE	0xC000E800
+#define LF1000_I2C1_END		0xC000E904
+#define LF1000_I2C1_IRQ		33
+
+/* CLOCK and POWER */
+#define LF1000_CLKPWR_BASE	0xC000F000
+#define LF1000_CLKPWR_END	0xC000F07F
+
+/* RTC controller */
+#define LF1000_RTC_BASE		0xC000F080
+#define LF1000_RTC_END		0xC000F097
+#define LF1000_RTC_IRQ		31
+
+/* IDCT Macro Block Decoder */
+#define LF1000_IDCT_BASE	0xC000F800
+#define LF1000_IDCT_END		0xC000FFC4
+
+/* GPIO drive current control registers */
+#define LF1000_GPIOCURRENT_BASE	0xC000F100
+#define LF1000_GPIOCURRENT_END	0xC000F11B
+
+/* MCU-Y Memory Controller */
+#define LF1000_MCU_Y_BASE	0xC0014800
+#define LF1000_MCU_Y_END	0xC0014811
+#define LF1000_MEMCFG		0x00
+#define LF1000_MEMTIME0		0x02
+#define LF1000_MEMTIME1		0x04
+#define LF1000_MEMREFRESH	0x08
+#define LF1000_MEMCONTROL	0x0A
+#define LF1000_MEMCLKDELAY	0x0C
+#define LF1000_MEMDQSOUTDELAY	0x0E
+#define LF1000_MEMDQSINDELAY	0x10
+
+/* MCU-S Memory Controller */
+#define LF1000_MCU_S_BASE	0xC0015800
+#define LF1000_MCU_S_END	0xC001587C
+
+/* UART */
+#define LF1000_UART0_BASE	0xC0016000
+#define LF1000_UART0_END	0xC0016044
+#define LF1000_UART0_IRQ	10
+#define LF1000_UART1_BASE	0xC0016080
+#define LF1000_UART1_END	0xC00160C4
+#define LF1000_UART1_IRQ	34
+#define LF1000_UART2_BASE	0xC0016800
+#define LF1000_UART2_END	0xC0016844
+#define LF1000_UART2_IRQ	35
+#define LF1000_UART3_BASE	0xC0016880
+#define LF1000_UART3_END	0xC00168C4
+#define LF1000_UART3_IRQ	36
+
+/* HDC (USB) */
+#define LF1000_UHC_BASE		0xC000D000
+#define LF1000_UHC_END		0xC000D0C8
+#define LF1000_UHC_IRQ		28
+
+/* UDC (USB) */
+#define LF1000_UDC_BASE		0xC0018000
+#define LF1000_UDC_END		0xC00188C8
+//#define LF1000_UDC_END		0xC0018880
+#define LF1000_UDC_IRQ		20
+
+/* Alive GPIO on LF1000 */
+#define LF1000_ALIVE_BASE	0xC0019000
+#define LF1000_ALIVE_END	0xC0019018
+
+/* 3D Engine Control (GA3D) */
+#define LF1000_GA3D_BASE	0xC001A000
+#define LF1000_GA3D_END		0xC001BFFF
+
+/* Processor ID (ECID) */
+#define LF1000_ECID_BASE	0xC001F800
+
+#define LF1000_3DGE_BASE	0xE0000000
+
+/* Extint 0-1 */
+#define	LF1000_EXTINT0		8
+#define	LF1000_EXTINT1		9
+
+///////////////////////////////// TIMER //////////////////////////////////////////////
+/* FIXME: this needs to go away, see timer.h */
+
+#ifndef	__ASSEMBLY__
+struct lf1000_timer {
+    volatile unsigned int	tmrcount;
+    volatile unsigned int	tmrmatch;
+    volatile unsigned int	tmrcontrol;
+    volatile unsigned int	tmrreserved[0x0d];
+    volatile unsigned int	tmrclkenb;
+    volatile unsigned int	tmrclkgen;
+};
+
+struct lf1000_timer_init {
+    struct lf1000_timer*	timer_pnt;
+    int			 	irq_number;
+};
+
+#endif
+
+//------------- SET ONLY THIS DEFINITIONS -------------//
+
+#define	TIMER_PLL		PLL1		/* timer clock source is PLL1 */
+
+#define	LF1000_SYS_TIMER	0		/* system   timer is TIMER0   */
+#define LF1000_SYS_TIMER_IRQ	LF1000_TIMER0_IRQ
+#define	LF1000_FREE_TIMER	1		/* free run timer is TIMER1   */
+
+#define LF1000_INTERTICK_TIMER	2		/* Time since SYS_TIMER tick  */
+						/* reset in SYS_TIMER isr     */
+
+#define	LF1000_INTERVAL_IN_USEC	(USEC_PER_SEC/HZ) /* system timer cycle */
+
+#define	TIMER_FREE_RUN		0xffffffff
+#define	CLKDIV			32		/* timer predivider */
+#define	SELTCLK			0x03		/* TCLK/1 */
+
+#define	SELTCLK_MASK		0x03 /*XXX: duplicate? */
+#define	CLKDIVR			((CLKDIV<1)?0:(CLKDIV>256)?255:(CLKDIV-1))
+
+#define	TIMER_DIV		((1<<((SELTCLK+1)&SELTCLK_MASK))*CLKDIV)
+#define TICKS_PER_mSEC		(get_pll_freq(TIMER_PLL)/TIMER_DIV/1000)
+#define TICKS_PER_uSEC          (get_pll_freq(TIMER_PLL)/TIMER_DIV/1000000)
+#define	TIMER_SYS_TICK	\
+	(TICKS_PER_mSEC * (LF1000_INTERVAL_IN_USEC / 1000 /* for mSec */))
+
+#define TIMER_INTERVAL		TIMER_SYS_TICK
+#define TIMER_RELOAD		(TIMER_INTERVAL)
+
+#define	TCLK_MAX_HZ		50000000	/* maximum allowed TCLK freq */
+
+#define	TIMER_PLL_OUT_HZ	((TIMER_PLL == PLL0)? PLL0_OUT_HZ:	\
+				 (TIMER_PLL == PLL1)? PLL1_OUT_HZ:	\
+							(TCLK_MAX_HZ+1))
+
+#if ((TIMER_PLL_OUT_HZ/TIMER_DIV) > TCLK_MAX_HZ)
+    #error	Maximum allowed Timer Frequency is 50 MHz !!!
+#endif
+
+#undef TIMER_PLL_OUT_HZ		// used just for checking max freq
+
+/////////////////////////////// FUNCTIONS /////////////////////////////////////
+
+#ifndef	__ASSEMBLY__
+// PLL
+extern void			lf1000_clock_init( void);
+extern int			lf1000_CalcDivider( unsigned int pll_khz,
+						   unsigned int desired_hz);
+extern unsigned int		get_pll_div( int pll,int fin_hz,int fout_hz);
+extern int			get_pll_freq( unsigned int pll);
+// CPU
+extern unsigned int		get_cpu_freq( void);
+extern void			calc_freq_ratio( unsigned long * loops);
+// Memory
+extern unsigned int		lf1000_is_shadow(void);
+// Timer
+extern struct lf1000_timer*	get_sys_timer_pnt( void);
+extern struct lf1000_timer*	get_timer_pnt( int timer);
+
+extern void			clear_timer_irq( int irq);
+extern int			get_timer_irq( int timer);
+extern unsigned long		get_timer_cnt( int timer);
+extern unsigned long		get_timer_match( int timer);
+//extern unsigned long		get_timer_div( int timer);
+extern int			get_timer_freq( int timer);
+extern unsigned int 		get_cpu_freq(void);
+extern void	 		set_cpu_freq(unsigned int hertz);
+
+// UART
+extern void			set_uart_baud( int uart, int baud);
+#endif
+
+#define MAX_TIMER                       2
+#define MAX_PERIOD                      699050
+
+#endif
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/power.h linux-2.6/arch/arm/mach-lf1000/include/mach/power.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/power.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/power.h	2011-03-08 14:52:57.000000000 -0800
@@ -0,0 +1,38 @@
+#ifndef _LF1000_POWER_H_
+#define _LF1000_POWER_H_
+
+/* default values */
+#define MAX_BATTERY_MV	8000		/* max expected battery value	*/
+#define LOW_BATTERY_MV	4200		/* low battery			*/
+#define LOW_BATTERY_REPEAT_MV 100	/* repeat every 100mv drop	*/
+/*
+ * Lower critical battery level below hardware shutoff,
+ * allowing play until you die.  Can still adjust level via
+ * /sys/devices/platform/lf1000-power/critical_battery_mv interface
+ */
+#define CRITICAL_BATTERY_MV 2000	/* critical low battery		*/
+
+/* Hysteresis low to normal Battery */
+#define NORMAL_BATTERY_MV   (LOW_BATTERY_MV + 400)
+
+enum lf1000_power_status {
+	UNKNOWN 		= 0,
+	EXTERNAL		= 1,	/* on external power */
+	BATTERY			= 2,	/* on battery power */
+	LOW_BATTERY		= 3,
+	CRITICAL_BATTERY	= 4,
+	NIMH			= 5,	/* on NIMH battery power   */
+	NIMH_CHARGER		= 6,	/* in NiMH battery charger */
+};
+
+enum lf1000_power_source {
+	POWER_UNKNOWN		= 0,	/* Unknown power source	*/
+	POWER_OTHER		= 1,	/* Unknown power source	*/
+	POWER_NIMH		= 2,	/* using NiMH battery */
+	POWER_NIMH_CHARGER	= 3,	/* in NiMH battery charger */
+	POWER_NIMH_EXTERNAL	= 4,	/* using NiMH with external power */
+	POWER_BATTERY		= 5,	/* standard battery */
+	POWER_EXTERNAL		= 6,	/* external power source */
+};
+	
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/pwm.h linux-2.6/arch/arm/mach-lf1000/include/mach/pwm.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/pwm.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/pwm.h	2011-01-04 14:10:40.000000000 -0800
@@ -0,0 +1,43 @@
+/* LF1000 Pulse Width Modulator (PWM) Driver 
+ *
+ * mach-lf1000/include/mach/pwm.h -- PWM API.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef LF1000_PWM_H
+#define LF1000_PWM_H
+
+#include <mach/platform.h>
+
+#define PWM_MAX_VALUE	0x3FF
+
+enum pwm_pol {
+	POL_INV		= 0,
+	POL_BYP 	= 1,
+	POL_INVALID	= 2,
+};
+
+enum pwm_chan {
+	PWM_CHAN0 = 0,
+	PWM_CHAN1,
+	PWM_CHAN2,
+	PWM_CHAN_INVALID,
+};
+
+enum pwm_clk {
+	PWM_CLK0 = 0,
+	PWM_CLK1,
+	PWM_CLK_INVALID,
+};
+
+int pwm_configure_pin(enum pwm_chan channel);
+int pwm_set_prescale(enum pwm_chan channel, u32 prescale);
+int pwm_set_polarity(enum pwm_chan channel, u8 polarity);
+int pwm_set_period(enum pwm_chan channel, u32 period);
+int pwm_set_duty_cycle(enum pwm_chan channel, u32 duty);
+int pwm_set_clock(u8 source, u8 div, u8 mode, u8 enable);
+int pwm_get_clock_rate(void);
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/pwm_hal.h linux-2.6/arch/arm/mach-lf1000/include/mach/pwm_hal.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/pwm_hal.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/pwm_hal.h	2011-03-10 10:44:58.000000000 -0800
@@ -0,0 +1,42 @@
+/* LF1000 Pulse Width Modulator (PWM) Driver
+ *
+ * pwm_hal.h -- PWM hardware abstraction.
+ *
+ * Scott Esters <sesters@leapfrog.com
+ */
+
+#ifndef PWM_HAL_H
+#define PWM_HAL_H
+
+/* registers, as offsets */
+#define PWM01PRES		0x00
+#define	PWM0DUTY		0x02
+#define PWM1DUTY		0x04
+#define PWM0PERIOD		0x06
+#define PWM1PERIOD		0x08
+#define PWM2PRES		0x10
+#define PWM2DUTY		0x12
+#define PWM2PERIOD		0x16
+#define PWMCLKENB		0x40
+#define PWMCLKGEN		0x44
+
+/* PWM PRESCALER0/1 REGISTER (PWM01PRES) */
+#define PWM1POL			15
+#define PWM1PRESCALE		8
+#define PWM0POL			7
+#define PWM0PRESCALE		0
+
+/* PWM PRESCALER 2 REGISTER (PWM2PRES) */
+#define PWM2POL			7
+#define PWM2PRESCALE		0
+
+/* PWM CLOCK ENABLE REGISTER (PWMCLKENB) */
+#define PWMPCLKMODE		3
+#define PWMCLKGENENB		2
+
+/* PWM CLOCK GENERATE REGISTER (PWMCLKGEN) */
+#define PWMCLKDIV		4
+#define PWMCLKSRCSEL		1
+
+#endif
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/screen.h linux-2.6/arch/arm/mach-lf1000/include/mach/screen.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/screen.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/screen.h	2011-01-04 14:48:19.000000000 -0800
@@ -0,0 +1,38 @@
+/*
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * Describe platform screen modules and provide information on the system's
+ * screen.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#ifndef __LF1000_SCREEN_H__
+#define __LF1000_SCREEN_H__
+
+struct lf1000_screen_info {
+	const char *name;
+	u16 xres;
+	u16 yres;
+
+	u32 clk_hz;
+
+	/* horizonal sync */
+	u16 hsw;	/* sync width */
+	u16 hfp;	/* front porch */
+	u16 hbp;	/* back porch */
+
+	/* vertical sync */
+	u16 vsw;	/* sync width */
+	u16 vfp;	/* front porch */
+	u16 vbp;	/* back porch */
+};
+
+struct lf1000_screen_info *lf1000_get_screen_info(void);
+void lf1000_dpc_enable_int(bool en);
+bool lf1000_dpc_int_pending(void);
+void lf1000_dpc_clear_int(void);
+
+#endif /* __LF1000_SCREEN_H__ */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/serial_reg-lf1000.h linux-2.6/arch/arm/mach-lf1000/include/mach/serial_reg-lf1000.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/serial_reg-lf1000.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/serial_reg-lf1000.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,352 @@
+/*
+ * mach-lf1000/include/mach/serial_reg-lf1000.h
+ *
+ * Redistribution of this file is permitted under the terms of the GNU 
+ * Public License (GPL)
+ * 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#ifndef _LINUX_SERIAL_REG_H
+#define _LINUX_SERIAL_REG_H
+
+/*
+ * DLAB=0
+ */
+#define UART_FSR	0x0c	/* fifo status reg */
+  #define UART_FSR_TX_FIFO_COUNT_MASK	0xf0	/* fifo count reg mask */
+  #define UART_FSR_RX_FIFO_COUNT_MASK	0x0f	/* fifo count reg mask */
+// next byte UART_FSR+1
+  #define UART_FSR_TX_FIFO_FULL		0x2	/* fifo status reg */
+  #define UART_FSR_RX_FIFO_FULL		0x1	/* fifo status reg */
+
+#define UART_RX		0x12	/* In:  Receive buffer */
+#define UART_TX		0x10	/* Out: Transmit buffer */
+
+#define UART_IER	0x18	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x80 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x20 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x10 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x20 /* Enable receiver data interrupt */
+
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+//#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+#define UART_IIR	0x18	/* In:  Interrupt ID Register */
+//#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+//#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+
+/* No interrupts pending */
+#define UART_IIR_MASK_INT	( UART_IIR_MSI | UART_IIR_ERRPEND | UART_IIR_RDI | UART_IIR_THRI)
+//#define UART_IIR_MASK_INT	( UART_IIR_RDI | UART_IIR_ERRPEND)
+
+#define UART_IIR_MSI		0x08 /* Modem status interrupt */
+#define UART_IIR_ERRPEND	0x04 /* Receiver line status interrupt */
+#define UART_IIR_RDI		0x02 /* Receiver data interrupt */
+#define UART_IIR_THRI		0x01 /* Transmitter holding register empty */
+
+#define	CLR_IIR_THRI()		{ serial_outp( up, UART_IIR, (serial_inp( up, UART_IIR) & ~UART_IIR_MASK_INT) | UART_IIR_THRI); serial_outp(up, UART_LCR, serial_inp( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);}
+
+#define	CLR_IIR_RDI()		{ serial_outp( up, UART_IIR, (serial_inp( up, UART_IIR) & ~UART_IIR_MASK_INT) | UART_IIR_RDI); serial_outp(up, UART_LCR, serial_inp( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);}
+
+#define	CLR_IIR_MSI_ERR()	{ serial_outp( up, UART_IIR, (serial_inp( up, UART_IIR) & ~UART_IIR_MASK_INT) | UART_IIR_MSI | UART_IIR_ERRPEND); serial_outp(up, UART_LCR, serial_inp( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);}
+
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+//#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_04	0x10
+#define UART_FCR_R_TRIG_08	0x20
+#define UART_FCR_R_TRIG_12	0x30
+
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_04	0x40
+#define UART_FCR_T_TRIG_08	0x80
+#define UART_FCR_T_TRIG_12	0xc0
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+#define UART_LCR	0	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+//#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+//#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SYNC_PENDCLR	0x80 /* Stick parity (?) */
+#define UART_LCR_SPAR		0x10 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x08 /* Even parity select */
+#define UART_LCR_PARITY		0x20 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+#define UART_CR		2	/* Control Register */
+#define UART_CR_SBC		0x10 /* Set break control */
+
+#define UART_MCR	6	/* Out: Modem Control Register */
+//#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+//#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+//#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x10 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+//#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+//#define UART_MCR_OUT2		0x08 /* Out2 complement */
+//#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x01 /* RTS complement */
+#define UART_MCR_DTR		0x02 /* DTR complement */
+
+#define UART_TRSR	0x08	/* In:  Line Status Register */
+#define UART_TRSR_TEMT		0x04 /* Transmitter empty */
+#define UART_TRSR_THRE		0x02 /* Transmit-hold-register empty */
+#define UART_TRSR_DR		0x01 /* Receiver data ready */
+
+#define UART_LSR	0x0a	/* In:  Line Status Register */
+//#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+//#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x08 /* Break interrupt indicator */
+#define UART_LSR_FE		0x04 /* Frame error indicator */
+#define UART_LSR_PE		0x02 /* Parity error indicator */
+#define UART_LSR_OE		0x01 /* Overrun error indicator */
+//#define UART_LSR_DR		0x01 /* Receiver data ready */
+
+#define UART_MSR	0x0e	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x08 /* Data Carrier Detect */
+#define UART_MSR_RI		0x04 /* Ring Indicator */
+#define UART_MSR_DSR		0x02 /* Data Set Ready */
+#define UART_MSR_CTS		0x01 /* Clear to Send */
+#define UART_MSR_DDCD		0x80 /* Delta DCD */
+#define UART_MSR_TERI		0x40 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x20 /* Delta DSR */
+#define UART_MSR_DCTS		0x10 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+//#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO treshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO treshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO treshold = 32 */
+
+
+
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Register
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Transmitter disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+
+#endif /* _LINUX_SERIAL_REG_H */
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/system.h linux-2.6/arch/arm/mach-lf1000/include/mach/system.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/system.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/system.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,52 @@
+/*
+ *  mach-lf1000/include/mach/system.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	/*XXX: this doesn't apply */
+#if 0
+	u32 val;
+
+	val = __raw_readl(IO_ADDRESS(LF1000_SYS_RESETCTL)) & ~0x7;
+	val |= 0x105;
+
+	__raw_writel(0xa05f, IO_ADDRESS(LF1000_SYS_LOCK));
+	__raw_writel(val, IO_ADDRESS(LF1000_SYS_RESETCTL));
+	__raw_writel(0, IO_ADDRESS(LF1000_SYS_LOCK));
+#endif
+}
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/timer.h linux-2.6/arch/arm/mach-lf1000/include/mach/timer.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/timer.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/timer.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,34 @@
+/* 
+ * asm/arch-lf1000/timer.h -- Timer hardware abstraction.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef _LF1000_TIMER_H
+#define _LF1000_TIMER_H
+
+/* Timer n Registers (offsets from LF1000_TIMERn_BASE) */
+#define TMRCOUNT	0x00
+#define TMRMATCH	0x04
+#define TMRCONTROL	0x08
+#define TMRCLKENB	0x40
+#define TMRCLKGEN	0x44
+
+/* Timer Control Register n (TMRCONTROLn) */
+#define LDCNT		6
+#define INTPEND		5
+#define INTENB_T	4 /*  added _T to differentiate from INTENB reg! */
+#define RUN		3
+#define WDENB		2
+#define SETCLK		0
+
+/* Timer Clock Generation Enable Register n (TMRCLKENBn) */
+#define TCLKMODE	3
+#define TCLKGENENB	2 /* added T to differentiate from others */
+
+/* Timer Clock Generation Control Register n (TMRCLKGENn) */
+#define TCLKDIV		4 /* added T to differentiate from others */
+#define TCLKSRCSEL	1
+
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/timex.h linux-2.6/arch/arm/mach-lf1000/include/mach/timex.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/timex.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/timex.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,26 @@
+/*
+ *  mach-lf1000/include/mach/timex.h
+ *
+ *  LF1000 architecture timex specifications
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	CONFIG_ARCH_LF1000
+    #include <mach/platform.h>
+    #define CLOCK_TICK_RATE		PLL0_OUT*1000	/* from KHz to Hz */
+#else
+    #define CLOCK_TICK_RATE		(50000000 / 16)
+#endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/uart.h linux-2.6/arch/arm/mach-lf1000/include/mach/uart.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/uart.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/uart.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,163 @@
+/* LF1000 UART Driver
+ *
+ * mach-lf1000/include/mach/uart.h -- UART hardware abstraction, settings.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+#ifndef LF1000_UART_H
+#define LF1000_UART_H
+
+#include <mach/platform.h>	/* for CPU variant */
+
+/*
+ * clock source
+ */
+#define UART_PLL	PLL1
+
+/*
+ * available ports
+ */
+#define UART0		0
+#define UART1		1
+#define UART2		2
+#define UART3		3
+#define UART4		4
+#define UART5		5
+#define UART_MAX	6
+
+/*
+ * Settings:
+ *
+ * - LF1000_SYS_UART is the UART number, LF1000_SYS_UART_BASE is the base 
+ *   address, LF1000_SYS_UART_IRQ is the IRQ number.  These are required.
+ * - define LF1000_SYS_UART_TX_PORT or LF1000_SYS_UART_RX_PORT if a mode change
+ *   is required, then:
+ * - define LF1000_SYS_UART_TX_PIN or LF1000_SYS_UART_RX_PIN as the bit 
+ *   position in the ALTFNn register, for ALTFN1 this is (pin*2-32), for ALTFN0
+ *   it is (pin*2)
+ * - define LF1000_SYS_UART_TX_MODE or LF1000_SYS_UART_RX_MODE to set the mode
+ */
+#define LF1000_SYS_UART		UART0
+#define LF1000_SYS_UART_BASE	LF1000_UART0_BASE
+#define LF1000_SYS_UART_IRQ     LF1000_UART0_IRQ
+/* set up pin functions: */
+#define LF1000_SYS_UART_TX_PORT	GPIOAALTFN0 /* change TX pin mode */
+#define LF1000_SYS_UART_TX_PIN	(8*2)
+#define LF1000_SYS_UART_TX_MODE	GPIO_ALT1
+/* nothing needs to be done for RX pin */
+#define LF1000_SYS_UART_BR	115200	/* system baud rate */
+
+/*
+ * UART helper macros
+ */
+
+/* (for bootloaders, where we don't calculate the divider) */
+#define UARTDIV			40
+
+/* calculate baud rate from registers */
+#define	UART_BRD(pll, brate)	\
+	((get_pll_freq(pll)/1000*(500*PLL_MUL(pll))/((brate)*16))-1)
+
+/* 
+ * UART registers, offsets from LF1000_UARTn_BASE where n is the channel set
+ * by the LF1000_SYS_UART macro.
+ */
+#define LCON			0x00
+#define UCON			0x02
+#define FCON			0x04
+#define MCON			0x06
+#define TRSTATUS		0x08
+#define ESTATUS			0x0A
+#define FSTATUS			0x0C
+#define MSTATUS			0x0E
+#define THB			0x10
+#define RHB			0x12
+#define BRD			0x14
+#define TIMEOUTREG		0x16
+#define INTSTATUSREG		0x18
+#define UARTCLKENB		0x40
+#define UARTCLKGEN		0x44
+
+/*
+ * UART Register bits
+ */
+
+/* LCON Register */
+#define SYNC_PENDCLR		7
+#define SIR_MODE		6
+#define PARITY_MODE		3
+#define STOPBIT			2
+#define WORD_LEN		0
+
+/* UCON Register */
+#define TX_INT			9
+#define RX_INT			8
+#define RX_TIMEOUT		7
+#define RX_ERRSTATUS		6
+#define LOOPBACK_MODE		5
+#define SEND_ BREAK		4
+#define TRANS_MODE		2
+#define RECEIVE_MODE		0
+
+/* FCON Register */
+#define TX_FIFO_TRIGGER		6
+#define RX_FIFO_TRIGGER		4
+#define TX_FIFO_RESET		2
+#define RX_FIFO_RESET		1
+#define FIFO_EN			0
+
+/* MCON Register */
+#define HALF_CH_ENB		7
+#define SCRXENB			6
+#define SCTXENB			5
+#define AFC			4
+#define DTR_ACTIVE		1
+#define RTS_ACTIVE		0
+
+/* FSTATUS Register */
+#define RX_FIFO_ERROR		10
+#define TX_FIFO_FULL		9
+#define RX_FIFO_FULL		8
+#define TX_FIFO_COUNT		4
+#define RX_FIFO_COUNT		0
+
+/* TRSTATUS */
+#define TRANSMITTER_EMPTY	2
+#define	TRANSMIT_BUFFER_EMPTY	1
+#define RECEIVE_BUFFER_DATA_READY	0
+
+/* UARTCLKENB */
+#define UARTCLKGENENB		2
+
+/* UARTCLKGEN */
+#define UARTCLKDIV		4
+#define UARTCLKSRCSEL		1
+
+#ifndef	__ASSEMBLY__
+struct lf1000_uart {
+    volatile unsigned short	lcon;
+    volatile unsigned short	ucon;
+    volatile unsigned short	fcon;
+    volatile unsigned short	mcon;
+    volatile unsigned short	trstatus;
+    volatile unsigned short	estatus;
+    volatile unsigned short	fstatus;
+    volatile unsigned short	mstatus;
+    volatile unsigned short	thb;
+    volatile unsigned short	rhb;
+    volatile unsigned short	brd;
+    volatile unsigned short	timeoutreg;
+    volatile unsigned short	intstatusreg;
+    volatile unsigned char	reserved1[0x26];
+    volatile unsigned int	uartclkenb;
+    volatile unsigned int	uartclkgen;
+};
+
+struct lf1000_uart_init {
+    struct lf1000_uart*		uart_pnt;
+    int			 	irq_number;
+};
+#endif
+
+#endif /* LF1000_UART_H */
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/uncompress.h linux-2.6/arch/arm/mach-lf1000/include/mach/uncompress.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/uncompress.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/uncompress.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,46 @@
+/*
+ *  mach-lf1000/include/mach/uncompress.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <asm/io.h>
+#include <mach/uart.h>
+
+static void flush(void)
+{
+}
+
+static void putc(int c)
+{
+	if(readw(LF1000_SYS_UART_BASE+FCON) & (1<<FIFO_EN)) { 
+		/* FIFO enabled */
+		while(readw(LF1000_SYS_UART_BASE+FSTATUS) & 
+				(1<<TX_FIFO_FULL)) {
+			barrier();
+		}
+	} else { /* FIFO disabled */
+		while(!(readw(LF1000_SYS_UART_BASE+TRSTATUS) &
+				(1<<TRANSMITTER_EMPTY))) {
+			barrier();
+		}
+	}
+	writeb(c, LF1000_SYS_UART_BASE+THB);
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/include/mach/vmalloc.h linux-2.6/arch/arm/mach-lf1000/include/mach/vmalloc.h
--- linux-2.6.31/arch/arm/mach-lf1000/include/mach/vmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/include/mach/vmalloc.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,21 @@
+/*
+ *  mach-lf1000/include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(PAGE_OFFSET + 0x18000000)
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/Kconfig linux-2.6/arch/arm/mach-lf1000/Kconfig
--- linux-2.6.31/arch/arm/mach-lf1000/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/Kconfig	2011-01-04 15:06:55.000000000 -0800
@@ -0,0 +1,146 @@
+if ARCH_LF1000
+menu "LF1000 platform type"
+
+choice
+	prompt "LeapFrog development board"
+	default MACH_LF_LF1000
+
+config MACH_ME_LF1000
+	bool "Support MagicEyes platform                    (ME board / LF1000  cpu)"
+	help
+	  Include support for the MagicEyes platform (ME board / LF1000  cpu).
+
+config MACH_LF_LF1000
+	bool "Support LeapFrog(R) LF1000 platform     (LF board / LF1000  cpu)"
+	help
+	  Include support for the LeapFrog(R) LF1000 platform (LF board / LF1000  cpu).
+
+endchoice
+
+choice
+	prompt "CPU speed"
+	default CPU_SPEED_393216000
+
+config CPU_SPEED_385024000
+	bool "385.024 Mhz"
+	help
+	  Older CPU speed.
+
+config CPU_SPEED_393216000
+	bool "393.216 Mhz"
+	help
+	  Standard CPU speed.
+
+config CPU_SPEED_532480000
+	bool "532.480 Mhz"
+	help
+	  Requires higher CPU Core voltage
+endchoice
+
+config LF1000_SCREEN
+	bool "Support for configurable LCD modules (screens)"
+	depends on ARCH_LF1000 && (FB_LF1000 || FB_LF1000_MODULE)
+	default y
+	---help---
+	This option enables platform support for LCD modules, including display
+	controller initialization.  IF you are using the LF1000 frame buffer,
+	say Y.
+
+config LF1000_DMA_CONTROLLER
+	bool "Support for the DMA controller in the LF1000 SoC"
+	depends on ARCH_LF1000 && !LF1000_DMA
+	default n
+	---help---
+	This option enables platform support for the DMA controller in the
+	LF1000 SoC.  If your drivers need DMA support, say Y.
+
+config LF1000_LFP100
+	bool "Support for the LFP100 audio/power/backlight chip"
+	depends on ARCH_LF1000
+	default y
+	---help---
+	This option enables platform support for the LF-P100 combination
+	chip.  It is checked at runtime.  If you are unsure, say Y.
+
+config LF1000_GPIO
+       tristate "Device driver for LF1000 General Purpose IO"
+       depends on ARCH_LF1000
+       ---help---
+       This option enables device driver support for LF1000 General Purpose IO. If unsure, say Y.
+
+config LF1000_GPIO_DEBUG
+	bool "Debugging for LF1000 General Purpose IO Driver"
+	depends on ARCH_LF1000 && LF1000_GPIO
+	default n
+	---help---
+	This option enables additional debugging for the LF1000 GPIO Driver.
+	If unsure, say N.
+
+config LF1000_ADC
+	bool "Device driver for LF1000 analog to digital converter"
+	depends on ARCH_LF1000 && LF1000_GPIO
+	default y
+	---help---
+	This option enables device driver support for the LF1000 analog to
+	digital converter.  If unsure, say Y.
+
+config LF1000_SDRAM_TUNE
+	bool "Enable sysfs entries for SDRAM tuning"
+	depends on ARCH_LF1000
+	default n
+	---help---
+	This option enables the SYSFS MCU_Y entries for tuning SDRAM access.
+
+config LF1000_BOOT_PARAMS_ADDR
+	hex "Address where kernel finds its boot parameters"
+	depends on ARCH_LF1000
+	default 0x00003000
+	---help---
+	Sets option sets the address where the kernel expects to find its boot
+	parameters at initialization time.  They are placed there by the 
+	bootstrap loader.  Only change this if you know what you're doing (and
+	are recompiling and bootloader as well)!
+
+config LF1000_OVERRIDE_BOARD_ID
+        bool "Override Board ID"
+        ---help---
+        Override Board hardware ID
+
+config LF1000_OVERRIDE_BOARD_ID_VALUE
+	int "Override value"
+	depends on LF1000_OVERRIDE_BOARD_ID
+	default 0
+	---help---
+	Selected Board override value
+
+config LF1000_OVERRIDE_CARTRIDGE_ID
+        bool "Override Cartridge ID"
+        ---help---
+        Override Cartridge ID
+
+config LF1000_OVERRIDE_CARTRIDGE_ID_VALUE
+	int "Override value"
+	depends on LF1000_OVERRIDE_CARTRIDGE_ID
+	default 7
+	---help---
+	Selected  Cartridge override value
+
+config LF1000_STRESS_TEST
+	bool "Enable LF1000 stress testing"
+	depends on ARCH_LF1000
+	default n
+	---help---
+	Activates instrumented code which is used to validate the robustness
+	of the platform.  Example tests include inopportune power failures and
+	spontaneous peripheral disconnects.  In addition to this master switch,
+	individual tests must be activated in the appropriate sub-menus.  This
+	option also creates sysfs entries in
+	/sys/devices/platform/lf1000-gpio/stress/
+	which control the mapping of GPIO pins to stress test functions (e.g.,
+	to cut power, assert GPIOB[5]).
+
+	You do not want this, say N.
+
+endmenu
+
+endif
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/lf1000.c linux-2.6/arch/arm/mach-lf1000/lf1000.c
--- linux-2.6.31/arch/arm/mach-lf1000/lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/lf1000.c	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,48 @@
+/*
+ *  arch/arm/mach-lf1000/lf1000.c
+ *
+ *      Copyright (C) 2007 Kosta Demirev <kdemirev@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/core.h>
+#include <plat/irq.h>
+
+static void __init lf1000_init_irq(void)
+{
+	mes_irq_init(__io(IO_ADDRESS(LF1000_IC_BASE)));
+}
+
+MACHINE_START(DIDJ, "ARM-LF1000")
+	.phys_io	= LF1000_SYS_IO,
+	.io_pg_offst	= (IO_ADDRESS(LF1000_SYS_IO) >> 18) & 0xfffc,
+	.boot_params	= CONFIG_LF1000_BOOT_PARAMS_ADDR,
+	.map_io		= lf1000_map_io,
+	.init_irq	= lf1000_init_irq,
+	.timer		= &lf1000_timer,
+	.init_machine	= lf1000_init,
+MACHINE_END
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/lf1000_core_func.c linux-2.6/arch/arm/mach-lf1000/lf1000_core_func.c
--- linux-2.6.31/arch/arm/mach-lf1000/lf1000_core_func.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/lf1000_core_func.c	2011-01-04 14:56:42.000000000 -0800
@@ -0,0 +1,327 @@
+/* arch/arm/mach-lf1000/lf1000_core_func.c
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/uart.h>
+#include <mach/timer.h>
+#include <mach/clkpwr.h>
+#include <mach/nand.h>
+
+//#define MAKE_PLL_LIST	// define when building a list of popular PLL freqs
+
+#define	PRECISION	4096	// scale partial results to preserve precision
+/*
+ * macro calculating frequency out
+ *    PRECISION       -- simulate fixed-point math
+ *    MP()            -- frequency out
+ *    m               -- main divider
+ *    p               -- pre divider
+ *    s               -- post scaler
+ *    mpll            -- pll multiplier
+ *    				=1 for LF1000 PLLs
+ */
+
+#define	MP( m, p, s, mpll) ((PRECISION*mpll*m)/(p*(1<<s)))
+
+/* macros to build PLL register */
+#define PLL0_REG( m, p, s) \
+	(((unsigned int)(m) << MDIV_0) | \
+	 ((unsigned int)(p) << PDIV_0) | \
+	 ((unsigned int)(s) << SDIV_0))
+
+#define PLL1_REG( m, p, s) \
+	(((unsigned int)(m) << MDIV_1) | \
+	 ((unsigned int)(p) << PDIV_1) | \
+	 ((unsigned int)(s) << SDIV_1))
+
+#define PLL2_REG( m, p, s) \
+	(((unsigned int)(m) << MDIV_2) | \
+	 ((unsigned int)(p) << PDIV_2) | \
+	 ((unsigned int)(s) << SDIV_2))
+
+/*
+ * get_pll_div()
+ *
+ * Determine PLL divisor register setting given the pll, frequency in hz,
+ * and frequency out in hz.  The PLL is set by adjusting 3 variables, a
+ * pre-divider 'p', a master dividor 'm', and a scaler 's'.
+ * 
+ * This routine first checks to see if the best PLL setting has already been
+ * calculated previously, otherwise it loops through all possible settings to
+ * find the best match.
+ 
+ * There are two frequency calculations.  The first describes the LF1000 PLL0
+ * and PLL1 operation
+ *     PLL Frequency = ( m * frequency_in ) / ( p * 2^s )
+ */
+
+unsigned int __init get_pll_div( int pll, int fin_hz, int fout_hz)
+{
+	unsigned int fin_khz = fin_hz / 1000;
+	unsigned int fout_khz = fout_hz / 1000;
+	
+	/*
+	 * rewrite the frequency out equation as a ratio:
+	 *   (frequency_out)/(frequency_in) = (mpll * m) / (p*(2^s))
+	 */
+
+	unsigned int fratio = (PRECISION * fout_khz / fin_khz);	// actual ratio
+
+	// initialize, assuming first choice is the best
+	unsigned int mdiv = MIN_MDIV;
+	unsigned int pdiv = MIN_PDIV;
+	unsigned int sdiv = SDIV_HZ(pll, fout_hz);		// select post-scaler
+	unsigned int mpll = PLL_MUL(pll);			// pll multiplier (1/2)
+	unsigned int mdiff = MP( pdiv, mdiv, sdiv, mpll );
+
+	unsigned int m = 0;
+	unsigned int p = 0;
+	unsigned int diff = 0;
+
+#ifndef MAKE_PLL_LIST
+	/*
+	 * Check popular PLL frequency settings before looping through all
+	 * possible combinations of 'p' and 'm'. Return if found.
+	 */
+
+	if (fout_hz == 144000000 && fin_hz == 27000000)
+	       	return(PLL0_REG( 64,  3, 2));
+	if (fout_hz == 147000000 && fin_hz == 27000000)
+	       	return(PLL0_REG(196,  9, 2));
+	if (fout_hz == 393216000 && fin_hz == 27000000)
+		return(PLL0_REG(801, 55, 0));
+	if (fout_hz == 532480000 && fin_hz == 27000000)
+		return(PLL0_REG(355, 18, 0));
+#endif
+
+	/* Loop through all settings for 'p' and 'm' saving the best match */
+	for(p=MIN_PDIV; p<(MAX_PDIV+1); p++) {
+		for(m=MIN_MDIV; m<(MAX_MDIV+1); m++) {
+			// see if this is a better setting
+			if((diff = abs(fratio - MP(m,p,sdiv,mpll))) < mdiff) {
+				mdiff = diff;
+				mdiv = m;
+				pdiv = p;
+			}
+		}
+	}
+
+
+#ifdef MAKE_PLL_LIST
+	// uncomment when building up list of popular frequencies
+	printk(KERN_INFO "%s   pll=%d, fin_hz=%d, fout_hz=%d\n", __FUNCTION__,
+		pll, fin_hz, fout_hz);
+	printk(KERN_INFO "%s   mdiv=%d, pdiv=%d, sdiv=%d\n", __FUNCTION__,
+		mdiv, pdiv, sdiv);
+#endif
+
+	/* construct the PLL register setting */
+	return(PLL0_REG(mdiv,pdiv,sdiv));
+}
+
+/* 
+ * Returns PLL frequency in Hz, or -1 if an invalid PLL number is specified. 
+ * On the LF1000, there are two PLLs, 0 and 1.  The formula for PLL Frequency
+ * for them is:
+ *
+ *  F = (MDIV*CRYSTAL_FREQ_HZ)/(PDIV*(1<<SDIV))
+ *
+ *  Rewritten, to avoid overflowing 32 bits it is:
+ *
+ *  F = (((CRYSTAL_FREQ_HZ)/PDIV)/(1<<SDIV))*MDIV
+ */
+
+int get_pll_freq(unsigned int pll)
+{
+	u32 tmp, p, m, s;
+	
+	if(pll >= NUM_PLLS)
+		return -1;
+
+	tmp = REG32(IO_ADDRESS(LF1000_CLKPWR_BASE+PLLSETREG0+pll*sizeof(u32)));
+
+	p = ((tmp>>PDIV_0) & BIT_MASK_ONES((24-PDIV_0)));
+	m = ((tmp>>MDIV_0) & BIT_MASK_ONES((PDIV_0-MDIV_0)));
+	s = ((tmp>>SDIV_0) & BIT_MASK_ONES((MDIV_0-SDIV_0)));
+
+	return ((((CRYSTAL_FREQ_HZ)/p)/(1<<s))*m);
+}
+EXPORT_SYMBOL(get_pll_freq);
+
+/* returns freq in Hz */
+unsigned int get_cpu_freq( void)
+{
+	return ((get_pll_freq((clock_p->clkmodereg >> 4) & 0x03))/
+		((ioread32(&clock_p->clkmodereg) & 0x0f)+1));
+}
+EXPORT_SYMBOL(get_cpu_freq);
+
+void calc_freq_ratio(unsigned long * loops)
+{
+#define	SCALE	(10)
+
+	*loops = ((*loops)*(get_cpu_freq()/(get_timer_freq(LF1000_FREE_TIMER)>>SCALE)))>>SCALE;
+}
+///////////////////////// Timer init ///////////////////////////////
+static struct lf1000_timer_init init_lf1000_timers[] = {
+	{
+		(struct lf1000_timer*)IO_ADDRESS(LF1000_TIMER0_BASE), 
+		LF1000_TIMER0_IRQ
+	},
+	{
+		(struct lf1000_timer*)IO_ADDRESS(LF1000_TIMER1_BASE), 
+		LF1000_TIMER1_IRQ
+	},
+	{
+		(struct lf1000_timer*)IO_ADDRESS(LF1000_TIMER2_BASE), 
+		LF1000_TIMER2_IRQ
+	},
+	{
+		(struct lf1000_timer*)IO_ADDRESS(LF1000_TIMER3_BASE),
+		LF1000_TIMER3_IRQ
+	},
+	{
+		(struct lf1000_timer*)IO_ADDRESS(LF1000_TIMER4_BASE), 
+		LF1000_TIMER4_IRQ
+	},
+};
+
+////////////////////// NON INIT functions ////////////////////////////
+struct lf1000_timer* get_timer_pnt( int timer)
+{
+	if(timer >= ARRAY_SIZE(init_lf1000_timers)) 
+		return NULL;
+	return init_lf1000_timers[timer].timer_pnt;
+}
+
+/* returns timer freq in Hz */
+int get_timer_freq( int timer)
+{
+	struct lf1000_timer* timer_p = get_timer_pnt( timer);
+	unsigned int divider;
+
+	if( timer >= ARRAY_SIZE( init_lf1000_timers)) return 0;
+
+	// transform TC=div 0; TC/2=div 1; TC/4 = div 2; TC/8 = div 3
+	
+	/* get SELTCLK and transform it */
+	divider = (1<<((ioread32(&timer_p->tmrcontrol)+1) & 0x03));
+	/* get CLKDIV */
+	divider *= ((ioread32(&timer_p->tmrclkgen)>>4) & 0xff)+1;
+
+	return ((get_pll_freq((ioread32(&timer_p->tmrclkgen) > 1) & 0x03))/divider);
+}
+
+int get_timer_irq( int timer)
+{
+	if(timer >= ARRAY_SIZE( init_lf1000_timers)) 
+		return 0;
+	return init_lf1000_timers[timer].irq_number;
+}
+
+void clear_timer_irq( int irq)
+{
+int i;
+
+	for( i=0; i<ARRAY_SIZE( init_lf1000_timers); i++)
+	if( irq == init_lf1000_timers[i].irq_number) {
+		iowrite32( ioread32(&init_lf1000_timers[i].timer_pnt->tmrcontrol) | (1<<INTPEND),
+			  &init_lf1000_timers[i].timer_pnt->tmrcontrol);
+	}
+}
+
+/*
+ * get_timer_cnt() -- return number of ticks since last interrupt
+ * The LF1000 timer is an up counter, but zeros automaticly when
+ * the match value is reached.
+ */
+
+unsigned long get_timer_cnt( int timer)
+{
+struct lf1000_timer* timer_p = get_timer_pnt( timer);
+unsigned int tmrcontrol, tmrcount;
+
+	if (!timer_p) return -1;	// timer does not exist
+
+	tmrcontrol = ioread32(&timer_p->tmrcontrol);
+	tmrcontrol &= ~(1<<INTPEND);	// do not clear pend
+	tmrcontrol |=  (1<<LDCNT);	// latch count
+	iowrite32( tmrcontrol, &timer_p->tmrcontrol);
+	tmrcount = ioread32(&timer_p->tmrcount);
+	return(tmrcount);
+}
+
+int read_current_timer(unsigned long *timer_value)
+{
+	*timer_value = get_timer_cnt( LF1000_FREE_TIMER);
+	return 0;
+}
+
+unsigned long get_timer_match( int timer)
+{
+struct lf1000_timer* timer_p = get_timer_pnt( timer);
+
+	return ioread32(&timer_p->tmrmatch);
+}
+
+///////////////////////// UART init ///////////////////////////////
+
+static struct lf1000_uart_init __initdata init_lf1000_uarts[] = {
+	{
+		(struct lf1000_uart*)IO_ADDRESS(LF1000_UART0_BASE), 
+		LF1000_UART0_IRQ
+	},
+	{
+		(struct lf1000_uart*)IO_ADDRESS(LF1000_UART1_BASE), 
+		LF1000_UART1_IRQ
+	},
+	{ 
+		(struct lf1000_uart*)IO_ADDRESS(LF1000_UART2_BASE), 
+		LF1000_UART2_IRQ
+	},
+	{ 
+		(struct lf1000_uart*)IO_ADDRESS(LF1000_UART3_BASE), 
+		LF1000_UART3_IRQ
+	},
+};
+
+static struct lf1000_uart* __init get_uart_pnt( int uart)
+{
+	if(uart >= ARRAY_SIZE(init_lf1000_uarts)) return NULL;
+	return init_lf1000_uarts[uart].uart_pnt;
+}
+
+void __init set_uart_baud( int uart, int baud)
+{ 
+
+	struct lf1000_uart* uart_p = get_uart_pnt( uart);
+	iowrite32((UART_BRD( UART_PLL, baud)<<4)+(UART_PLL<<1), 
+			&uart_p->uartclkgen);
+	iowrite16(1, &uart_p->brd);
+}
+
+/*
+ * helper routines that dynamicly adjust for NOR / NAND boot
+ */
+
+unsigned int lf1000_is_shadow(void)
+{
+	void __iomem *addr = (void __iomem *)IO_ADDRESS(LF1000_MCU_S_BASE + NFCONTROL);
+
+	return !!(readl(addr) & (1<<NFBOOTENB));
+}
+EXPORT_SYMBOL(lf1000_is_shadow);
+
+/* return location of SDRAM based on shadow bit setting */
+unsigned int lf1000_get_phys_offset(void)
+{
+	return lf1000_is_shadow() ? PHYS_OFFSET_SHADOW : PHYS_OFFSET_NO_SHADOW;
+}
+EXPORT_SYMBOL(lf1000_get_phys_offset);
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/lfp100.c linux-2.6/arch/arm/mach-lf1000/lfp100.c
--- linux-2.6.31/arch/arm/mach-lf1000/lfp100.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/lfp100.c	2011-03-03 11:17:24.000000000 -0800
@@ -0,0 +1,695 @@
+/*
+ * LeapFrog LFP100 device driver
+ *
+ * Written by Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * The LFP100 chip haves codec, LCD backlight, and power functions in a
+ * single package.  Chip support is here with addtional functionality
+ * in the respective hwmon, sound/soc, and video driver directories.
+ *
+ * Place shared code here for all I2C access.  Cache the I2C registers, like
+ * in the sound driver codecs.  Provide access via private getter/setter calls
+ * and sysfs hooks.  Monitor register changes via IRQ, read_reg and write_reg
+ * routines.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/sysfs.h>
+
+#include <mach/gpio.h>
+#include <mach/lfp100.h>
+
+struct lfp100_chip {
+	wait_queue_head_t wait;
+	spinlock_t lock;
+	struct work_struct lfp100_work;		/* task			*/
+	struct workqueue_struct *lfp100_tasks;	/* workqueue		*/
+	bool	have_lfp100;			/* 1 = found chip	*/
+	bool	busy;				/* 1 = chip is busy	*/
+	u8	reg_cache[LFP100_NUMREGS];	/* saved reg values	*/
+	u8	reg_properties[LFP100_NUMREGS];	/* register properties	*/
+	struct	i2c_client *client;
+	void	(*power_button_callback)(void);
+};
+
+#define REG_HAS_PASSWORD 0x01	/* register has password */
+#define REG_IS_VOLATILE	 0x02	/* register value is volatile  */
+
+static struct lfp100_chip *local_chip;
+
+/*
+ * local LFP100 write reg routine, no range checking
+ */
+static int lfp100_write_reg_raw(unsigned int reg, unsigned int value)
+{
+	struct i2c_adapter* i2c;
+	struct i2c_msg i2c_messages[2];
+	u8 buf[2];
+
+	/* write new register value */
+	i2c = i2c_get_adapter(0);
+	if (!i2c) {
+		printk(KERN_ERR "%s.%d return -EIO\n",
+			__FUNCTION__, __LINE__);
+		return -EIO;
+	}
+
+	buf[0] = 0xff & reg;
+	buf[1] = 0xFF & value;
+
+	/* write portion */
+	i2c_messages[0].addr = LFP100_ADDR;
+	i2c_messages[0].buf = buf;
+	i2c_messages[0].len = 2;
+	i2c_messages[0].flags = 0;      /* write */
+
+	if (i2c_transfer(i2c, i2c_messages, 1) < 0) {
+		i2c_put_adapter(i2c);
+		printk(KERN_ERR "%s.%d return -EIO\n",
+			__FUNCTION__, __LINE__);
+		return -EIO;
+	}
+
+	i2c_put_adapter(i2c);
+	return 0;
+}
+
+/*
+ * local i2c read reg routine
+ */
+static int lfp100_read_reg_raw(unsigned int reg)
+{
+	struct i2c_adapter* i2c;
+	struct i2c_msg i2c_messages[2];
+	u8 buf[2];
+	int ret;
+
+	i2c = i2c_get_adapter(0);
+	if (!i2c)
+		return -1;
+
+	buf[0] = 0xFF & reg;           /* read this register */
+	buf[1] = 0;
+
+	/* write portion */
+	i2c_messages[0].addr = LFP100_ADDR;
+	i2c_messages[0].buf = buf;
+	i2c_messages[0].len = 1;
+	i2c_messages[0].flags = 0;      /* write */
+
+	/* read portion */
+	i2c_messages[1].addr = LFP100_ADDR;
+	i2c_messages[1].buf = buf;
+	i2c_messages[1].len = 2;
+	i2c_messages[1].flags = I2C_M_RD;
+
+	ret = i2c_transfer(i2c, i2c_messages, 2);
+	i2c_put_adapter(i2c);
+	if (ret < 0) {
+		printk(KERN_ERR "%s.%d reg=%d, i2c_transfer=%d\n",
+			__FUNCTION__, __LINE__, reg, ret);
+		return -EIO;
+	}
+	return 0xFF & buf[1];
+}
+
+static int lfp100_available(void)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&local_chip->busy, flags);
+	ret = !local_chip->busy;
+	spin_unlock_irqrestore(&local_chip->busy, flags);
+
+	return ret;
+}
+
+/*
+ * local LFP100 write reg routine
+ * Handle password protected registers, lock access as needed
+ */
+
+int lfp100_write_reg(unsigned int reg, unsigned int value)
+{
+	u8 *cache = local_chip->reg_cache;
+	u8 *properties = local_chip->reg_properties;
+	unsigned long flags;
+	int ret=0;
+	int i;
+	
+	if ((!local_chip->have_lfp100) || (reg < LFP100_FIRSTREG ||
+		reg > LFP100_LASTREG))
+		return -EIO;
+
+	/* serialize access to LFP100 and cache */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	while (local_chip->busy) {
+		spin_unlock_irqrestore(&local_chip->lock, flags);
+		if (wait_event_interruptible(local_chip->wait,
+			(lfp100_available())))
+			return -ERESTARTSYS;
+		spin_lock_irqsave(&local_chip->lock, flags);
+	}
+	local_chip->busy = 1;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+
+	/* wait for busy bit to clear */
+	for (i=0; i < 20; i++) {
+		if(lfp100_read_reg_raw(LFP100_STATUS2) &
+			LFP100_STATUS2_ABUSY) {
+			msleep(20);
+		} else {
+			break;
+		}
+	}
+
+	/*
+	 * Only perform an I2C operation if reg is
+	 * volatile or the new value is different
+	 */
+	if ((properties[reg - LFP100_FIRSTREG] == REG_IS_VOLATILE) ||
+	    (cache[reg - LFP100_FIRSTREG] != value)) {
+
+		if (properties[reg - LFP100_FIRSTREG] ==
+			REG_HAS_PASSWORD) {
+			/* unlock reg if needed */
+			ret =
+			   lfp100_write_reg_raw(LFP100_PASSWORD,
+				LFP100_UNLOCK(reg));
+			if (ret < 0)
+				goto exit;
+		}
+		ret = lfp100_write_reg_raw(reg, value);
+
+		if (0 <= ret) /* wrote value to hardware, update the cache */
+			cache[reg - LFP100_FIRSTREG] = value;
+	}
+
+	/* release LFP100 */
+exit:
+	spin_lock_irqsave(&local_chip->lock, flags);
+	local_chip->busy = 0;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+	wake_up_interruptible(&local_chip->wait);
+	return ret;
+}
+
+EXPORT_SYMBOL(lfp100_write_reg);
+
+/*
+ * local i2c read reg routine, use buffer if possible
+ * Handle password protected registers, lock access as needed
+ */
+
+int lfp100_read_reg(unsigned int reg)
+{
+	u8 *cache = local_chip->reg_cache;
+	u8 *properties = local_chip->reg_properties;
+	unsigned long flags;
+	int ret;
+
+	if ((!local_chip->have_lfp100) || (reg < LFP100_FIRSTREG ||
+		reg > LFP100_LASTREG))
+		return -EIO;
+
+	/* serialize access to LFP100 and cache */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	while (local_chip->busy) {
+		spin_unlock_irqrestore(&local_chip->lock, flags);
+		if (wait_event_interruptible(local_chip->wait,
+			(lfp100_available())))
+			return -ERESTARTSYS;
+		spin_lock_irqsave(&local_chip->lock, flags);
+	}
+	local_chip->busy = 1;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+
+	/* return cached value if register is not volatile */
+	if (properties[reg - LFP100_FIRSTREG] != REG_IS_VOLATILE) {
+		ret = cache[reg - LFP100_FIRSTREG];
+	} else { /* register is volatile, read it */
+		ret = lfp100_read_reg_raw(reg);
+		if (0 <= ret )	/* update the cache */
+			cache[reg - LFP100_FIRSTREG] = ret;
+		else
+			printk(KERN_ERR "%s.%d ret=%d\n",
+				__FUNCTION__, __LINE__, ret);
+	}
+
+	/* release LFP100 */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	local_chip->busy = 0;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+	wake_up_interruptible(&local_chip->wait);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(lfp100_read_reg);
+
+/*
+ * sysfs interface
+ */
+
+static ssize_t show_volume(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	u32 tmp;
+
+	tmp = lfp100_read_reg(LFP100_VOLUME);
+	return sprintf(buf, "VOLUME = %d\n", tmp);
+}
+
+static ssize_t set_volume(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	if (63 < value)
+		return -EINVAL;
+
+	lfp100_write_reg(LFP100_VOLUME, (u8)value);
+	return count;
+}
+
+static DEVICE_ATTR(volume, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+	show_volume, set_volume);
+
+static ssize_t show_backlight(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	u32 tmp;
+
+	tmp = lfp100_read_reg(LFP100_WLED);
+	return sprintf(buf, "BACKLIGHT = %d\n", tmp);
+}
+
+static ssize_t set_backlight(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	if (31 < value)
+		return -EINVAL;
+
+	lfp100_write_reg(LFP100_WLED, (u8)value);
+	return count;
+}
+
+static DEVICE_ATTR(backlight, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+	show_backlight, set_backlight);
+
+static struct attribute *lfp100_attributes[] = {
+	&dev_attr_volume.attr,
+	&dev_attr_backlight.attr,
+	NULL
+};
+
+static struct attribute_group lfp100_attr_group = {
+	.attrs = lfp100_attributes
+};
+
+
+static void lfp100_monitor_task(struct work_struct *work)
+{
+	u8 *cache = local_chip->reg_cache;
+	unsigned long flags;
+	int reg;
+
+	/* serialize access to LFP100 and cache */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	while (local_chip->busy) {
+		spin_unlock_irqrestore(&local_chip->lock, flags);
+		if (wait_event_interruptible(local_chip->wait,
+			(lfp100_available())))
+			return;
+		spin_lock_irqsave(&local_chip->lock, flags);
+	}
+	local_chip->busy = 1;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+
+	/* read LFP100 registers */
+	reg = lfp100_read_reg_raw(LFP100_CONTROL);
+	if (0 <= reg)
+		cache[LFP100_CONTROL] = reg;
+
+	reg = lfp100_read_reg_raw(LFP100_STATUS1);
+	if (0 <= reg)
+		cache[LFP100_STATUS1] = reg;
+
+	reg = lfp100_read_reg_raw(LFP100_STATUS2);
+	if (0 <= reg)
+		cache[LFP100_STATUS2] = reg;
+
+	reg = lfp100_read_reg_raw(LFP100_INT1);
+	if (0 <= reg)
+		cache[LFP100_INT1] = reg;
+
+	reg = lfp100_read_reg_raw(LFP100_INT2);
+	if (0 <= reg)
+		cache[LFP100_INT2] = reg;
+
+	reg = lfp100_read_reg_raw(LFP100_INT3);
+	if (0 <= reg)
+		cache[LFP100_INT3] = reg;
+
+	/* release LFP100 */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	local_chip->busy = 0;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+	wake_up_interruptible(&local_chip->wait);
+
+	gpio_set_int(lf1000_l2p_port(LFP100_INT),
+		     lf1000_l2p_pin(LFP100_INT), 1);	//renable ints
+
+	if (local_chip->power_button_callback)		// call power handler
+		local_chip->power_button_callback();
+	return;
+}
+
+/*
+ * unmute HP or SPK, depending on HP switch setting
+ */
+void lfp100_unmute_hp_sp(void)
+{
+	int	reg;
+	int	ret;
+	int	hp;
+	int	i;
+	int	status2;
+	unsigned long flags;
+	u8	*cache = local_chip->reg_cache;
+
+	/* serialize access to LFP100 */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	while (local_chip->busy) {
+		spin_unlock_irqrestore(&local_chip->lock, flags);
+		if (wait_event_interruptible(local_chip->wait,
+			(lfp100_available())))
+			return;
+		spin_lock_irqsave(&local_chip->lock, flags);
+	}
+	local_chip->busy = 1;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+
+	/* wait for busy bit to clear */
+	for (i=0; i < 20; i++) {
+		if (lfp100_read_reg_raw(LFP100_STATUS2) &
+				LFP100_STATUS2_ABUSY) {
+			msleep(20);
+		} else {
+			break;
+		}
+	}
+
+	/* read HP status switch before change */
+	status2 = lfp100_read_reg_raw(LFP100_STATUS2);
+	if (status2 < 0) {
+		printk(KERN_ERR "%s.%d error reading LFP100_STATUS2 (%d)\n",
+			__FUNCTION__, __LINE__, status2);
+		goto read_err;
+	}
+	hp = (status2 & LFP100_STATUS2_HP) ? 1 : 0;
+
+	reg = lfp100_read_reg_raw(LFP100_A_CONTROL);
+	if (reg < 0) {
+		printk(KERN_ERR "%s.%d error reading LFP100_A_CONTROL (%d)\n",
+			__FUNCTION__, __LINE__, reg);
+		goto read_err;
+	}
+
+	/* remove existing HP and SPK enable bits */
+	reg &= ~(LFP100_A_CONTROL_HP_EN | LFP100_A_CONTROL_SPK_EN);
+
+	if (hp)
+		reg |= LFP100_A_CONTROL_HP_EN;
+	else
+		reg |= LFP100_A_CONTROL_SPK_EN;
+
+	ret = lfp100_write_reg_raw(LFP100_A_CONTROL, reg);
+	if (0 <= ret) /* wrote value to hardware, update the cache */
+		cache[LFP100_A_CONTROL - LFP100_FIRSTREG] = reg;
+
+	/* wait for busy bit to clear */
+	for (i=0; i < 20; i++) {
+		if (lfp100_read_reg_raw(LFP100_STATUS2) &
+				LFP100_STATUS2_ABUSY) {
+			msleep(20);
+		} else {
+			break;
+		}
+	}
+
+read_err:
+	/* release LFP100 */
+	spin_lock_irqsave(&local_chip->lock, flags);
+	local_chip->busy = 0;
+	spin_unlock_irqrestore(&local_chip->lock, flags);
+	wake_up_interruptible(&local_chip->wait);
+}
+
+EXPORT_SYMBOL(lfp100_unmute_hp_sp);
+
+/*
+ * got an interrupt.  Let background task process it.
+ */
+static irqreturn_t lfp100_chip_irq(enum gpio_port port, enum gpio_pin pin,
+					void *priv)
+{
+	struct lfp100_chip *chip = (struct lfp100_chip *)priv;
+
+	if (gpio_get_pend(lf1000_l2p_port(LFP100_INT),
+			  lf1000_l2p_pin(LFP100_INT))) {
+		/* disable int, clear pending int, schedule task */
+		gpio_set_int(lf1000_l2p_port(LFP100_INT),
+			     lf1000_l2p_pin(LFP100_INT), 0);
+		gpio_clear_pend(lf1000_l2p_port(LFP100_INT),
+				lf1000_l2p_pin(LFP100_INT));
+		queue_work(chip->lfp100_tasks, &chip->lfp100_work);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+int lfp100_is_battery(void)
+{
+	int ret = 0;
+
+	ret = ((lfp100_read_reg(LFP100_STATUS1) &
+		LFP100_STATUS1_SOURCE) == LFP100_STATUS1_SOURCE_BAT) ? 1 : 0;
+	return ret;
+}
+
+EXPORT_SYMBOL(lfp100_is_battery);
+
+void lfp100_set_power_button_callback(void (*callback)(void))
+{
+	local_chip->power_button_callback = callback;
+}
+
+EXPORT_SYMBOL(lfp100_set_power_button_callback);
+
+int lfp100_get_power_button(void)
+{
+	int ret = 0;
+
+	if (lfp100_read_reg(LFP100_STATUS1) &
+		LFP100_STATUS1_PB) {
+		ret = 1;
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(lfp100_get_power_button);
+
+void lfp100_set_power_standby(void)
+{
+	/* go to standby mode */
+	lfp100_write_reg(LFP100_CONTROL, LFP100_CONTROL_STANDBY);
+}
+
+EXPORT_SYMBOL(lfp100_set_power_standby);
+
+int lfp100_have_lfp100(void)
+{
+	if (local_chip && local_chip->have_lfp100)
+		return 1;
+	else
+		return 0;
+}
+EXPORT_SYMBOL(lfp100_have_lfp100);
+
+static int lfp100_chip_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int i;
+	int ret = 0;
+	struct lfp100_chip *priv;
+
+	priv = kzalloc(sizeof(struct lfp100_chip), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	local_chip = priv;
+
+	/* mark registers that are password protected or volatile */
+	priv->reg_properties[LFP100_PASSWORD]	= REG_IS_VOLATILE;
+	priv->reg_properties[LFP100_DCDC1_PW]   = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_DCDC2_PW]   = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SLEW_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_LDO1_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_LDO2_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_LDO3_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_PG_PW]      = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_UVLO_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SEQ1_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SEQ2_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SEQ3_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SEQ4_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_SEQ5_PW]    = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_FORMAT_PW]  = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_A_APOP_PW]  = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_GAINADJ_PW] = REG_HAS_PASSWORD;
+	priv->reg_properties[LFP100_VLIMIT_PW]  = REG_HAS_PASSWORD;
+	init_waitqueue_head(&priv->wait);
+	priv->lock = SPIN_LOCK_UNLOCKED;
+
+	/* initialize LFP100 cache by reading registers */
+
+	for (i = 0; i < LFP100_NUMREGS; i++) {
+		ret = lfp100_read_reg_raw(i);
+		if (ret < 0) {
+			printk(KERN_ERR "%s.%d No LFP100\n",
+				__FUNCTION__, __LINE__);
+			ret = -ENXIO;
+			goto no_lfp100;
+		}
+		priv->reg_cache[i] = ret;
+	}
+	priv->have_lfp100 = 1;		/* read registers */
+	ret = sysfs_create_group(&client->dev.kobj, &lfp100_attr_group);
+	if (ret)
+		goto sysfs_fail;
+
+	ret = gpio_request_irq(lf1000_l2p_port(LFP100_INT),
+			       lf1000_l2p_pin(LFP100_INT),
+		lfp100_chip_irq, priv);
+	if (ret) {
+		printk(KERN_ERR "%s.%d: failed to get LFP100 IRQ\n",
+			__FUNCTION__, __LINE__);
+		goto sysfs_fail;
+	}
+
+	/* initialize worker thread which processes irq */
+	priv->lfp100_tasks = create_singlethread_workqueue("lfp100 tasks");
+	INIT_WORK(&priv->lfp100_work, lfp100_monitor_task);
+
+	/* turn on LFP100 backlight */
+	lfp100_write_reg(LFP100_P_ENABLE,
+		lfp100_read_reg(LFP100_P_ENABLE) | LFP100_P_ENABLE_WLED_EN);
+	/* setup LFP100 IRQ for USB, AC, power button, or headphone changes */
+	lfp100_write_reg(LFP100_MASK1, 0xFF);
+	lfp100_write_reg(LFP100_MASK2,
+		~(LFP100_MASK2_USBM | LFP100_MASK2_ACM | LFP100_MASK2_PBM));
+	lfp100_write_reg(LFP100_MASK3, ~(LFP100_MASK3_HP));
+
+	/* clear any pending interrupts */
+	lfp100_read_reg(LFP100_INT1);
+	lfp100_read_reg(LFP100_INT2);
+	lfp100_read_reg(LFP100_INT3);
+
+	/* setup IRQ */
+	gpio_set_fn(lf1000_l2p_port(LFP100_INT),
+		    lf1000_l2p_pin(LFP100_INT), GPIO_GPIOFN);
+	gpio_set_int_mode(lf1000_l2p_port(LFP100_INT),
+			  lf1000_l2p_pin(LFP100_INT),
+			  GPIO_IMODE_LOW_LEVEL);
+	gpio_clear_pend(lf1000_l2p_port(LFP100_INT),
+			lf1000_l2p_pin(LFP100_INT));
+	gpio_set_int(lf1000_l2p_port(LFP100_INT),
+		     lf1000_l2p_pin(LFP100_INT), 1);
+
+	ret = 0;
+no_lfp100:
+	return ret;
+
+sysfs_fail:
+	sysfs_remove_group(&client->dev.kobj, &lfp100_attr_group);
+	kfree(i2c_get_clientdata(client));
+fail_alloc:
+	return ret;
+}
+
+
+static int lfp100_chip_remove(struct i2c_client *client)
+{
+	gpio_set_int(lf1000_l2p_port(LFP100_INT),
+		     lf1000_l2p_pin(LFP100_INT), 0); /* disable int   */
+	gpio_clear_pend(lf1000_l2p_port(LFP100_INT),
+			lf1000_l2p_pin(LFP100_INT)); /* clear pending */
+	gpio_free_irq(lf1000_l2p_port(LFP100_INT),
+		      lf1000_l2p_pin(LFP100_INT), lfp100_chip_irq);
+
+	destroy_workqueue(local_chip->lfp100_tasks);
+
+	sysfs_remove_group(&client->dev.kobj, &lfp100_attr_group);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id lfp100_chip_id[] = {
+	{ LFP100_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, lfp100_chip_id);
+
+static struct i2c_driver lfp100_chip_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= LFP100_NAME,
+	},
+	.probe		= lfp100_chip_probe,
+	.remove		= lfp100_chip_remove,
+	.id_table	= lfp100_chip_id,
+};
+
+/*
+ * module stuff
+ */
+
+static int __init lfp100_chip_init(void)
+{
+	return i2c_add_driver(&lfp100_chip_driver);
+}
+
+static void lfp100_chip_exit(void)
+{
+	i2c_del_driver(&lfp100_chip_driver);
+}
+
+MODULE_AUTHOR("Scott Esters");
+MODULE_DESCRIPTION("LFP100 support");
+MODULE_LICENSE("GPL");
+
+module_init(lfp100_chip_init);
+module_exit(lfp100_chip_exit);
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/Makefile linux-2.6/arch/arm/mach-lf1000/Makefile
--- linux-2.6.31/arch/arm/mach-lf1000/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/Makefile	2011-01-04 15:06:55.000000000 -0800
@@ -0,0 +1,13 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y					:= core.o clock.o clock_dev.o
+obj-$(CONFIG_LF1000_GPIO)		+= gpio_main.o gpio.o gpio_l2p.o
+obj-$(CONFIG_ARCH_LF1000)		+= lf1000_core_func.o
+obj-$(CONFIG_ARCH_LF1000)		+= lf1000.o
+obj-$(CONFIG_ARCH_LF1000)		+= pwm.o
+obj-$(CONFIG_LF1000_SCREEN)		+= screen.o
+obj-$(CONFIG_LF1000_DMA_CONTROLLER)	+= dma.o
+obj-$(CONFIG_LF1000_ADC)		+= adc.o
+obj-$(CONFIG_LF1000_LFP100)		+= lfp100.o
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/Makefile.boot linux-2.6/arch/arm/mach-lf1000/Makefile.boot
--- linux-2.6.31/arch/arm/mach-lf1000/Makefile.boot	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/Makefile.boot	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,2 @@
+   zreladdr-y	:= 0x00008000
+initrd_phys-y	:= 0x00800000
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/pwm.c linux-2.6/arch/arm/mach-lf1000/pwm.c
--- linux-2.6.31/arch/arm/mach-lf1000/pwm.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/pwm.c	2011-05-03 12:54:00.000000000 -0700
@@ -0,0 +1,333 @@
+/* 
+ * drivers/lf1000/pwm/pwm.c
+ * 
+ * LF1000 Pulse Width Modulator (PWM) Driver
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com> 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation. 
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/pwm.h>
+#include <mach/gpio.h>
+#include <mach/pwm_hal.h>
+
+#define RESSIZE(res) 		(((res)->end - (res)->start)+1)
+#define DRIVER_NAME 		"lf1000-pwm"
+
+/* number of PWM output channels */
+#define PWM_NUM_CHANNELS	3
+#define PWM_CLK_SRC		PLL1
+
+/* PWM derived clock settings */
+#define PWM_CLOCK_HZ		10240000
+#define PWM_POLARITY		POL_BYP
+
+static struct pwm_device {
+	void __iomem 		*base;
+	int 			clock_rate;
+} pwm;
+
+/*************
+ * show regs *
+ *************/
+
+void dump_regs(void)
+{
+	printk(KERN_ERR "%s.%d PWM registers\n", __FUNCTION__, __LINE__);
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM01PRES",  readw(pwm.base+PWM01PRES));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM0DUTY",   readw(pwm.base+PWM0DUTY));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM1DUTY",   readw(pwm.base+PWM1DUTY));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM0PERIOD", readw(pwm.base+PWM0PERIOD));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM1PERIOD", readw(pwm.base+PWM1PERIOD));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM2PRES",   readw(pwm.base+PWM2PRES));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM2DUTY",   readw(pwm.base+PWM2DUTY));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWM2PERIOD", readw(pwm.base+PWM2PERIOD));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWMCLKENB",  readw(pwm.base+PWMCLKENB));
+	printk(KERN_ERR "%11s: 0x%4.4X\n", "PWMCLKGEN",  readw(pwm.base+PWMCLKGEN));
+}
+
+
+/*********************
+ * PWM API Functions *
+ *********************/
+
+int pwm_configure_pin(enum pwm_chan channel)
+{
+	enum gpio_port port;
+	enum gpio_pin pin;
+
+	switch(channel) {
+		case PWM_CHAN0:
+		port = GPIO_PORT_A;
+		pin = GPIO_PIN30;
+		break;
+		case PWM_CHAN1:
+		port = GPIO_PORT_A;
+		pin = GPIO_PIN31;
+		break;
+		case PWM_CHAN2:
+		port = GPIO_PORT_C;
+		pin = GPIO_PIN7;
+		break;
+		default:
+		return -1;
+		break;
+	}
+	gpio_set_fn(port, pin, GPIO_ALT1);
+	gpio_set_pu(port, pin, 0);
+	gpio_set_out_en(port, pin, 1);
+	gpio_set_cur(port, pin, GPIO_CURRENT_8MA);
+	return 0;
+}
+EXPORT_SYMBOL(pwm_configure_pin);
+
+int pwm_set_prescale(enum pwm_chan channel, u32 prescale)
+{
+	u16 tmp;
+	u8 shift = 0;
+	void *reg;
+
+
+	if(channel >= PWM_CHAN_INVALID || prescale >= 128)
+		return -EINVAL;
+
+	switch(channel) {
+	case PWM_CHAN0:
+		reg = pwm.base + PWM01PRES;
+		shift = PWM0PRESCALE;
+		break;
+	case PWM_CHAN1:
+		reg = pwm.base + PWM01PRES;
+		shift = PWM1PRESCALE;
+		break;
+	case PWM_CHAN2:
+		reg = pwm.base + PWM2PRES;
+		shift = PWM2PRESCALE;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	tmp = readw(reg);
+	tmp &= ~(0x3F<<shift); /* clear prescaler bits */
+	tmp |=  (prescale<<shift); /* set prescaler */
+	writew(tmp, reg);
+	return 0;
+}
+EXPORT_SYMBOL(pwm_set_prescale);
+
+int pwm_set_polarity(enum pwm_chan channel, u8 polarity)
+{
+	void *reg;
+	u16 tmp;
+	u8 shift = 0;
+
+	if( channel >= PWM_CHAN_INVALID || polarity >= POL_INVALID )
+		return -EINVAL;
+
+	switch(channel) {
+	case PWM_CHAN0:
+		reg = pwm.base + PWM01PRES;
+		shift = PWM0POL;
+		break;
+	case PWM_CHAN1:
+		reg = pwm.base + PWM01PRES;
+		shift = PWM1POL;
+		break;
+	case PWM_CHAN2:
+		reg = pwm.base + PWM2PRES;
+		shift = PWM2POL;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	tmp = readw(reg);
+	if(polarity == POL_INV)
+		tmp &= ~(1<<shift);
+	else
+		tmp |= (1<<shift);
+	writew(polarity, reg);
+	return 0;
+}
+EXPORT_SYMBOL(pwm_set_polarity);
+
+int pwm_set_period(enum pwm_chan channel, u32 period)
+{
+	void *reg = NULL;
+
+	if(channel >= PWM_CHAN_INVALID || period >= 1024)
+		return -EINVAL;
+
+	switch(channel) {
+		case PWM_CHAN0:
+		reg = pwm.base+PWM0PERIOD;
+		break;
+		case PWM_CHAN1:
+		reg = pwm.base+PWM1PERIOD;
+		break;
+		case PWM_CHAN2:
+		reg = pwm.base+PWM2PERIOD;
+		break;
+		default:
+		return -1;
+		break;
+	}
+
+	if(reg == NULL)
+		return -EINVAL;
+
+	writew(period,reg);
+	return 0;
+
+}
+EXPORT_SYMBOL(pwm_set_period);
+
+int pwm_set_duty_cycle(enum pwm_chan channel, u32 duty)
+{
+	void *reg = NULL;
+
+	if(channel >= PWM_CHAN_INVALID || duty >= PWM_MAX_VALUE)
+		return -EINVAL;
+
+	switch(channel) {
+		case PWM_CHAN0:
+		reg = pwm.base+PWM0DUTY;
+		break;
+		case PWM_CHAN1:
+		reg = pwm.base+PWM1DUTY;
+		break;
+		case PWM_CHAN2:
+		reg = pwm.base+PWM2DUTY;
+		break;
+		default:
+		return -1;
+		break;
+	}
+
+	if(reg == NULL)
+		return -EINVAL;
+
+	writew(duty,reg);
+	return 0;
+}
+EXPORT_SYMBOL(pwm_set_duty_cycle);
+
+int pwm_set_clock(u8 source, u8 div, u8 mode, u8 enable)
+{
+	u32 tmp;
+
+	if(source >= PWM_CLK_INVALID || div > 63)
+		return -EINVAL;
+
+	writew((u16)((div<<PWMCLKDIV)|(source<<PWMCLKSRCSEL)),
+		  pwm.base+PWMCLKGEN);
+
+	tmp = ioread32(pwm.base+PWMCLKENB);
+	mode ? BIT_SET(tmp, PWMPCLKMODE) : BIT_CLR(tmp, PWMPCLKMODE);
+	enable ? BIT_SET(tmp, PWMCLKGENENB) : BIT_CLR(tmp, PWMCLKGENENB);
+	iowrite32(tmp,pwm.base+PWMCLKENB);
+	return 0;
+}
+EXPORT_SYMBOL(pwm_set_clock);
+
+int pwm_get_clock_rate(void)
+{
+	return pwm.clock_rate;
+}
+EXPORT_SYMBOL(pwm_get_clock_rate);
+
+static int lf1000_pwm_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+	int div;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, RESSIZE(res), DRIVER_NAME)) {
+		dev_err(&pdev->dev, "failed to map memory region.");
+		return -EBUSY;
+	}
+
+	div = lf1000_CalcDivider(get_pll_freq(PWM_CLK_SRC), PWM_CLOCK_HZ);
+	if(div < 0) {
+		dev_err(&pdev->dev, "failed to a get clock divider\n");
+		return -EFAULT;
+	}
+
+	pwm.base = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(pwm.base == NULL) {
+		printk(KERN_ERR "pwm: failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	ret = pwm_set_clock(PWM_CLK_SRC, div, 1, 1);
+	if(ret < 0) {
+		dev_err(&pdev->dev, "divider too high, using 63\n");
+		pwm_set_clock(PWM_CLK_SRC, 63, 1, 1);
+		div = 63;
+	}
+
+	pwm.clock_rate = get_pll_freq(PWM_CLK_SRC)/(div+1);
+
+	return 0;
+
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	return ret;
+}
+
+static int lf1000_pwm_remove(struct platform_device *pdev)
+{
+	struct resource *res  = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if(pwm.base != NULL)
+		iounmap(pwm.base);
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	return 0;
+}
+
+static struct platform_driver lf1000_pwm_driver = {
+	.probe		= lf1000_pwm_probe,
+	.remove		= lf1000_pwm_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static void __exit pwm_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_pwm_driver);
+}
+
+static int __init pwm_init(void)
+{
+	return platform_driver_register(&lf1000_pwm_driver);
+}
+
+module_init(pwm_init);
+module_exit(pwm_cleanup);
+
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1:2.0");
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/README.gpio linux-2.6/arch/arm/mach-lf1000/README.gpio
--- linux-2.6.31/arch/arm/mach-lf1000/README.gpio	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/README.gpio	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,71 @@
+###############################################################################
+# LF1000 GPIO and PWM Driver                                                  #
+#                                                                             #
+# 04/28/2007 by Andrey Yurovsky <andrey@cozybit.com>                          #
+###############################################################################
+
+This is the GPIO driver documentation.
+
+0) Contents:
+   1) Building and Installing
+   2) Creating /dev/gpio Device
+   3) Application Interface
+   4) Debugging
+
+1) Building and Installing
+
+Before building the driver, edit the Makefile and ensure that the KERNELDIR is
+set to the correct path for your LF1000 kernel source.  You may also want to
+check that your cross compiler is in your path.  Finally, adjust the 'install' 
+paths as needed.
+
+Run 'make' to build the module:
+
+$ make
+
+To build the module with debug capability such as register inspection, define
+DEBUG when you build:
+
+$ make DEBUG=1
+
+Once the module, LF1000gpio.ko, is created, copy it to the target (or use 'make
+install').  On the target, insert the module:
+
+$ insmod LF1000gpio.ko
+
+To remove the module,
+
+$ rmmod LF1000gpio
+
+2) Creating /dev/gpio Device
+
+You may need to create the /dev/gpio device during initial installation.  To do
+so, you must know the major number (DPC_MAJOR in gpio.h).  For example, to 
+create the device with a major number 253:
+
+$ mknod /dev/gpio c 253 0
+$ chmod a+rw /dev/gpio
+
+3) Application Interface
+
+GPIO configuration from user space is done through ioctl() calls.  Documentaion
+for this will be available soon.  For now, the example user space utility
+test_gpio is used by the init.sh script to turn on several pins.
+
+4) Debugging
+
+The LF1000gpio driver allows the GPIO registers to be inspected at any time by
+reading a file in /proc.  This capability is available only if the driver was
+built with the DEBUG flag defined (see Section 1).  First, ensure that /proc is
+mounted:
+
+$ mount /proc
+
+The /proc/driver directory contains the following files for GPIO debugging:
+
+You may read the GPIO file with the 'cat' command, for example:
+
+$ cat /proc/driver/gpio
+
+Refer to the LF1000 data book for GPIO register definitions.
+
diff -ruaN linux-2.6.31/arch/arm/mach-lf1000/screen.c linux-2.6/arch/arm/mach-lf1000/screen.c
--- linux-2.6.31/arch/arm/mach-lf1000/screen.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/mach-lf1000/screen.c	2011-08-03 19:16:56.000000000 -0700
@@ -0,0 +1,743 @@
+/*
+ * arch/arm/mach-lf1000/screen.c
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * Display Controller (DPC) support.  We also describe platform screen modules
+ * and provide information on the system's screen.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#include <mach/platform.h>
+#include <mach/screen.h>
+#include <mach/gpio.h>
+
+#define RESSIZE(res)	(((res)->end - (res)->start)+1)
+#define DRIVER_NAME	"lf1000-dpc"
+#define DPC_DEFAULT_HZ	6400000
+
+static struct lf1000_screen_info screens[] = {
+	{
+		.name = "ILI9322",
+		.xres	= 320,
+		.yres	= 240,
+		.clk_hz	= 6400000,
+		.hsw	= 2,
+		.hfp	= 50,
+		.hbp	= 36,
+		.vsw	= 1,
+		.vfp	= 4,
+		.vbp	= 17,
+	},
+	{
+		.name = "ILI6480G2",
+		.xres	= 480,
+		.yres	= 272,
+		.clk_hz = 9200000,
+		.hsw	= 2,
+		.hfp	= 5,
+		.hbp	= 40,
+		.vsw	= 1,
+		.vfp	= 8,
+		.vbp	= 8,
+	},
+};
+
+static struct lf1000_screen_info *system_screen = &screens[0];
+
+static int __init screen_module_name(char *str)
+{
+	int i;
+	int l = 0;
+	char c;
+
+	do {
+		c = *(str+l);
+		l++;
+	} while (c && c != ' ');
+
+	for (i = 0; i < ARRAY_SIZE(screens); i++) {
+		if (strlen(screens[i].name) == l-1 &&
+		    !strncmp(str, screens[i].name, l-1)) {
+			system_screen = &screens[i];
+			break;
+		}
+	}
+
+	return 0;
+}
+
+__setup("screen_module=", screen_module_name);
+
+static struct dpc_priv {
+	void __iomem			*mem;
+	int				div;
+	struct lf1000_screen_info	*screen;
+	unsigned			tvout : 1;
+	struct dentry			*debug;
+} dpc;
+
+struct lf1000_screen_info *lf1000_get_screen_info(void)
+{
+	return system_screen;
+}
+EXPORT_SYMBOL_GPL(lf1000_get_screen_info);
+
+/* DPC Hardware */
+
+static char pvd_pins[] = {  
+	GPIO_PIN0, GPIO_PIN1, GPIO_PIN2, GPIO_PIN3, GPIO_PIN4, GPIO_PIN5,
+	GPIO_PIN6, GPIO_PIN7, GPIO_PIN16, GPIO_PIN17, GPIO_PIN18, GPIO_PIN19,
+	GPIO_PIN20, GPIO_PIN21, GPIO_PIN22, GPIO_PIN23, GPIO_PIN24,
+	GPIO_PIN25, GPIO_PIN26, GPIO_PIN27, GPIO_PIN28, GPIO_PIN29, GPIO_PIN30,
+	GPIO_PIN31                
+};                                
+
+static char pvd_ports[] = { 
+	GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A,
+	GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B,
+};
+
+#define DPCHTOTAL	0x07C
+#define DPCHSWIDTH	0x07E
+#define DPCHASTART	0x080
+#define DPCHAEND	0x082
+#define DPCVTOTAL	0x084
+#define DPCVSWIDTH	0x086
+#define DPCVASTART	0x088
+#define DPCVAEND	0x08A
+#define DPCCTRL0	0x08C
+#define DPCCTRL1	0x08E
+#define DPCEVTOTAL	0x090
+#define DPCEVSWIDTH	0x092
+#define DPCEVASTART	0x094
+#define DPCEVAEND	0x096
+#define DPCCTRL2	0x098
+#define DPCVSEOFFSET	0x09A
+#define DPCVSSOFFSET	0x09C
+#define DPCEVSEOFFSET	0x09E
+#define DPCEVSSOFFSET	0x0A0
+#define DPCDELAY0	0x0A2
+#define DPCCLKENB	0x1C0
+#define DPCCLKGEN0	0x1C4
+#define DPCCLKGEN1	0x1C8
+
+#define VENCCTRLA	0x002 
+#define VENCCTRLB	0x004 
+#define VENCSCH		0x008 
+#define VENCHUE		0x00A 
+#define VENCSAT		0x00C 
+#define VENCCRT		0x00E 
+#define VENCBRT		0x010 
+#define VENCFSCADJH	0x012 
+#define VENCFSCADJL	0x014
+#define VENCDACSEL	0x020 
+#define VENCICNTL	0x040
+#define VENCHSVS0	0x048 
+#define VENCHSOS	0x04A 
+#define VENCHSOE	0x04C 
+#define VENCVSOS	0x04E 
+#define VENCVSOE	0x050  
+#define DPUPSCALECON0	0x0A4
+#define DPUPSCALECON1	0x0A6
+#define DPUPSCALECON2	0x0A8
+
+/* DPC CLOCK GENERATION CONTROL 0 REGISTER (DPCCLKGEN0) */
+#define OUTCLKENB       15
+#define OUTCLKDELAY0    12
+#define CLKDIV0         4
+#define CLKSRCSEL0      1
+#define OUTCLKINV0      0
+
+/* DPC CLOCK GENERATION CONTROL 1 REGISTER (DPCCLKGEN1) */
+#define OUTCLKDELAY1    12
+#define CLKDIV1         4
+#define CLKSRCSEL1      1
+#define OUTCLKINV1      0
+
+/* debugging */
+
+static void regs_show_u16(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct dpc_priv *priv = s->private;
+
+	seq_printf(s, "%10s:\t0x%04X\n", nm, readw(priv->mem + reg));
+}
+
+static void regs_show_u32(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct dpc_priv *priv = s->private;
+
+	seq_printf(s, "%10s:\t0x%08X\n", nm, readl(priv->mem + reg));
+}
+
+static int lf1000_regs_show(struct seq_file *s, void *v)
+{
+	struct dpc_priv *priv = s->private;
+	void __iomem *mem = priv->mem;
+	int n;
+
+	for (n = 0; n < 2; n++, priv->mem += 0x400)
+	{
+	regs_show_u16(s, "HTOTAL", DPCHTOTAL);
+	regs_show_u16(s, "HSWIDTH", DPCHSWIDTH);
+	regs_show_u16(s, "HASTART", DPCHASTART);
+	regs_show_u16(s, "HAEND", DPCHAEND);
+	regs_show_u16(s, "VTOTAL", DPCVTOTAL);
+	regs_show_u16(s, "VSWIDTH", DPCVSWIDTH);
+	regs_show_u16(s, "VASTART", DPCVASTART);
+	regs_show_u16(s, "VAEND", DPCVAEND);
+	regs_show_u16(s, "CTRL0", DPCCTRL0);
+	regs_show_u16(s, "CTRL1", DPCCTRL1);
+	regs_show_u16(s, "EVTOTAL", DPCEVTOTAL);
+	regs_show_u16(s, "EVSWIDTH", DPCEVSWIDTH);
+	regs_show_u16(s, "EVASTART", DPCEVASTART);
+	regs_show_u16(s, "EVAEND", DPCEVAEND);
+	regs_show_u16(s, "CTRL2", DPCCTRL2);
+	regs_show_u16(s, "VSEOFFSET", DPCVSEOFFSET);
+	regs_show_u16(s, "VSSOFFSET", DPCVSSOFFSET);
+	regs_show_u16(s, "EVSEOFFSET", DPCEVSEOFFSET);
+	regs_show_u16(s, "EVSSOFFSET", DPCEVSSOFFSET);
+	regs_show_u16(s, "DELAY0", DPCDELAY0);
+
+	regs_show_u32(s, "CLKENB", DPCCLKENB);
+	regs_show_u32(s, "CLKGEN0", DPCCLKGEN0);
+	regs_show_u32(s, "CLKGEN1", DPCCLKGEN1);
+
+	regs_show_u16(s, "VENCCTRLA", VENCCTRLA);
+	regs_show_u16(s, "VENCCTRLB", VENCCTRLB);
+	regs_show_u16(s, "VENCSCH", VENCSCH);
+	regs_show_u16(s, "VENCHUE", VENCHUE);
+	regs_show_u16(s, "VENCSAT", VENCSAT);
+	regs_show_u16(s, "VENCCRT", VENCCRT);
+	regs_show_u16(s, "VENCBRT", VENCBRT);
+	regs_show_u16(s, "VENCFSCADJH", VENCFSCADJH);
+	regs_show_u16(s, "VENCFSCADJL", VENCFSCADJL);
+	regs_show_u16(s, "VENCDACSEL", VENCDACSEL);
+	regs_show_u16(s, "VENCICNT", VENCICNTL);
+	regs_show_u16(s, "VENCHSVS", VENCHSVS0);
+	regs_show_u16(s, "VENCHS", VENCHSOS);
+	regs_show_u16(s, "VENCHS", VENCHSOE);
+	regs_show_u16(s, "VENCVS", VENCVSOS);
+	regs_show_u16(s, "VENCVS", VENCVSOE);
+	regs_show_u16(s, "DPUPSCALECON0", DPUPSCALECON0);
+	regs_show_u16(s, "DPUPSCALECON1", DPUPSCALECON1);
+	regs_show_u16(s, "DPUPSCALECON2", DPUPSCALECON2);
+	}
+
+	priv->mem = mem;
+
+	return 0;
+}
+
+static int lf1000_dpc_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lf1000_regs_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_dpc_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_dpc_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int screen_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "%s, %dx%d @ %dHz\n", system_screen->name,
+			system_screen->xres, system_screen->yres,
+			system_screen->clk_hz);
+	seq_printf(s, "hsw: %d, hfp %d, hbp: %d\n", system_screen->hsw,
+			system_screen->hfp, system_screen->hbp);
+	seq_printf(s, "vsw: %d, vfp %d, vbp: %d\n", system_screen->vsw,
+			system_screen->vfp, system_screen->vbp);
+
+	return 0;
+}
+
+static int lf1000_dpc_screen_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, screen_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_dpc_screen_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_dpc_screen_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* controls */
+
+void lf1000_dpc_clear_int(void)
+{
+	u16 reg = readw(dpc.mem + DPCCTRL0);
+	writew(reg | (1<<10), dpc.mem + DPCCTRL0);
+}
+EXPORT_SYMBOL_GPL(lf1000_dpc_clear_int);
+
+bool lf1000_dpc_int_pending(void)
+{
+	return !!(readw(dpc.mem + DPCCTRL0) & (1<<10));
+}
+EXPORT_SYMBOL_GPL(lf1000_dpc_int_pending);
+
+void lf1000_dpc_enable_int(bool en)
+{
+	u16 reg = readw(dpc.mem + DPCCTRL0);
+
+	reg |= (1<<10);
+
+	if (en)
+		writew(reg | (1<<11), dpc.mem + DPCCTRL0);
+	else
+		writew(reg & ~(1<<11), dpc.mem + DPCCTRL0);
+
+	lf1000_dpc_clear_int();
+}
+EXPORT_SYMBOL_GPL(lf1000_dpc_enable_int);
+
+static void lf1000_dpc_set_enable(u8 index, bool en)
+{
+	void __iomem *mem = index ? dpc.mem + 0x400 : dpc.mem;
+	u16 reg = readw(mem + DPCCTRL0) & ~(1<<15);
+
+	if (en)
+		reg |= (1<<15);
+	writew(reg, mem + DPCCTRL0);
+}
+
+static void lf1000_dpc_set_clock_enable(u8 index, bool en)
+{
+	u32 reg = readl(dpc.mem + DPCCLKENB) & ~(1<<2);
+	void __iomem *mem = index ? dpc.mem + 0x400 : dpc.mem;
+
+	if (en)
+		reg |= (1<<2);
+	writel(reg, mem + DPCCLKENB);
+}
+
+static void lf1000_dpc_configure(void)
+{
+	u32 reg32;
+	u16 reg16;
+	int i;
+	unsigned int div;
+	struct lf1000_screen_info *screen = dpc.screen;
+
+	for (i = 0; i < ARRAY_SIZE(pvd_pins); i++)
+		gpio_configure_pin(pvd_ports[i], pvd_pins[i], GPIO_ALT1,
+				1, 0, 0);
+
+	/* set PCLK mode to "only when CPU accesses" */
+	reg32 = readl(dpc.mem + DPCCLKENB) & ~(1<<3);
+	writel(reg32, dpc.mem + DPCCLKENB);
+
+	/* configure Clock 0 */
+	div = dpc.div > 0 ? dpc.div - 1 : dpc.div;
+	div &= 0x3F;
+	reg32 = readl(dpc.mem + DPCCLKGEN0);
+	reg32 &= ~((7<<CLKSRCSEL0)|(0x3F<<CLKDIV0)|(3<<OUTCLKDELAY0));
+	reg32 |= (1<<CLKSRCSEL0);		/* clock source: PLL1 */
+	reg32 |= (div<<CLKDIV0);		/* clock divider */
+	reg32 |= (1<<OUTCLKINV0);		/* inverted */
+	writel(reg32, dpc.mem + DPCCLKGEN0);
+
+	/* configure Clock 1 to derive from Clock 0, no divider */
+	reg32 = readl(dpc.mem + DPCCLKGEN1);
+	reg32 &= ~((7<<CLKSRCSEL1)|(0x3F<<CLKDIV1)|(3<<OUTCLKDELAY1));
+	reg32 |= (7<<CLKSRCSEL1);		/* clock source: DPC Clock 0 */
+	reg32 |= (1<<OUTCLKINV1);		/* inverted */
+	writel(reg32, dpc.mem + DPCCLKGEN1);
+
+	lf1000_dpc_set_clock_enable(0, 1);
+
+	/* set Control Register 0 flags */
+	reg16 = readw(dpc.mem + DPCCTRL0) & ~(1<<10);
+	reg16 &= ~(0x304); /* turn off: embedded sync, inverted, interlace */
+	reg16 |= (1<<12); /* enable RGB mode */
+	writew(reg16, dpc.mem + DPCCTRL0);
+
+	/* set Control Register 1 flags (vid order: CbYCrY, don't swap RGB,
+	 * no dithering), RGB888 format */
+	reg16 = readw(dpc.mem + DPCCTRL1) & ~(0xAFFF);
+	writew(reg16 | (3<<8), dpc.mem + DPCCTRL1);
+
+	/* set Control Register 2 flags (pad Vclk set to nVCLK2) */
+	reg16 = readw(dpc.mem + DPCCTRL2);
+	reg16 &= ~(3<<0);
+	writew(reg16 | (1<<0), dpc.mem + DPCCTRL2);
+	/* set up horizonal sync */
+	writew(screen->xres - 1 + screen->hbp + screen->hfp + screen->hsw,
+			dpc.mem + DPCHTOTAL);
+	writew(screen->hsw - 1, dpc.mem + DPCHSWIDTH);
+	writew(screen->hsw + screen->hbp - 1, dpc.mem + DPCHASTART);
+	writew(screen->hsw + screen->hbp + screen->xres - 1,
+			dpc.mem + DPCHAEND);
+	lf1000_dpc_clear_int();
+
+	/* set up vertical sync */
+	writew(screen->yres - 1 + screen->vbp + screen->vfp + screen->vsw,
+			dpc.mem + DPCVTOTAL);
+	writew(screen->vsw - 1, dpc.mem + DPCVSWIDTH);
+	writew(screen->vsw + screen->vbp - 1, dpc.mem + DPCVASTART);
+	writew(screen->vsw + screen->vbp + screen->yres - 1,
+			dpc.mem + DPCVAEND);
+	writew(0, dpc.mem + DPCEVTOTAL);
+	writew(0, dpc.mem + DPCEVSWIDTH);
+	writew(0, dpc.mem + DPCEVASTART);
+	writew(0, dpc.mem + DPCEVAEND);
+	lf1000_dpc_clear_int();
+
+	/* delays */
+	writew((7<<8)|(7<<4)|(7<<0), dpc.mem + DPCDELAY0);
+	lf1000_dpc_clear_int();
+
+	/* vsync offset */
+	writew(1, dpc.mem + DPCVSEOFFSET);
+	writew(1, dpc.mem + DPCVSSOFFSET);
+	writew(1, dpc.mem + DPCEVSEOFFSET);
+	writew(1, dpc.mem + DPCEVSSOFFSET);
+
+	lf1000_dpc_set_enable(0, 1);
+}
+
+static void lf1000_dpc_set_encoder_powerdown(bool en)
+{
+	u16 reg;
+	void __iomem *mem = dpc.mem + 0x400; /* second DPC register set */
+
+	/* power-down mode */
+	reg = readw(mem + VENCCTRLA) & ~(1<<7);
+	if (en)
+		reg |= (1<<7);
+	writew(reg, mem + VENCCTRLA);
+
+	/* DAC output */
+	reg = (en) ? 0x0 : 0x1;
+	writew(reg, mem + VENCDACSEL);
+}
+
+static void lf1000_dpc_set_dac_enable(bool en)
+{
+	u16 reg;
+	void __iomem *mem = dpc.mem + 0x400; /* second DPC register set */
+
+	reg = readw(mem + DPCCTRL0) & ~(1<<10);
+	if (en)
+		reg |= (1<<13);
+	else
+		reg &= ~(1<<13);
+	reg |= (1<<14); /* ENCENB */
+	writew(reg, mem + DPCCTRL0);
+
+	if (en)
+		writew(7, mem + VENCICNTL); /* encoder timing config */
+}
+
+static inline void lf1000_dpc_reset_encoder(void)
+{
+	lf1000_dpc_set_dac_enable(1);
+	udelay(100);
+	lf1000_dpc_set_clock_enable(1, 1);
+	udelay(100);
+	lf1000_dpc_set_dac_enable(0);
+	udelay(100);
+	lf1000_dpc_set_clock_enable(1, 0);
+	udelay(100);
+	lf1000_dpc_set_clock_enable(1, 1);
+}
+
+static void lf1000_dpc_enable_tvout(void)
+{
+	u32 reg32;
+	u16 reg16;
+	struct lf1000_screen_info *screen = dpc.screen;
+	void __iomem *mem = dpc.mem + 0x400; /* second DPC register set */
+
+	/* set PCLK mode to "only when CPU accesses" */
+	reg32 = readl(mem + DPCCLKENB) & ~(1<<3);
+	writel(reg32, mem + DPCCLKENB);
+
+	/* configure Clock 0 */
+	reg32 = readl(mem + DPCCLKGEN0);
+	reg32 &= ~((7<<CLKSRCSEL0)|(0x3F<<CLKDIV0)|(3<<OUTCLKDELAY0));
+	reg32 |= (5<<CLKSRCSEL0);		/* clock source: XTI */
+	writel(reg32, mem + DPCCLKGEN0);
+
+	/* configure Clock 1 to derive from Clock 0 */
+	reg32 = readl(mem + DPCCLKGEN1);
+	reg32 &= ~((7<<CLKSRCSEL1)|(0x3F<<CLKDIV1)|(3<<OUTCLKDELAY1));
+	reg32 |= (7<<CLKSRCSEL1);		/* clock source: DPC Clock 0 */
+	reg32 |= (1<<4);			/* divide by 2 */
+	writel(reg32, mem + DPCCLKGEN1);
+
+	/* set Control Register 0 flags */
+	reg16 = readw(mem + DPCCTRL0) & ~(1<<10);
+	reg16 &= ~(0x304); /* turn off: embedded sync, inverted */
+	reg16 |= (1<<9); /* enable interlacing */
+	reg16 &= ~(1<<12); /* disable RGB mode */
+	writew(reg16, mem + DPCCTRL0);
+
+	/* set Control Register 1 flags (vid order: CbYCrY, don't swap RGB,
+	 * no dithering, CCIR601B format, clamp YCbCr) */
+	reg16 = readw(mem + DPCCTRL1) & ~(0xAFFF);
+	writew(reg16 | (1<<13) | (13<<8), mem + DPCCTRL1);
+
+	/* set Control Register 2 flags (pad Vclk set to nVCLK2) */
+	reg16 = readw(mem + DPCCTRL2);
+	reg16 &= ~(3<<0);
+	writew(reg16 | (1<<0), mem + DPCCTRL2);
+	/* set up horizonal sync: 720 */
+	writew(720 - 1 + 81 + 24 + 33, mem + DPCHTOTAL);
+	writew(33 - 1, mem + DPCHSWIDTH);
+	writew(33 + 81 - 1, mem + DPCHASTART);
+	writew(33 + 81 + 720 - 1, mem + DPCHAEND);
+	lf1000_dpc_clear_int();
+
+	/* set up vertical sync: 240 */
+	writew(240 - 1 + 16 + 3 + 3, mem + DPCVTOTAL);
+	writew(3 - 1, mem + DPCVSWIDTH);
+	writew(3 + 16 - 1, mem + DPCVASTART);
+	writew(3 + 16 + 240 - 1, mem + DPCVAEND);
+	writew(240 - 1 + 3 + 4 + 16, mem + DPCEVTOTAL);
+	writew(3 - 1, mem + DPCEVSWIDTH);
+	writew(3 - 1 + 16, mem + DPCEVASTART);
+	writew(240 - 1 + 16 + 3, mem + DPCEVAEND);
+	lf1000_dpc_clear_int();
+
+	/* delays */
+	writew((4<<8)|(4<<4)|(4<<0), mem + DPCDELAY0);
+	lf1000_dpc_clear_int();
+
+	/* vsync offset */
+	writew(0, mem + DPCVSEOFFSET);
+	writew(0, mem + DPCVSSOFFSET);
+	writew(0, mem + DPCEVSEOFFSET);
+	writew(0, mem + DPCEVSSOFFSET);
+
+	lf1000_dpc_reset_encoder();
+	lf1000_dpc_set_dac_enable(1);
+	lf1000_dpc_set_encoder_powerdown(1);
+
+	/* NTSC mode with pedestal */
+	reg16 = readw(mem + VENCCTRLA);
+	reg16 &= ~((0xF<<3)|(0x3<<0));
+	writew(reg16 | (0x9<<3)|(0<<0), mem + VENCCTRLA);
+
+	/* color burst frequency adjust */
+	writew(0, mem + VENCFSCADJH);
+	writew(0, mem + VENCFSCADJL);
+
+	/* luma/chroma bandwidth */
+	writew(0, mem + VENCCTRLB);
+
+	/* color phase, hue, saturation, contrast, brightness */
+	writew(0, mem + VENCSCH);
+	writew(0, mem + VENCHUE);
+	writew(0, mem + VENCSAT);
+	writew(0, mem + VENCCRT);
+	writew(0, mem + VENCBRT);
+
+	/* set encoder timings */
+	writew(((1716-1)>>8) & 0x7, mem + VENCHSVS0);
+	writew(64-1, mem + VENCHSOS);
+	writew(1716-1, mem + VENCHSOE);
+	writew(0, mem + VENCVSOS);
+	writew(3, mem + VENCVSOE);
+
+	/* set horizontal upscaler: screen resolution to 720 */
+	writew(screen->xres - 1, mem + DPUPSCALECON2);
+	reg32 = ((screen->xres - 1)*(1<<11))/(720-1);
+	reg16 = reg32;
+	writew((reg16>>8) & 0x7F, mem + DPUPSCALECON1);
+	writew(((reg16 & 0xFF) << 8) | 1, mem + DPUPSCALECON0);
+
+	lf1000_dpc_set_encoder_powerdown(0);
+	lf1000_dpc_set_enable(1, 1);
+	lf1000_dpc_set_clock_enable(1, 1);
+}
+
+static void lf1000_dpc_disable_tvout(void)
+{
+	lf1000_dpc_set_dac_enable(0);
+	lf1000_dpc_set_encoder_powerdown(1);
+	lf1000_dpc_set_clock_enable(1, 0);
+	lf1000_dpc_set_enable(1, 0);
+}
+
+/* sysfs interface */
+
+static ssize_t show_tvout(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	return sprintf(buf, "%d\n", dpc.tvout);
+}
+
+static ssize_t set_tvout(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	int val;
+
+	if ((sscanf(buf, "%i", &val) != 1) || (val != 0 && val != 1))
+		return -EINVAL;
+
+	if (val)
+		lf1000_dpc_enable_tvout();
+	else
+		lf1000_dpc_disable_tvout();
+	dpc.tvout = val;
+
+	return count;
+}
+
+static DEVICE_ATTR(tvout, S_IRUGO | S_IWUGO, show_tvout, set_tvout);
+
+static ssize_t show_xres(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	return sprintf(buf, "%d\n", system_screen->xres);
+}
+
+static DEVICE_ATTR(xres, S_IRUGO , show_xres, NULL);
+
+static ssize_t show_yres(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	return sprintf(buf, "%d\n", system_screen->yres);
+}
+
+static DEVICE_ATTR(yres, S_IRUGO , show_yres, NULL);
+
+static struct attribute *dpc_attributes[] = {
+	&dev_attr_tvout.attr,
+	&dev_attr_xres.attr,
+	&dev_attr_yres.attr,
+	NULL
+};
+
+static struct attribute_group dpc_attr_group = {
+	.attrs = dpc_attributes,
+};
+
+static int lf1000_dpc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct dentry *dir;
+	struct lf1000_screen_info *screen = lf1000_get_screen_info();
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if (!screen->clk_hz)
+		screen->clk_hz = DPC_DEFAULT_HZ;
+	dpc.div = lf1000_CalcDivider(get_pll_freq(PLL1), screen->clk_hz);
+	if (dpc.div < 0) {
+		dev_err(&pdev->dev, "failed to get clock divider\n");
+		return -EFAULT;
+	}
+
+	if (!request_mem_region(res->start, RESSIZE(res), DRIVER_NAME)) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		return -EBUSY;
+	}
+
+	dpc.mem = ioremap_nocache(res->start, RESSIZE(res));
+	if (!dpc.mem) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		release_mem_region(res->start, RESSIZE(res));
+		return -ENOMEM;
+	}
+
+	dev_info(&pdev->dev, "screen: %dx%d\n", screen->xres, screen->yres);
+
+	dpc.screen = screen;
+
+	lf1000_dpc_configure();
+
+	dpc.tvout = gpio_have_tvout();
+	if (dpc.tvout)
+		lf1000_dpc_enable_tvout();
+	else
+		lf1000_dpc_disable_tvout();
+
+	sysfs_create_group(&pdev->dev.kobj, &dpc_attr_group);
+
+	dir = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (!dir || IS_ERR(dir)) {
+		dpc.debug = NULL;
+	} else {
+		debugfs_create_file("registers", S_IRUSR, dir, &dpc,
+				&lf1000_dpc_regs_fops);
+		debugfs_create_file("screen", S_IRUSR, dir, &dpc,
+				&lf1000_dpc_screen_fops);
+		debugfs_create_u32("div", S_IRUSR, dir, (u32 *)&dpc.div);
+	}
+
+	return 0;
+}
+
+static int lf1000_dpc_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	sysfs_remove_group(&pdev->dev.kobj, &dpc_attr_group);
+
+	iounmap(dpc.mem);
+	if (res)
+		release_mem_region(res->start, RESSIZE(res));
+
+	if (dpc.debug)
+		debugfs_remove_recursive(dpc.debug);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_dpc_driver = {
+	.probe	= lf1000_dpc_probe,
+	.remove	= lf1000_dpc_remove,
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lf1000_dpc_init(void)
+{
+	return platform_driver_register(&lf1000_dpc_driver);
+}
+
+static void __exit lf1000_dpc_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_dpc_driver);
+}
+
+module_init(lf1000_dpc_init);
+module_exit(lf1000_dpc_cleanup);
+MODULE_DESCRIPTION("LF1000 Display Controller Driver");
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -ruaN linux-2.6.31/arch/arm/Makefile linux-2.6/arch/arm/Makefile
--- linux-2.6.31/arch/arm/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/arch/arm/Makefile	2011-01-04 14:47:37.000000000 -0800
@@ -83,6 +83,12 @@
 tune-$(CONFIG_CPU_FEROCEON)	:=$(call cc-option,-mtune=marvell-f,-mtune=xscale)
 tune-$(CONFIG_CPU_V6)		:=$(call cc-option,-mtune=arm1136j-s,-mtune=strongarm)
 
+# tune for LF1000 ARM926T processor
+ifeq ($(CONFIG_ARCH_LF1000),y)
+arch-y :=-D__LINUX_ARM_ARCH__=5
+tune-y :=-mcpu=arm926ej-s
+endif
+
 ifeq ($(CONFIG_AEABI),y)
 CFLAGS_ABI	:=-mabi=aapcs-linux -mno-thumb-interwork
 else
@@ -128,6 +134,7 @@
 machine-$(CONFIG_ARCH_KIRKWOOD)		:= kirkwood
 machine-$(CONFIG_ARCH_KS8695)		:= ks8695
 machine-$(CONFIG_ARCH_L7200)		:= l7200
+machine-$(CONFIG_ARCH_LF1000)		:= lf1000
 machine-$(CONFIG_ARCH_LH7A40X)		:= lh7a40x
 machine-$(CONFIG_ARCH_LOKI) 		:= loki
 machine-$(CONFIG_ARCH_MMP)		:= mmp
@@ -169,6 +176,7 @@
 plat-$(CONFIG_PLAT_S3C24XX)	:= s3c24xx s3c
 plat-$(CONFIG_PLAT_S3C64XX)	:= s3c64xx s3c
 plat-$(CONFIG_ARCH_STMP3XXX)	:= stmp3xxx
+plat-$(CONFIG_PLAT_MES)		:= mes
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff -ruaN linux-2.6.31/arch/arm/plat-mes/include/plat/hardware.h linux-2.6/arch/arm/plat-mes/include/plat/hardware.h
--- linux-2.6.31/arch/arm/plat-mes/include/plat/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/plat-mes/include/plat/hardware.h	2011-01-04 14:52:00.000000000 -0800
@@ -0,0 +1,10 @@
+#ifndef __LF1000_PLAT_HARDWARE_H__
+#define __LF1000_PLAT_HARDWARE_H__
+
+#ifdef CONFIG_ARCH_LF1000
+#define cpu_is_lf1000()	(read_cpuid_id() == 0x41069265)
+#else
+#define cpu_is_lf1000()	(0)
+#endif
+
+#endif /* __LF1000_PLAT_HARDWARE_H__ */
diff -ruaN linux-2.6.31/arch/arm/plat-mes/include/plat/irq.h linux-2.6/arch/arm/plat-mes/include/plat/irq.h
--- linux-2.6.31/arch/arm/plat-mes/include/plat/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/plat-mes/include/plat/irq.h	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,16 @@
+/*
+ * arch/arm/plat-mes/include/plat/irq.h
+ *
+ * MagicEyes/LeapFrog SoC IRQ Handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_IRQ_H__
+#define __PLAT_IRQ_H__
+
+void mes_irq_init(void __iomem *base);
+
+#endif /* __PLAT_IRQ_H__ */
diff -ruaN linux-2.6.31/arch/arm/plat-mes/irq.c linux-2.6/arch/arm/plat-mes/irq.c
--- linux-2.6.31/arch/arm/plat-mes/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/plat-mes/irq.c	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,170 @@
+/* arch/arm/plat-mes/irq.c - vectored interrupt controller support for
+ * MagicEyes/Leapfrog SoCs.
+ *
+ * Copyright (c) 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/list.h>
+
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+#include <asm/hardware/vic.h>
+#include <mach/platform.h>
+#include <mach/ic.h>
+
+/* FIXME: IRQ Base */
+#define MES_INT_BASE	0xC0000800
+#define INTMASKL	0x10
+#define INTMASKH	0x14
+#define INTPENDL	0x20
+#define INTPENDH	0x24
+
+/* FIXME: DMA Mode and interrupt bit */
+#define MES_DMA_BASE	0xC0000000
+#define DMAMODE		0x0C
+#define DMA_INTENB	(1<<18)
+#define DMA_INTPEND	(1<<17)
+
+static __inline void mes_irq_clear(unsigned int irq)
+{
+	if (irq < 32)
+		writel((1 << irq), IO_ADDRESS(MES_INT_BASE + INTPENDL));
+	else
+		writel((1 << (irq - 32)), IO_ADDRESS(MES_INT_BASE + INTPENDH));
+}
+
+static void mes_irq_mask(unsigned int irq)
+{
+	unsigned long val;
+	unsigned int shift =irq & 63;
+
+	mes_irq_clear(irq);
+
+	if (irq < 32) {
+		val = readl(IO_ADDRESS(MES_INT_BASE + INTMASKL));
+		val |= (1 << shift);
+		writel(val, IO_ADDRESS(MES_INT_BASE + INTMASKL));
+	} else {
+		shift -= 32;
+		val = readl(IO_ADDRESS(MES_INT_BASE + INTMASKH));
+		val |= (1 << shift);
+		writel(val, IO_ADDRESS(MES_INT_BASE + INTMASKH));
+	}
+}
+
+static void mes_irq_unmask(unsigned int irq)
+{
+	unsigned long val;
+	unsigned int shift = irq & 63;
+
+	mes_irq_clear(irq);
+
+	if (irq < 32) {
+		val = readl(IO_ADDRESS(MES_INT_BASE + INTMASKL));
+		val &= ~(1 << shift);
+		writel(val, IO_ADDRESS(MES_INT_BASE + INTMASKL));
+	} else {
+		shift -= 32;
+		val = readl(IO_ADDRESS(MES_INT_BASE + INTMASKH));
+		val &= ~(1 << shift);
+		writel(val, IO_ADDRESS(MES_INT_BASE + INTMASKH));
+	}
+}
+
+static struct irq_chip mes_irq_chip = {
+	.name		= "MES IRQ",
+	.mask		= mes_irq_mask,
+	.mask_ack	= mes_irq_mask,
+	.unmask		= mes_irq_unmask,
+};
+
+static void mes_dma_irq_mask(unsigned int irq)
+{
+	unsigned int dma = irq_to_dma(irq);
+	unsigned long val;
+
+	mes_irq_clear(IRQ_DMA);
+
+	val = readl(IO_ADDRESS(MES_DMA_BASE + DMAMODE + (0x80 * dma)));
+	val &= ~(DMA_INTENB);	/* mask interrupt */
+	val |= DMA_INTPEND;	/* clear pending interrupt */
+	writel(val, IO_ADDRESS(MES_DMA_BASE + DMAMODE + (0x80 * dma)));
+}
+
+static void mes_dma_irq_unmask(unsigned int irq)
+{
+	unsigned int dma = irq_to_dma(irq);
+	unsigned long val;
+
+	mes_irq_clear(IRQ_DMA);
+	val = readl(IO_ADDRESS(MES_DMA_BASE + DMAMODE + (0x80 * dma)));
+	val |= DMA_INTENB;	/* enable interrupt */
+	val |= DMA_INTPEND;	/* clear interrupt */
+	writel(val, IO_ADDRESS(MES_DMA_BASE + DMAMODE + (0x80 * dma)));
+}
+
+static void mes_dma_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *mode = (void __iomem *)IO_ADDRESS(MES_DMA_BASE + DMAMODE);
+	unsigned long val;
+	int i;
+
+	for (i = 0; i < NR_DMA_IRQS; ++i) {
+		val = readl(mode + (0x80 * i));
+		if (val & DMA_INTPEND) {		   /* int pending ? */
+			generic_handle_irq(dma_to_irq(i)); /* software int  */
+		}
+	}
+}
+
+static struct irq_chip mes_dma_irq_chip = {
+	.name		= "MES DMA IRQ",
+	.mask		= mes_dma_irq_mask,
+	.mask_ack	= mes_dma_irq_mask,
+	.unmask		= mes_dma_irq_unmask,
+};
+
+void __init mes_irq_init(void __iomem *base)
+{
+	int i;
+
+	writel(0, base + INTMODEL);
+	writel(0, base + INTMODEH);
+	writel(~0, base + INTMASKL);
+	writel(~0, base + INTMASKH);
+	writel(~0, base + INTPENDL);
+	writel(~0, base + INTPENDH);
+	writel(0, base + PRIORDER);
+
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, &mes_irq_chip);
+		set_irq_chip_data(i, base);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* set DMA IRQ sources */
+	set_irq_chained_handler(IRQ_DMA, mes_dma_irq_handler);
+	for (i = dma_to_irq(0); i < dma_to_irq(NR_DMA_IRQS); ++i) {
+		set_irq_chip(i, &mes_dma_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	} 
+}
diff -ruaN linux-2.6.31/arch/arm/plat-mes/Makefile linux-2.6/arch/arm/plat-mes/Makefile
--- linux-2.6.31/arch/arm/plat-mes/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/arch/arm/plat-mes/Makefile	2011-01-04 14:47:37.000000000 -0800
@@ -0,0 +1,5 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-y	:= irq.o
diff -ruaN linux-2.6.31/build.sh linux-2.6/build.sh
--- linux-2.6.31/build.sh	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/build.sh	2011-01-04 15:11:12.000000000 -0800
@@ -0,0 +1,16 @@
+#!/bin/bash
+
+set +x
+
+./install.sh
+if [ "$?" != "0" ]; then
+	exit $?
+fi
+
+../scripts/make_cbf.py
+cp kernel.cbf /home/lfu
+
+pushd $ROOTFS_PATH
+tar -cvf modules.tar ./lib/modules
+cp modules.tar /home/lfu
+popd
diff -ruaN linux-2.6.31/default-log-level.patch linux-2.6/default-log-level.patch
--- linux-2.6.31/default-log-level.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/default-log-level.patch	2011-01-04 14:19:37.000000000 -0800
@@ -0,0 +1,13 @@
+Index: kernel/printk.c
+===================================================================
+--- kernel/printk.c	(revision 7350)
++++ kernel/printk.c	(working copy)
+@@ -52,7 +52,7 @@
+ 
+ /* We show everything that is MORE important than this.. */
+ #define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
+-#define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */
++#define DEFAULT_CONSOLE_LOGLEVEL 2 /* anything MORE serious than KERN_DEBUG */
+ 
+ DECLARE_WAIT_QUEUE_HEAD(log_wait);
+ 
diff -ruaN linux-2.6.31/drivers/hwmon/hwmon-lf1000.c linux-2.6/drivers/hwmon/hwmon-lf1000.c
--- linux-2.6.31/drivers/hwmon/hwmon-lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/hwmon/hwmon-lf1000.c	2012-11-16 18:18:27.000000000 -0800
@@ -0,0 +1,1092 @@
+/* hwmon-lf1000.c
+ *
+ * Power and Battery monitoring.  This driver provides battery and external
+ * power information, as well as an input device for the Power button.
+ * 
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * Copyright 2008 LeapFrog Enterprises Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/workqueue.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+
+#include <mach/adc.h>
+#include <mach/gpio.h>
+#include <mach/gpio_hal.h>
+#include <mach/common.h>
+#include <mach/clkpwr.h>
+#include <mach/power.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+/*
+ * power hardware
+ */
+
+enum lf1000_power_chip {
+	UNDEFINED = 0,
+	LF1000 = 1,	/* uses LF1000 power toggle input pin */
+};
+
+
+/*
+ * pins
+ */
+
+#define POWER_PORT	GPIO_PORT_C	/* power button */
+#define POWER_PIN	GPIO_PIN20
+
+/*
+ * configuration
+ */
+
+#define POWER_BUTTON_SAMPLING_J	(HZ/4)
+#define POWER_SAMPLING_J	(HZ/4)
+
+#define SHUTDOWN_SECS	2
+/* power down system after SHUTDOWN_SECS */
+#define POWER_BUTTON_COUNT  ((HZ * SHUTDOWN_SECS) / POWER_BUTTON_SAMPLING_J)
+
+/* platform device data */
+struct lf1000_hwmon {
+	enum lf1000_power_status status;	/* board status	*/
+	unsigned int max_battery_mv;		/* max battery, above is Ext */
+	unsigned int normal_battery_mv;		/* hysterisis low -> normal */
+	unsigned int low_battery_mv;		/* low battery level */
+	unsigned int low_battery_repeat_mv;	/* low battery repeat delta */
+	unsigned int critical_battery_mv;	/* critical battery level */
+
+	unsigned int adc_slope_256;		/* mx part of line	*/
+	unsigned int adc_constant;		/* constant part of line */
+
+	int supply_mv;				/* power supply, in mV */
+	int low_battery_reported_mv;		/* low battery reported,in mV */
+	unsigned on_battery :1;			/* running on battery */
+	unsigned shutdown : 1;			/* shutdown requested */
+	unsigned request_battery_report;	/* report battery status changes */
+
+	struct platform_device *pdev;
+
+	struct work_struct battery_work;	/* monitor power */
+	struct workqueue_struct *battery_tasks;
+	struct timer_list battery_timer;
+
+	struct work_struct power_button_work;	/* monitor power button*/
+	struct workqueue_struct *power_button_tasks;
+	struct timer_list power_button_timer;
+
+	int	power_button_count;		/* count power button calls */
+
+	enum	lf1000_power_chip chip;		/* support LF1000 */
+
+	/* input device interface */
+	unsigned char buttons[5];		/* one slot for each state */
+	struct input_dev *input;
+};
+
+static struct lf1000_hwmon *hwmon_dev = NULL;
+
+/* return battery reading in millivolts */
+static int lf1000_get_battery_mv(struct lf1000_hwmon *hwmon_dev)
+{
+	int reading;
+
+	/* ignore battery check on older Didj TouchScreen prototypes */
+	if (gpio_have_touchscreen() &&
+	    (gpio_have_gpio_dev() || gpio_have_gpio_didj()))
+		return (987654321);
+
+	reading = adc_GetReading(LF1000_ADC_VBATSENSE);
+	if(reading < 0) /* pass the error code down */
+		return reading;
+	return ((hwmon_dev->adc_slope_256 * reading / 256) +
+		 hwmon_dev->adc_constant);
+}
+EXPORT_SYMBOL_GPL(lf1000_get_battery_mv);
+
+/*
+ * Battery pack thermister value below 1000 mv (1 volts) means not in
+ * charger ADC reference is 3.3 volts, so each count is 3300/1024 ~ 3.2 mv
+ */
+
+#define BATTERY_PACK_LOW	(900 * 1024) / 3300 	// aprox .9 volts
+#define BATTERY_PACK_MEDIUM	(2250 * 1024) / 3300	// aprox 2.25 volts
+
+/*
+ * Have NiMH returns if NiMH pack is present and also if in charger.
+ *
+ * Take two battery pack ADC readings, GPIO low for first and high for second.
+ * ADC reading is LOW (<350), MEDIUM(350-700), or HIGH(>700).
+ * Return result based on this table:
+ *
+ * ADC    ADC 
+ * FIRST  SECOND  battery pack
+ * low    low     BATTERY_NIMH
+ * medium medium  BATTERY_NIMH_CHARGER
+ * low    high    BATTERY_OTHER
+ */
+
+static enum lf1000_power_source lf1000_get_power_source(unsigned int on_battery)
+{
+	int adc_val_0 = 0;
+	int adc_val_1 = 0;
+
+	// Madrid does not support charger
+	if (!gpio_have_gpio_madrid()) {
+		gpio_set_val(lf1000_l2p_port(BATTERY_PACK),	/* set pin low */
+				lf1000_l2p_pin(BATTERY_PACK), 0);
+
+		udelay(10);		/* 10 us settling time */
+		adc_val_0 = adc_GetReading(LF1000_ADC_BATT_TEMP);
+
+		gpio_set_val(lf1000_l2p_port(BATTERY_PACK),	/* set pin high */
+				lf1000_l2p_pin(BATTERY_PACK), 1);
+
+		udelay(10);		/* 10 us settling time */
+		adc_val_1 = adc_GetReading(LF1000_ADC_BATT_TEMP);
+
+		if (adc_val_0 < BATTERY_PACK_LOW && 
+				adc_val_1 < BATTERY_PACK_LOW)
+			return (on_battery ? POWER_NIMH : POWER_NIMH_EXTERNAL);
+
+		if (BATTERY_PACK_LOW     < adc_val_0 &&
+			adc_val_0        < BATTERY_PACK_MEDIUM &&
+			BATTERY_PACK_LOW < adc_val_1 &&
+			adc_val_1        < BATTERY_PACK_MEDIUM)
+
+			return (POWER_NIMH_CHARGER);
+	}	/* if (!gpio_have_gpio_madrid()) */
+
+	return(on_battery ? POWER_BATTERY : POWER_EXTERNAL);
+}
+
+/*
+ * Convert battery reading to power status based on current status 
+ */
+static enum lf1000_power_status power_to_status(
+		struct lf1000_hwmon *hwmon_dev, int mv)
+{
+	enum lf1000_power_source power_source;
+
+	if(gpio_have_gpio_k2())	     /* K2 hack: always external power */
+		return EXTERNAL;
+
+	// Look for NiMH charger
+	power_source = lf1000_get_power_source(hwmon_dev->on_battery);
+
+	/* see if we're on the NiMH Charger */
+	switch (power_source) {
+	case POWER_UNKNOWN:		break;
+	case POWER_OTHER:		break;
+	case POWER_NIMH:		break;
+	case POWER_NIMH_CHARGER:	return(NIMH_CHARGER);
+	case POWER_NIMH_EXTERNAL:	break;
+	case POWER_BATTERY:		break;
+	case POWER_EXTERNAL:		break;
+	default:			break;
+	}
+
+
+	if(!hwmon_dev->on_battery) /* no need to make measurements */
+		return EXTERNAL;
+
+	if(mv < 0)
+		return UNKNOWN;
+
+	if(mv < hwmon_dev->critical_battery_mv)
+		return CRITICAL_BATTERY;
+	
+	/* hysterisis between 'low' and 'normal' battery */
+	if(mv < hwmon_dev->low_battery_mv || 
+		(mv < hwmon_dev->normal_battery_mv &&
+		 hwmon_dev->status == LOW_BATTERY)) {
+		return LOW_BATTERY;
+	}
+	if(mv < hwmon_dev->max_battery_mv)
+		return (power_source == POWER_BATTERY ? BATTERY : NIMH);
+	
+	return EXTERNAL;
+}
+
+/*
+ * Determine and report current power status
+ */
+static enum lf1000_power_status lf1000_get_battery_status(void)
+{
+	if(!hwmon_dev)
+		return UNKNOWN;
+	return power_to_status(hwmon_dev, lf1000_get_battery_mv(hwmon_dev));
+}
+EXPORT_SYMBOL_GPL(lf1000_get_battery_status);
+
+/*
+ * sysfs Interface
+ */
+
+/* report whether shutdown was requested */
+static ssize_t show_shutdown(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->shutdown);
+}
+static DEVICE_ATTR(shutdown, S_IRUSR|S_IRGRP|S_IROTH, show_shutdown, NULL);
+
+/* report current battery voltage, in mV */
+static ssize_t show_voltage(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->supply_mv);
+}
+static DEVICE_ATTR(voltage, S_IRUSR|S_IRGRP|S_IROTH, show_voltage, NULL);
+
+/* low battery reported voltage, in mV */
+static ssize_t show_low_battery_reported_voltage(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->low_battery_reported_mv);
+}
+static DEVICE_ATTR(low_battery_reported_voltage, S_IRUSR|S_IRGRP|S_IROTH,
+			show_low_battery_reported_voltage, NULL);
+
+/* report state of external power (1 = on external, 0 = on battery) */
+static ssize_t show_external(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->on_battery ? 0 : 1);
+}
+static DEVICE_ATTR(external, S_IRUSR|S_IRGRP|S_IROTH, show_external, NULL);
+
+/* report power status as a number */
+static ssize_t show_status(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->status);
+}
+static DEVICE_ATTR(status, S_IRUSR|S_IRGRP|S_IROTH, show_status, NULL);
+
+static ssize_t show_max_battery_mv(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->max_battery_mv);
+}
+
+static ssize_t set_max_battery_mv(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > 16384)
+		return -EINVAL;
+	priv->max_battery_mv = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(max_battery_mv, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_max_battery_mv, set_max_battery_mv);
+
+static ssize_t show_normal_battery_mv(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->normal_battery_mv);
+}
+
+static ssize_t set_normal_battery_mv(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > 16384)
+		return -EINVAL;
+	priv->normal_battery_mv = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(normal_battery_mv, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_normal_battery_mv, set_normal_battery_mv);
+
+static ssize_t show_low_battery_mv(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->low_battery_mv);
+}
+
+static ssize_t set_low_battery_mv(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > 16384)
+		return -EINVAL;
+	priv->low_battery_mv = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(low_battery_mv, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_low_battery_mv, set_low_battery_mv);
+
+
+static ssize_t show_low_battery_repeat_mv(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->low_battery_repeat_mv);
+}
+
+static ssize_t set_low_battery_repeat_mv(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > 16384)
+		return -EINVAL;
+	priv->low_battery_repeat_mv = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(low_battery_repeat_mv, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_low_battery_repeat_mv, set_low_battery_repeat_mv);
+
+static ssize_t show_critical_battery_mv(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->critical_battery_mv);
+}
+
+static ssize_t set_critical_battery_mv(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > 16384)
+		return -EINVAL;
+	priv->critical_battery_mv = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(critical_battery_mv,
+		S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_critical_battery_mv, set_critical_battery_mv);
+
+static ssize_t show_adc_slope_256(struct device *pdev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->adc_slope_256);
+}
+
+static ssize_t set_adc_slope_256(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < -65536 || temp > 65535)
+		return -EINVAL;
+	priv->adc_slope_256 = temp;
+	priv->request_battery_report = 1;	/* report battery status */
+	return(count);
+}
+
+static DEVICE_ATTR(adc_slope_256, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_adc_slope_256, set_adc_slope_256);
+
+static ssize_t show_adc_constant(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	return sprintf(buf, "%d\n", priv->adc_constant);
+}
+
+static ssize_t set_adc_constant(struct device *pdev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		return -EINVAL;
+	if (temp < -4096 || temp > 4095)
+		return -EINVAL;
+	priv->adc_constant = temp;
+	priv->request_battery_report = 1;	/* report battery status */
+	return(count);
+}
+
+static DEVICE_ATTR(adc_constant, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH,
+		show_adc_constant, set_adc_constant);
+
+static ssize_t show_power_source(struct device *pdev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)pdev->driver_data;
+	enum lf1000_power_source power_source;
+
+	power_source = lf1000_get_power_source(priv->on_battery);
+
+	switch (power_source) {
+	case POWER_UNKNOWN:	  return sprintf(buf, "UNKNOWN\n");
+	case POWER_OTHER:	  return sprintf(buf, "OTHER\n");
+	case POWER_NIMH:	  return sprintf(buf, "NIMH\n");
+	case POWER_NIMH_CHARGER:  return sprintf(buf, "NIMH_CHARGER\n");
+	case POWER_NIMH_EXTERNAL: return sprintf(buf, "NIMH_EXTERNAL\n");
+	case POWER_BATTERY:	  return sprintf(buf, "BATTERY\n");
+	case POWER_EXTERNAL:	  return sprintf(buf, "EXTERNAL\n");
+	default:	          return sprintf(buf, "default(%d)\n",
+						power_source);
+	}
+}
+
+static DEVICE_ATTR(power_source, S_IRUSR|S_IRGRP|S_IROTH,
+		show_power_source, NULL);
+
+static struct attribute *power_attributes[] = {
+	&dev_attr_shutdown.attr,
+	&dev_attr_voltage.attr,
+	&dev_attr_low_battery_reported_voltage.attr,
+	&dev_attr_external.attr,
+	&dev_attr_status.attr,
+	&dev_attr_max_battery_mv.attr,
+	&dev_attr_normal_battery_mv.attr,
+	&dev_attr_low_battery_mv.attr,
+	&dev_attr_low_battery_repeat_mv.attr,
+	&dev_attr_critical_battery_mv.attr,
+	&dev_attr_adc_slope_256.attr,
+	&dev_attr_adc_constant.attr,
+	&dev_attr_power_source.attr,
+	NULL
+};
+
+static struct attribute_group power_attr_group = {
+	.attrs = power_attributes
+};
+
+static void battery_monitoring_task(unsigned long data)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)data;
+
+	queue_work(priv->battery_tasks, &priv->battery_work);
+	priv->battery_timer.expires += POWER_SAMPLING_J;
+	priv->battery_timer.function = battery_monitoring_task;
+	priv->battery_timer.data = data;
+	if (!timer_pending(&priv->battery_timer))
+		add_timer(&priv->battery_timer);
+}
+
+static void power_button_monitoring_task(unsigned long data)
+{
+	struct lf1000_hwmon *priv = (struct lf1000_hwmon *)data;
+
+	queue_work(priv->power_button_tasks, &priv->power_button_work);
+}
+
+/*
+ * read the system power button status
+ */
+static int get_power_button(int chip)
+{
+	int ret = 0;
+	
+	switch(chip)
+	{
+		case LF1000:
+			ret = gpio_get_val(POWER_PORT, POWER_PIN);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, chip);
+			break;
+	}
+	return ret;
+}
+
+
+/*
+ * handle power button, shutdown if pressed for SHUTDOWN_SECS
+ */
+
+static void lf1000_power_button(struct work_struct *work)
+{
+	int power_button = get_power_button(hwmon_dev->chip);
+
+	/* report event if power button just pressed */
+	if (!hwmon_dev->power_button_count && power_button) {	
+		input_report_key(hwmon_dev->input, KEY_POWER, 1);
+		dev_info(&hwmon_dev->pdev->dev,
+			"Power button pressed\n");
+	}
+
+	/* report if power button is released */
+	if (hwmon_dev->power_button_count < POWER_BUTTON_COUNT &&
+		!power_button) {
+
+		/* report event if power button just released */
+		if (hwmon_dev->power_button_count) {
+			input_report_key(hwmon_dev->input, KEY_POWER, 0);
+			dev_info(&hwmon_dev->pdev->dev,
+				"Power button released\n");
+		}
+
+		hwmon_dev->power_button_count = 0; /* reset count */ 
+		/* enable the power button IRQ */
+		switch (hwmon_dev->chip)
+		{
+		case LF1000:
+			gpio_set_int(POWER_PORT, POWER_PIN, 1);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, hwmon_dev->chip);
+			break;
+		}
+		return;
+	}
+
+	/* note shutdown was requested, set shutdown bit but never clear it */
+	hwmon_dev->shutdown = 1;
+
+	/* button still pressed, run task up to POWER_BUTTON_COUNT times */
+	if (hwmon_dev->power_button_count++ <= POWER_BUTTON_COUNT) {
+		hwmon_dev->power_button_timer.expires +=
+			 POWER_BUTTON_SAMPLING_J;
+		hwmon_dev->power_button_timer.function =
+			power_button_monitoring_task;
+		hwmon_dev->power_button_timer.data = (unsigned long)hwmon_dev;
+
+		if (!timer_pending(&hwmon_dev->power_button_timer))
+			add_timer(&hwmon_dev->power_button_timer);
+
+		/*
+		 * Use second to last time through to show some status,
+		 * as pm_power_off() is too late.
+		 */
+		if (hwmon_dev->power_button_count == POWER_BUTTON_COUNT)
+		       dev_info(&hwmon_dev->pdev->dev,
+			"Power button held, shutdown with pm_power_off()\n");
+	} else {
+		/* ran timer long enough, shutdown */
+		pm_power_off();
+	}
+}
+
+/*
+ * Start background process
+ */
+
+static void lf1000_start_power_button_monitor(void)
+{
+	if (!hwmon_dev->power_button_count) {/* run background task */
+		hwmon_dev->power_button_timer.expires = get_jiffies_64();
+		hwmon_dev->power_button_timer.function =
+			power_button_monitoring_task;
+		hwmon_dev->power_button_timer.data = (unsigned long)hwmon_dev;
+		if (!timer_pending(&hwmon_dev->power_button_timer))
+			add_timer(&hwmon_dev->power_button_timer);
+	}
+}
+
+
+/*
+ * Got an interrupt.  Let background task process it
+ */
+static irqreturn_t power_button_irq(enum gpio_port port, enum gpio_pin pin,
+					void *data) 
+{
+	if (gpio_get_pend(POWER_PORT, POWER_PIN)) {
+		gpio_set_int(POWER_PORT, POWER_PIN, 0);
+		lf1000_start_power_button_monitor();
+		gpio_clear_pend(POWER_PORT, POWER_PIN);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/* Running on battery?  If so return non-zero */
+static int lf1000_is_battery(int chip)
+{
+	int ret = 0;
+
+	switch(chip)
+	{
+	case LF1000:
+		ret = gpio_get_val(lf1000_l2p_port(EXT_POWER),
+				   lf1000_l2p_pin(EXT_POWER)) ? 0 : 1;
+		break;
+	default:
+		dev_alert(&hwmon_dev->pdev->dev,
+			"%s.%d unknown chip %d\n", __FUNCTION__,
+			__LINE__, chip);
+	}
+	return ret;
+}
+
+static void lf1000_set_battery(struct work_struct *work)
+{
+	/* last reported battery status */
+	enum lf1000_power_status last_status = hwmon_dev->status;
+	int supply_drop;
+#ifdef CONFIG_MACH_LF_LF1000
+	/* get external power status */
+
+	if(gpio_have_gpio_k2())	     /* K2 hack: always external power */
+		hwmon_dev->on_battery = 0;
+	else
+		hwmon_dev->on_battery = lf1000_is_battery(hwmon_dev->chip);
+#endif
+	/* read the current battery voltage */
+	hwmon_dev->supply_mv = lf1000_get_battery_mv(hwmon_dev);
+	/* determine the current power status */
+	hwmon_dev->status = power_to_status(hwmon_dev, hwmon_dev->supply_mv);
+
+	switch(hwmon_dev->status)
+	{
+	case CRITICAL_BATTERY:
+	    /* first report of critical battery */
+	    if(last_status != CRITICAL_BATTERY) {
+		input_report_key(hwmon_dev->input, KEY_BATTERY, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_BATTERY, 1); /* down */
+		dev_alert(&hwmon_dev->pdev->dev,
+				"Report Critical Battery (%d mv)\n",
+				hwmon_dev->supply_mv);
+		hwmon_dev->low_battery_reported_mv = hwmon_dev->supply_mv;
+	    }
+	    break;
+
+	case LOW_BATTERY:
+	    /* first report of LOW_BATTERY, key down */
+	    if ((last_status != LOW_BATTERY &&
+		 last_status != CRITICAL_BATTERY) ||
+		(last_status != LOW_BATTERY &&
+		 hwmon_dev->request_battery_report)) {
+		input_report_key(hwmon_dev->input, KEY_MINUS, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_MINUS, 1); /* down */
+	    	dev_alert(&hwmon_dev->pdev->dev,
+				"Report Low Battery (%d mv)\n",
+				hwmon_dev->supply_mv);
+		hwmon_dev->low_battery_reported_mv = hwmon_dev->supply_mv;
+	    } else {
+		/* repeat LOW_BATTERY when voltage drops below threshold */
+		supply_drop = hwmon_dev->low_battery_reported_mv -
+		hwmon_dev->supply_mv;
+		if (0 < supply_drop &&
+		    hwmon_dev->low_battery_repeat_mv < supply_drop) {
+		    input_report_key(hwmon_dev->input, KEY_MINUS, 0); /* up */
+		    input_report_key(hwmon_dev->input, KEY_MINUS, 1); /* down */
+		    dev_alert(&hwmon_dev->pdev->dev,
+				    "Report Low Battery (%d mv)\n",
+				    hwmon_dev->supply_mv);
+		    hwmon_dev->low_battery_reported_mv = hwmon_dev->supply_mv;
+		}
+	    }
+	    break;
+
+	case BATTERY:
+	    /* first report of BATTERY, key down */
+	    if ((last_status != BATTERY && last_status != CRITICAL_BATTERY) ||
+		(last_status != BATTERY && hwmon_dev->request_battery_report)) {
+		input_report_key(hwmon_dev->input, KEY_EQUAL, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_EQUAL, 1); /* down */
+		dev_alert(&hwmon_dev->pdev->dev, "Report Battery (%d mv)\n",
+				hwmon_dev->supply_mv);
+	    }
+	    break;
+
+	case EXTERNAL:
+	    /* first report of EXTERNAL, key down */
+	    if ((last_status != EXTERNAL && last_status != CRITICAL_BATTERY) ||
+	       (last_status != EXTERNAL && hwmon_dev->request_battery_report)) {
+		input_report_key(hwmon_dev->input, KEY_UP, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_UP, 1); /* down */
+		dev_alert(&hwmon_dev->pdev->dev, "Report External (%d mv)\n",
+				hwmon_dev->supply_mv);
+	    }
+	    break;
+
+	case NIMH:
+	    /* first report of NIMH, key down */
+	    if ((last_status != NIMH && last_status != CRITICAL_BATTERY) ||
+		(last_status != NIMH && hwmon_dev->request_battery_report)) {
+		input_report_key(hwmon_dev->input, KEY_KPEQUAL, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_KPEQUAL, 1); /* down */
+		dev_alert(&hwmon_dev->pdev->dev, "Report NIMH (%d mv)\n",
+				hwmon_dev->supply_mv);
+	    }
+	    break;
+
+
+	case NIMH_CHARGER:
+	    /* first report of NIMH_CHARGER, key down */
+	    if ((last_status != NIMH_CHARGER &&
+					last_status != CRITICAL_BATTERY) ||
+		(last_status != NIMH_CHARGER &&
+					hwmon_dev->request_battery_report)) {
+		input_report_key(hwmon_dev->input, KEY_PAGEUP, 0); /* up */
+		input_report_key(hwmon_dev->input, KEY_PAGEUP, 1); /* down */
+		dev_alert(&hwmon_dev->pdev->dev, "Report NIMH_CHARGER (%d mv)\n",
+				hwmon_dev->supply_mv);
+	    }
+	    break;
+
+	default:
+	    break;
+	}
+	hwmon_dev->request_battery_report = 0;	/* finished any reporting */
+}
+
+/*
+ * set up input device for power button and critical battery
+ */
+static int setup_power_button(struct platform_device *pdev)
+{
+	struct lf1000_hwmon *data = platform_get_drvdata(pdev);
+	struct input_dev *input_dev;
+	int ret;
+
+	input_dev = input_allocate_device();
+	if(!input_dev)
+		return -ENOMEM;
+
+	input_dev->name = "Power Button";
+	input_dev->phys = "lf1000/power_button";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0001;
+	
+	input_dev->evbit[0] = BIT(EV_KEY);
+	input_dev->keycode = data->buttons;
+	input_dev->keycodesize = sizeof(unsigned char);
+	input_dev->keycodemax = 7;
+
+	data->input = input_dev;
+	data->buttons[0] = KEY_POWER;	/* we only support power button */
+	data->buttons[1] = KEY_BATTERY;	/* and critical battery warning */
+	data->buttons[2] = KEY_MINUS;	/* low battery warning */
+	data->buttons[3] = KEY_EQUAL;	/* normal battery */
+	data->buttons[4] = KEY_UP;	/* external power */
+	data->buttons[5] = KEY_KPEQUAL;	/* NiMH battery */
+	data->buttons[6] = KEY_PAGEUP;	/* NiMH Charger */
+	set_bit(data->buttons[0], input_dev->keybit);
+	set_bit(data->buttons[1], input_dev->keybit);
+	set_bit(data->buttons[2], input_dev->keybit);
+	set_bit(data->buttons[3], input_dev->keybit);
+	set_bit(data->buttons[4], input_dev->keybit);
+	set_bit(data->buttons[5], input_dev->keybit);
+	set_bit(data->buttons[6], input_dev->keybit);
+
+	ret = input_register_device(data->input);
+	if(ret)
+		goto fail_register;
+
+	switch (data->chip)
+	{
+		case LF1000:
+			ret = gpio_request_irq(POWER_PORT, POWER_PIN,
+					power_button_irq, data);
+			if(ret) {
+				dev_err(&pdev->dev,
+					"failed to get button IRQ\n");
+				goto fail_irq;
+			}
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, data->chip);
+			break;
+	}
+	
+	/* configure GPIO pin for interrupts */
+	switch (data->chip)
+	{
+		case LF1000:
+			gpio_set_fn(POWER_PORT, POWER_PIN, GPIO_GPIOFN);
+			gpio_set_int_mode(POWER_PORT, POWER_PIN,
+						GPIO_IMODE_RISING_EDGE);
+			gpio_set_int(POWER_PORT, POWER_PIN, 0);
+			gpio_clear_pend(POWER_PORT, POWER_PIN);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, data->chip);
+			break;
+	}
+
+	/* enable the power button IRQ */
+	switch (data->chip)
+	{
+		case LF1000:
+			gpio_set_int(POWER_PORT, POWER_PIN, 1);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, data->chip);
+			break;
+	}
+
+	return 0;
+
+fail_irq:
+	switch (data->chip)
+	{
+		case LF1000:
+			gpio_set_int(POWER_PORT, POWER_PIN, 0);
+			gpio_clear_pend(POWER_PORT, POWER_PIN);
+			gpio_free_irq(POWER_PORT, POWER_PIN, power_button_irq);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, data->chip);
+			break;
+	}
+
+fail_register:
+	input_free_device(input_dev);
+	return ret;
+}
+
+static int lf1000_power_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct lf1000_hwmon *priv;
+
+	priv = kzalloc(sizeof(struct lf1000_hwmon), GFP_KERNEL);
+	if(!priv) {
+		ret = -ENOMEM;
+		goto fail_alloc;
+	}
+
+	priv->pdev = pdev;
+
+	platform_set_drvdata(pdev, priv);
+
+	hwmon_dev = priv;
+
+	/* sniff for LFP100 power chip */
+	priv->chip = LF1000;
+	dev_info(&pdev->dev, "%s.%d use LF1000 power control\n",
+		__FUNCTION__, __LINE__);
+	
+	/* set initial battery thresholds */
+	priv->max_battery_mv      = MAX_BATTERY_MV;
+	priv->normal_battery_mv   = NORMAL_BATTERY_MV;
+	priv->low_battery_mv      = LOW_BATTERY_MV;
+	priv->low_battery_repeat_mv = LOW_BATTERY_REPEAT_MV;
+	priv->low_battery_mv      = LOW_BATTERY_MV;
+	priv->critical_battery_mv = CRITICAL_BATTERY_MV;
+
+	if (gpio_have_gpio_dev()) {
+		priv->adc_slope_256 = ADC_SLOPE_256_ME_LF1000;
+		priv->adc_constant  = ADC_CONSTANT_ME_LF1000;
+	} else {
+		priv->adc_slope_256 = ADC_SLOPE_256_LF_LF1000;
+		priv->adc_constant  = ADC_CONSTANT_LF_LF1000;
+	}
+
+#ifdef CONFIG_MACH_LF_LF1000
+	if(gpio_have_gpio_k2())	     /* K2 hack: never on battery */
+		hwmon_dev->on_battery = 0;
+	else
+		hwmon_dev->on_battery = lf1000_is_battery(hwmon_dev->chip);
+#else /* CONFIG_MACH_ME_LF1000 */
+	hwmon_dev->on_battery = 0; /* never on battery */
+#endif
+
+	/* grab initial battery setting */
+	hwmon_dev->supply_mv = lf1000_get_battery_mv(priv);
+	priv->low_battery_reported_mv = LOW_BATTERY_MV;
+	if(priv->supply_mv < 0) {
+		dev_err(&pdev->dev, "%s.%d: initial battery read failed\n",
+			__FUNCTION__, __LINE__);
+		goto fail_adc;
+	}
+
+	/* set initial power state */
+	priv->status = power_to_status(priv, priv->supply_mv);
+
+	dev_info(&pdev->dev, "%s.%d status is: %d\n",
+			__FUNCTION__, __LINE__, priv->status);
+
+	dev_info(&pdev->dev, "%s.%d have_external is: %d\n",
+			__FUNCTION__, __LINE__, priv->on_battery ? 0 : 1);
+
+	dev_info(&pdev->dev, "%s.%d initial battery reading is: %d\n",
+			__FUNCTION__, __LINE__, priv->supply_mv);
+
+	/* no initial battery report */
+	priv->request_battery_report = 0;
+
+	/*
+	 * setup to BATTERY_PACK GPIO as output
+	 * to sniff for NiMH battery pack
+	 */
+	gpio_configure_pin(lf1000_l2p_port(BATTERY_PACK),
+		lf1000_l2p_pin(BATTERY_PACK), GPIO_GPIOFN, 1, 0, 0);
+
+	/* set up work queue to monitor the battery */
+	priv->battery_tasks =
+		create_singlethread_workqueue("power tasks");
+	INIT_WORK(&priv->battery_work, lf1000_set_battery);
+
+	/* set up periodic sampling of the battery */
+	setup_timer(&priv->battery_timer, battery_monitoring_task,
+		       (unsigned long)priv);
+	priv->battery_timer.expires = get_jiffies_64() + POWER_SAMPLING_J;
+	add_timer(&priv->battery_timer);
+
+	/* set up work queue to handle the power button */
+	priv->power_button_tasks =
+		create_singlethread_workqueue("power button tasks");
+	INIT_WORK(&priv->power_button_work, lf1000_power_button);
+
+	/* init button power timer */
+	setup_timer(&priv->power_button_timer, power_button_monitoring_task,
+		       (unsigned long)priv);
+
+	/* setup power button monitoring after initializing timer structure */
+	ret = setup_power_button(pdev);
+	if(ret)
+		goto fail_button;
+	sysfs_create_group(&pdev->dev.kobj, &power_attr_group);
+	return 0;
+
+fail_adc:
+fail_button:
+fail_alloc:
+	kfree(priv);
+	return ret;
+}
+
+static int lf1000_power_remove(struct platform_device *pdev)
+{
+	struct lf1000_hwmon *priv = platform_get_drvdata(pdev);
+
+	switch (priv->chip)
+	{
+		case LF1000:
+			gpio_set_int(POWER_PORT, POWER_PIN, 0);
+			gpio_clear_pend(POWER_PORT, POWER_PIN);
+			gpio_free_irq(POWER_PORT, POWER_PIN, power_button_irq);
+			break;
+		default:
+			dev_alert(&hwmon_dev->pdev->dev,
+				"%s.%d unknown chip %d\n", __FUNCTION__,
+				__LINE__, priv->chip);
+			break;
+	}
+
+	destroy_workqueue(priv->battery_tasks);
+	destroy_workqueue(priv->power_button_tasks);
+
+	sysfs_remove_group(&pdev->dev.kobj, &power_attr_group);
+
+	input_unregister_device(priv->input);
+
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_power_driver = {
+	.probe      = lf1000_power_probe,
+	.remove     = lf1000_power_remove,
+	.driver     = {
+		.name	= "lf1000-power",
+		.owner	= THIS_MODULE,
+	},
+};
+
+/*
+ * module stuff
+ */
+ 
+static int __init init_lf1000_power(void)
+{
+	return platform_driver_register(&lf1000_power_driver);
+}
+
+static void cleanup_lf1000_power(void)
+{
+	platform_driver_unregister(&lf1000_power_driver);
+}
+
+module_init(init_lf1000_power);
+module_exit(cleanup_lf1000_power);
+
+MODULE_AUTHOR("Scott Esters, Andrey Yurovsky");
+MODULE_DESCRIPTION("LF1000 hardware monitoring");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/hwmon/Kconfig linux-2.6/drivers/hwmon/Kconfig
--- linux-2.6.31/drivers/hwmon/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/hwmon/Kconfig	2011-01-04 15:06:55.000000000 -0800
@@ -448,6 +448,13 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called it87.
 
+config SENSORS_LF1000
+    boolean "LF1000 Hardware Monitoring"
+    depends on ARCH_LF1000
+    help
+      If you say yes here you get support for the LF1000 battery
+      and power monitoring.
+
 config SENSORS_LM63
 	tristate "National Semiconductor LM63"
 	depends on I2C
diff -ruaN linux-2.6.31/drivers/hwmon/Makefile linux-2.6/drivers/hwmon/Makefile
--- linux-2.6.31/drivers/hwmon/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/hwmon/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -53,6 +53,7 @@
 obj-$(CONFIG_SENSORS_IBMPEX)	+= ibmpex.o
 obj-$(CONFIG_SENSORS_IT87)	+= it87.o
 obj-$(CONFIG_SENSORS_K8TEMP)	+= k8temp.o
+obj-$(CONFIG_SENSORS_LF1000)	+= hwmon-lf1000.o
 obj-$(CONFIG_SENSORS_LIS3LV02D) += lis3lv02d.o hp_accel.o
 obj-$(CONFIG_SENSORS_LIS3_SPI)	+= lis3lv02d.o lis3lv02d_spi.o
 obj-$(CONFIG_SENSORS_LM63)	+= lm63.o
diff -ruaN linux-2.6.31/drivers/i2c/busses/i2c-lf1000.c linux-2.6/drivers/i2c/busses/i2c-lf1000.c
--- linux-2.6.31/drivers/i2c/busses/i2c-lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/i2c/busses/i2c-lf1000.c	2011-02-04 10:30:03.000000000 -0800
@@ -0,0 +1,574 @@
+/*
+ * drivers/i2c/bus/i2c-lf1000.c
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * I2C bus driver for the LF1000 CPUs.  Based heavily on 
+ * i2c-at91.c and i2c-mpc.c
+ *
+ * TODO: more pin configurations (for the rest of the channels)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/i2c.h>
+#include <mach/gpio.h>
+
+#define DRIVER_NAME		"lf1000-i2c"
+#define I2C_CHANNEL		CONFIG_I2C_LF1000_CHANNEL
+#define LF1000_I2C_TIMEOUT	10 /* (in jiffies) */
+#define LF1000_I2C_RATE_HZ	100000
+
+/* FIXME: add channel 0 settings, choose based on I2C_CHANNEL */
+#define I2C_SCL0_PORT	GPIO_PORT_A
+#define I2C_SCL0_PIN	GPIO_PIN26
+#define I2C_SCL0_FN	GPIO_ALT1
+#define I2C_SDA0_PORT	GPIO_PORT_A
+#define I2C_SDA0_PIN	GPIO_PIN27
+#define I2C_SDA0_FN	GPIO_ALT1
+
+#define I2C_SCL1_PORT	GPIO_PORT_A
+#define I2C_SCL1_PIN	GPIO_PIN28
+#define I2C_SCL1_FN	GPIO_ALT1
+#define I2C_SDA1_PORT	GPIO_PORT_A
+#define I2C_SDA1_PIN	GPIO_PIN29
+#define I2C_SDA1_FN	GPIO_ALT1
+
+enum lf1000_i2c_state {
+	I2C_SEND_ADDR,
+	I2C_SEND_DATA,
+	I2C_SEND_DONE,
+};
+
+struct lf1000_i2c {
+	int			div;
+
+	/* device access */
+	wait_queue_head_t	wait;
+	int			ready;
+
+	/* bus access */
+	wait_queue_head_t	bus_access;
+	int			busy;
+	struct i2c_adapter	adap;
+	
+	void __iomem		*reg_base;
+
+	unsigned long		iobase;
+	unsigned long		iosize;
+
+	int			irq;
+};
+
+static irqreturn_t lf1000_i2c_irq(int irq, void *dev_id)
+{
+	struct lf1000_i2c *i2c = dev_id;
+	u32 tmp = ioread32(i2c->reg_base+IRQ_PEND);
+
+	if(!(tmp & (1<<PEND))) /* sanity check */
+		return IRQ_NONE;
+
+	/* clear pending interrupt */
+	tmp |= (1<<PEND);
+	iowrite32(tmp, i2c->reg_base+IRQ_PEND);
+
+	i2c->ready = 1;
+	wake_up_interruptible(&i2c->wait); /* wake up anyone that is waiting */
+	return IRQ_HANDLED;
+}
+
+static int lf1000_i2c_wait(struct lf1000_i2c *i2c)
+{
+	int ret = wait_event_interruptible_timeout(i2c->wait, (i2c->ready),
+						   LF1000_I2C_TIMEOUT);
+
+	if(unlikely(ret < 0))
+		printk(KERN_INFO "i2c: interrupted\n");
+	else if(unlikely(!(i2c->ready)))
+		return -ETIMEDOUT;
+
+	i2c->ready = 0;
+	return 0;
+}
+
+static int i2c_bus_available(struct lf1000_i2c *i2c)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&i2c->bus_access, flags);
+	ret = !(i2c->busy);
+	spin_unlock_irqrestore(&i2c->bus_access, flags);
+
+	return ret;
+}
+
+static void start_stop_condition(struct lf1000_i2c *i2c)
+{
+	u32 tmp = ioread32(i2c->reg_base+IRQ_PEND);
+	tmp |= (1<<OP_HOLD); /* generate a condition */
+	iowrite32(tmp, i2c->reg_base+IRQ_PEND);
+}
+
+static void lf1000_i2c_clock(struct lf1000_i2c *i2c, char en)
+{
+	u32 tmp = ioread32(i2c->reg_base+I2C_CLKENB);
+
+	en ? BIT_SET(tmp, 3) :BIT_CLR(tmp, 3);
+
+	iowrite32(tmp, i2c->reg_base+I2C_CLKENB);
+}
+
+/* initialize the I2C hardware, see page 17-6 in the MP2530 data book */
+static void lf1000_i2c_hwinit(struct lf1000_i2c *i2c)
+{
+	/* clear control registers */
+	iowrite32(0, i2c->reg_base+ICCR);
+	iowrite32(0, i2c->reg_base+BURST_CTRL);
+
+	/* Pclk/256/div, enable interrupts */
+	iowrite32((1<<CLK_SRC)|((i2c->div-1)<<CLK_SCALER)|(1<<IRQ_ENB), 
+			i2c->reg_base+ICCR);
+
+	iowrite32((1<<CNT_MAX), i2c->reg_base+QCNT_MAX);
+
+	iowrite32(0x1010, i2c->reg_base+ICSR);
+
+	start_stop_condition(i2c); /* STOP */
+}
+
+static void xfer_start(struct lf1000_i2c *i2c, bool transmit)
+{
+	u32 tmp;
+
+	/* configure for master transmit or receive mode */
+	tmp = ioread32(i2c->reg_base+ICSR);
+	tmp &= 0x1F0F;
+	tmp |= ((1<<ST_ENB)|(1<<MASTER_SLV)|(1<<ST_BUSY)|(1<<TXRX_ENB));
+	if (transmit)
+		tmp |= (1<<TX_RX); /* transmitter */
+	iowrite32(tmp, i2c->reg_base+ICSR);
+
+	start_stop_condition(i2c); /*START*/
+}
+
+static void xfer_stop(struct lf1000_i2c *i2c, bool transmit)
+{
+	u32 tmp;
+
+	/* set up to generate STOP condition */
+	tmp = ioread32(i2c->reg_base+ICSR);
+	tmp &= 0x1F0F;
+	tmp |= ((1<<ST_ENB)|(1<<MASTER_SLV)|(1<<TXRX_ENB));
+	if (transmit)
+		tmp |= (1<<TX_RX);
+	iowrite32(tmp, i2c->reg_base+ICSR);
+
+	start_stop_condition(i2c); /* STOP */
+}
+
+/* write to a slave device, see page 17-6 in the MP2530 data book */
+static int xfer_write(struct lf1000_i2c *i2c, unsigned char *buf, int length)
+{
+	u32 tmp;
+	int ret;
+	enum lf1000_i2c_state state = I2C_SEND_ADDR;
+
+	while(1) {
+		switch(state) {
+			case I2C_SEND_ADDR:
+			ret = lf1000_i2c_wait(i2c);
+			if (ret != 0)
+				goto done_write;
+
+			tmp = readl(i2c->reg_base+ICSR);
+			if (tmp & (1<<ACK_STATUS)) {
+				dev_err(&i2c->adap.dev, "no ACK in %s\n",
+						__FUNCTION__);
+				ret = -EFAULT;
+				goto done_write;
+			}
+
+			state = I2C_SEND_DATA;
+			break;
+
+			case I2C_SEND_DATA:
+			writel(*buf++, i2c->reg_base+IDSR); /* write data */
+			start_stop_condition(i2c); /* START */
+			ret = lf1000_i2c_wait(i2c); /* wait for IRQ */
+			if (ret != 0)
+				goto done_write;
+
+			tmp = readl(i2c->reg_base+ICSR);
+			if (tmp & (1<<ACK_STATUS)) {
+				dev_err(&i2c->adap.dev, "no DATA ACK in %s\n",
+						__FUNCTION__);
+				ret = -EFAULT;
+				goto done_write;
+			}
+
+			if (--length <= 0)
+				state = I2C_SEND_DONE;
+			break;
+
+			case I2C_SEND_DONE:
+			ret = 0;
+			goto done_write;
+		}
+	}
+
+done_write:
+	return 0;
+}
+
+/* read from a slave device, see page 17-7 in the MP2530 data book */
+static int xfer_read(struct lf1000_i2c *i2c, unsigned char *buf, int length)
+{
+	u32 tmp;
+	int ret;
+	enum lf1000_i2c_state state = I2C_SEND_ADDR;
+
+	while(1) {
+		switch(state) {
+			case I2C_SEND_ADDR:
+			ret = lf1000_i2c_wait(i2c);
+			if(ret != 0)
+				goto done_read;
+			tmp = ioread32(i2c->reg_base+ICSR); /* check for an ACK */
+			if(tmp & (1<<ACK_STATUS)) {
+				printk(KERN_INFO "i2c: no ACK in xfer_read\n");
+				ret = -EFAULT;
+				goto done_read;
+			}
+			/* master generates ACK for received bytes */
+			tmp = readl(i2c->reg_base+ICCR);
+			tmp |= (1<<ACK_GEN);
+			writel(tmp, i2c->reg_base+ICCR);
+			state = I2C_SEND_DATA;
+			break;
+
+			case I2C_SEND_DATA:
+			*buf++ = ioread32(i2c->reg_base+IDSR); /* get data */
+			/* master stops generating ACK on last byte */
+			if (length <= 1) {
+				tmp = readl(i2c->reg_base+ICCR);
+				tmp &= ~(1<<ACK_GEN);
+				writel(tmp, i2c->reg_base+ICCR);
+			}
+			start_stop_condition(i2c); /* START (request more data) */
+			ret = lf1000_i2c_wait(i2c); /* wait for IRQ */
+			if(ret != 0)
+				goto done_read;
+
+			if(--length <= 0)
+				state = I2C_SEND_DONE;
+			break;
+
+			case I2C_SEND_DONE:
+			ret = 0;
+			goto done_read;
+		}
+	}
+
+done_read:
+	return ret;
+}
+
+/* generic I2C master transfer entrypoint */
+static int lf1000_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct lf1000_i2c *i2c = adap->algo_data;
+	int i, ret;
+	unsigned long flags;
+
+	/* wait to get access to the bus */
+	spin_lock_irqsave(&i2c->bus_access, flags);
+	while(i2c->busy) {
+		spin_unlock_irqrestore(&i2c->bus_access, flags);
+		if(wait_event_interruptible(i2c->bus_access, 
+					    i2c_bus_available(i2c))) {
+			return -ERESTARTSYS;
+		}
+		spin_lock_irqsave(&i2c->bus_access, flags);
+	}
+	i2c->busy = 1; /* got the bus */
+	spin_unlock_irqrestore(&i2c->bus_access, flags);
+
+	lf1000_i2c_clock(i2c, 1);
+
+	lf1000_i2c_hwinit(i2c);
+
+	for(i = 0; i < num; i++) {
+		/* set slave device address */
+		iowrite32(msgs[i].addr | ((msgs[i].flags & I2C_M_RD) ? 1 : 0), 
+				  i2c->reg_base+IDSR);
+
+		/* signal start for each message part */
+		xfer_start(i2c, (msgs[i].flags & I2C_M_RD) ? 0 : 1);
+
+		if(msgs[i].len && msgs[i].buf) {
+			if(msgs[i].flags & I2C_M_RD) 
+				ret = xfer_read(i2c, msgs[i].buf, msgs[i].len);
+			else
+				ret = xfer_write(i2c, msgs[i].buf, msgs[i].len);
+
+			if(ret != 0)
+				goto xfer_done;
+		}
+	}
+	ret = i;
+
+xfer_done:
+	/* signal stop at end of message */
+	xfer_stop(i2c, (msgs[i].flags & I2C_M_RD) ? 0 : 1);
+
+	/* turn off I2C controller */
+	iowrite32(0, i2c->reg_base+ICSR);
+
+	lf1000_i2c_clock(i2c, 0);
+
+	/* realease the bus */
+	spin_lock_irqsave(&i2c->bus_access, flags);
+	i2c->busy = 0;
+	spin_unlock_irqrestore(&i2c->bus_access, flags);
+	return ret;
+}
+
+/*
+ * Return list of supported functionality.
+ */
+static u32 lf1000_func(struct i2c_adapter *adapter)
+{
+    return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm lf1000_algorithm = {
+    .master_xfer    = lf1000_xfer,
+    .functionality  = lf1000_func,
+};
+
+#define res_len(r)              ((r)->end - (r)->start + 1)
+static int lf1000_i2c_probe(struct platform_device *dev)
+{
+	struct lf1000_i2c *i2c;
+	struct resource *res;
+	int ret = 0;
+	unsigned int pclk_hz;
+	int irq;
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		printk(KERN_ERR "i2c: failed to get memory resource\n");
+		return -ENODEV;
+	}
+
+	irq = platform_get_irq(dev, 0);
+
+	if (irq < 0) {
+		printk(KERN_ERR "i2c: failed to get irq resource\n");
+		return -ENODEV;
+	}
+	
+	if(!request_mem_region(res->start, res_len(res), res->name)) {
+		printk(KERN_ERR "i2c: failed to request memory region\n");
+		return -ENOMEM;
+	}
+
+	i2c = kzalloc(sizeof(struct lf1000_i2c), GFP_KERNEL);
+	if (!i2c) {
+		printk(KERN_ERR "i2c: failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto fail_emalloc;
+	}
+
+	i2c->adap.owner   = THIS_MODULE;
+	i2c->adap.retries = 5;
+	
+	/* set up I2C IRQ wait queue */
+	init_waitqueue_head(&i2c->wait);
+
+	/* set up I2C bus access queue */
+	init_waitqueue_head(&i2c->bus_access);
+
+        /*
+ 	 * If "dev->id" is negative we consider it as zero.
+ 	 * The reason to do so is to avoid sysfs names that only make
+ 	 * sense when there are multiple adapters.
+ 	 */
+	i2c->adap.nr = dev->id !=-1 ? dev->id : 0;
+	snprintf(i2c->adap.name, sizeof(i2c->adap.name),"lf1000_i2c-i2c.%u",
+		 i2c->adap.nr);
+
+	i2c->reg_base = ioremap(res->start, res_len(res));
+	if(!i2c->reg_base) {
+		ret = -EIO;
+		goto fail_eremap;
+	}
+
+	i2c->iobase = res->start;
+	i2c->iosize = res_len(res);
+
+	i2c->adap.algo = &lf1000_algorithm;
+	i2c->adap.class = I2C_CLASS_HWMON;
+
+	platform_set_drvdata(dev, i2c);
+
+	/* set up IRQ handler */
+	i2c->irq = irq;
+	if(i2c->irq < 0) {
+		printk(KERN_ERR "i2c: failed to get an IRQ\n");
+		ret = i2c->irq;
+		goto fail_irq;
+	}
+	ret = request_irq(i2c->irq, lf1000_i2c_irq, 
+			IRQF_DISABLED, i2c->adap.name, i2c);
+	if(ret) {
+		printk(KERN_ERR "i2c: requesting IRQ failed\n" );
+		goto fail_irq;
+	}
+
+	pclk_hz = get_pll_freq(PCLK_PLL)/2;
+	i2c->div = lf1000_CalcDivider(pclk_hz/256, LF1000_I2C_RATE_HZ);
+	if(i2c->div < 0) {
+		printk(KERN_ALERT "i2c: failed to get divider, using 16\n");
+		i2c->div = 16;
+	}
+	else if(i2c->div > 16) {
+		printk(KERN_ALERT "i2c: divider too high, using 16\n");
+		i2c->div = 16;
+	}
+
+	if (dev->id < 0)
+		dev->id = 0;
+
+	/* set up IO pins */
+	if (dev->id == 0) {
+		gpio_configure_pin(I2C_SCL0_PORT, I2C_SCL0_PIN, I2C_SCL0_FN,
+				1, 0, 0);
+		gpio_configure_pin(I2C_SDA0_PORT, I2C_SDA0_PIN, I2C_SDA0_FN,
+				1, 0, 0);
+	} else if (dev->id == 1) {
+		gpio_configure_pin(I2C_SCL1_PORT, I2C_SCL1_PIN, I2C_SCL1_FN,
+				1, 0, 0);
+		gpio_configure_pin(I2C_SDA1_PORT, I2C_SDA1_PIN, I2C_SDA1_FN,
+				1, 0, 0);
+	}
+
+	/* initialize I2C hardware */
+	lf1000_i2c_hwinit(i2c);
+	lf1000_i2c_clock(i2c,1);
+
+	i2c->adap.algo_data = i2c;
+	i2c->adap.dev.parent = &dev->dev;
+	
+	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if(ret != 0) {
+		printk(KERN_ERR "i2c: failed to add adapter\n");
+		goto fail_register;
+	}
+
+	return 0;
+
+fail_register:
+	lf1000_i2c_clock(i2c, 0);
+	platform_set_drvdata(dev, NULL);
+fail_irq:
+	free_irq(i2c->irq, NULL);
+	i2c->irq = -1;
+	iounmap(i2c->reg_base);
+fail_eremap:
+	kfree(i2c);
+fail_emalloc:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	printk(KERN_DEBUG "%s.%s:%d: error loading driver",
+		__FILE__, __FUNCTION__, __LINE__);
+	return ret;
+}
+
+static int lf1000_i2c_remove(struct platform_device *dev)
+{
+	struct lf1000_i2c *i2c = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	i2c_del_adapter(&i2c->adap);
+	free_irq(i2c->irq, i2c);
+	
+	lf1000_i2c_clock(i2c,0);
+
+	iounmap(i2c->reg_base);
+	release_mem_region(i2c->iobase, i2c->iosize);
+	kfree(i2c);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_i2c_suspend(struct platform_device *dev, pm_message_t mesg)
+{
+	struct lf1000_i2c *i2c = platform_get_drvdata(dev);
+	lf1000_i2c_clock(i2c,0);
+	return 0;
+}
+
+static int lf1000_i2c_resume(struct platform_device *dev)
+{
+	struct lf1000_i2c *i2c = platform_get_drvdata(dev);
+	lf1000_i2c_clock(i2c,1);
+	return 0;
+}
+#else
+#define lf1000_i2c_suspend	NULL
+#define lf1000_i2c_resume	NULL
+#endif
+
+static struct platform_driver lf1000_i2c_driver = {
+	.probe      = lf1000_i2c_probe,
+	.remove     = lf1000_i2c_remove,
+	.suspend    = lf1000_i2c_suspend,
+	.resume     = lf1000_i2c_resume,
+	.driver     = {
+		.name   = DRIVER_NAME,
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init lf1000_i2c_init(void)
+{
+	return platform_driver_register(&lf1000_i2c_driver);
+}
+
+static void __exit lf1000_i2c_exit(void)
+{
+	return platform_driver_unregister(&lf1000_i2c_driver);
+}
+
+module_init(lf1000_i2c_init);
+module_exit(lf1000_i2c_exit);
+
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_AUTHOR("Scott Esters");
+MODULE_DESCRIPTION("I2C driver for LF1000");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/i2c/busses/Kconfig linux-2.6/drivers/i2c/busses/Kconfig
--- linux-2.6.31/drivers/i2c/busses/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/i2c/busses/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -76,6 +76,19 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-amd8111.
 
+config I2C_LF1000
+	tristate "LF1000 I2C"
+	help
+		This supports the I2C interface on the LF1000 processor.
+
+config I2C_LF1000_CHANNEL
+	int "LF1000 I2C channel"
+	depends on I2C_LF1000
+	default 0
+	help
+		Choose the channel for the LF1000 I2C controller.  If you are
+		unsure, choose the default.
+
 config I2C_I801
 	tristate "Intel 82801 (ICH)"
 	depends on PCI
diff -ruaN linux-2.6.31/drivers/i2c/busses/Makefile linux-2.6/drivers/i2c/busses/Makefile
--- linux-2.6.31/drivers/i2c/busses/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/i2c/busses/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -37,6 +37,7 @@
 obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
 obj-$(CONFIG_I2C_IOP3XX)	+= i2c-iop3xx.o
 obj-$(CONFIG_I2C_IXP2000)	+= i2c-ixp2000.o
+obj-$(CONFIG_I2C_LF1000)	+= i2c-lf1000.o
 obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
 obj-$(CONFIG_I2C_MV64XXX)	+= i2c-mv64xxx.o
 obj-$(CONFIG_I2C_OCORES)	+= i2c-ocores.o
diff -ruaN linux-2.6.31/drivers/input/keyboard/Kconfig linux-2.6/drivers/input/keyboard/Kconfig
--- linux-2.6.31/drivers/input/keyboard/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/keyboard/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -361,4 +361,13 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called xtkbd.
 
+config KEYBOARD_LF1000
+	tristate "LF1000 keypad support"
+	depends on ARCH_LF1000
+	default n
+	help
+	  Keypad/buttons driver for the LF1000 development board.
+	  Say Y here to enable buttons support, or M to build
+	  the driver as a module.
+
 endif
diff -ruaN linux-2.6.31/drivers/input/keyboard/lf1000-keypad.c linux-2.6/drivers/input/keyboard/lf1000-keypad.c
--- linux-2.6.31/drivers/input/keyboard/lf1000-keypad.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/input/keyboard/lf1000-keypad.c	2012-11-14 00:02:53.000000000 -0800
@@ -0,0 +1,256 @@
+/*
+ * drivers/input/keyboard/lf1000.c
+ *
+ * Keyboard/Buttons driver for the LF1000 boards
+ *
+ * Copyright 2008 LeapFrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include <mach/platform.h>
+#include <mach/gpio.h>
+
+/* 
+ * Software debouncing: number of ISRs for which a button must be held before 
+ * we change state.
+ * sde: like it or not each tick at 393MHZ is 23.5us, or 42553 ticks / second
+ */
+#define BUTTON_DELAY		4
+#define BRIGHTNESS_DELAY	20
+
+#define INPUT_SAMPLING_J	HZ / 200
+
+/*
+ * Key Map
+ */
+
+struct button_entry {
+	enum gpio_port port;
+	enum gpio_pin pin;
+	enum gpio_resource resource;
+	unsigned int key;
+	unsigned int type;			/* event: EV_KEY or EV_SW */
+	unsigned int debounce_max;		/* debounce value	*/
+
+	enum gpio_interrupt_mode push;		/* IRQ for 'pushed' */
+	enum gpio_interrupt_mode release;	/* IRQ for 'released' */
+	unsigned int debounce;			/* int count		*/
+};
+
+/* the physical button map
+ * fill in port and pin values at run-time in probe()
+ */
+static struct button_entry button_map[] = {
+ /*port, pin, resource, key, key type, delay value */
+ {-1, -1, DPAD_UP, KEY_UP, EV_KEY, BUTTON_DELAY},
+ {-1, -1, DPAD_DOWN, KEY_DOWN, EV_KEY, BUTTON_DELAY},
+ {-1, -1, DPAD_RIGHT, KEY_RIGHT, EV_KEY, BUTTON_DELAY},
+ {-1, -1, DPAD_LEFT, KEY_LEFT, EV_KEY, BUTTON_DELAY},
+ {-1, -1, BUTTON_A, KEY_A, EV_KEY, BUTTON_DELAY},
+ {-1, -1, BUTTON_B, KEY_B, EV_KEY, BUTTON_DELAY},
+ {-1, -1, SHOULDER_LEFT, KEY_L, EV_KEY, BUTTON_DELAY},/* L 'shoulder' */
+ {-1, -1, SHOULDER_RIGHT, KEY_R, EV_KEY, BUTTON_DELAY},/* R 'shoulder' */
+ {-1, -1, BUTTON_HOME, KEY_M, EV_KEY, BUTTON_DELAY},/* menu / home / start */
+ {-1, -1, BUTTON_HINT, KEY_ENTER, EV_KEY, BUTTON_DELAY},/* hint */
+ {-1, -1, BUTTON_PAUSE, KEY_P, EV_KEY, BUTTON_DELAY},/* pause */
+ {-1, -1, BUTTON_BRIGHTNESS, KEY_X, EV_KEY, BRIGHTNESS_DELAY},/* brightness */
+							/* headphone jack */
+ {-1, -1, HEADPHONE_JACK, SW_HEADPHONE_INSERT, EV_SW, BUTTON_DELAY},
+};
+
+
+/* Keycodes that we can generate.  Although codes like KEY_MENU are defined, it
+ * is easier to test with the usual alphabet keys, so we do not use the special
+ * definitions. */
+static unsigned int lf1000_keycode[]= {
+	KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT, 
+	KEY_A, KEY_B, KEY_L, KEY_R, KEY_M, KEY_ENTER, KEY_P, KEY_X};
+
+/*
+ * device
+ */
+
+struct lf1000_kp {
+	unsigned int keycode[ARRAY_SIZE(lf1000_keycode)];
+	struct input_dev *input;
+	struct timer_list input_timer;
+};
+
+static void input_monitor_task(unsigned long data)
+{
+	struct lf1000_kp *i_dev = (struct lf1000_kp *)data;
+	struct button_entry *bme;
+	int i;
+	int val;
+	int old;
+
+	for(i = 0; i < ARRAY_SIZE(button_map); i++) {
+		bme = &button_map[i];
+
+		/* assume push GPIO is normally low, invert if needed	*/
+		val = gpio_get_val(bme->port, bme->pin) ^ bme->push;
+		old = bme->debounce & 0x10;
+		bme->debounce = old | ((bme->debounce << 1 | val) & 0xf);
+		switch(bme->debounce)
+		{
+		case 0x03://0 0011 (key release)
+			input_event(i_dev->input, bme->type, bme->key, 0);
+			bme->debounce = 0x13;
+			break;
+		case 0x1C://1 1100  (key press)
+			input_event(i_dev->input, bme->type, bme->key, 1);
+			bme->debounce = 0x0C;
+			break;
+		}
+	}
+
+	i_dev->input_timer.expires += INPUT_SAMPLING_J;
+	i_dev->input_timer.function = input_monitor_task;
+	i_dev->input_timer.data = data;
+	add_timer(&i_dev->input_timer);
+}
+
+/*
+ * platform device
+ */
+
+static int lf1000_kp_probe(struct platform_device *pdev)
+{
+	struct lf1000_kp *lf1000_kp_dev;
+	struct input_dev *input_dev;
+	int i;
+	int ret;
+
+	lf1000_kp_dev = kzalloc(sizeof(struct lf1000_kp), GFP_KERNEL);
+	if(!lf1000_kp_dev)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, lf1000_kp_dev);
+
+	input_dev = input_allocate_device();
+	if(!input_dev) {
+		ret = -ENOMEM;
+		goto fail_input;
+	}
+
+	memcpy(lf1000_kp_dev->keycode, lf1000_keycode, 
+			sizeof(lf1000_kp_dev->keycode));
+
+	input_dev->name = "LF1000 Keyboard";
+	input_dev->phys = "lf1000/input0";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0001;
+	lf1000_kp_dev->input = input_dev;	
+	
+	/* event types that we support */
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_SW);
+
+	input_dev->keycode = lf1000_kp_dev->keycode;
+	input_dev->keycodesize = sizeof(unsigned int);
+	input_dev->keycodemax = ARRAY_SIZE(lf1000_keycode);
+
+	for(i = 0; i < ARRAY_SIZE(lf1000_keycode); i++)
+		set_bit(lf1000_kp_dev->keycode[i], input_dev->keybit);
+
+	/* audio jack */
+	set_bit(SW_HEADPHONE_INSERT, input_dev->swbit);
+
+	ret = input_register_device(lf1000_kp_dev->input);
+	if(ret)
+		goto fail_register;
+
+	/*
+ 	 * map button port and pin values at run-time
+ 	 */
+
+	for (i = 0; i < ARRAY_SIZE(button_map); i++) {
+		button_map[i].port = lf1000_l2p_port(button_map[i].resource);
+		button_map[i].pin  = lf1000_l2p_pin(button_map[i].resource);
+	}
+
+	/* 
+	 * initialize and claim the buttons/switches, enable interrupts 
+	 */
+
+	for(i = 0; i < ARRAY_SIZE(button_map); i++) {
+		button_map[i].debounce = 0x1f;
+		button_map[i].push = GPIO_IMODE_LOW_LEVEL;
+		button_map[i].release = GPIO_IMODE_HIGH_LEVEL;
+		if(button_map[i].key == SW_HEADPHONE_INSERT) {
+			/* reverse headphone jack on all boards except DEV */
+			if(!gpio_have_gpio_dev()) {
+				button_map[i].push = GPIO_IMODE_HIGH_LEVEL;
+				button_map[i].release = GPIO_IMODE_LOW_LEVEL;
+			}
+		}
+		gpio_configure_pin(button_map[i].port, button_map[i].pin,
+			GPIO_GPIOFN, 0, 0, 0);
+	}
+	setup_timer(&lf1000_kp_dev->input_timer, input_monitor_task, (unsigned long)lf1000_kp_dev);
+	lf1000_kp_dev->input_timer.expires = get_jiffies_64() + INPUT_SAMPLING_J;
+	lf1000_kp_dev->input_timer.function = input_monitor_task;
+	lf1000_kp_dev->input_timer.data = (unsigned long)lf1000_kp_dev;
+	add_timer(&lf1000_kp_dev->input_timer);
+
+	return 0;
+
+fail_register:
+	input_free_device(input_dev);
+fail_input:
+	kfree(lf1000_kp_dev);
+	return ret;
+}
+
+static int lf1000_kp_remove(struct platform_device *pdev)
+{
+	struct lf1000_kp *lf1000_kp_dev = platform_get_drvdata(pdev);
+
+	del_timer_sync(&lf1000_kp_dev->input_timer);
+	input_unregister_device(lf1000_kp_dev->input);
+	kfree(lf1000_kp_dev);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_kp_driver = {
+	.probe		= lf1000_kp_probe,
+	.remove		= lf1000_kp_remove,
+	.driver		= {
+		.name	= "lf1000-keypad",
+	},
+};
+
+/*
+ * module stuff
+ */
+
+static int __devinit lf1000_kp_init(void)
+{
+	return platform_driver_register(&lf1000_kp_driver);
+}
+
+static void __exit lf1000_kp_exit(void)
+{
+	platform_driver_unregister(&lf1000_kp_driver);
+}
+
+module_init(lf1000_kp_init);
+module_exit(lf1000_kp_exit);
+
+MODULE_AUTHOR("Andrey Yurovsky <andrey@cozybit.com>");
+MODULE_DESCRIPTION("LF1000 Development Board buttons driver");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/input/keyboard/Makefile linux-2.6/drivers/input/keyboard/Makefile
--- linux-2.6.31/drivers/input/keyboard/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/keyboard/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -31,3 +31,4 @@
 obj-$(CONFIG_KEYBOARD_SUNKBD)		+= sunkbd.o
 obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
+obj-$(CONFIG_KEYBOARD_LF1000)		+= lf1000-keypad.o
diff -ruaN linux-2.6.31/drivers/input/misc/Kconfig linux-2.6/drivers/input/misc/Kconfig
--- linux-2.6.31/drivers/input/misc/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/misc/Kconfig	2011-01-04 15:15:39.000000000 -0800
@@ -269,4 +269,14 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called dm355evm_keys.
+
+config INPUT_LF1000_ACLMTR
+	tristate "LF1000 Accelerometer support"
+	depends on ARCH_LF1000
+	default n
+	help
+	  Accelerometer driver for the LF1000 platform.
+	  Say Y here to enable accelerometer support, or M to build
+	  the driver as a module.
+
 endif
diff -ruaN linux-2.6.31/drivers/input/misc/lf1000_aclmtr.c linux-2.6/drivers/input/misc/lf1000_aclmtr.c
--- linux-2.6.31/drivers/input/misc/lf1000_aclmtr.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/input/misc/lf1000_aclmtr.c	2011-05-17 13:59:00.000000000 -0700
@@ -0,0 +1,586 @@
+/*
+ * drivers/input/misc/lf1000_aclmtr.c
+ *
+ * Accelerometer driver for the LF1000 platform.
+ * Generically named to fit input driver framework.
+ * Supports Bosch BMA150, BMA220 devices via I2C.
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ *
+ * Dave Milici <dmilici@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <mach/platform.h>
+#include <mach/gpio.h>
+
+#include <linux/sysfs.h>
+
+/*
+ * device
+ */
+
+#define INPUT_SAMPLING_HZ		10
+#define INPUT_SAMPLING_JIFFIES	(HZ / INPUT_SAMPLING_HZ)
+
+#define BMA150_ADDR			0x70
+#define BMA220_ADDR			0x16
+
+#define MIN_XYZ				-(0x001F+1)
+#define MAX_XYZ				0x001F
+
+#define MIN_PHI				0x00
+#define MAX_PHI				0x07
+
+struct lf1000_aclmtr {
+	struct input_dev *input;
+	struct timer_list input_timer;
+
+	struct	workqueue_struct *input_tasks;
+	struct	work_struct       input_work;
+
+	struct i2c_client  *control_data;
+	struct i2c_adapter *i2c_dev;
+	unsigned int		i2c_bus;
+	unsigned int		i2c_addr;
+
+	unsigned int do_enable;
+	unsigned int do_orient;
+	unsigned int do_tick;
+	unsigned int rate;
+	unsigned int rate_jiffies;
+	unsigned int average;
+	int biasx, biasy, biasz;
+	int	x, y, z, phi;
+};
+
+static int bma_write_reg(struct lf1000_aclmtr *dev, unsigned int reg,
+		unsigned int value)
+{
+	struct i2c_adapter *adapter = i2c_get_adapter(dev->i2c_bus);
+	struct i2c_msg msg;
+	char buf[2];
+	int ret;
+
+	/* BMA220 left-justified index */
+	if (BMA220_ADDR == dev->i2c_addr)
+		reg <<= 1;
+
+	buf[0] = reg & 0xFF;
+	buf[1] = value & 0xFF;
+
+	msg.addr = dev->i2c_addr;
+	msg.buf = buf;
+	msg.len = 2;
+	msg.flags = 0; /* write */
+
+	ret = i2c_transfer(adapter, &msg, 1);
+
+	i2c_put_adapter(adapter);
+
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static unsigned int bma_read_reg(struct lf1000_aclmtr *dev,
+		unsigned int reg)
+{
+	struct i2c_adapter *adapter = i2c_get_adapter(dev->i2c_bus);
+	struct i2c_msg msg[2];
+	char buf[2];
+	int ret;
+
+	/* BMA220 left-justified index */
+	if (BMA220_ADDR == dev->i2c_addr)
+		reg <<= 1;
+
+	buf[0] = reg & 0xFF;
+	buf[1] = 0;
+
+	msg[0].addr = dev->i2c_addr;
+	msg[0].buf = buf;
+	msg[0].len = 1;
+	msg[0].flags = 0; /* write */
+
+	msg[1].addr = dev->i2c_addr;
+	msg[1].buf = buf;
+	msg[1].len = 2;
+	msg[1].flags = I2C_M_RD;
+
+	ret = i2c_transfer(adapter, msg, 2);
+
+	i2c_put_adapter(adapter);
+
+	return (ret < 0) ? ret : buf[1];
+}
+
+static int bma_detect(struct lf1000_aclmtr* dev)
+{
+	int id[2];
+	int n = 0;
+
+	/* Madrid, Emerald CIP */
+	if (gpio_have_gpio_madrid() || n++ || gpio_have_gpio_emerald()) {
+		dev->i2c_bus = n;
+		dev->i2c_addr = BMA220_ADDR;
+		id[0] = bma_read_reg(dev, 0x00);
+		id[1] = bma_read_reg(dev, 0x01);
+
+		if (0xDD == id[0] && 0x00 == id[1]) {
+			printk(KERN_INFO "%s: BMA220 device found\n", __FUNCTION__);
+			bma_write_reg(dev, 0x0D, 0xC0);	/* data mode enable */
+			bma_write_reg(dev, 0x0F, 0x07);	/* x,y,z axis enable */
+			return 1;
+		}
+	}
+
+	/* Acorn */
+	if (gpio_have_gpio_acorn()) {
+		dev->i2c_bus = 0;
+		dev->i2c_addr = BMA150_ADDR;
+		id[0] = bma_read_reg(dev, 0x00);
+		id[1] = bma_read_reg(dev, 0x01);
+
+		if (0x02 == id[0] && 0x11 == id[1]) {
+			printk(KERN_INFO "%s: BMA150 device found\n", __FUNCTION__);
+			return 1;
+		}
+	}
+
+	printk(KERN_INFO "%s: device not found\n", __FUNCTION__);
+	return 0;
+}
+
+static void bma150_get_xyz(struct lf1000_aclmtr* dev, int* x, int* y, int* z)
+{
+	*x = (bma_read_reg(dev, 0x02) >> 6) | (bma_read_reg(dev, 0x03) << 2);
+	*y = (bma_read_reg(dev, 0x04) >> 6) | (bma_read_reg(dev, 0x05) << 2);
+	*z = (bma_read_reg(dev, 0x06) >> 6) | (bma_read_reg(dev, 0x07) << 2);
+	if (*x > 0x01FF)
+		*x -= 0x3FF+1;
+	if (*y > 0x01FF)
+		*y -= 0x3FF+1;
+	if (*z > 0x01FF)
+		*z -= 0x3FF+1;
+	dev->x = *x;
+	dev->y = *y;
+	dev->z = *z;
+}
+
+static void bma220_get_xyz(struct lf1000_aclmtr* dev, int* x, int* y, int* z)
+{
+	*x = bma_read_reg(dev, 0x02) >> 2;
+	*y = bma_read_reg(dev, 0x03) >> 2;
+	*z = bma_read_reg(dev, 0x04) >> 2;
+	if (*x > 0x001F)
+		*x -= 0x03F+1;
+	if (*y > 0x001F)
+		*y -= 0x03F+1;
+	if (*z > 0x001F)
+		*z -= 0x03F+1;
+	dev->x = *x;
+	dev->y = *y;
+	dev->z = *z;
+}
+
+static void get_orient(struct lf1000_aclmtr* dev, int* orient)
+{
+	if (BMA220_ADDR == dev->i2c_addr) {
+		*orient = bma_read_reg(dev, 0x0B) >> 4;
+		*orient &= MAX_PHI;
+		dev->phi = *orient;
+		return;
+	}
+	*orient = 0;
+}
+
+static void get_xyz(struct lf1000_aclmtr* dev, int* x, int* y, int* z)
+{
+	switch (dev->i2c_addr) {
+	case BMA150_ADDR:
+		return bma150_get_xyz(dev, x, y, z);
+	case BMA220_ADDR:
+		return bma220_get_xyz(dev, x, y, z);
+	}
+	*x = *y = *z = 0;
+}
+
+static struct lf1000_aclmtr* g_dev = NULL;	/* not cached in work_struct */
+static void input_work_task(struct	work_struct *work)
+{
+	struct lf1000_aclmtr *i_dev = g_dev;
+	int x, y, z;
+	int orient = 0;
+	static int tick=0;
+	static int acount=0;
+	static int sx=0, sy=0, sz=0;
+
+	/* get x,y,z from device */
+	get_xyz(i_dev, &x, &y, &z);
+
+	/* get orientation from device */
+	if (i_dev->do_orient)
+		get_orient(i_dev, &orient);
+
+	if (i_dev->average > 1)
+	{
+		sx += x;
+		sy += y;
+		sz += z;
+		if (++acount >= i_dev->average)
+		{
+			int a=i_dev->average; /* Make signed */
+			x = (sx-i_dev->biasx)/a;
+			y = (sy-i_dev->biasy)/a;
+			z = (sz-i_dev->biasz)/a;
+			/* Clear accumulators */
+			acount = 0;
+			sx = sy = sz = 0;
+		}
+		else
+			return; /* No report */
+	}
+	else
+	{
+		x -= i_dev->biasx;
+		y -= i_dev->biasy;
+		z -= i_dev->biasz;
+	}
+		
+	/* report input data */
+	input_report_abs(i_dev->input, ABS_X, x);
+	input_report_abs(i_dev->input, ABS_Y, y);
+	input_report_abs(i_dev->input, ABS_Z, z);
+	/* orientation is optional */
+	if (i_dev->do_orient)
+		input_report_abs(i_dev->input, ABS_MISC, orient);
+	/* Force at least one changing value to get a new event every sample */
+	if (i_dev->do_tick)
+		input_report_abs(i_dev->input, ABS_WHEEL, tick++);
+	input_sync(i_dev->input);
+}
+
+static void input_monitor_task(unsigned long data)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)data;
+
+	/* defer input sampling to work queue */
+	if (i_dev->do_enable)
+		queue_work(i_dev->input_tasks, &i_dev->input_work);
+
+	/* reset task timer */
+	i_dev->input_timer.expires += i_dev->rate_jiffies;
+	i_dev->input_timer.function = input_monitor_task;
+	i_dev->input_timer.data = data;
+	add_timer(&i_dev->input_timer);
+}
+
+/*
+ * sysfs Interface
+ */
+
+static ssize_t show_tick(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->do_tick);
+}
+static ssize_t set_tick(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	i_dev->do_tick = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(tick, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tick, set_tick);
+
+static ssize_t show_rate(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->rate);
+}
+static ssize_t set_rate(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp <= 0 || temp > HZ)
+		return -EINVAL;
+	i_dev->rate = temp;
+	i_dev->rate_jiffies = HZ / temp;
+	return(count);
+}
+
+static DEVICE_ATTR(rate, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_rate, set_rate);
+
+static ssize_t show_average(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->average);
+}
+static ssize_t set_average(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	i_dev->average = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(average, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_average, set_average);
+
+static ssize_t show_bias(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d %d %d\n", 
+		       i_dev->biasx, i_dev->biasy, i_dev->biasz);
+}
+static ssize_t set_bias(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int tx, ty, tz;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%d %d %d", &tx, &ty, &tz) != 3)
+		return -EINVAL;
+	i_dev->biasx = tx;
+	i_dev->biasy = ty;
+	i_dev->biasz = tz;
+	return(count);
+}
+
+static DEVICE_ATTR(bias, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_bias, set_bias);
+
+static ssize_t show_enable(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->do_enable);
+}
+static ssize_t set_enable(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	i_dev->do_enable = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(enable, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_enable, set_enable);
+
+static ssize_t show_orient(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->do_orient);
+}
+static ssize_t set_orient(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	i_dev->do_orient = temp;
+	return(count);
+}
+
+static DEVICE_ATTR(orient, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_orient, set_orient);
+
+static ssize_t show_raw_xyz(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d %d %d\n", i_dev->x, i_dev->y, i_dev->z);
+}
+
+static DEVICE_ATTR(raw_xyz, S_IRUSR|S_IRGRP|S_IROTH, show_raw_xyz, NULL);
+
+static ssize_t show_raw_phi(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct lf1000_aclmtr *i_dev = (struct lf1000_aclmtr *)dev->driver_data;
+	return sprintf(buf, "%d\n", i_dev->phi);
+}
+
+static DEVICE_ATTR(raw_phi, S_IRUSR|S_IRGRP|S_IROTH, show_raw_phi, NULL);
+
+static struct attribute *aclmtr_attributes[] = {
+	&dev_attr_tick.attr,
+	&dev_attr_rate.attr,
+	&dev_attr_average.attr,
+	&dev_attr_bias.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_orient.attr,
+	&dev_attr_raw_xyz.attr,
+	&dev_attr_raw_phi.attr,
+	NULL
+};
+
+static struct attribute_group aclmtr_attr_group = {
+	.attrs = aclmtr_attributes
+};
+
+
+/*
+ * platform device
+ */
+
+static int lf1000_aclmtr_probe(struct platform_device *pdev)
+{
+	struct lf1000_aclmtr *lf1000_aclmtr_dev;
+	struct input_dev *input_dev;
+	int ret;
+
+	lf1000_aclmtr_dev = kzalloc(sizeof(struct lf1000_aclmtr), GFP_KERNEL);
+	if (!lf1000_aclmtr_dev)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, lf1000_aclmtr_dev);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		goto fail_input;
+	}
+
+	input_dev->name = "LF1000 Accelerometer";
+	input_dev->phys = "lf1000/aclmtr";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0001;
+	lf1000_aclmtr_dev->input = input_dev;
+
+	lf1000_aclmtr_dev->do_enable = 0;
+	lf1000_aclmtr_dev->do_orient = 0;
+	lf1000_aclmtr_dev->do_tick = 0;
+	lf1000_aclmtr_dev->rate = INPUT_SAMPLING_HZ;
+	lf1000_aclmtr_dev->rate_jiffies = INPUT_SAMPLING_JIFFIES;
+	lf1000_aclmtr_dev->average = 1;
+	lf1000_aclmtr_dev->biasx = 0;
+	lf1000_aclmtr_dev->biasy = 0;
+	lf1000_aclmtr_dev->biasz = 0;
+	
+	/* event types that we support */
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_ABS);
+	input_dev->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) |
+		BIT_MASK(ABS_Z) | BIT_MASK(ABS_WHEEL) | BIT_MASK(ABS_MISC);
+	input_set_abs_params(input_dev, ABS_X, MIN_XYZ, MAX_XYZ, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, MIN_XYZ, MAX_XYZ, 0, 0);
+	input_set_abs_params(input_dev, ABS_Z, MIN_XYZ, MAX_XYZ, 0, 0);
+	input_set_abs_params(input_dev, ABS_WHEEL, 0, 0x7FFFFFFF, 0, 0);
+	input_set_abs_params(input_dev, ABS_MISC, MIN_PHI, MAX_PHI, 0, 0);
+
+	ret = input_register_device(lf1000_aclmtr_dev->input);
+	if (ret)
+		goto fail_register;
+
+	/* query for accelerometer device */
+	ret = bma_detect(lf1000_aclmtr_dev);
+	if (!ret) {
+		ret = -ENODEV;
+		goto fail_detect;
+	}
+
+	/* create work queue to defer input sampling */
+	lf1000_aclmtr_dev->input_tasks = create_singlethread_workqueue("accelerometer-tasks");
+	INIT_WORK(&lf1000_aclmtr_dev->input_work, input_work_task);
+	g_dev = lf1000_aclmtr_dev;
+
+	/* create periodic input task */
+	setup_timer(&lf1000_aclmtr_dev->input_timer, input_monitor_task, (unsigned long)lf1000_aclmtr_dev);
+	lf1000_aclmtr_dev->input_timer.expires = get_jiffies_64() + 
+		lf1000_aclmtr_dev->rate_jiffies;
+	lf1000_aclmtr_dev->input_timer.function = input_monitor_task;
+	lf1000_aclmtr_dev->input_timer.data = (unsigned long)lf1000_aclmtr_dev;
+	add_timer(&lf1000_aclmtr_dev->input_timer);
+
+
+	sysfs_create_group(&pdev->dev.kobj, &aclmtr_attr_group);
+
+	return 0;
+
+fail_detect:
+	input_unregister_device(input_dev);
+fail_register:
+	input_free_device(input_dev);
+fail_input:
+	kfree(lf1000_aclmtr_dev);
+	return ret;
+}
+
+static int lf1000_aclmtr_remove(struct platform_device *pdev)
+{
+	struct lf1000_aclmtr *lf1000_aclmtr_dev = platform_get_drvdata(pdev);
+
+	sysfs_remove_group(&pdev->dev.kobj, &aclmtr_attr_group);
+	del_timer_sync(&lf1000_aclmtr_dev->input_timer);
+	destroy_workqueue(lf1000_aclmtr_dev->input_tasks);
+	input_unregister_device(lf1000_aclmtr_dev->input);
+	kfree(lf1000_aclmtr_dev);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_aclmtr_driver = {
+	.probe		= lf1000_aclmtr_probe,
+	.remove		= lf1000_aclmtr_remove,
+	.driver		= {
+		.name		= "lf1000-aclmtr",
+	},
+};
+
+/*
+ * module stuff
+ */
+
+static int __devinit lf1000_aclmtr_init(void)
+{
+	return platform_driver_register(&lf1000_aclmtr_driver);
+}
+
+static void __exit lf1000_aclmtr_exit(void)
+{
+	platform_driver_unregister(&lf1000_aclmtr_driver);
+}
+
+module_init(lf1000_aclmtr_init);
+module_exit(lf1000_aclmtr_exit);
+
+MODULE_AUTHOR("Dave Milici <dmilici@leapfrog.com>");
+MODULE_DESCRIPTION("LF1000 Accelerometer driver");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/input/misc/Makefile linux-2.6/drivers/input/misc/Makefile
--- linux-2.6.31/drivers/input/misc/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/misc/Makefile	2011-01-04 15:15:39.000000000 -0800
@@ -14,6 +14,7 @@
 obj-$(CONFIG_HP_SDC_RTC)		+= hp_sdc_rtc.o
 obj-$(CONFIG_INPUT_IXP4XX_BEEPER)	+= ixp4xx-beeper.o
 obj-$(CONFIG_INPUT_KEYSPAN_REMOTE)	+= keyspan_remote.o
+obj-$(CONFIG_INPUT_LF1000_ACLMTR)	+= lf1000_aclmtr.o
 obj-$(CONFIG_INPUT_M68K_BEEP)		+= m68kspkr.o
 obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
 obj-$(CONFIG_INPUT_PCSPKR)		+= pcspkr.o
diff -ruaN linux-2.6.31/drivers/input/touchscreen/Kconfig linux-2.6/drivers/input/touchscreen/Kconfig
--- linux-2.6.31/drivers/input/touchscreen/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/touchscreen/Kconfig	2011-01-04 15:01:42.000000000 -0800
@@ -479,6 +479,26 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called touchit213.
 
+config TOUCHSCREEN_LF1000
+	tristate "LF1000 touchscreen"
+	depends on ARCH_LF1000	
+	help
+	  Say Y here if you have an LF1000 with touchscreen connected to
+	  your systemi (ADC0 to ADC3).
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called lf1000_touch.
+
+config TOUCHSCREEN_LF1000_PRESSURE
+	bool "Use pressure readings/calculations in the driver"
+	depends on TOUCHSCREEN_LF1000
+	default n
+	help
+	  Say Y here to enable the driver to use calculated pressure to
+	  judge when the screen is touched.
+
 config TOUCHSCREEN_TSC2007
 	tristate "TSC2007 based touchscreens"
 	depends on I2C
diff -ruaN linux-2.6.31/drivers/input/touchscreen/lf1000_ts2.c linux-2.6/drivers/input/touchscreen/lf1000_ts2.c
--- linux-2.6.31/drivers/input/touchscreen/lf1000_ts2.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/input/touchscreen/lf1000_ts2.c	2011-08-07 09:47:06.000000000 -0700
@@ -0,0 +1,2018 @@
+/*
+ *  LF1000 touchscreen driver
+ *
+ *  Author:	Scott Esters, <sesters@leapfrog.com>
+ *  Created:	May 27, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This code is heavily based on ucb1x00-*.c copyrighted by Russell King
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/suspend.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <mach/gpio.h>
+#include <mach/adc.h>
+
+#include <linux/sysfs.h>
+
+#define LED1_ON gpio_configure_pin(GPIO_PORT_B, GPIO_PIN0, GPIO_GPIOFN, 1, 0, 0)
+#define LED2_ON gpio_configure_pin(GPIO_PORT_B, GPIO_PIN1, GPIO_GPIOFN, 1, 0, 0)
+
+#define LED1_OFF gpio_configure_pin(GPIO_PORT_B, GPIO_PIN0, GPIO_GPIOFN, 1, 0, 1)
+#define LED2_OFF gpio_configure_pin(GPIO_PORT_B, GPIO_PIN1, GPIO_GPIOFN, 1, 0, 1)
+
+#define TOUCHSCREEN_SAMPLING_J	HZ / 100  // sample touchscreen every 10 ms
+
+#define TOUCHSCREEN_MAJOR	247
+
+#define RAW_ABS_PARAMS	 11	// How many input event codes raw sends
+
+#define TS_DEBOUNCE_DOWN 1	// default debounce down, min samples for down
+#define TS_DEBOUNCE_UP	 1	// default debounce up, min samples for up
+/* NOTE:
+ *  Using 1 as the debounce threshold is equivalent to no debouncing.
+ *  This allows greatest responsiveness.  It also allows some bouncing --
+ *  when the stylus hits the touch screen, bounces off, then touches the
+ *  screen again.
+ *  We'll need to check if this is the way we want it.
+ */
+
+// input event touch defines. X=0 and Y=0 is reserved for no touch.
+#define TS_MIN_X	1	    // min X resolution value
+#define TS_MAX_X	1023	// max X resolution value
+#define	TS_FUZZ_X	2	    // gaussian filter window size, 0=none
+
+#define TS_MIN_Y	1	    // min Y resolution value
+#define TS_MAX_Y	1023	// max Y resolution value
+#define	TS_FUZZ_Y	2	    // gaussian filter window size, 0=none
+
+// Pressure
+#define	TS_FUZZ_P	5	    // gaussian filter window size, 0=none
+
+/* Rob's calculations indicated the driver was delaying longer than necessary for
+ * the voltages to settle before reading the ADC.
+ * Experiments indicated that a 10-microsecond delay is long enough for the
+ * x, y, and Z readings but not for the TNT readings.  Though 15 microseconds
+ * might be a long enough delay for the TNT reading, 18 seemed a little better:
+ * the tnt2 reading is a bit closer to the tnt1 reading.
+ */
+
+#define TS_DELAY_IN_US	 1
+#define TS_Y_DELAY_IN_US 1
+#define TNT_DELAY_IN_US  1
+
+
+#define	N_PCURVE_PTS	9   // With nine control points, we get 10 bins
+
+// Default rotation, translation, and shear values.  System should set these
+// at startup.  Note order in /etc/pointercal is A1 A2 A0 A4 A5 A3 A6
+#define TS_A0  -12097127
+#define TS_A1	   52942
+#define TS_A2	     149
+#define TS_A3  -12950733	
+#define TS_A4	      78 
+#define TS_A5	   42024
+#define TS_A6	   65536
+
+/* These are the states of a touch screen state machine managed by get_touch()
+ */
+#define TSTATE_DOWN         0
+#define TSTATE_GOING_DOWN   1
+#define TSTATE_GOING_UP     2
+#define TSTATE_UP           3
+
+static int abs_x[3] = {TS_MIN_X, TS_MAX_X, TS_FUZZ_X};
+module_param_array(abs_x, int, NULL, 0);
+MODULE_PARM_DESC(abs_x, "Touchscreen absolute X min, max, fuzz");
+
+static int abs_y[3] = {TS_MIN_Y, TS_MAX_Y, TS_FUZZ_Y};
+module_param_array(abs_y, int, NULL, 0);
+MODULE_PARM_DESC(abs_y, "Touchscreen absolute Y min, max, fuzz");
+
+static int abs_p[3] = {TS_MIN_X, TS_MAX_X, TS_FUZZ_P};
+module_param_array(abs_p, int, NULL, 0);
+MODULE_PARM_DESC(abs_p, "Touchscreen absolute P min, max, fuzz");
+
+#define SCAN_DELAY_LUT_SIZE 8
+static int scan_delay_lut[SCAN_DELAY_LUT_SIZE] = { 5, 10, 15, 20, 30, 40, 60, 80 };
+
+/* Enable the following #define if you want to collect nand access timing data*/
+// #define TS_TIMING 1
+int timing = 0;
+
+struct touch {
+	struct input_dev	*i_dev, *iraw_dev;
+
+	struct task_struct	*ts_task;
+
+	struct	timer_list        touchscreen_timer;
+	struct	workqueue_struct *touchscreen_tasks;
+	struct	work_struct       touchscreen_work;	// check touchscreen
+
+	int	stop_timer;	          // non-zero = stop timer reload
+	int	sample_rate_in_jiffies;	  // screen sample rate
+	int	debounce_in_samples_down; // samples before stylus down declared
+	int	debounce_in_samples_up;   // samples before stylus up declared
+
+	/*
+	 * report_events, controls sending data up to Linux
+	 * as well as debugging messages.  Also has bitfield definitions
+	 *   bit 0 ==0 no events reported to Linux
+	 *         ==1 report events to Linux
+	 *   bit 1 ==1 show ADC debugging messages
+	 *   bit 2 ==0 no raw events reported to Linux
+	 *         ==1 report raw events to Linux
+	 *   bit 3 ==x Control debugging messages
+	 *   bit 4-31  Count of debugging messages
+	 */
+#define REBIT_REPORT    0
+#define REBIT_ADC_DBG   1
+#define REBIT_RAW_REPORT    2
+#define REBIT_ADC_DBG_MODE   3
+
+#define RESHIFT_COUNT	4
+#define REMASK_REPORT   (1 << REBIT_REPORT)
+#define REMASK_ADC_DBG  (1 << REBIT_ADC_DBG)
+#define REMASK_RAW_REPORT   (1 << REBIT_RAW_REPORT)
+#define REMASK_ADC_DBG_MODE  (1 << REBIT_ADC_DBG_MODE)
+	int	report_events;
+
+	int	delay_in_us;		// delay between GPIO setup and reading
+	int	y_delay_in_us;		// delay between GPIO setup and reading
+	int	tnt_delay_in_us;	// delay between GPIO setup and reading
+					// for tnt
+
+	int	first_adc;		// 0=didj-ts, 4=Leapster 3
+
+	int	adc_x;			// raw adc for x measurements
+	int	adc_x2;			// raw adc for x measurements
+
+	int	adc_y;			// raw adc for y measurements
+	int	adc_y2;			// raw adc for y measurements
+
+	int	averaging;		// Number of samples to average
+	int	tails;			// Tails mode, in honor of a silly bug
+	int	scanning;		// Enable/Disable scanning mode
+	int	scan_ctr;		// Scan counter
+	int	tnt_mode;		// Which TNT to read from
+	int	tnt_plane[3];		// TNT planar offset model params
+
+	int	adc_p1;		        // raw adc for p1 measurements
+	int	adc_p2;		        // raw adc for p2 measurements
+	int	adc_pressure;
+	int	adc_tnt1;		// raw adc for first tnt measurement
+	int	adc_tnt2;		// raw adc for second tnt measurement
+
+	int	adc_max_tnt_down;   // tnt readings must be <= this for touch
+	int	adc_min_tnt_up;     // either tnt reading > this ==> Up
+	int	adc_max_delta_tnt;  // for Down, both tnt readings must be 
+				    // less than or equal to adc_max_tnt_down
+	                            // AND must differ by no more than this.
+
+	int	pressure_curve[N_PCURVE_PTS];	// Pressure transfer function
+	// This is a peice-wise approximation to an inverse of the pressure
+	// curve, so we can relate computed pressure to something more linear
+	// for the user.
+
+	int	ts_state;
+
+	int	touch_x, touch_y;	// raw ADC touchscreen x and y values
+	int	touch_pressure;		// Linearized pressure
+
+	int	touch_button;		// screen touched
+	int	screen_x, screen_y;	// transformed screen x and y values
+
+	int	screen_last_x, screen_last_y;  // debugging values
+
+	int	stylus_down_count;	// count consecutive stylus down samples
+	int	stylus_up_count;	// count consecutive stylus up samples
+
+	int	a[7];			// /etc/pointercal values
+
+#ifdef TS_TIMING
+	u32	min_us, max_us, N_us, sum_us;
+#endif
+
+	struct cdev *cdev;		// char device
+	int	dev;
+	int	major;
+} touch_dev;
+
+struct touch * t_dev = &touch_dev;
+
+#ifdef TS_TIMING
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/timer.h>
+
+
+#define TIMER32(r)	REG32(IO_ADDRESS(TIMER_BASE+r))
+
+#define TIMER_BASE	LF1000_TIMER3_BASE
+/* Timer Clock Rate: 4.5Mhz */
+
+/* start the stopwatch */
+void timer_start(void)
+{
+	/* make sure the timer is stopped */
+	BIT_CLR(TIMER32(TMRCONTROL), RUN);
+
+	/* zero out the timer */
+	TIMER32(TMRCOUNT) = 0;
+
+	/* run the timer */
+	BIT_SET(TIMER32(TMRCONTROL), RUN);
+}
+
+/* stop the stopwatch, and return the time in us*/
+u32 timer_stop(void)
+{
+	BIT_CLR(TIMER32(TMRCONTROL), RUN);	/* stop the timer */
+	BIT_SET(TIMER32(TMRCONTROL), LDCNT);	/* get access to counter */
+	return (2*TIMER32(TMRCOUNT))/9;		/* and return it */
+}
+
+#endif  /* TS_TIMING */
+
+/*
+ * sysfs Interface
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "Name is %s\n", __FILE__);
+}
+static DEVICE_ATTR(name, S_IRUSR|S_IRGRP|S_IROTH, show_name, NULL);
+
+/* Return /etc/pointercal values.  pointercal order is A1 A2 A0 A4 A5 A3 A6 */
+static ssize_t set_pointercal(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int i, temp[7];
+	struct touch *t_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i %i %i %i %i %i %i", 
+		  &temp[1], &temp[2], &temp[0],
+		  &temp[4], &temp[5], &temp[3], &temp[6]) != 7)
+		return -EINVAL;
+	if (temp[6] == 0)
+		return -EINVAL;
+	for (i=0; i<7; i++)
+		t_dev->a[i] = temp[i];
+	dev_dbg(dev, "%s.%s:%d pointercal=%d %d %d %d %d %d %d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		t_dev->a[1], t_dev->a[2], t_dev->a[0],
+		t_dev->a[4], t_dev->a[5], t_dev->a[3], t_dev->a[6]);
+	return(count);
+}
+
+static ssize_t show_pointercal(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct touch *t_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d %d %d %d %d %d %d\n",
+		t_dev->a[1], t_dev->a[2], t_dev->a[0],
+		t_dev->a[4], t_dev->a[5], t_dev->a[3], t_dev->a[6]);
+}
+static DEVICE_ATTR(pointercal, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH, show_pointercal, set_pointercal);
+
+
+/* report current x1 coordinate, 'x0' is used by calibration programs */
+static ssize_t show_x0(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n",lf1000_touch_dev->touch_x);
+}
+static DEVICE_ATTR(x0, S_IRUSR|S_IRGRP|S_IROTH, show_x0, NULL);
+
+
+/* report current y coordinate, 'y1' is used by calibration programs */
+static ssize_t show_y1(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_y);
+}
+static DEVICE_ATTR(y1, S_IRUSR|S_IRGRP|S_IROTH, show_y1, NULL);
+
+static ssize_t show_touch_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_x);
+}
+static DEVICE_ATTR(touch_x, S_IRUSR|S_IRGRP|S_IROTH, show_touch_x, NULL);
+
+static ssize_t show_touch_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_y);
+}
+static DEVICE_ATTR(touch_y, S_IRUSR|S_IRGRP|S_IROTH, show_touch_y, NULL);
+
+static ssize_t show_touch_pressure(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_pressure);
+}
+static DEVICE_ATTR(touch_pressure, S_IRUSR|S_IRGRP|S_IROTH, show_touch_pressure, NULL);
+
+static ssize_t show_touch_button(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_button);
+}
+static DEVICE_ATTR(touch_button, S_IRUSR|S_IRGRP|S_IROTH, show_touch_button, NULL);
+
+static ssize_t show_screen_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->screen_x);
+}
+static DEVICE_ATTR(screen_x, S_IRUSR|S_IRGRP|S_IROTH, show_screen_x, NULL);
+
+static ssize_t show_screen_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->screen_y);
+}
+static DEVICE_ATTR(screen_y, S_IRUSR|S_IRGRP|S_IROTH, show_screen_y, NULL);
+
+static ssize_t show_raw_adc(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	static char *lut = "DV^U";
+	return sprintf(buf, "x1=%d x2=%d y1=%d y2=%d p1=%d p2=%d tnt1=%d tnt2=%d S=%c X=%d Y=%d P=%d\n", 
+		       lf1000_touch_dev->adc_x, lf1000_touch_dev->adc_x2, 
+		       lf1000_touch_dev->adc_y, lf1000_touch_dev->adc_y2, 
+		       lf1000_touch_dev->adc_p1, lf1000_touch_dev->adc_p2, 
+		       lf1000_touch_dev->adc_tnt1, lf1000_touch_dev->adc_tnt2, 
+		       lut[lf1000_touch_dev->ts_state],
+		       lf1000_touch_dev->screen_x, lf1000_touch_dev->screen_y,
+		       lf1000_touch_dev->adc_pressure);
+}
+static DEVICE_ATTR(raw_adc, S_IRUSR|S_IRGRP|S_IROTH, show_raw_adc, NULL);
+
+static ssize_t show_delay_in_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->delay_in_us);
+}
+static ssize_t set_delay_in_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	lf1000_touch_dev->delay_in_us = temp;
+	dev_dbg(dev, "%s.%s:%d delay_in_us=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->delay_in_us);
+	return(count);
+}
+
+static DEVICE_ATTR(delay_in_us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_delay_in_us, set_delay_in_us);
+
+static ssize_t show_y_delay_in_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->y_delay_in_us);
+}
+static ssize_t set_y_delay_in_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	lf1000_touch_dev->y_delay_in_us = temp;
+	dev_dbg(dev, "%s.%s:%d y_delay_in_us=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->y_delay_in_us);
+	return(count);
+}
+
+static DEVICE_ATTR(y_delay_in_us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_y_delay_in_us, set_y_delay_in_us);
+
+#ifdef TS_TIMING
+/* Us_In_Driver: time spent in driver */
+static ssize_t show_us_in_driver(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d/%d/%d N=%d\n",
+		       lf1000_touch_dev->min_us,
+		       lf1000_touch_dev->N_us > 0 ? 
+		       lf1000_touch_dev->sum_us/lf1000_touch_dev->N_us : 0,
+		       lf1000_touch_dev->max_us,
+		       lf1000_touch_dev->N_us);
+}
+static ssize_t set_us_in_driver(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	lf1000_touch_dev->min_us = 0;
+	lf1000_touch_dev->max_us = 0;
+	lf1000_touch_dev->N_us = 0;
+	lf1000_touch_dev->sum_us = 0;
+	return(count);
+}
+static DEVICE_ATTR(us_in_driver, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_us_in_driver, set_us_in_driver);
+
+/* us: time spent between write and read, in us */
+static ssize_t show_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	// struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	/* This is revealing!  I see udelay(1) take 4us, udelay(20)=80us
+	LED1_OFF; LED2_OFF;
+	udelay (1);
+	LED1_OFF; LED2_ON;
+	udelay (2);
+	LED1_ON; LED2_OFF;
+	udelay (5);
+	LED1_ON; LED2_ON;
+	udelay (10);
+	LED1_OFF; LED2_OFF;
+	udelay (20);
+	LED1_OFF; LED2_ON;
+	udelay (2);
+	LED1_ON; LED2_OFF;
+	udelay (1);
+	LED1_ON; LED2_ON;
+	*/
+
+        int t = timer_stop();
+	timing = 0; // Let other people use timer
+	return sprintf(buf, "%d\n", t);
+}
+static ssize_t set_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	/*
+	timing = 1; // Don't let other people use timer
+	timer_start ();
+	*/
+	u32 x, y, p;
+	if(sscanf(buf, "%u %u %u", &x, &y, &p) != 3)
+		return -EINVAL;
+	input_report_abs(t_dev->i_dev, ABS_X, x);
+	input_report_abs(t_dev->i_dev, ABS_Y, y);
+	input_report_abs(t_dev->i_dev, ABS_PRESSURE, p);
+	input_sync(t_dev->i_dev);
+	return(count);
+
+}
+static DEVICE_ATTR(us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_us, set_us);
+
+#endif
+
+/* Scanning: set to 1 scan various delay times */
+static ssize_t show_scanning(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d: %d %d %d %d %d %d %d %d\n", lf1000_touch_dev->scanning,
+		       scan_delay_lut[0], scan_delay_lut[1], scan_delay_lut[2], scan_delay_lut[3],
+		       scan_delay_lut[4], scan_delay_lut[5], scan_delay_lut[6], scan_delay_lut[7]);
+}
+static ssize_t set_scanning(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp, temp2[SCAN_DELAY_LUT_SIZE], n, i;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	n = sscanf(buf, "%i %i %i %i %i %i %i %i %i", &temp,
+		   &temp2[0], &temp2[1], &temp2[2], &temp2[3], 
+		   &temp2[4], &temp2[5], &temp2[6], &temp2[7]);
+	if (n<1 || (n>1 && n<9))
+		return -EINVAL;
+	if (n==1)
+		lf1000_touch_dev->scanning = temp;
+	if (n==9)
+		for (i=0; i<SCAN_DELAY_LUT_SIZE; i++)
+			scan_delay_lut[i] = temp2[i];
+	lf1000_touch_dev->scan_ctr = 0;
+	dev_dbg(dev, "%s.%s:%d scanning=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->scanning);
+	return(count);
+}
+static DEVICE_ATTR(scanning, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_scanning, set_scanning);
+
+/* TNT mode: 0-3 for which channel to read from */
+static ssize_t show_tnt_mode(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->tnt_mode);
+}
+
+static ssize_t set_tnt_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp, n;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	n = sscanf(buf, "%i", &temp);
+	if (n<1 || temp<0 || temp>3)
+		return -EINVAL;
+	lf1000_touch_dev->tnt_mode = temp;
+	return(count);
+}
+static DEVICE_ATTR(tnt_mode, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tnt_mode, set_tnt_mode);
+
+/* TNT mode: 0-3 for which channel to read from */
+static ssize_t show_tnt_plane(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d %d %d\n", 
+		       lf1000_touch_dev->tnt_plane[0],
+		       lf1000_touch_dev->tnt_plane[1],
+		       lf1000_touch_dev->tnt_plane[2]);
+}
+
+static ssize_t set_tnt_plane(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp[3], n;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	n = sscanf(buf, "%i %i %i", &temp[0], &temp[1], &temp[2]);
+	if (n<3)
+		return -EINVAL;
+	lf1000_touch_dev->tnt_plane[0] = temp[0];
+	lf1000_touch_dev->tnt_plane[1] = temp[1];
+	lf1000_touch_dev->tnt_plane[2] = temp[2];
+	return(count);
+}
+static DEVICE_ATTR(tnt_plane, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tnt_plane, set_tnt_plane);
+
+/* Averaging: set to >1 to average during read_xy */
+static ssize_t show_averaging(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->averaging);
+}
+static ssize_t set_averaging(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->averaging = temp;
+	dev_dbg(dev, "%s.%s:%d averaging=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->averaging);
+	return(count);
+}
+static DEVICE_ATTR(averaging, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_averaging, set_averaging);
+
+/* Enable Tails for compatibility */
+static ssize_t show_tails(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->tails);
+}
+static ssize_t set_tails(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->tails = temp;
+	dev_dbg(dev, "%s.%s:%d tails=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->tails);
+	return(count);
+}
+static DEVICE_ATTR(tails, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tails, set_tails);
+
+/* pressure_curve: N_PCURVE_PTS points on a curve to translate computed 
+   pressure to user pressure (0..100) in steps of 10% */
+static ssize_t show_pressure_curve(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *t_dev = (struct touch *)dev->driver_data;
+	int i, x=0;
+	for (i=0; i<N_PCURVE_PTS; i++)
+		x += sprintf (buf+x, "%d ", t_dev->pressure_curve[i]);
+	buf[x-1] = '\n'; /* Replace last ' ' with \n */
+	return x;
+}
+static ssize_t set_pressure_curve(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int i, temp[N_PCURVE_PTS];
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	/* Sorry, I don't want to figure out a loop for this... */
+	if(sscanf(buf, "%i %i %i %i %i %i %i %i %i", 
+		  &temp[0], &temp[1], &temp[2],
+		  &temp[3], &temp[4], &temp[5],
+		  &temp[6], &temp[7], &temp[8]) != 9)
+		return -EINVAL;
+	for (i=0; i<N_PCURVE_PTS; i++)
+		lf1000_touch_dev->pressure_curve[i] = temp[i];
+	dev_dbg(dev, "%s.%s:%d pressure_curve=%d %d %d %d %d %d %d %d %d\n",
+		__FILE__, __FUNCTION__, __LINE__, 
+		lf1000_touch_dev->pressure_curve[0],
+		lf1000_touch_dev->pressure_curve[1],
+		lf1000_touch_dev->pressure_curve[2],
+		lf1000_touch_dev->pressure_curve[3],
+		lf1000_touch_dev->pressure_curve[4],
+		lf1000_touch_dev->pressure_curve[5],
+		lf1000_touch_dev->pressure_curve[6],
+		lf1000_touch_dev->pressure_curve[7],
+		lf1000_touch_dev->pressure_curve[8]);
+	return(count);
+}
+static DEVICE_ATTR(pressure_curve, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_pressure_curve, set_pressure_curve);
+
+static ssize_t show_min_x(struct device *dev, struct device_attribute *attr, char *buf) { return sprintf(buf, "%d\n", 1); }
+static ssize_t show_max_x(struct device *dev, struct device_attribute *attr, char *buf) { return sprintf(buf, "%d\n", 1024); }
+static ssize_t show_min_y(struct device *dev, struct device_attribute *attr, char *buf) { return sprintf(buf, "%d\n", 1); }
+static ssize_t show_max_y(struct device *dev, struct device_attribute *attr, char *buf) { return sprintf(buf, "%d\n", 1024); }
+
+static DEVICE_ATTR(min_x, S_IRUSR|S_IRGRP|S_IROTH, show_min_x, NULL);
+static DEVICE_ATTR(max_x, S_IRUSR|S_IRGRP|S_IROTH, show_max_x, NULL);
+static DEVICE_ATTR(min_y, S_IRUSR|S_IRGRP|S_IROTH, show_min_y, NULL);
+static DEVICE_ATTR(max_y, S_IRUSR|S_IRGRP|S_IROTH, show_max_y, NULL);
+
+static ssize_t show_tnt_delay_in_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->tnt_delay_in_us);
+}
+static ssize_t set_tnt_delay_in_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	lf1000_touch_dev->tnt_delay_in_us = temp;
+	dev_dbg(dev, "%s.%s:%d tnt_delay_in_us=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->tnt_delay_in_us);
+	return(count);
+}
+
+static DEVICE_ATTR(tnt_delay_in_us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tnt_delay_in_us, set_tnt_delay_in_us);
+
+static ssize_t show_max_tnt_down(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_max_tnt_down);
+}
+
+static ssize_t set_max_tnt_down(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_max_tnt_down = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_max_tnt_down);
+	return(count);
+}
+
+static DEVICE_ATTR(max_tnt_down, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_max_tnt_down, set_max_tnt_down);
+
+
+static ssize_t show_min_tnt_up(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_min_tnt_up);
+}
+
+static ssize_t set_min_tnt_up(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_min_tnt_up = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_min_tnt_up);
+	return(count);
+}
+
+static DEVICE_ATTR(min_tnt_up, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_min_tnt_up, set_min_tnt_up);
+
+
+static ssize_t show_max_delta_tnt(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_max_delta_tnt);
+}
+
+static ssize_t set_max_delta_tnt(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_max_delta_tnt = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_max_delta_tnt);
+	return(count);
+}
+
+static DEVICE_ATTR(max_delta_tnt, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_max_delta_tnt, set_max_delta_tnt);
+
+
+static ssize_t show_debounce_in_samples_down(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->debounce_in_samples_down);
+}
+
+static ssize_t set_debounce_in_samples_down(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) 
+	{
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->debounce_in_samples_down = temp;
+	lf1000_touch_dev->stylus_down_count = 0;	/* reset counter */
+
+	dev_dbg(dev, "%s.%s:%d debounce_in_samples_down=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->debounce_in_samples_down);
+	return(count);
+}
+
+static DEVICE_ATTR(debounce_in_samples_down, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_debounce_in_samples_down, set_debounce_in_samples_down);
+
+static ssize_t show_debounce_in_samples_up(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->debounce_in_samples_up);
+}
+
+static ssize_t set_debounce_in_samples_up(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) 
+	{
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->debounce_in_samples_up = temp;
+	lf1000_touch_dev->stylus_down_count = 0;	/* reset counter */
+
+	dev_dbg(dev, "%s.%s:%d debounce_in_samples_up=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->debounce_in_samples_up);
+	return(count);
+}
+
+static DEVICE_ATTR(debounce_in_samples_up, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_debounce_in_samples_up, set_debounce_in_samples_up);
+
+
+static ssize_t show_stylus_down_count(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->stylus_down_count);
+}
+
+static DEVICE_ATTR(stylus_down_count, \
+	S_IRUSR|S_IRGRP|S_IROTH,
+	show_stylus_down_count, NULL);
+
+static ssize_t show_a0(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[0]);
+}
+static ssize_t set_a0(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[0] = temp;
+	dev_dbg(dev, "%s.%s:%d a[0]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[0]);
+	return(count);
+}
+static DEVICE_ATTR(a0, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a0, set_a0);
+
+static ssize_t show_a1(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[1]);
+}
+
+static ssize_t set_a1(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[1] = temp;
+	dev_dbg(dev, "%s.%s:%d a[1]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[1]);
+	return(count);
+}
+
+static DEVICE_ATTR(a1, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a1, set_a1);
+
+static ssize_t show_a2(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[2]);
+}
+
+static ssize_t set_a2(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[2] = temp;
+	dev_dbg(dev, "%s.%s:%d a[2]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[2]);
+	return(count);
+}
+
+static DEVICE_ATTR(a2, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a2, set_a2);
+
+
+static ssize_t show_a3(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[3]);
+}
+static ssize_t set_a3(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[3] = temp;
+	dev_dbg(dev, "%s.%s:%d a[3]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[3]);
+	return(count);
+}
+
+static DEVICE_ATTR(a3, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a3, set_a3);
+
+static ssize_t show_a4(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[4]);
+}
+static ssize_t set_a4(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[4] = temp;
+	dev_dbg(dev, "%s.%s:%d a[4]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[4]);
+	return(count);
+}
+
+static DEVICE_ATTR(a4, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a4, set_a4);
+
+static ssize_t show_a5(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[5]);
+}
+static ssize_t set_a5(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[5] = temp;
+	dev_dbg(dev, "%s.%s:%d a[5]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[5]);
+	return(count);
+}
+
+static DEVICE_ATTR(a5, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a5, set_a5);
+
+static ssize_t show_a6(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[6]);
+}
+static ssize_t set_a6(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[6] = temp;
+	dev_dbg(dev, "%s.%s:%d a[6]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[6]);
+	return(count);
+}
+
+static DEVICE_ATTR(a6, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a6, set_a6);
+
+static ssize_t show_sample_rate_in_hz(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int rate;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	rate = lf1000_touch_dev->sample_rate_in_jiffies;
+	rate = (0 < rate) ? (HZ / rate) : 0 ;	// expect positive value
+	return sprintf(buf, "%d\n", rate);
+}
+static ssize_t set_sample_rate_in_hz(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	temp = (0 < temp )   ? temp : 1;  // set min rate to 1
+	temp = (temp <= HZ ) ? temp : HZ; // set max rate to HZ
+	lf1000_touch_dev->sample_rate_in_jiffies = (HZ / temp); 
+	dev_dbg(dev,  "%s.%s:%d sample_rate_in_jiffies=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->sample_rate_in_jiffies);
+	return(count);
+}
+
+static DEVICE_ATTR(sample_rate_in_hz, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_sample_rate_in_hz, set_sample_rate_in_hz);
+
+static ssize_t show_report_events(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->report_events);
+}
+static ssize_t set_report_events(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	//	if (temp < 0 || temp > 7)	// ensure value between 0 and 7
+	//		return -EINVAL;
+	lf1000_touch_dev->report_events = temp;
+	dev_dbg(dev, "%s.%s:%d report_events=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->report_events);
+	return(count);
+}
+
+static DEVICE_ATTR(report_events, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_report_events, set_report_events);
+
+static struct attribute *touchscreen_attributes[] = {
+	&dev_attr_name.attr,
+	&dev_attr_pointercal.attr,
+	&dev_attr_x0.attr,
+	&dev_attr_y1.attr,
+	&dev_attr_touch_x.attr,
+	&dev_attr_touch_y.attr,
+	&dev_attr_touch_pressure.attr,
+	&dev_attr_touch_button.attr,
+	&dev_attr_screen_x.attr,
+	&dev_attr_screen_y.attr,
+	&dev_attr_raw_adc.attr,
+	&dev_attr_delay_in_us.attr,
+	&dev_attr_y_delay_in_us.attr,
+	&dev_attr_averaging.attr,
+	&dev_attr_tails.attr,
+	&dev_attr_pressure_curve.attr,
+	&dev_attr_scanning.attr,
+	&dev_attr_tnt_mode.attr,
+	&dev_attr_tnt_plane.attr,
+	&dev_attr_min_x.attr,
+	&dev_attr_max_x.attr,
+	&dev_attr_min_y.attr,
+	&dev_attr_max_y.attr,
+	&dev_attr_tnt_delay_in_us.attr,
+	&dev_attr_max_tnt_down.attr,
+	&dev_attr_min_tnt_up.attr,
+	&dev_attr_max_delta_tnt.attr,
+	&dev_attr_debounce_in_samples_down.attr,
+	&dev_attr_debounce_in_samples_up.attr,
+	&dev_attr_stylus_down_count.attr,
+	&dev_attr_a0.attr,
+	&dev_attr_a1.attr,
+	&dev_attr_a2.attr,
+	&dev_attr_a3.attr,
+	&dev_attr_a4.attr,
+	&dev_attr_a5.attr,
+	&dev_attr_a6.attr,
+	&dev_attr_sample_rate_in_hz.attr,
+	&dev_attr_report_events.attr,
+#ifdef TS_TIMING
+	&dev_attr_us_in_driver.attr,
+	&dev_attr_us.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group touchscreen_attr_group = {
+	.attrs = touchscreen_attributes
+};
+
+int adc_GetMedian3Reading(int channel)
+{
+	int a, b, c;
+	a = adc_GetReading(channel);
+	b = adc_GetReading(channel);
+	c = adc_GetReading(channel);
+	if (a<b)
+	{
+		// a X Y   or   c a b
+		if (a<c)
+			return b<c ? b : c;
+		else
+			// 2 0 1
+			return a;
+	}
+	else
+	{
+		// b X Y   or   c b a
+		if (b<c)
+			return a<c ? a : c;
+		else
+			return b;
+	}
+}
+
+int adc_GetMedian4Reading(int channel)
+{
+	int a, b, c, d, min, max;
+	a = adc_GetReading(channel);
+	b = adc_GetReading(channel);
+	c = adc_GetReading(channel);
+	d = adc_GetReading(channel);
+	min = a;
+	if (min>b) min=b;
+	if (min>c) min=c;
+	if (min>d) min=d;
+	max = a;
+	if (max<b) max=b;
+	if (max<c) max=c;
+	if (max<d) max=d;
+	return (a+b+c+d-min-max)/2;
+}
+
+#define adc_GetMedianReading(channel)  adc_GetMedian3Reading(channel)
+
+void delay_in_us (void)
+{
+	if (t_dev->scanning)
+		udelay (scan_delay_lut[t_dev->scan_ctr & (SCAN_DELAY_LUT_SIZE-1)]);
+	else
+		udelay (t_dev->delay_in_us);
+}
+
+void y_delay_in_us (void)
+{
+	if (t_dev->scanning)
+		udelay (scan_delay_lut[t_dev->scan_ctr & (SCAN_DELAY_LUT_SIZE-1)]);
+	else
+		udelay (t_dev->y_delay_in_us);
+}
+
+void tnt_delay_in_us (void)
+{
+	if (t_dev->scanning)
+		udelay (scan_delay_lut[t_dev->scan_ctr & (SCAN_DELAY_LUT_SIZE-1)]);
+	else
+		udelay (t_dev->tnt_delay_in_us);
+}
+
+/* experimental version suggested by Rob (from Sam)
+ * configure one sheet's terminals as inputs with pullup
+ * configure the other sheet's terminals as outputs with level 0.
+ * When untouched, the value on the inputs ought to be high.
+ * When touched, the value on the inputs will be low.
+ *               
+ * There seems to be a big difference in voltages between touched and untouched.
+ * There's a smaller variation of voltages when touched.  The harder the touch,
+ * the lower the voltage.
+ */
+void set_read_tnt(void) // touch / no-touch
+{
+	switch (t_dev->tnt_mode)
+	{
+	case 0:
+	case 2:
+		// Input on X with pullup, Drive Y low
+		// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+				   lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 0, 1, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+				   lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 1, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+				   lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 1, 0, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+				   lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+		break;
+	case 1:
+	case 3:
+		// Input on Y with pullup, Drive X low
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+				   lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, 1, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+				   lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 0, 1, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+				   lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 0);
+		gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+				   lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 1, 0, 0);
+	}
+}
+static void read_first_tnt(void)
+{
+
+	if (t_dev->averaging < 0)
+		t_dev->adc_tnt1 = adc_GetMedianReading(t_dev->first_adc+t_dev->tnt_mode);
+	else
+		t_dev->adc_tnt1 = adc_GetReading(t_dev->first_adc+t_dev->tnt_mode);
+}
+static void read_second_tnt(void)
+{
+	if (t_dev->averaging < 0)
+		t_dev->adc_tnt2 = adc_GetMedianReading(t_dev->first_adc+t_dev->tnt_mode);
+	else
+		t_dev->adc_tnt2 = adc_GetReading(t_dev->first_adc+t_dev->tnt_mode);
+}
+/* NOTE: there is no delay before the first reading of tnt1, because the gpios
+ *       have been properly configured since tnt2 was read at the end of the
+ * previous sampling period.
+ */
+static void first_reading_tnt(void)
+{
+    // This assumes the gpio configuration remains from previous reading,
+    // which occurs in the _probe() routine or in second_reading_tnt().
+    read_first_tnt();
+}
+/* NOTE: experiments indicated it's necessary to delay longer for the gpio
+ *       voltages to settle before reading tnt2.  Apparently this is due
+ * to differences in the resistors.
+ */
+static void second_reading_tnt(void)
+{
+	set_read_tnt();
+	tnt_delay_in_us ();	// Let the screen settle and charge up
+	read_second_tnt();
+}
+
+
+void set_read_p12(void)
+{
+	// 15sep10  Experimental version suggested by Rob and Sam
+        //          don't use pull-ups
+
+	// X1 = 1; Y2 = 0;  X2 and Y1 inputs
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set X1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+		                lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 0, 0);
+	// Set Y1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, 0, 0);
+	// Set X1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+		                lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 1);
+	// Set Y2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+}
+
+
+/* Configure the gpios for reading the x-position voltage */
+void set_read_x(void)
+{
+	// float X1 and X2 first, then drive Y1 high and Y2 low
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set X1 and X2 as inputs with or without pullup, based on "tails" sysfs.
+	// With "tails" on, you will get tails!  But it won't require recalibrating your device.
+	int PU = t_dev->tails ? 1 : 0;
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 0, PU, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, PU, 0);
+	// Set Y1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+                   	    lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 1, 0, 1);
+	// Set Y2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+}
+
+/* Configure the gpios for reading the y-position voltage */
+void set_read_y(void)
+{
+	// float Y1 and Y2 first, then drive X1 high and X2 low
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set Y1 and Y2 as inputs with or without pullup, based on "tails" sysfs.
+	// With "tails" on, you will get tails!  But it won't require recalibrating your device.
+	int PU = t_dev->tails ? 1 : 0;
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, PU, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 0, PU, 0);
+	// Set X1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 1);
+	// Set X2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 1, 0, 0);
+}
+
+
+/*
+ * int read_xy(void)
+ * returns RXY_UP:         Stylus UP, 
+ *         RXY_DOWN:       Stylus DOWN, have ADC values.
+ *         RXY_IN_BETWEEN: Stylus neither UP nor DOWN; have ADC values
+ *
+ * Reads adc to determine touch/no-touch (tnt).
+ * If no-touch, immediately returns RXY_UP.
+ * Otherwise reads X and Y touchscreen values.
+ * Reads voltages to calculate touch pressure.
+ * Then reads touch/no-touch again.
+ * If second tnt reading indicates no-touch, returns RXY_UP.
+ *
+ * If both tnt readings are <= t_dev->adc_max_tnt_down and are close to each
+ * other (differ by no more than t_dev->adc_max_delta_tnt), returns RXY_DOWN.  
+ * If both tnt readings are <= t_dev->adc_max_tnt_down and differ by more
+ * than t_dev->adc_max_delta_tnt, returns RXY_IN_BETWEEN.  
+ *
+ * Also returns RXY_IN_BETWEEN if both tnt readings are <= t_dev->adc_min_tnt_up
+ * and at least one of them is > t_dev->adc_max_tnt_down.
+ */
+
+#define MAX_TNT_DOWN    19      // Down if all tnt are <= this
+#define MIN_TNT_UP      520     // UP if any tnt is > this
+#define MAX_DELTA_TNT   5		// 
+
+#define RXY_UP          0
+#define RXY_DOWN        1
+#define RXY_IN_BETWEEN  2
+
+static int read_xy(void)
+{
+	int x, y, fancy_tnt;
+
+	first_reading_tnt();
+	if (t_dev->adc_tnt1 > t_dev->adc_min_tnt_up) {
+		t_dev->adc_tnt2 = 1024; // indicate unread (to prevent lots of output)
+		/* Don't return early if we're getting raw reports */
+		if (!(t_dev->report_events & REMASK_RAW_REPORT))
+			return RXY_UP;          // UP unless both tnt readings are low enough
+	}
+	/*
+	 * now read voltages for x
+	 */
+	set_read_x();			    // set GPIO pins to read X value
+	delay_in_us ();	// Let the screen settle and charge up
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc);     // read X1 ADC
+			s2 += adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+		}
+		t_dev->adc_x  = s1 / t_dev->averaging;
+		t_dev->adc_x2 = s2 / t_dev->averaging;
+	}
+	else if (t_dev->averaging < 0)
+	{
+		t_dev->adc_x  = adc_GetMedianReading(t_dev->first_adc);     // read X1 ADC
+		t_dev->adc_x2 = adc_GetMedianReading(t_dev->first_adc + 2); // read X2 ADC
+	}
+	else
+	{
+		t_dev->adc_x  = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+		t_dev->adc_x2 = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+	}
+
+	/*
+	 * read voltages for y
+	 */
+	set_read_y();			    // set GPIO pins to read Y value
+	y_delay_in_us ();	// Let the screen settle and charge up
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+			s2 += adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+
+		}
+		t_dev->adc_y  = s1 / t_dev->averaging;
+		t_dev->adc_y2 = s2 / t_dev->averaging;
+	}
+	else if (t_dev->averaging < 0)
+	{
+		t_dev->adc_y  = adc_GetMedianReading(t_dev->first_adc + 1); // read Y1 ADC
+		t_dev->adc_y2 = adc_GetMedianReading(t_dev->first_adc + 3); // read Y2 ADC
+	}
+	else
+	{
+		t_dev->adc_y  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+		t_dev->adc_y2 = adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+	}
+
+	/*
+	 * read voltages for pressure
+	 */
+	set_read_p12();
+	delay_in_us ();	// Let the screen settle and charge up
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc+2);       // read X2 ADC
+			s2 += adc_GetReading(t_dev->first_adc+1);       // read Y1 ADC
+		}
+		t_dev->adc_p1 = s1 / t_dev->averaging;
+		t_dev->adc_p2 = s2 / t_dev->averaging;
+	}
+	else if (t_dev->averaging < 0)
+	{
+		t_dev->adc_p1 = adc_GetMedianReading(t_dev->first_adc+2);       // read X2 ADC
+		t_dev->adc_p2 = adc_GetMedianReading(t_dev->first_adc+1);       // read Y1 ADC
+	}
+	else
+	{
+		t_dev->adc_p1 = adc_GetReading(t_dev->first_adc+2);       // read X2 ADC
+		t_dev->adc_p2 = adc_GetReading(t_dev->first_adc+1);       // read Y1 ADC
+	}
+
+	/* second touch/no-touch reading */
+	second_reading_tnt();
+
+	if (t_dev->adc_tnt1 + t_dev->adc_tnt2 > 2*t_dev->adc_min_tnt_up)
+		return RXY_UP;   // UP unless both tnt readings are low enough
+
+#if 1
+	/* Compute a fancy tnt threshold based on position */
+	x = (t_dev->adc_x + t_dev->adc_x2)/2;
+	y = (t_dev->adc_y + t_dev->adc_y2)/2;
+	fancy_tnt = t_dev->adc_max_tnt_down +
+		(t_dev->tnt_plane[0] * x +
+		 t_dev->tnt_plane[1] * y +
+		 t_dev->tnt_plane[2] + 32768)/65536;
+	if (t_dev->adc_tnt1 + t_dev->adc_tnt2 <= 2*fancy_tnt)
+#else
+	if (t_dev->adc_tnt1 + t_dev->adc_tnt2 <= 2*t_dev->adc_max_tnt_down)
+#endif
+	{
+		// both are low enough for Down; check for stability
+		// if unstable, say going down or going up
+		if (abs(t_dev->adc_tnt1 - t_dev->adc_tnt2) > t_dev->adc_max_delta_tnt)
+		{
+			return RXY_IN_BETWEEN;
+		}
+		else return RXY_DOWN;  // if both low and stable, say Down
+	}
+        // else both are <= t_dev->adc_min_tnt_up and at least one is greater
+        // than t_dev->adc_max_tnt_down.
+        // Seems to be in transition
+	else {
+		return RXY_IN_BETWEEN;
+	}
+}
+
+
+/* State transitions and debouncing
+ *
+ * If read_xy() returns:
+ *      0 (up) - increment stylus_up_count;
+ *               if (stylus_up_count >= debounce_up)
+ *                  if (stylus_up_count == debounce_up) {
+ *                      state = TSTATE_UP
+ *                      report stylus up
+ *                  }
+ *               else
+ *                  state = TSTATE_GOING_UP
+ *                  ignore the touch info
+ *
+ *      1 (down) - increment stylus_down_count;
+ *               if (stylus_down_count >= debounce_down)
+ *                  if (state != TSTATE_DOWN {
+ *                      state = TSTATE_DOWN
+ *                      report stylus down
+ *                      stylus_up_count = 0;
+ *                  }
+ *                  process the touch point
+ *               else
+ *                  state = TSTATE_GOING_DOWN
+ *                  ignore the touch info
+ *
+ *      2 (going up)
+ *                  state = TSTATE_GOING_UP
+ *                  ignore the touch info
+ *
+ *      3 (going down)
+ *                  state = TSTATE_GOING_DOWN
+ *                  ignore the touch info
+ */
+
+
+static void process_down(int report_events)
+{
+	if (++t_dev->stylus_down_count >= t_dev->debounce_in_samples_down) {
+		t_dev->ts_state = TSTATE_DOWN;
+		t_dev->stylus_up_count = 0;
+		if (report_events & REMASK_REPORT) /* say stylus down */
+		{
+			input_report_key(t_dev->i_dev, BTN_TOUCH, 1);
+		}
+	}
+	else
+		t_dev->ts_state = TSTATE_GOING_DOWN;
+}
+
+static void process_up(int report_events)
+{
+	if (++t_dev->stylus_up_count >= t_dev->debounce_in_samples_up) {
+		t_dev->ts_state = TSTATE_UP;
+		t_dev->stylus_down_count = 0;
+		if (report_events & REMASK_REPORT) /* say stylus up */
+		{
+			input_report_key(t_dev->i_dev, BTN_TOUCH, 0);
+			// Send a 0 pressure event for TSLIB
+			input_report_abs(t_dev->i_dev, ABS_X, t_dev->screen_x);
+			input_report_abs(t_dev->i_dev, ABS_Y, t_dev->screen_y);
+			input_report_abs(t_dev->i_dev, ABS_PRESSURE, 0);
+			input_sync(t_dev->i_dev);
+		}
+
+	}
+	else
+		t_dev->ts_state = TSTATE_GOING_UP;
+}
+
+/*
+ * void get_touch(struct work_struct work)
+ * read touchscreen, debounce stylus up/down, and report screen activity.
+ */
+
+static void get_touch(struct work_struct *work)
+{
+	int report_events = t_dev->report_events;
+	static int counter=0;
+
+	t_dev->scan_ctr++;
+
+#ifdef TS_TIMING
+	if (!timing) timer_start();
+#endif
+	t_dev->touch_button = read_xy();
+
+	switch (t_dev->ts_state) {
+	case TSTATE_UP:
+		if (t_dev->touch_button == RXY_DOWN)
+			process_down(report_events);
+		else if (t_dev->touch_button == RXY_IN_BETWEEN)
+			t_dev->ts_state = TSTATE_GOING_DOWN;
+		break;
+
+	case TSTATE_GOING_DOWN:
+		if (t_dev->touch_button == RXY_UP) {
+			t_dev->ts_state = TSTATE_UP;
+		}
+		else if (t_dev->touch_button == RXY_DOWN)
+			process_down(report_events);
+		break;
+
+	case TSTATE_DOWN:
+		if (t_dev->touch_button == RXY_IN_BETWEEN)
+			t_dev->ts_state = TSTATE_GOING_UP;
+		else if (t_dev->touch_button == RXY_UP)
+			process_up(report_events);
+		break;
+
+	case TSTATE_GOING_UP:
+		if (t_dev->touch_button == RXY_DOWN)
+			t_dev->ts_state = TSTATE_DOWN;
+		else if (t_dev->touch_button == RXY_UP)
+			process_up(report_events);
+		break;
+	}
+	if (t_dev->ts_state == TSTATE_DOWN) {
+		/* average the x1 and 2 readings; ditto with y1,2 */
+		t_dev->touch_x = (t_dev->adc_x + t_dev->adc_x2)/2;
+		t_dev->touch_y = (t_dev->adc_y + t_dev->adc_y2)/2;
+
+		/* use calibration data to convert from adc reading to
+                 * screen position.
+                 */
+		t_dev->screen_x = (t_dev->a[1] * t_dev->touch_x +
+				   t_dev->a[2] * t_dev->touch_y +
+				   t_dev->a[0]) / t_dev->a[6];
+		t_dev->screen_y = (t_dev->a[4] * t_dev->touch_x +
+				   t_dev->a[5] * t_dev->touch_y +
+				   t_dev->a[3]) / t_dev->a[6];
+		if (t_dev->adc_p2 == 0) {
+			t_dev->adc_pressure = 0;
+			t_dev->touch_pressure = 0;
+		}
+		else {
+			int i;
+			t_dev->adc_pressure = t_dev->touch_x
+				* ((1000 * t_dev->adc_p1)/t_dev->adc_p2 - 1000)
+				/ 1000;
+		/* Convert computed pressure to linear pressure with piecewise curve */
+			t_dev->touch_pressure=10;
+			for (i=0; i<N_PCURVE_PTS; i++)
+			{
+				if (t_dev->adc_pressure < t_dev->pressure_curve[i])
+				{
+					t_dev->touch_pressure = 100-i*10;
+					break;
+				}
+			}
+		}
+
+		if (report_events & REMASK_REPORT) {
+			input_report_abs(t_dev->i_dev, ABS_X, t_dev->screen_x);
+			input_report_abs(t_dev->i_dev, ABS_Y, t_dev->screen_y);
+			input_report_abs(t_dev->i_dev, ABS_PRESSURE, t_dev->touch_pressure);
+			input_sync(t_dev->i_dev);
+		}
+	}
+
+	if (report_events & REMASK_RAW_REPORT) {
+		input_report_abs(t_dev->iraw_dev, 0x0, t_dev->adc_x);
+		input_report_abs(t_dev->iraw_dev, 0x1, t_dev->adc_x2);
+		input_report_abs(t_dev->iraw_dev, 0x2, t_dev->adc_y);
+		input_report_abs(t_dev->iraw_dev, 0x3, t_dev->adc_y2);
+		input_report_abs(t_dev->iraw_dev, 0x4, t_dev->adc_p1);
+		input_report_abs(t_dev->iraw_dev, 0x5, t_dev->adc_p2);
+		input_report_abs(t_dev->iraw_dev, 0x6, t_dev->adc_tnt1);
+		input_report_abs(t_dev->iraw_dev, 0x7, t_dev->adc_tnt2);
+		input_report_abs(t_dev->iraw_dev, 0x8, t_dev->adc_pressure);
+		input_report_abs(t_dev->iraw_dev, 0x9, 
+				 t_dev->scanning ? 
+				 scan_delay_lut[t_dev->scan_ctr & (SCAN_DELAY_LUT_SIZE-1)] : 
+				 t_dev->delay_in_us);
+		// show life to keep events flowing
+		input_report_abs(t_dev->iraw_dev, 0xa, counter++);
+		input_sync(t_dev->iraw_dev);
+	}
+
+	// Rob Debug--No one was using REMASK_ADC_DBG, so I will.
+	// To enable, echo 3 or 9+100*N (instead of 1) >
+	// /sys/devices/platform/lf1000-touchscreen/report_events
+	if (report_events & (REMASK_ADC_DBG | REMASK_ADC_DBG_MODE))
+	{
+		static char *lut = "DV^U";
+		static int y=0;
+		int do_report = 0;
+
+		if (report_events & REMASK_ADC_DBG_MODE)
+		{
+			// Report N times, decrementing the
+			// upper bits in report_events, until 0
+			y = report_events >> RESHIFT_COUNT;
+			if (y > 0)
+			{
+				y--;
+				t_dev->report_events = (y << RESHIFT_COUNT) |
+					(report_events & ((1<<RESHIFT_COUNT)-1));
+				do_report = 1;
+			}
+		}
+		else
+		{
+			// Report once every second
+			y=(y+1)%((HZ)/t_dev->sample_rate_in_jiffies);
+			if (y==0)
+				do_report = 1;
+
+		}
+		if (do_report)
+		{
+			static int lastx, lasty;
+			if ((report_events & REMASK_ADC_DBG) &&
+			    (report_events & REMASK_ADC_DBG_MODE))
+				printk (KERN_ALERT // Super report! 10
+					"x1=%4d x2=%4d y1=%4d y2=%4d p1=%4d p2=%4d tnt1=%4d tnt2=%4d P=%4d\n",
+					t_dev->adc_x, t_dev->adc_x2,
+					t_dev->adc_y, t_dev->adc_y2,
+					t_dev->adc_p1, t_dev->adc_p2,
+					t_dev->adc_tnt1, t_dev->adc_tnt2,
+					t_dev->adc_pressure);
+					/* "x1=%4d x2=%4d y1=%4d y2=%4d p1=%4d p2=%4d tnt1=%4d tnt2=%4d S=%c X=%3d Y=%3d P=%4d LP=%3d %4d,%4d\n", */
+					/* t_dev->adc_x, t_dev->adc_x2, */
+					/* t_dev->adc_y, t_dev->adc_y2, */
+					/* t_dev->adc_p1, t_dev->adc_p2, */
+					/* t_dev->adc_tnt1, t_dev->adc_tnt2, */
+					/* lut[t_dev->ts_state], */
+					/* t_dev->screen_x, t_dev->screen_y, */
+					/* t_dev->adc_pressure, */
+					/* t_dev->touch_pressure, */
+					/* t_dev->screen_x-lastx, t_dev->screen_y-lasty); */
+			else
+				printk (KERN_ALERT // Regular report: 2
+					"x1=%4d x2=%4d y1=%4d y2=%4d p1=%4d p2=%4d tnt1=%4d tnt2=%4d S=%c X=%d Y=%d P=%d LP=%d\n",
+					t_dev->adc_x, t_dev->adc_x2,
+					t_dev->adc_y, t_dev->adc_y2,
+					t_dev->adc_p1, t_dev->adc_p2,
+					t_dev->adc_tnt1, t_dev->adc_tnt2,
+					lut[t_dev->ts_state],
+					t_dev->screen_x, t_dev->screen_y,
+					t_dev->adc_pressure,
+					t_dev->touch_pressure);
+			lastx=t_dev->screen_x;
+			lasty=t_dev->screen_y;
+		}
+	}
+#ifdef TS_TIMING
+	if (t_dev->N_us++)
+	{
+		u32 t = timing ? 1 : timer_stop();
+		t_dev->sum_us += t;
+		if (t_dev->max_us < t) t_dev->max_us = t;
+		if (t_dev->min_us > t) t_dev->min_us = t;
+	}
+	else
+		t_dev->sum_us = t_dev->max_us = t_dev->min_us = 
+			timing ? 1 : timer_stop();
+#endif
+}
+
+void touchscreen_monitor_task(unsigned long data)
+{
+	struct touch *t_dev = (struct touch *)data;
+
+	if (!t_dev->stop_timer) {	// not stopping, reload timer
+		queue_work(t_dev->touchscreen_tasks, &t_dev->touchscreen_work);
+		t_dev->touchscreen_timer.expires += t_dev->sample_rate_in_jiffies;
+		t_dev->touchscreen_timer.function = touchscreen_monitor_task;
+		t_dev->touchscreen_timer.data = data;
+		add_timer(&t_dev->touchscreen_timer);
+	}
+}
+
+int touchscreen_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+                                          unsigned long arg)
+{
+	return 0;
+}
+	
+struct file_operations touchscreen_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = touchscreen_ioctl,
+};
+
+static int lf1000_ts2_probe(struct platform_device *pdev)
+{
+	struct input_dev *i_dev, *iraw_dev;
+	int error, i;
+
+	i_dev = input_allocate_device();
+
+	if (!i_dev)  {
+		error = -ENOMEM;
+		goto err_free_devs;
+	}
+
+	iraw_dev = input_allocate_device();
+	if (!iraw_dev)  {
+		error = -ENOMEM;
+		goto err_free_devs;
+	}
+
+	i_dev->name		= "LF1000 touchscreen interface";
+	i_dev->phys		= "lf1000/touchscreen";
+	i_dev->id.bustype	= BUS_HOST;
+	i_dev->id.vendor	= 0x0001;
+	i_dev->id.product	= 0x0001;
+	i_dev->id.version	= 0x0001;
+	t_dev->i_dev		= i_dev;
+
+	iraw_dev->name		= "LF1000 touchscreen raw";
+	iraw_dev->phys		= "lf1000/touchscreen-raw";
+	iraw_dev->id.bustype	= BUS_HOST;
+	iraw_dev->id.vendor	= 0x0001;
+	iraw_dev->id.product	= 0x0001;
+	iraw_dev->id.version	= 0x0001;
+	t_dev->iraw_dev		= iraw_dev;
+
+	t_dev->ts_state          = TSTATE_UP;
+
+	t_dev->adc_tnt1          = 1024;
+	t_dev->adc_tnt2          = 1024;
+	t_dev->adc_max_tnt_down  = MAX_TNT_DOWN;
+	t_dev->adc_min_tnt_up    = MIN_TNT_UP;
+	t_dev->adc_max_delta_tnt = MAX_DELTA_TNT;
+
+	t_dev->averaging	 = -1; /* Median mode instead of avg */
+	t_dev->tails		 = 0; /* Not compatible with V3 calib */
+	t_dev->scanning		 = 0;
+	t_dev->tnt_mode		 = gpio_have_gpio_madrid() ? 1 : 0;
+
+	t_dev->tnt_plane[0]	 = 0; /* All 3 0's means no plane offset */
+	t_dev->tnt_plane[1]	 = 0;
+	t_dev->tnt_plane[2]	 = 0;
+
+	t_dev->delay_in_us	= TS_DELAY_IN_US;
+	t_dev->y_delay_in_us	= TS_Y_DELAY_IN_US;
+	t_dev->tnt_delay_in_us	= TNT_DELAY_IN_US;
+
+	t_dev->pressure_curve[0] = 468;
+	t_dev->pressure_curve[1] = 471;
+	t_dev->pressure_curve[2] = 487;
+	t_dev->pressure_curve[3] = 495;
+	t_dev->pressure_curve[4] = 509;
+	t_dev->pressure_curve[5] = 524;
+	t_dev->pressure_curve[6] = 553;
+	t_dev->pressure_curve[7] = 575;
+	t_dev->pressure_curve[8] = 612;
+
+	/* set GPIOs to max output current */
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_X1),
+		      lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		      lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_X2),
+		      lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		      lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_CURRENT_8MA);
+
+	/*
+ 	 * set first ADC channel hooked to touchscreen
+ 	 * Didj TS uses ADC[0] to ADC[3]
+ 	 * Leapster 3 uses ADC[4] to ADC[7]
+ 	 */
+
+	if (gpio_have_gpio_dev() || gpio_have_gpio_didj())
+		t_dev->first_adc = 0;
+	else if (gpio_have_gpio_acorn() || gpio_have_gpio_emerald())
+		t_dev->first_adc = 4;
+	else {
+		t_dev->first_adc = 4;
+		dev_dbg(&t_dev->i_dev->dev,
+				"%s.%s:%d unknown touchscreen interface",
+				__FILE__, __FUNCTION__, __LINE__);
+	}
+
+	/* event types that we support */	
+	i_dev->evbit[0]			   = BIT(EV_KEY) | BIT(EV_ABS);
+	i_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	/* initial screen coordination      min=[0]   max=[1]  fuzz=[2]  */
+	input_set_abs_params(i_dev, ABS_X, abs_x[0], abs_x[1], abs_x[2], 0);
+	input_set_abs_params(i_dev, ABS_Y, abs_y[0], abs_y[1], abs_y[2], 0);
+	input_set_abs_params(i_dev, ABS_PRESSURE, abs_p[0], abs_p[1], abs_p[2], 0);
+	platform_set_drvdata(pdev, t_dev);
+
+	error = input_register_device(i_dev);
+	if(error)
+		goto err_free_devs;
+
+	/* event types that we support */	
+	iraw_dev->evbit[0]			   = BIT(EV_ABS);
+
+	/* initial screen coordination      min=[0]   max=[1]  fuzz=[2]  */
+	for (i=0x0; i<RAW_ABS_PARAMS; i++)
+		input_set_abs_params(iraw_dev, i, 0, 65535, 0, 0);
+
+	error = input_register_device(iraw_dev);
+	if(error)
+		goto err_free_devs;
+
+	/* setup work queue */
+	t_dev->touchscreen_tasks = create_singlethread_workqueue("touchscreen"
+								 " tasks");
+	INIT_WORK(&t_dev->touchscreen_work, get_touch);
+
+	/* Do the initial configuration for reading tnt */
+	set_read_tnt();
+	tnt_delay_in_us ();	// Let the screen settle and charge up
+
+	/* grab initial touchscreen settings */
+	read_xy();
+
+	/* set default /etc/pointercal values */
+	t_dev->a[0] = TS_A0;
+	t_dev->a[1] = TS_A1;
+	t_dev->a[2] = TS_A2;
+	t_dev->a[3] = TS_A3;
+	t_dev->a[4] = TS_A4;
+	t_dev->a[5] = TS_A5;
+	t_dev->a[6] = TS_A6;
+
+	/* setup periodic sampling */
+	t_dev->sample_rate_in_jiffies   = TOUCHSCREEN_SAMPLING_J;
+	t_dev->debounce_in_samples_down = TS_DEBOUNCE_DOWN; /* min down */
+	t_dev->debounce_in_samples_up   = TS_DEBOUNCE_UP;  /* min up    */
+	t_dev->report_events     = REMASK_REPORT;   /* send input_event data */
+	t_dev->stylus_down_count = 0;	/* # consecutive stylus down samples */
+	t_dev->stylus_up_count   = 0;   /* "      "        "     up     "    */
+	setup_timer(&t_dev->touchscreen_timer, touchscreen_monitor_task,
+		    (unsigned long)t_dev);
+	t_dev->touchscreen_timer.expires = get_jiffies_64()
+		                                + t_dev->sample_rate_in_jiffies;
+
+	add_timer(&t_dev->touchscreen_timer);	/*run*/
+
+	sysfs_create_group(&pdev->dev.kobj, &touchscreen_attr_group);
+	dev_info( &t_dev->i_dev->dev, "lf1000_ts2: probe done ok\n");
+	return 0;
+
+err_free_devs:
+	dev_crit( &t_dev->i_dev->dev, "lf1000_ts2: probe error\n");
+	if (&t_dev->touchscreen_timer != NULL) {
+		t_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&t_dev->touchscreen_timer);
+	}
+	sysfs_remove_group(&pdev->dev.kobj, &touchscreen_attr_group);
+	input_free_device(t_dev->i_dev);
+	input_free_device(t_dev->iraw_dev);
+	return error;
+}
+
+static int lf1000_ts2_remove(struct platform_device *pdev)
+{
+	struct touch *t_dev = platform_get_drvdata(pdev);
+
+	if (&t_dev->touchscreen_timer != NULL) {
+		t_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&t_dev->touchscreen_timer);
+	}
+
+	destroy_workqueue(t_dev->touchscreen_tasks);
+
+	sysfs_remove_group(&pdev->dev.kobj, &touchscreen_attr_group);
+
+	input_unregister_device(t_dev->i_dev);
+	input_unregister_device(t_dev->iraw_dev);
+	return 0;
+}
+
+/* fake release function to quiet "does not have a release()" warning */
+
+void lf1000_ts2_release(struct device *dev)
+{
+}
+
+static struct platform_device lf1000_ts2_device = {
+	.name		= "lf1000-touchscreen",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.release = lf1000_ts2_release,
+	}
+};
+
+static struct platform_driver lf1000_ts2_driver = {
+	.probe		= lf1000_ts2_probe,
+	.remove		= lf1000_ts2_remove,
+	.driver		= {
+		.name	= "lf1000-touchscreen",
+		.owner	= THIS_MODULE,
+		},
+};
+
+static int __init lf1000_ts2_init(void)
+{
+	int ret;
+	ret = platform_device_register(&lf1000_ts2_device);
+	ret = platform_driver_register(&lf1000_ts2_driver);
+	return(ret);
+}
+
+static void __exit lf1000_ts2_exit(void)
+{
+	platform_driver_unregister(&lf1000_ts2_driver);
+	platform_device_unregister(&lf1000_ts2_device);
+}
+
+module_init(lf1000_ts2_init);
+module_exit(lf1000_ts2_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("LF1000 Touchscreen driver Try 2");
+MODULE_LICENSE("GPL");
+
diff -ruaN linux-2.6.31/drivers/input/touchscreen/lf1000_ts.c linux-2.6/drivers/input/touchscreen/lf1000_ts.c
--- linux-2.6.31/drivers/input/touchscreen/lf1000_ts.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/input/touchscreen/lf1000_ts.c	2012-11-14 20:56:52.000000000 -0800
@@ -0,0 +1,2255 @@
+/*
+ *  LF1000 touchscreen driver
+ *
+ *  Author:	Scott Esters, <sesters@leapfrog.com>
+ *  Created:	May 27, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This code is heavily based on ucb1x00-*.c copyrighted by Russell King
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/suspend.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <mach/gpio.h>
+#include <mach/adc.h>
+
+#include <linux/sysfs.h>
+
+#define TOUCHSCREEN_SAMPLING_J	HZ / 100  // sample touchscreen every 10 ms
+
+#define TOUCHSCREEN_MAJOR	247
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/* Enable the definition of DEVCRITpm if you want the driver to generate
+ * debug output during initial development.
+ * Most of the stuff inside #ifdef DEVCRITpm ... #endif brackets ought to be
+ * removed before this code is released.
+ */
+#define DEVCRITpm 1
+
+#define TS_DEBOUNCE_DOWN 1	// default debounce down, min samples for down
+#define TS_DEBOUNCE_UP	 1	// default debounce up, min samples for up
+/* NOTE:
+ *  Using 1 as the debounce threshold is equivalent to no debouncing.
+ *  This allows greatest responsiveness.  It also allows some bouncing --
+ *  when the stylus hits the touch screen, bounces off, then touches the
+ *  screen again.
+ *  We'll need to check if this is the way we want it.
+ */
+#else
+#define TS_DEBOUNCE_DOWN 4	// default debounce down, min samples for down
+#define TS_DEBOUNCE_UP	 1	// default debounce up, min samples for up
+#define TS_HISTORY_MAX	50	// max length of sample history queue
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+
+// input event touch defines. X=0 and Y=0 is reserved for no touch.
+#define TS_MIN_X	1	    // min X resolution value
+#define TS_MAX_X	1023	// max X resolution value
+#define	TS_FUZZ_X	2	    // gaussian filter window size, 0=none
+
+#define TS_MIN_Y	1	    // min Y resolution value
+#define TS_MAX_Y	1023	// max Y resolution value
+#define	TS_FUZZ_Y	2	    // gaussian filter window size, 0=none
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/* Rob's calculations indicated the driver was delaying longer than necessary for
+ * the voltages to settle before reading the ADC.
+ * Experiments indicated that a 10-microsecond delay is long enough for the
+ * x, y, and Z readings but not for the TNT readings.  Though 15 microseconds
+ * might be a long enough delay for the TNT reading, 18 seemed a little better:
+ * the tnt2 reading is a bit closer to the tnt1 reading.
+ */
+//#define TS_DELAY_IN_US	150	// settling time before sample
+//#define TS_DELAY_IN_US	50	// settling time before sample
+                                // 50 seems long enough
+//#define TS_DELAY_IN_US	20	// settling time before sample
+//#define TS_DELAY_IN_US	15	// settling time before sample (works well
+                                // without extra readings
+#define TS_DELAY_IN_US	10	// settling time before sample; too small for tnt
+                            // might be ok for others.  Light touches often
+                            // are not detected because tnt2 is too high.
+#define TNT_DELAY_IN_US 18  // a little better than 15, but not much difference
+//#define TS_DELAY_IN_US	5	// settling time (in microsecs) before sample
+
+/* Enable the definition of READ_Z1Z2_PRESSURE to enable collection of Z1 and
+ * Z2 voltages and calculation of pressure using the standard method.
+ */
+#define READ_Z1Z2_PRESSURE  1
+
+
+/* Enable the definition of EXTRA_READINGS if you want to evaluate various
+ * settling times (delays).
+ */
+//#define EXTRA_READINGS      1
+//#define NUM_EXTRA_READINGS  2   // take this many extra readings before the
+                                // "official" reading
+#else
+#define TS_DELAY_IN_US	150	// settling time before sample
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+// default stylus touch rectangle.  These are conservative values for
+// use during device driver load and need to be adjusted for each device.
+#define TS_TOUCH_MIN_X	100	// min valid X touch value
+#define TS_TOUCH_MAX_X	930	// max valid X touch value
+#define TS_TOUCH_MIN_Y	100	// min valid Y touch value
+#define TS_TOUCH_MAX_Y	930	// max valid Y touch value
+
+// Default rotation, translation, and shear values.  System should set these
+// at startup.  Note order in /etc/pointercal is A1 A2 A0 A4 A5 A3 A6
+#define TS_A0	25786444
+#define TS_A1	  -29676
+#define TS_A2	    -170
+#define TS_A3	21441222	
+#define TS_A4	    -632 
+#define TS_A5	  -26927
+#define TS_A6	   65536
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/* These are the states of a touch screen state machine managed by get_touch()
+ */
+#define TSTATE_DOWN         0
+#define TSTATE_GOING_DOWN   1
+#define TSTATE_GOING_UP     2
+#define TSTATE_UP           3
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+static int abs_x[3] = {TS_MIN_X, TS_MAX_X, TS_FUZZ_X};
+module_param_array(abs_x, int, NULL, 0);
+MODULE_PARM_DESC(abs_x, "Touchscreen absolute X min, max, fuzz");
+
+static int abs_y[3] = {TS_MIN_Y, TS_MAX_Y, TS_FUZZ_Y};
+module_param_array(abs_y, int, NULL, 0);
+MODULE_PARM_DESC(abs_y, "Touchscreen absolute Y min, max, fuzz");
+
+struct touch {
+	struct input_dev	*i_dev;
+
+	struct task_struct	*ts_task;
+
+	struct	timer_list        touchscreen_timer;
+	struct	workqueue_struct *touchscreen_tasks;
+	struct	work_struct       touchscreen_work;	// check touchscreen
+
+	int	stop_timer;	          // non-zero = stop timer reload
+	int	sample_rate_in_jiffies;	  // screen sample rate
+	int	debounce_in_samples_down; // samples before stylus down declared
+	int	debounce_in_samples_up;   // samples before stylus up declared
+
+#ifndef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	int	history_queue[TS_HISTORY_MAX][2]; // history queue
+	int	queue_head;		  // write X,Y data here
+	int	queue_tail;		  // read X,Y data here
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	/*
+	 * report_events, controls sending data up to Linux
+	 * as well as debugging messages.  Also has bitfield definitions
+	 *   bit 0 ==0 no events reported to Linux
+	 *         ==1 report events to Linux
+	 *   bit 1 ==1 show ADC debugging messages
+	 *   bit 2 ==0 use read_xy() to read x ADC, then y ADC value
+	 *         ==1 use read_yx() to read y ADC, then x ADC value
+	 */
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/* TODO: FIXME: 22sep10
+ * Decide if there's any reason to keep read_yx().  If there is, modify it to
+ * more like read_xy().  If not, delete previous comment about bit 2.
+ */
+#define REBIT_REPORT    0
+#define REBIT_ADC_DBG   1
+#define REBIT_Y_FIRST   2
+#define REBIT_ADC_DBG_MODE   3
+
+#define RESHIFT_COUNT	4
+#define REMASK_REPORT   (1 << REBIT_REPORT)
+#define REMASK_ADC_DBG  (1 << REBIT_ADC_DBG)
+#define REMASK_ADC_DBG_MODE  (1 << REBIT_ADC_DBG_MODE)
+#define REMASK_Y_FIRST  (1 << REBIT_Y_FIRST)
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	int	report_events;
+
+	int	delay_in_us;		// delay between GPIO setup and reading
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	int	tnt_delay_in_us;	// delay between GPIO setup and reading
+					// for tnt
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	int	min_x;			// min screen touched
+	int	min_y;			// min screen touched
+
+	int	max_x;			// max screen touched
+	int	max_y;			// max screen touched
+
+	int	first_adc;		// 0=didj-ts, 4=Leapster 3
+
+	int	adc_x;			// raw adc for x measurements
+	int	adc_x2;			// raw adc for x measurements
+
+	int	adc_y;			// raw adc for y measurements
+	int	adc_y2;			// raw adc for y measurements
+
+	int	averaging;		// Number of samples to average
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+#ifdef READ_Z1Z2_PRESSURE
+	int	adc_p1;		        // raw adc for p1 measurements
+	int	adc_p2;		        // raw adc for p2 measurements
+	int	adc_pressure;
+#endif
+	int	adc_tnt1;		// raw adc for first tnt measurement
+	int	adc_tnt2;		// raw adc for second tnt measurement
+#ifdef EXTRA_READINGS
+	int	adc_x_pre[NUM_EXTRA_READINGS];
+	int	adc_x2_pre[NUM_EXTRA_READINGS];
+
+	int	adc_y_pre[NUM_EXTRA_READINGS];
+	int	adc_y2_pre[NUM_EXTRA_READINGS];
+
+	int	adc_tnt1_pre[NUM_EXTRA_READINGS];
+	int	adc_tnt2_pre[NUM_EXTRA_READINGS];
+
+#ifdef READ_Z1Z2_PRESSURE
+	int	adc_p1_pre[NUM_EXTRA_READINGS];
+	int	adc_p2_pre[NUM_EXTRA_READINGS];
+#endif
+#endif  // EXTRA_READINGS
+
+	int	adc_max_tnt_down;   // tnt readings must be <= this for touch
+	int	adc_min_tnt_up;     // either tnt reading > this ==> Up
+	int	adc_max_delta_tnt;  // for Down, both tnt readings must be 
+				    // less than or equal to adc_max_tnt_down
+	                            // AND must differ by no more than this.
+#ifdef DEVCRITpm
+	int	prev_adc_x;		// raw adc for x measurements
+	int	prev_adc_x2;		// raw adc for x measurements
+	int	prev_adc_y;		// raw adc for y measurements
+	int	prev_adc_y2;		// raw adc for y measurements
+#endif  // DEVCRITpm
+
+	int	stylus_went_up;
+	int	stylus_went_down;
+	int	ts_state;
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	int	touch_x, touch_y;	// raw ADC touchscreen x and y values
+	int	touch_button;		// screen touched
+	int	screen_x, screen_y;	// transformed screen x and y values
+
+	int	screen_last_x, screen_last_y;  // debugging values
+
+	int	stylus_down_count;	// count consecutive stylus down samples
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	int	stylus_up_count;	// count consecutive stylus up samples
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	int	a[7];			// /etc/pointercal values
+
+	struct cdev *cdev;		// char device
+	int	dev;
+	int	major;
+} touch_dev;
+
+struct touch * t_dev = &touch_dev;
+
+/*
+ * sysfs Interface
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "Name is %s\n", __FILE__);
+}
+static DEVICE_ATTR(name, S_IRUSR|S_IRGRP|S_IROTH, show_name, NULL);
+
+/* Return /etc/pointercal values.  pointercal order is A1 A2 A0 A4 A5 A3 A6 */
+static ssize_t show_pointercal(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d %d %d %d %d %d %d\n",
+		t_dev->a[1], t_dev->a[2], t_dev->a[0],
+		t_dev->a[4], t_dev->a[5], t_dev->a[3], t_dev->a[6]);
+}
+static DEVICE_ATTR(pointercal, S_IRUSR|S_IRGRP|S_IROTH, show_pointercal, NULL);
+
+
+/* report current x1 coordinate, 'x0' is used by calibration programs */
+static ssize_t show_x0(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n",lf1000_touch_dev->touch_x);
+}
+static DEVICE_ATTR(x0, S_IRUSR|S_IRGRP|S_IROTH, show_x0, NULL);
+
+
+/* report current y coordinate, 'y1' is used by calibration programs */
+static ssize_t show_y1(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_y);
+}
+static DEVICE_ATTR(y1, S_IRUSR|S_IRGRP|S_IROTH, show_y1, NULL);
+
+static ssize_t show_touch_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_x);
+}
+static DEVICE_ATTR(touch_x, S_IRUSR|S_IRGRP|S_IROTH, show_touch_x, NULL);
+
+static ssize_t show_touch_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_y);
+}
+static DEVICE_ATTR(touch_y, S_IRUSR|S_IRGRP|S_IROTH, show_touch_y, NULL);
+
+static ssize_t show_touch_button(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->touch_button);
+}
+static DEVICE_ATTR(touch_button, S_IRUSR|S_IRGRP|S_IROTH, show_touch_button, NULL);
+
+static ssize_t show_screen_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->screen_x);
+}
+static DEVICE_ATTR(screen_x, S_IRUSR|S_IRGRP|S_IROTH, show_screen_x, NULL);
+
+static ssize_t show_screen_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->screen_y);
+}
+static DEVICE_ATTR(screen_y, S_IRUSR|S_IRGRP|S_IROTH, show_screen_y, NULL);
+
+static ssize_t show_raw_adc(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	static char *lut = "DV^U";
+	return sprintf(buf, "x1=%d x2=%d y1=%d y2=%d p1=%d p2=%d tnt1=%d tnt2=%d S=%c X=%d Y=%d P=%d\n", 
+		       lf1000_touch_dev->adc_x, lf1000_touch_dev->adc_x2, 
+		       lf1000_touch_dev->adc_y, lf1000_touch_dev->adc_y2, 
+		       lf1000_touch_dev->adc_p1, lf1000_touch_dev->adc_p2, 
+		       lf1000_touch_dev->adc_tnt1, lf1000_touch_dev->adc_tnt2, 
+		       lut[lf1000_touch_dev->ts_state],
+		       lf1000_touch_dev->screen_x, lf1000_touch_dev->screen_y,
+		       lf1000_touch_dev->adc_pressure);
+}
+static DEVICE_ATTR(raw_adc, S_IRUSR|S_IRGRP|S_IROTH, show_raw_adc, NULL);
+
+static ssize_t show_fuzz_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->i_dev->absfuzz[ABS_X]);
+}
+static ssize_t set_fuzz_x(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->i_dev->absfuzz[ABS_X] = temp;
+	dev_dbg(dev, "%s.%s:%d fuzz_x=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->i_dev->absfuzz[ABS_X]);
+	return(count);
+}
+
+static DEVICE_ATTR(fuzz_x, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_fuzz_x, set_fuzz_x);
+
+static ssize_t show_fuzz_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+
+	return sprintf(buf, "%d\n", lf1000_touch_dev->i_dev->absfuzz[ABS_Y]);
+}
+static ssize_t set_fuzz_y(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->i_dev->absfuzz[ABS_Y] = temp;
+	dev_dbg(dev, "%s.%s:%d fuzz_y=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->i_dev->absfuzz[ABS_Y]);
+	return(count);
+}
+
+static DEVICE_ATTR(fuzz_y, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_fuzz_y, set_fuzz_y);
+
+static ssize_t show_delay_in_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->delay_in_us);
+}
+static ssize_t set_delay_in_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	lf1000_touch_dev->delay_in_us = temp;
+	dev_dbg(dev, "%s.%s:%d delay_in_us=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->delay_in_us);
+	return(count);
+}
+
+static DEVICE_ATTR(delay_in_us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_delay_in_us, set_delay_in_us);
+
+/* Averaging: set to >1 to average during read_xy */
+static ssize_t show_averaging(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->averaging);
+}
+static ssize_t set_averaging(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->averaging = temp;
+	dev_dbg(dev, "%s.%s:%d averaging=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->averaging);
+	return(count);
+}
+static DEVICE_ATTR(averaging, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_averaging, set_averaging);
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+
+static ssize_t show_tnt_delay_in_us(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->tnt_delay_in_us);
+}
+static ssize_t set_tnt_delay_in_us(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0)
+		return -EINVAL;
+	lf1000_touch_dev->tnt_delay_in_us = temp;
+	dev_dbg(dev, "%s.%s:%d tnt_delay_in_us=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->tnt_delay_in_us);
+	return(count);
+}
+
+static DEVICE_ATTR(tnt_delay_in_us, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_tnt_delay_in_us, set_tnt_delay_in_us);
+
+
+
+
+static ssize_t show_max_tnt_down(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_max_tnt_down);
+}
+
+static ssize_t set_max_tnt_down(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_max_tnt_down = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_max_tnt_down);
+	return(count);
+}
+
+static DEVICE_ATTR(max_tnt_down, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_max_tnt_down, set_max_tnt_down);
+
+
+static ssize_t show_min_tnt_up(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_min_tnt_up);
+}
+
+static ssize_t set_min_tnt_up(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_min_tnt_up = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_min_tnt_up);
+	return(count);
+}
+
+static DEVICE_ATTR(min_tnt_up, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_min_tnt_up, set_min_tnt_up);
+
+
+static ssize_t show_max_delta_tnt(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->adc_max_delta_tnt);
+}
+
+static ssize_t set_max_delta_tnt(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+	if (temp < 0) {
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->adc_max_delta_tnt = temp;
+
+	dev_dbg(dev, "%s.%s:%d max_delta_tnt=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->adc_max_delta_tnt);
+	return(count);
+}
+
+static DEVICE_ATTR(max_delta_tnt, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_max_delta_tnt, set_max_delta_tnt);
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+
+static ssize_t show_debounce_in_samples_down(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->debounce_in_samples_down);
+}
+
+static ssize_t set_debounce_in_samples_down(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	if (temp < 0) 
+#else
+	if (temp < 0 || (TS_HISTORY_MAX / 2) < temp)
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	{
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->debounce_in_samples_down = temp;
+	lf1000_touch_dev->stylus_down_count = 0;	/* reset counter */
+
+	dev_dbg(dev, "%s.%s:%d debounce_in_samples_down=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->debounce_in_samples_down);
+	return(count);
+}
+
+static DEVICE_ATTR(debounce_in_samples_down, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_debounce_in_samples_down, set_debounce_in_samples_down);
+
+static ssize_t show_debounce_in_samples_up(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->debounce_in_samples_up);
+}
+
+static ssize_t set_debounce_in_samples_up(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+
+	/* if value out of range then ignore it */
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	if (temp < 0) 
+#else
+	if (temp < 0 || (TS_HISTORY_MAX / 2) < temp)
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	{
+		dev_err(dev, "%s: Invalid value %s\n",
+			__FUNCTION__, buf);
+		return (count);
+	}
+
+	lf1000_touch_dev->debounce_in_samples_up = temp;
+	lf1000_touch_dev->stylus_down_count = 0;	/* reset counter */
+
+	dev_dbg(dev, "%s.%s:%d debounce_in_samples_up=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->debounce_in_samples_up);
+	return(count);
+}
+
+static DEVICE_ATTR(debounce_in_samples_up, \
+	S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, \
+	show_debounce_in_samples_up, set_debounce_in_samples_up);
+
+
+static ssize_t show_stylus_down_count(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->stylus_down_count);
+}
+
+static DEVICE_ATTR(stylus_down_count, \
+	S_IRUSR|S_IRGRP|S_IROTH,
+	show_stylus_down_count, NULL);
+
+static ssize_t show_min_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->min_x);
+}
+static ssize_t set_min_x(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->min_x = temp;
+	dev_dbg(dev, "%s.%s:%d min_x=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->min_x);
+	return(count);
+}
+
+static DEVICE_ATTR(min_x, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_min_x, set_min_x);
+
+static ssize_t show_max_x(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->max_x);
+}
+static ssize_t set_max_x(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->max_x = temp;
+	dev_dbg(dev, "%s.%s:%d max_x=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->max_x);
+	return(count);
+}
+
+static DEVICE_ATTR(max_x, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_max_x, set_max_x);
+
+static ssize_t show_min_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->min_y);
+}
+static ssize_t set_min_y(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->min_y = temp;
+	dev_dbg(dev, "%s.%s:%d min_y=%d\n", __FILE__, __FUNCTION__, 
+			__LINE__, lf1000_touch_dev->min_y);
+	return(count);
+}
+
+static DEVICE_ATTR(min_y, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_min_y, set_min_y);
+
+static ssize_t show_max_y(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->max_y);
+}
+static ssize_t set_max_y(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->max_y = temp;
+	dev_dbg(dev, "%s.%s:%d max_y=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->max_y);
+	return(count);
+}
+
+static DEVICE_ATTR(max_y, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_max_y, set_max_y);
+
+static ssize_t show_a0(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[0]);
+}
+static ssize_t set_a0(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[0] = temp;
+	dev_dbg(dev, "%s.%s:%d a[0]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[0]);
+	return(count);
+}
+static DEVICE_ATTR(a0, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a0, set_a0);
+
+static ssize_t show_a1(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[1]);
+}
+
+static ssize_t set_a1(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[1] = temp;
+	dev_dbg(dev, "%s.%s:%d a[1]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[1]);
+	return(count);
+}
+
+static DEVICE_ATTR(a1, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a1, set_a1);
+
+static ssize_t show_a2(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[2]);
+}
+
+static ssize_t set_a2(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[2] = temp;
+	dev_dbg(dev, "%s.%s:%d a[2]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[2]);
+	return(count);
+}
+
+static DEVICE_ATTR(a2, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a2, set_a2);
+
+
+static ssize_t show_a3(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[3]);
+}
+static ssize_t set_a3(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[3] = temp;
+	dev_dbg(dev, "%s.%s:%d a[3]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[3]);
+	return(count);
+}
+
+static DEVICE_ATTR(a3, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a3, set_a3);
+
+static ssize_t show_a4(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[4]);
+}
+static ssize_t set_a4(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[4] = temp;
+	dev_dbg(dev, "%s.%s:%d a[4]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[4]);
+	return(count);
+}
+
+static DEVICE_ATTR(a4, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a4, set_a4);
+
+static ssize_t show_a5(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[5]);
+}
+static ssize_t set_a5(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[5] = temp;
+	dev_dbg(dev, "%s.%s:%d a[5]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[5]);
+	return(count);
+}
+
+static DEVICE_ATTR(a5, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a5, set_a5);
+
+static ssize_t show_a6(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->a[6]);
+}
+static ssize_t set_a6(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	lf1000_touch_dev->a[6] = temp;
+	dev_dbg(dev, "%s.%s:%d a[6]=%d\n",
+		__FILE__, __FUNCTION__, __LINE__, lf1000_touch_dev->a[6]);
+	return(count);
+}
+
+static DEVICE_ATTR(a6, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_a6, set_a6);
+
+static ssize_t show_sample_rate_in_hz(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int rate;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	rate = lf1000_touch_dev->sample_rate_in_jiffies;
+	rate = (0 < rate) ? (HZ / rate) : 0 ;	// expect positive value
+	return sprintf(buf, "%d\n", rate);
+}
+static ssize_t set_sample_rate_in_hz(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%u", &temp) != 1)
+		return -EINVAL;
+	temp = (0 < temp )   ? temp : 1;  // set min rate to 1
+	temp = (temp <= HZ ) ? temp : HZ; // set max rate to HZ
+	lf1000_touch_dev->sample_rate_in_jiffies = (HZ / temp); 
+	dev_dbg(dev,  "%s.%s:%d sample_rate_in_jiffies=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->sample_rate_in_jiffies);
+	return(count);
+}
+
+static DEVICE_ATTR(sample_rate_in_hz, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_sample_rate_in_hz, set_sample_rate_in_hz);
+
+static ssize_t show_report_events(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	return sprintf(buf, "%d\n", lf1000_touch_dev->report_events);
+}
+static ssize_t set_report_events(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp;
+	struct touch *lf1000_touch_dev = (struct touch *)dev->driver_data;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	//	if (temp < 0 || temp > 7)	// ensure value between 0 and 7
+	//		return -EINVAL;
+	lf1000_touch_dev->report_events = temp;
+	dev_dbg(dev, "%s.%s:%d report_events=%d\n",
+		__FILE__, __FUNCTION__, __LINE__,
+		lf1000_touch_dev->report_events);
+	return(count);
+}
+
+static DEVICE_ATTR(report_events, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, show_report_events, set_report_events);
+
+static struct attribute *touchscreen_attributes[] = {
+	&dev_attr_name.attr,
+	&dev_attr_pointercal.attr,
+	&dev_attr_x0.attr,
+	&dev_attr_y1.attr,
+	&dev_attr_touch_x.attr,
+	&dev_attr_touch_y.attr,
+	&dev_attr_touch_button.attr,
+	&dev_attr_screen_x.attr,
+	&dev_attr_screen_y.attr,
+	&dev_attr_raw_adc.attr,
+	&dev_attr_fuzz_x.attr,
+	&dev_attr_fuzz_y.attr,
+	&dev_attr_delay_in_us.attr,
+	&dev_attr_averaging.attr,
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	&dev_attr_tnt_delay_in_us.attr,
+	&dev_attr_max_tnt_down.attr,
+	&dev_attr_min_tnt_up.attr,
+	&dev_attr_max_delta_tnt.attr,
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	&dev_attr_debounce_in_samples_down.attr,
+	&dev_attr_debounce_in_samples_up.attr,
+	&dev_attr_stylus_down_count.attr,
+	&dev_attr_min_x.attr,
+	&dev_attr_max_x.attr,
+	&dev_attr_min_y.attr,
+	&dev_attr_max_y.attr,
+	&dev_attr_a0.attr,
+	&dev_attr_a1.attr,
+	&dev_attr_a2.attr,
+	&dev_attr_a3.attr,
+	&dev_attr_a4.attr,
+	&dev_attr_a5.attr,
+	&dev_attr_a6.attr,
+	&dev_attr_sample_rate_in_hz.attr,
+	&dev_attr_report_events.attr,
+	NULL
+};
+
+static struct attribute_group touchscreen_attr_group = {
+	.attrs = touchscreen_attributes
+};
+
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/* experimental version suggested by Rob (from Sam)
+ * configure one sheet's terminals as inputs with pullup
+ * configure the other sheet's terminals as outputs with level 0.
+ * When untouched, the value on the inputs ought to be high.
+ * When touched, the value on the inputs will be low.
+ *               
+ * There seems to be a big difference in voltages between touched and untouched.
+ * There's a smaller variation of voltages when touched.  The harder the touch,
+ * the lower the voltage.
+ */
+void set_read_tnt(void) // touch / no-touch
+{
+	    // Set X1 and X2 as inputs with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+		                lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 0, 1, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+		                lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 1, 0);
+    	// Set Y1 and Y2 as outputs low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 1, 0, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+}
+static void read_first_tnt(void)
+{
+	t_dev->adc_tnt1 = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+}
+static void read_second_tnt(void)
+{
+	t_dev->adc_tnt2 = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+}
+/* NOTE: there is no delay before the first reading of tnt1, because the gpios
+ *       have been properly configured since tnt2 was read at the end of the
+ * previous sampling period.
+ */
+static void first_reading_tnt(void)
+{
+#ifdef EXTRA_READINGS
+	t_dev->adc_tnt1_pre[0] = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_tnt1_pre[1] = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+#endif
+    // This assumes the gpio configuration remains from previous reading,
+    // which occurs in the _probe() routine or in second_reading_tnt().
+    read_first_tnt();
+}
+/* NOTE: experiments indicated it's necessary to delay longer for the gpio
+ *       voltages to settle before reading tnt2.  Apparently this is due
+ * to differences in the resistors.
+ */
+static void second_reading_tnt(void)
+{
+    set_read_tnt();
+	udelay(t_dev->tnt_delay_in_us);	// Let the screen settle and charge up
+#ifdef EXTRA_READINGS
+	t_dev->adc_tnt2_pre[0] = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_tnt2_pre[1] = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+#endif
+    read_second_tnt();
+}
+
+#ifdef READ_Z1Z2_PRESSURE
+
+void set_read_p12(void)
+{
+#if 1   // 15sep10  Experimental version suggested by Rob and Sam
+        //          don't use pull-ups
+
+	// X1 = 1; Y2 = 0;  X2 and Y1 inputs
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set X1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+		                lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 0, 0);
+	// Set Y1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, 0, 0);
+	// Set X1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+		                lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 1);
+	// Set Y2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+#else
+	// X1 = 1; Y2 = 0;  X2 and Y1 inputs
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set X1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+		                lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 1, 0);
+	// Set Y1 as input with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, 1, 0);
+	// Set X1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+		                lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 1);
+	// Set Y2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		                lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+#endif
+}
+
+#endif
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+/* Configure the gpios for reading the x-position voltage */
+void set_read_x(void)
+{
+	// float X1 and X2 first, then drive Y1 high and Y2 low
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set X1 and X2 as inputs with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 0, 1, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 0, 1, 0);
+	// Set Y1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+                   	    lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 1, 0, 1);
+	// Set Y2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 1, 0, 0);
+}
+
+/* Configure the gpios for reading the y-position voltage */
+void set_read_y(void)
+{
+	// float Y1 and Y2 first, then drive X1 high and X2 low
+	// gpio_configure_pin(PORT, PIN, FUNCTION, OUT=1, PULLUP=1, VALUE)
+	// Set Y1 and Y2 as inputs with pullup
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_GPIOFN, 0, 1, 0);
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_Y2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_GPIOFN, 0, 1, 0);
+	// Set X1 as output high
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X1),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_GPIOFN, 1, 0, 1);
+	// Set X2 as output low
+	gpio_configure_pin(lf1000_l2p_port(TOUCHSCREEN_X2),
+                	    lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_GPIOFN, 1, 0, 0);
+}
+
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+/*
+ * int read_xy(void)
+ * returns RXY_UP:         Stylus UP, 
+ *         RXY_DOWN:       Stylus DOWN, have ADC values.
+ *         RXY_IN_BETWEEN: Stylus neither UP nor DOWN; have ADC values
+ *
+ * Reads adc to determine touch/no-touch (tnt).
+ * If no-touch, immediately returns RXY_UP.
+ * Otherwise reads X and Y touchscreen values.
+ * If READ_Z1Z2_PRESSURE is defined, reads voltages to calculate touch pressure.
+ * Then reads touch/no-touch again.
+ * If second tnt reading indicates no-touch, returns RXY_UP.
+ *
+ * If both tnt readings are <= t_dev->adc_max_tnt_down and are close to each
+ * other (differ by no more than t_dev->adc_max_delta_tnt), returns RXY_DOWN.  
+ * If both tnt readings are <= t_dev->adc_max_tnt_down and differ by more
+ * than t_dev->adc_max_delta_tnt, returns RXY_IN_BETWEEN.  
+ *
+ * Also returns RXY_IN_BETWEEN if both tnt readings are <= t_dev->adc_min_tnt_up
+ * and at least one of them is > t_dev->adc_max_tnt_down.
+ */
+
+//#define MAX_TNT_DOWN    20      // Down if all tnt are <= this
+                                  // This seems a little too tight
+//#define MAX_TNT_DOWN    25      // Down if all tnt are <= this
+                                  // Still a little too tight; misses a few
+                                  // very light touches.
+                                // Try a slightly higher value; check if it 
+                                // allows some aberrant x,y coordinates to slip
+                                // through
+#define MAX_TNT_DOWN    28      // Down if all tnt are <= this
+#define MIN_TNT_UP      500     // UP if any tnt is > this
+#define MAX_DELTA_TNT   5
+//#define MAX_DELTA_TNT   10    // second guess; let through just a few spurious
+                                // points. 
+//#define MAX_DELTA_TNT   20    // first guess; let through some spurious points
+
+#define RXY_UP          0
+#define RXY_DOWN        1
+#define RXY_IN_BETWEEN  2
+
+static int read_xy(void)
+{
+    first_reading_tnt();
+    if (t_dev->adc_tnt1 > t_dev->adc_min_tnt_up) {
+        t_dev->adc_tnt2 = 1024; // indicate unread (to prevent lots of output)
+        return RXY_UP;          // UP unless both tnt readings are low enough
+    }
+	/*
+	 * now read voltages for x
+	 */
+	set_read_x();			    // set GPIO pins to read X value
+#ifdef EXTRA_READINGS
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_x_pre[0]  = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	t_dev->adc_x2_pre[0] = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_x_pre[1]  = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+	t_dev->adc_x2_pre[1] = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+#endif
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc);     // read X1 ADC
+			s2 += adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+		}
+		t_dev->adc_x  = s1 / t_dev->averaging;
+		t_dev->adc_x2 = s2 / t_dev->averaging;
+	}
+	else
+	{
+		t_dev->adc_x  = adc_GetReading(t_dev->first_adc);     // read X1 ADC
+		t_dev->adc_x2 = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+	}
+
+	/*
+	 * read voltages for y
+	 */
+	set_read_y();			    // set GPIO pins to read Y value
+#ifdef EXTRA_READINGS
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_y_pre[0]  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+	t_dev->adc_y2_pre[0] = adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_y_pre[1]  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+	t_dev->adc_y2_pre[1] = adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+#endif
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+			s2 += adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+
+		}
+		t_dev->adc_y  = s1 / t_dev->averaging;
+		t_dev->adc_y2 = s2 / t_dev->averaging;
+	}
+	else
+	{
+		t_dev->adc_y  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+		t_dev->adc_y2 = adc_GetReading(t_dev->first_adc + 3); // read Y2 ADC
+	}
+
+#ifdef READ_Z1Z2_PRESSURE
+	/*
+	 * read voltages for pressure
+	 */
+    set_read_p12();
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+#ifdef EXTRA_READINGS
+	t_dev->adc_p1_pre[0]  = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+	t_dev->adc_p2_pre[0]  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+	udelay(t_dev->delay_in_us);	
+	t_dev->adc_p1_pre[1]  = adc_GetReading(t_dev->first_adc + 2); // read X2 ADC
+	t_dev->adc_p2_pre[1]  = adc_GetReading(t_dev->first_adc + 1); // read Y1 ADC
+	udelay(t_dev->delay_in_us);
+#endif
+	if (t_dev->averaging > 1)
+	{
+		int s1=0, s2=0, i;
+		for (i=0; i<t_dev->averaging; i++)
+		{
+			s1 += adc_GetReading(t_dev->first_adc+2);       // read X2 ADC
+			s2 += adc_GetReading(t_dev->first_adc+1);       // read Y1 ADC
+		}
+		t_dev->adc_p1 = s1 / t_dev->averaging;
+		t_dev->adc_p2 = s2 / t_dev->averaging;
+	}
+	else
+	{
+		t_dev->adc_p1 = adc_GetReading(t_dev->first_adc+2);       // read X2 ADC
+		t_dev->adc_p2 = adc_GetReading(t_dev->first_adc+1);       // read Y1 ADC
+	}
+#endif
+
+    /* second touch/no-touch reading */
+    second_reading_tnt();
+
+    if (t_dev->adc_tnt2 > t_dev->adc_min_tnt_up)
+        return RXY_UP;   // UP unless both tnt readings are low enough
+
+    else if (   (t_dev->adc_tnt1 <= t_dev->adc_max_tnt_down) 
+             && (t_dev->adc_tnt2 <= t_dev->adc_max_tnt_down))
+    {
+        // both are low enough for Down; check for stability
+        // if unstable, say going down or going up
+        if (abs(t_dev->adc_tnt1 - t_dev->adc_tnt2) > t_dev->adc_max_delta_tnt)
+        {
+            return RXY_IN_BETWEEN;
+        }
+        else return RXY_DOWN;  // if both low and stable, say Down
+    }
+        // else both are <= t_dev->adc_min_tnt_up and at least one is greater 
+        // than t_dev->adc_max_tnt_down.
+        // Seems to be in transition
+    else {
+        return RXY_IN_BETWEEN;
+    }
+}
+
+#else
+
+/*
+ * int read_xy(void) -- returns 0==Stylus UP, 1==Stylus DOWN, have ADC values.
+ * Read X and Y touchscreen values, returning Stylus UP / Stylus DOWN results.
+ * Assume any ADC value out of Stylus DOWN range means the Stylus is UP.
+ */
+static int read_xy(void)
+{
+	/*
+	 * read first set of points
+	 */
+	set_read_x();			// set GPIO pins to read X value
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_x  = adc_GetReading(t_dev->first_adc);     // read X ADC
+	t_dev->adc_x2 = adc_GetReading(t_dev->first_adc + 2); // read X ADC
+	set_read_y();			// set GPIO pins to read Y value
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_y  = adc_GetReading(t_dev->first_adc + 1); // read Y ADC
+	t_dev->adc_y2 = adc_GetReading(t_dev->first_adc + 3); // read Y ADC
+
+	/* check for valid point */
+	if (t_dev->adc_x  < t_dev->min_x || t_dev->max_x < t_dev->adc_x  ||
+	    t_dev->adc_x2 < t_dev->min_x || t_dev->max_x < t_dev->adc_x2 ||
+	    t_dev->adc_y  < t_dev->min_y || t_dev->max_y < t_dev->adc_y  ||
+	    t_dev->adc_y2 < t_dev->min_y || t_dev->max_y < t_dev->adc_y2)
+		return 0;		// stylus UP
+
+	return 1;			// stylus DOWN
+}
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+
+/*
+ * int read_yx(void) -- returns 0==Stylus UP, 1==Stylus DOWN, have ADC values.
+ * Read Y and X touchscreen values, returning Stylus UP / Stylus DOWN results.
+ * Assume any ADC value out of Stylus DOWN range means the Stylus is UP.
+ */
+static int read_yx(void)
+{
+	/*
+	 * read first set of points
+	 */
+	set_read_y();			// set GPIO pins to read Y value
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_y  = adc_GetReading(t_dev->first_adc + 1); // read Y ADC
+	t_dev->adc_y2 = adc_GetReading(t_dev->first_adc + 3); // read Y ADC
+	set_read_x();			// set GPIO pins to read X value
+	udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+	t_dev->adc_x  = adc_GetReading(t_dev->first_adc);     // read X ADC
+	t_dev->adc_x2 = adc_GetReading(t_dev->first_adc + 2); // read X ADC
+
+	/* check for valid point */
+	if (t_dev->adc_x  < t_dev->min_x || t_dev->max_x < t_dev->adc_x  ||
+	    t_dev->adc_x2 < t_dev->min_x || t_dev->max_x < t_dev->adc_x2 ||
+	    t_dev->adc_y  < t_dev->min_y || t_dev->max_y < t_dev->adc_y  ||
+	    t_dev->adc_y2 < t_dev->min_y || t_dev->max_y < t_dev->adc_y2)
+		return 0;		// stylus UP
+
+	return 1;			// stylus DOWN
+}
+
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+
+/* State transitions and debouncing
+ *
+ * If read_xy() returns:
+ *      0 (up) - increment stylus_up_count;
+ *               if (stylus_up_count >= debounce_up)
+ *                  if (stylus_up_count == debounce_up) {
+ *                      state = TSTATE_UP
+ *                      report stylus up
+ *                  }
+ *               else
+ *                  state = TSTATE_GOING_UP
+ *                  ignore the touch info
+ *
+ *      1 (down) - increment stylus_down_count;
+ *               if (stylus_down_count >= debounce_down)
+ *                  if (state != TSTATE_DOWN {
+ *                      state = TSTATE_DOWN
+ *                      report stylus down
+ *                      stylus_up_count = 0;
+ *                  }
+ *                  process the touch point
+ *               else
+ *                  state = TSTATE_GOING_DOWN
+ *                  ignore the touch info
+ *
+ *      2 (going up)
+ *                  state = TSTATE_GOING_UP
+ *                  ignore the touch info
+ *
+ *      3 (going down)
+ *                  state = TSTATE_GOING_DOWN
+ *                  ignore the touch info
+ */
+
+
+static void process_down(int report_events) {
+    if (++t_dev->stylus_down_count >= t_dev->debounce_in_samples_down) {
+        if (t_dev->ts_state != TSTATE_DOWN)
+            t_dev->stylus_went_down = 1;
+        t_dev->ts_state = TSTATE_DOWN;
+        t_dev->stylus_up_count = 0;
+		if (report_events & REMASK_REPORT) /* say stylus down */
+		    input_report_key(t_dev->i_dev, BTN_TOUCH, 1);
+    }
+    else
+        t_dev->ts_state = TSTATE_GOING_DOWN;
+}
+
+static void process_up(int report_events) {
+    if (++t_dev->stylus_up_count >= t_dev->debounce_in_samples_up) {
+        if (t_dev->ts_state != TSTATE_UP)
+            t_dev->stylus_went_up = 1;
+        t_dev->ts_state = TSTATE_UP;
+        t_dev->stylus_down_count = 0;
+		if (report_events & REMASK_REPORT) /* say stylus up */
+		    input_report_key(t_dev->i_dev, BTN_TOUCH, 0);
+    }
+    else
+        t_dev->ts_state = TSTATE_GOING_UP;
+}
+
+/*
+ * void get_touch(struct work_struct work)
+ * read touchscreen, debounce stylus up/down, and report screen activity.
+ */
+
+static void get_touch(struct work_struct *work)
+{
+#ifdef DEVCRITpm
+//    int dbg_adc_delta = 5;// use this to reduce output
+    int dbg_adc_delta = -1; // use this to output info on all non-UP readings
+#endif
+	int report_events = t_dev->report_events;
+
+// 1Nov10rtd: Remove both of these overrides
+#if 0   // 17sep10pm    For now, force these to minimal debounce
+        //              Mr. Pencil (or something else) seems to change them.
+    t_dev->debounce_in_samples_down = 1;
+    t_dev->debounce_in_samples_up   = 1;
+#endif
+#if 0   // 20sep10pm    For now, force delay to default value
+        //              Mr. Pencil (or something else) seems to change it.
+	t_dev->delay_in_us	= TS_DELAY_IN_US;
+#endif
+	t_dev->touch_button = (report_events & REMASK_Y_FIRST) ? read_yx() 
+                                                           : read_xy();
+
+    switch (t_dev->ts_state) {
+    case TSTATE_UP:
+        if (t_dev->touch_button == RXY_DOWN)
+            process_down(report_events);
+        else if (t_dev->touch_button == RXY_IN_BETWEEN)
+            t_dev->ts_state = TSTATE_GOING_DOWN;
+        break;
+
+    case TSTATE_GOING_DOWN:
+        if (t_dev->touch_button == RXY_UP) {
+            t_dev->ts_state = TSTATE_UP;
+            t_dev->stylus_went_up = 1;
+        }
+        else if (t_dev->touch_button == RXY_DOWN)
+            process_down(report_events);
+        break;
+
+    case TSTATE_DOWN:
+        if (t_dev->touch_button == RXY_IN_BETWEEN)
+            t_dev->ts_state = TSTATE_GOING_UP;
+        else if (t_dev->touch_button == RXY_UP)
+            process_up(report_events);
+        break;
+
+    case TSTATE_GOING_UP:
+        if (t_dev->touch_button == RXY_DOWN)
+            t_dev->ts_state = TSTATE_DOWN;
+        else if (t_dev->touch_button == RXY_UP)
+            process_up(report_events);
+        break;
+    }
+    if (t_dev->ts_state == TSTATE_DOWN) {
+			    /* average the x1 and 2 readings; ditto with y1,2 */
+		t_dev->touch_x = (t_dev->adc_x + t_dev->adc_x2)/2;
+		t_dev->touch_y = (t_dev->adc_y + t_dev->adc_y2)/2;
+
+		
+			    /* use calibration data to convert from adc reading to 
+                 * screen position.
+                 */
+		t_dev->screen_x = (t_dev->a[1] * t_dev->touch_x +
+		                     t_dev->a[2] * t_dev->touch_y +
+			                 t_dev->a[0]) / t_dev->a[6];
+		t_dev->screen_y = (t_dev->a[4] * t_dev->touch_x +
+			                 t_dev->a[5] * t_dev->touch_y +
+			                 t_dev->a[3]) / t_dev->a[6];
+#ifdef DEVCRITpm
+        if (   t_dev->stylus_went_down
+            || (abs(t_dev->adc_x  - t_dev->prev_adc_x)  > dbg_adc_delta)
+            || (abs(t_dev->adc_x2 - t_dev->prev_adc_x2) > dbg_adc_delta)
+            || (abs(t_dev->adc_y  - t_dev->prev_adc_y)  > dbg_adc_delta)
+            || (abs(t_dev->adc_y2 - t_dev->prev_adc_y2) > dbg_adc_delta))
+        {
+#ifdef EXTRA_READINGS
+            int pre_x;
+            int pre_y;
+            int pre_screen_x;
+            int pre_screen_y;
+#ifdef READ_Z1Z2_PRESSURE
+            int pre_pressure;
+#endif
+
+		    pre_x = (t_dev->adc_x_pre[0] + t_dev->adc_x2_pre[0])/2;
+		    pre_y = (t_dev->adc_y_pre[0] + t_dev->adc_y2_pre[0])/2;
+			        /* use calibration data to convert from adc reading to 
+                     * screen position.
+                     */
+		    pre_screen_x = (t_dev->a[1] * pre_x +
+		                         t_dev->a[2] * pre_y +
+			                     t_dev->a[0]) / t_dev->a[6];
+		    pre_screen_y = (t_dev->a[4] * pre_x +
+			                     t_dev->a[5] * pre_y +
+			                     t_dev->a[3]) / t_dev->a[6];
+#ifdef READ_Z1Z2_PRESSURE
+            if (t_dev->adc_p2_pre[0] == 0) {
+                pre_pressure = 0;
+            }
+            else {
+                pre_pressure = pre_x * ((1000 * t_dev->adc_p1_pre[0])
+                                         /t_dev->adc_p2_pre[0] - 1000)
+                               / 1000;
+            }
+            dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d\n",
+                        t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[0], t_dev->adc_tnt2_pre[0], 
+				        t_dev->adc_x_pre[0], t_dev->adc_x2_pre[0], 
+                        t_dev->adc_y_pre[0], t_dev->adc_y2_pre[0],
+                        pre_pressure, pre_screen_x, pre_screen_y);
+#else
+            dev_crit( &t_dev->i_dev->dev,
+	                //dev_dbg( &t_dev->i_dev->dev,
+		            "%3d: tnt1 %d; tnt2 %d;"
+                    " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d\n",
+                    t_dev->delay_in_us,
+		            t_dev->adc_tnt1_pre[0], t_dev->adc_tnt2_pre[0], 
+				    t_dev->adc_x_pre[0], t_dev->adc_x2_pre[0], 
+                    t_dev->adc_y_pre[0], t_dev->adc_y2_pre[0],
+                    pre_screen_x, pre_screen_y);
+#endif  // READ_Z1Z2_PRESSURE
+
+		    pre_x = (t_dev->adc_x_pre[1] + t_dev->adc_x2_pre[1])/2;
+		    pre_y = (t_dev->adc_y_pre[1] + t_dev->adc_y2_pre[1])/2;
+			        /* use calibration data to convert from adc reading to 
+                     * screen position.
+                     */
+		    pre_screen_x = (t_dev->a[1] * pre_x +
+		                         t_dev->a[2] * pre_y +
+			                     t_dev->a[0]) / t_dev->a[6];
+		    pre_screen_y = (t_dev->a[4] * pre_x +
+			                     t_dev->a[5] * pre_y +
+			                     t_dev->a[3]) / t_dev->a[6];
+#ifdef READ_Z1Z2_PRESSURE
+            if (t_dev->adc_p2_pre[1] == 0) {
+                pre_pressure = 0;
+            }
+            else {
+                pre_pressure = pre_x * ((1000 * t_dev->adc_p1_pre[1])
+                                         /t_dev->adc_p2_pre[1] - 1000)
+                               / 1000;
+            }
+            dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d\n",
+                        2*t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[1], t_dev->adc_tnt2_pre[1], 
+				        t_dev->adc_x_pre[1], t_dev->adc_x2_pre[1], 
+                        t_dev->adc_y_pre[1], t_dev->adc_y2_pre[1],
+                        pre_pressure, pre_screen_x, pre_screen_y);
+#else
+            dev_crit( &t_dev->i_dev->dev,
+	                //dev_dbg( &t_dev->i_dev->dev,
+		            "%3d: tnt1 %d; tnt2 %d;"
+                    " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d\n",
+                    2*t_dev->delay_in_us,
+		            t_dev->adc_tnt1_pre[1], t_dev->adc_tnt2_pre[1], 
+				    t_dev->adc_x_pre[1], t_dev->adc_x2_pre[1], 
+                    t_dev->adc_y_pre[1], t_dev->adc_y2_pre[1],
+                    pre_screen_x, pre_screen_y);
+#endif  // READ_Z1Z2_PRESSURE
+
+#endif  // EXTRA_READINGS
+
+#ifdef READ_Z1Z2_PRESSURE
+            if (t_dev->adc_p2 == 0) {
+                t_dev->adc_pressure = 0;
+            }
+            else {
+		    t_dev->adc_pressure = t_dev->touch_x // adc_x 
+                                    * ((1000 * t_dev->adc_p1)/t_dev->adc_p2 - 1000)
+                                        / 1000;
+                //    t_dev->adc_pressure1 = t_dev->adc_pressure_normalizer
+                //                            - t_dev->adc_pressure1;
+            }
+            dev_crit( &t_dev->i_dev->dev,
+	                //dev_dbg( &t_dev->i_dev->dev,
+		            "ADC: tnt1 %d; tnt2 %d;"
+                    " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d\n",
+		            t_dev->adc_tnt1, t_dev->adc_tnt2, 
+				    t_dev->adc_x, t_dev->adc_x2, t_dev->adc_y, t_dev->adc_y2,
+                    t_dev->adc_pressure, t_dev->screen_x, t_dev->screen_y);
+#else
+            dev_crit( &t_dev->i_dev->dev,
+	                //dev_dbg( &t_dev->i_dev->dev,
+		            "ADC: tnt1 %d; tnt2 %d;"
+                    " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d\n",
+		            t_dev->adc_tnt1, t_dev->adc_tnt2, 
+				    t_dev->adc_x, t_dev->adc_x2, t_dev->adc_y, t_dev->adc_y2,
+                    t_dev->screen_x, t_dev->screen_y);
+#endif  // READ_Z1Z2_PRESSURE
+            t_dev->prev_adc_x  = t_dev->adc_x;
+            t_dev->prev_adc_x2 = t_dev->adc_x2;
+            t_dev->prev_adc_y  = t_dev->adc_y;
+            t_dev->prev_adc_y2 = t_dev->adc_y2;
+            t_dev->stylus_went_down = 0;
+        }
+#endif  // DEVCRITpm
+		if (report_events & REMASK_REPORT) {	/* report prior XY */
+		    input_report_abs(t_dev->i_dev, ABS_X, t_dev->screen_x);
+		    input_report_abs(t_dev->i_dev, ABS_Y, t_dev->screen_y);
+		}
+    }
+#ifdef DEVCRITpm
+    else {
+        int touch_x;
+        int touch_y;
+        int screen_x;
+        int screen_y;
+        int curState = t_dev->ts_state;
+
+        if (curState == TSTATE_UP) {
+            int adc_delta = 40;
+
+            if (   t_dev->stylus_went_up
+                || (t_dev->adc_tnt1 < 950)
+                || (t_dev->adc_tnt2 < 950)
+                || (abs(t_dev->adc_x  - t_dev->prev_adc_x)  > adc_delta)
+                || (abs(t_dev->adc_x2 - t_dev->prev_adc_x2) > adc_delta)
+                || (abs(t_dev->adc_y  - t_dev->prev_adc_y)  > adc_delta)
+                || (abs(t_dev->adc_y2 - t_dev->prev_adc_y2) > adc_delta))
+            {
+#ifdef EXTRA_READINGS
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d\n",
+                        t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[0], t_dev->adc_tnt2_pre[0], 
+				        t_dev->adc_x_pre[0], t_dev->adc_x2_pre[0], 
+                        t_dev->adc_y_pre[0], t_dev->adc_y2_pre[0]);
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d\n",
+                        2*t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[1], t_dev->adc_tnt2_pre[1], 
+				        t_dev->adc_x_pre[1], t_dev->adc_x2_pre[1], 
+                        t_dev->adc_y_pre[1], t_dev->adc_y2_pre[1]);
+#endif  // EXTRA_READINGS
+                dev_crit( &t_dev->i_dev->dev,
+                    //dev_dbg( &t_dev->i_dev->dev,
+           		        "ADC: tnt1 %d; tnt2 %d; x %d;x2 %d;y %d;y2 %d; UP\n",
+		                t_dev->adc_tnt1, t_dev->adc_tnt2, 
+		                t_dev->adc_x, t_dev->adc_x2, t_dev->adc_y, t_dev->adc_y2);
+                t_dev->prev_adc_x        = t_dev->adc_x;
+                t_dev->prev_adc_x2       = t_dev->adc_x2;
+                t_dev->prev_adc_y        = t_dev->adc_y;
+                t_dev->prev_adc_y2       = t_dev->adc_y2;
+                t_dev->stylus_went_up    = 0;
+            }
+        }
+        else { /* goingUp or goingDown */
+	        touch_x =(t_dev->adc_x + t_dev->adc_x2)/2;
+	        touch_y =(t_dev->adc_y + t_dev->adc_y2)/2;
+
+			        /* convert position */
+		    screen_x = (t_dev->a[1] * touch_x +
+				        t_dev->a[2] * touch_y + t_dev->a[0]) / t_dev->a[6];
+		    screen_y = (t_dev->a[4] * touch_x +
+				        t_dev->a[5] * touch_y + t_dev->a[3]) / t_dev->a[6];
+
+            if (   (abs(t_dev->adc_x  - t_dev->prev_adc_x)  > dbg_adc_delta)
+                || (abs(t_dev->adc_x2 - t_dev->prev_adc_x2) > dbg_adc_delta)
+                || (abs(t_dev->adc_y  - t_dev->prev_adc_y)  > dbg_adc_delta)
+                || (abs(t_dev->adc_y2 - t_dev->prev_adc_y2) > dbg_adc_delta))
+            {
+#ifdef EXTRA_READINGS
+                int pre_x;
+                int pre_y;
+                int pre_screen_x;
+                int pre_screen_y;
+#ifdef READ_Z1Z2_PRESSURE
+                int pre_pressure;
+#endif
+		        pre_x = (t_dev->adc_x_pre[0] + t_dev->adc_x2_pre[0])/2;
+		        pre_y = (t_dev->adc_y_pre[0] + t_dev->adc_y2_pre[0])/2;
+			            /* use calibration data to convert from adc reading to 
+                         * screen position.
+                         */
+		        pre_screen_x = (t_dev->a[1] * pre_x +
+		                             t_dev->a[2] * pre_y +
+			                         t_dev->a[0]) / t_dev->a[6];
+		        pre_screen_y = (t_dev->a[4] * pre_x +
+			                         t_dev->a[5] * pre_y +
+			                         t_dev->a[3]) / t_dev->a[6];
+#ifdef READ_Z1Z2_PRESSURE
+                if (t_dev->adc_p2_pre[0] == 0) {
+                    pre_pressure = 0;
+                }
+                else {
+                    pre_pressure = pre_x 
+                                    * ((1000 * t_dev->adc_p1_pre[0])
+                                        /t_dev->adc_p2_pre[0] - 1000)
+                                   / 1000;
+                }
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d\n",
+                        t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[0], t_dev->adc_tnt2_pre[0], 
+				        t_dev->adc_x_pre[0], t_dev->adc_x2_pre[0], 
+                        t_dev->adc_y_pre[0], t_dev->adc_y2_pre[0],
+                        pre_pressure, pre_screen_x, pre_screen_y);
+#else
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d\n",
+                        t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[0], t_dev->adc_tnt2_pre[0], 
+				        t_dev->adc_x_pre[0], t_dev->adc_x2_pre[0], 
+                        t_dev->adc_y_pre[0], t_dev->adc_y2_pre[0],
+                        pre_screen_x, pre_screen_y);
+#endif  // READ_Z1Z2_PRESSURE
+		        pre_x = (t_dev->adc_x_pre[1] + t_dev->adc_x2_pre[1])/2;
+		        pre_y = (t_dev->adc_y_pre[1] + t_dev->adc_y2_pre[1])/2;
+			            /* use calibration data to convert from adc reading to 
+                         * screen position.
+                         */
+		        pre_screen_x = (t_dev->a[1] * pre_x +
+		                             t_dev->a[2] * pre_y +
+			                         t_dev->a[0]) / t_dev->a[6];
+		        pre_screen_y = (t_dev->a[4] * pre_x +
+			                         t_dev->a[5] * pre_y +
+			                         t_dev->a[3]) / t_dev->a[6];
+#ifdef READ_Z1Z2_PRESSURE
+                if (t_dev->adc_p2_pre[1] == 0) {
+                    pre_pressure = 0;
+                }
+                else {
+                    pre_pressure = pre_x 
+                                    * ((1000 * t_dev->adc_p1_pre[1])
+                                        /t_dev->adc_p2_pre[1] - 1000)
+                                   / 1000;
+                }
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d\n",
+                        2*t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[1], t_dev->adc_tnt2_pre[1], 
+				        t_dev->adc_x_pre[1], t_dev->adc_x2_pre[1], 
+                        t_dev->adc_y_pre[1], t_dev->adc_y2_pre[1],
+                        pre_pressure, pre_screen_x, pre_screen_y);
+#else
+                dev_crit( &t_dev->i_dev->dev,
+	                    //dev_dbg( &t_dev->i_dev->dev,
+		                "%3d: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d\n",
+                        2*t_dev->delay_in_us,
+		                t_dev->adc_tnt1_pre[1], t_dev->adc_tnt2_pre[1], 
+				        t_dev->adc_x_pre[1], t_dev->adc_x2_pre[1], 
+                        t_dev->adc_y_pre[1], t_dev->adc_y2_pre[1],
+                        pre_screen_x, pre_screen_y);
+#endif  // READ_Z1Z2_PRESSURE
+#endif  // EXTRA_READINGS
+#ifdef READ_Z1Z2_PRESSURE
+                if (t_dev->adc_p2 == 0) {
+                    t_dev->adc_pressure = 0;
+                }
+                else {
+                    t_dev->adc_pressure = t_dev->adc_x 
+                                          * ((1000 * t_dev->adc_p1)
+                                              /t_dev->adc_p2 - 1000)
+                                          / 1000;
+                    //    t_dev->adc_pressure1 = t_dev->adc_pressure_normalizer
+                    //                            - t_dev->adc_pressure1;
+                }
+                dev_crit( &t_dev->i_dev->dev,
+           		        "ADC: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; P %d; X,Y %d, %d %s\n",
+	                    t_dev->adc_tnt1, t_dev->adc_tnt2, 
+	                    t_dev->adc_x, t_dev->adc_x2, 
+                        t_dev->adc_y, t_dev->adc_y2,
+                        t_dev->adc_pressure, screen_x, screen_y,
+                        curState == TSTATE_GOING_UP ? "GoingUp"
+                                                    : "GoingDown");
+#else
+                dev_crit( &t_dev->i_dev->dev,
+           		        "ADC: tnt1 %d; tnt2 %d;"
+                        " x %d;x2 %d;y %d;y2 %d; X,Y %d, %d %s\n",
+	                    t_dev->adc_tnt1, t_dev->adc_tnt2, 
+	                    t_dev->adc_x, t_dev->adc_x2, 
+                        t_dev->adc_y, t_dev->adc_y2,
+                        screen_x, screen_y,
+                        curState == TSTATE_GOING_UP ? "GoingUp"
+                                                    : "GoingDown");
+#endif  // READ_Z1Z2_PRESSURE
+                t_dev->prev_adc_x  = t_dev->adc_x;
+                t_dev->prev_adc_x2 = t_dev->adc_x2;
+                t_dev->prev_adc_y  = t_dev->adc_y;
+                t_dev->prev_adc_y2 = t_dev->adc_y2;
+            }
+        }
+    }
+#endif  // DEVCRITpm
+
+	if (report_events & REMASK_REPORT)	/* report sync */
+		input_sync(t_dev->i_dev);
+
+
+	// Rob Debug--No one was using REMASK_ADC_DBG, so I will.
+	// To enable, echo 3 or 9+100*N (instead of 1) >
+	// /sys/devices/platform/lf1000-touchscreen/report_events
+	if (report_events & (REMASK_ADC_DBG | REMASK_ADC_DBG_MODE))
+	{
+		static char *lut = "DV^U";
+		static int y=0;
+		int do_report = 0;
+		
+		if (report_events & REMASK_ADC_DBG_MODE)
+		{
+			// Report N times, decrementing the
+			// upper bits in report_events, until 0
+			y = report_events >> RESHIFT_COUNT;
+			if (y > 0)
+			{
+				y--;
+				t_dev->report_events = (y << RESHIFT_COUNT) |
+					(report_events & ((1<<RESHIFT_COUNT)-1));
+				do_report = 1;
+			}
+		}
+		else
+		{
+			// Report once every second
+			y=(y+1)%((HZ)/t_dev->sample_rate_in_jiffies);
+			if (y==0)
+				do_report = 1;
+			
+		}
+		if (do_report)
+		    printk (KERN_ALERT 
+/*                     "%c %4d TNT=%4d,%4d x=%4d,%4d y=%4d,%4d p=%4d,%4d P=%4d\n", */
+/* 			x[t_dev->ts_state], y, */
+/* 			t_dev->adc_tnt1, t_dev->adc_tnt2, */
+/* 			t_dev->adc_x, t_dev->adc_x2, */
+/* 			t_dev->adc_y, t_dev->adc_y2, */
+/* 			t_dev->adc_p1, t_dev->adc_p2, */
+/* 			t_dev->adc_pressure); */
+		      "x1=%d x2=%d y1=%d y2=%d p1=%d p2=%d tnt1=%d tnt2=%d S=%c X=%d Y=%d P=%d\n", 
+			t_dev->adc_x, t_dev->adc_x2,
+			t_dev->adc_y, t_dev->adc_y2,
+		       t_dev->adc_p1, t_dev->adc_p2, 
+		       t_dev->adc_tnt1, t_dev->adc_tnt2, 
+		       lut[t_dev->ts_state],
+		       t_dev->screen_x, t_dev->screen_y,
+		       t_dev->adc_pressure);
+
+	}
+}
+#else
+
+/*
+ * void get_touch(struct work_struct work)
+ * read touchscreen, debounce stylus up/down, and report screen activity.
+ */
+
+static void get_touch(struct work_struct *work)
+{
+	int report_events = t_dev->report_events; // keep, as value may change
+
+	t_dev->touch_button = (report_events & 1<<2) ? read_yx() : read_xy();
+
+	/* increment stylus up / down capture counters */
+	if (t_dev->touch_button) {
+		/* stylus down */
+		t_dev->stylus_down_count = t_dev->stylus_down_count + 1;
+		t_dev->stylus_down_count = min ( t_dev->stylus_down_count,
+	   t_dev->debounce_in_samples_down + t_dev->debounce_in_samples_up );
+	   
+	} else { /* stylus up */
+		t_dev->stylus_down_count = 0;
+		t_dev->queue_head = 0;		/* reset queue	*/
+		t_dev->queue_tail = 0;		/* reset queue	*/
+	}
+
+	if (0 == t_dev->stylus_down_count) {
+		if (report_events & 1<<0)	/* report stylus up */
+			input_report_key(t_dev->i_dev, BTN_TOUCH, 0);
+
+	/* stylus is down */
+	} else if (t_dev->debounce_in_samples_down < t_dev->stylus_down_count) {
+		/* save touchscreen data in queue */
+		t_dev->history_queue[t_dev->queue_head][0]=t_dev->adc_x;
+		t_dev->history_queue[t_dev->queue_head][1]=t_dev->adc_y;
+
+		t_dev->queue_head = t_dev->queue_head + 1;	/* inc */
+		if (t_dev->debounce_in_samples_up <= t_dev->queue_head)
+			t_dev->queue_head = 0;			/* wrap around*/
+
+		/* report stylus up or down */
+		if (t_dev->stylus_down_count < (t_dev->debounce_in_samples_down +
+					  t_dev->debounce_in_samples_up)) {
+			/* collect data, report stylus up */
+			if (report_events & 1<<0)	/* report stylus up */
+				input_report_key(t_dev->i_dev, BTN_TOUCH, 0);
+
+		} else { /* data valid, report stylus down */
+			if (report_events & 1<<0) /* say stylus down */
+			    input_report_key(t_dev->i_dev, BTN_TOUCH, 1);
+
+			/* get prior data */
+			t_dev->touch_x =
+				t_dev->history_queue[t_dev->queue_tail][0];
+			t_dev->touch_y =
+				t_dev->history_queue[t_dev->queue_tail][1];
+			t_dev->queue_tail = t_dev->queue_tail + 1; /* inc */
+			if (t_dev->debounce_in_samples_up <= t_dev->queue_tail)
+				t_dev->queue_tail = 0;
+		
+			/* convert position */
+			t_dev->screen_x =
+				(t_dev->a[1] * t_dev->touch_x +
+				 t_dev->a[2] * t_dev->touch_y +
+				 t_dev->a[0]) / t_dev->a[6];
+			t_dev->screen_y =
+				(t_dev->a[4] * t_dev->touch_x +
+				 t_dev->a[5] * t_dev->touch_y +
+				 t_dev->a[3]) / t_dev->a[6];
+
+			/* debugging data; showing output as data changes */
+			if ((report_events & 1<<1) &&
+		   		(t_dev->screen_x != t_dev->screen_last_x ||
+		    		 t_dev->screen_y != t_dev->screen_last_y)) {
+				dev_dbg(&t_dev->i_dev->dev,
+			"t_x:%d t_x2:%d t_y:%d t_y2:%d s_x:%d s_y:%d\n",
+					t_dev->adc_x, t_dev->adc_x2,
+					t_dev->adc_y, t_dev->adc_y2,
+					t_dev->screen_x, t_dev->screen_y);
+				t_dev->screen_last_x = t_dev->screen_x;
+				t_dev->screen_last_y = t_dev->screen_y;
+			}
+
+			if (report_events & 1<<0) {	/* report prior XY */
+				input_report_abs(
+					t_dev->i_dev, ABS_X, t_dev->screen_x);
+				input_report_abs(
+					t_dev->i_dev, ABS_Y, t_dev->screen_y);
+			}
+		}
+	}
+
+	if (report_events & 1<<0)	/* report sync */
+		input_sync(t_dev->i_dev);
+	
+}
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+
+
+void touchscreen_monitor_task(unsigned long data)
+{
+	struct touch *t_dev = (struct touch *)data;
+
+	if (!t_dev->stop_timer) {	// not stopping, reload timer
+		queue_work(t_dev->touchscreen_tasks, &t_dev->touchscreen_work);
+		t_dev->touchscreen_timer.expires += t_dev->sample_rate_in_jiffies;
+		t_dev->touchscreen_timer.function = touchscreen_monitor_task;
+		t_dev->touchscreen_timer.data = data;
+		add_timer(&t_dev->touchscreen_timer);
+	}
+}
+
+int touchscreen_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+                                          unsigned long arg)
+{
+	return 0;
+}
+	
+struct file_operations touchscreen_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = touchscreen_ioctl,
+};
+
+static int lf1000_ts_probe(struct platform_device *pdev)
+{
+	struct input_dev *i_dev;
+	int error;
+
+	i_dev = input_allocate_device();
+
+	if (!i_dev)  {
+		error = -ENOMEM;
+		goto err_free_devs;
+	}
+
+	i_dev->name		= "LF1000 touchscreen interface";
+	i_dev->phys		= "lf1000/touchscreen";
+	i_dev->id.bustype	= BUS_HOST;
+	i_dev->id.vendor	= 0x0001;
+	i_dev->id.product	= 0x0001;
+	i_dev->id.version	= 0x0001;
+	t_dev->i_dev		= i_dev;
+
+	/* initial X and Y clipping values */
+	t_dev->min_x		= TS_TOUCH_MIN_X;
+	t_dev->max_x		= TS_TOUCH_MAX_X;
+
+	t_dev->min_y		= TS_TOUCH_MIN_Y;
+	t_dev->max_y		= TS_TOUCH_MAX_Y;
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	t_dev->stylus_went_down  = 0;
+	t_dev->stylus_went_up    = 0;
+	t_dev->ts_state          = TSTATE_UP;
+
+	t_dev->adc_tnt1          = 1024;
+	t_dev->adc_tnt2          = 1024;
+	t_dev->adc_max_tnt_down  = MAX_TNT_DOWN;
+	t_dev->adc_min_tnt_up    = MIN_TNT_UP;
+	t_dev->adc_max_delta_tnt = MAX_DELTA_TNT;
+
+	t_dev->averaging	 = 1;
+#ifdef DEVCRITpm
+	t_dev->prev_adc_x	 = TS_TOUCH_MIN_X;
+	t_dev->prev_adc_x2	 = TS_TOUCH_MIN_X;
+	t_dev->prev_adc_y 	 = TS_TOUCH_MIN_Y;
+	t_dev->prev_adc_y2	 = TS_TOUCH_MIN_Y;
+#endif  // DEVCRITpm
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	t_dev->delay_in_us	= TS_DELAY_IN_US;
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	t_dev->tnt_delay_in_us	= TNT_DELAY_IN_US;
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	/* set GPIOs to max output current */
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_X1),
+		      lf1000_l2p_pin(TOUCHSCREEN_X1), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_Y1),
+		      lf1000_l2p_pin(TOUCHSCREEN_Y1), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_X2),
+		      lf1000_l2p_pin(TOUCHSCREEN_X2), GPIO_CURRENT_8MA);
+	gpio_set_cur(lf1000_l2p_port(TOUCHSCREEN_Y2),
+		      lf1000_l2p_pin(TOUCHSCREEN_Y2), GPIO_CURRENT_8MA);
+
+	/*
+ 	 * set first ADC channel hooked to touchscreen
+ 	 * Didj TS uses ADC[0] to ADC[3]
+ 	 * Leapster 3 uses ADC[4] to ADC[7]
+ 	 */
+
+	if (gpio_have_gpio_dev() || gpio_have_gpio_didj())
+		t_dev->first_adc = 0;
+	else if (gpio_have_gpio_acorn() || gpio_have_gpio_emerald())
+		t_dev->first_adc = 4;
+	else {
+		t_dev->first_adc = 4;
+		dev_dbg(&t_dev->i_dev->dev,
+				"%s.%s:%d unknown touchscreen interface",
+				__FILE__, __FUNCTION__, __LINE__);
+	}
+
+	/* event types that we support */	
+	i_dev->evbit[0]			   = BIT(EV_KEY) | BIT(EV_ABS);
+	i_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	/* initial screen coordination      min=[0]   max=[1]  fuzz=[2]  */
+	input_set_abs_params(i_dev, ABS_X, abs_x[0], abs_x[1], abs_x[2], 0);
+	input_set_abs_params(i_dev, ABS_Y, abs_y[0], abs_y[1], abs_y[2], 0);
+	platform_set_drvdata(pdev, t_dev);
+
+	error = input_register_device(i_dev);
+	if(error)
+		goto err_free_devs;
+
+	/* setup work queue */
+	t_dev->touchscreen_tasks = create_singlethread_workqueue("touchscreen"
+								 " tasks");
+	INIT_WORK(&t_dev->touchscreen_work, get_touch);
+
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	/* Do the initial configuration for reading tnt */
+	set_read_tnt();
+	udelay(t_dev->tnt_delay_in_us);	// Let the screen settle and charge up
+	//udelay(t_dev->delay_in_us);	// Let the screen settle and charge up
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+
+	/* grab initial touchscreen settings */
+	read_xy();
+
+	/* set default /etc/pointercal values */
+	t_dev->a[0] = TS_A0;
+	t_dev->a[1] = TS_A1;
+	t_dev->a[2] = TS_A2;
+	t_dev->a[3] = TS_A3;
+	t_dev->a[4] = TS_A4;
+	t_dev->a[5] = TS_A5;
+	t_dev->a[6] = TS_A6;
+
+	/* setup periodic sampling */
+	t_dev->sample_rate_in_jiffies   = TOUCHSCREEN_SAMPLING_J;
+	t_dev->debounce_in_samples_down = TS_DEBOUNCE_DOWN; /* min down */
+	t_dev->debounce_in_samples_up   = TS_DEBOUNCE_UP;  /* min up    */
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	t_dev->report_events     = REMASK_REPORT;   /* send input_event data */
+	t_dev->stylus_down_count = 0;	/* # consecutive stylus down samples */
+	t_dev->stylus_up_count   = 0;   /* "      "        "     up     "    */
+#else
+	t_dev->queue_head	 = 0;	/* write X,Y here	*/
+	t_dev->queue_tail	 = 0;	/* read X,Y here	*/
+	t_dev->report_events	 = 1;	/* send input_event data */
+	t_dev->stylus_down_count = 0;	/* # consecutive stylus down samples */
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	setup_timer(&t_dev->touchscreen_timer, touchscreen_monitor_task,
+		    (unsigned long)t_dev);
+	t_dev->touchscreen_timer.expires = get_jiffies_64()
+		                                + t_dev->sample_rate_in_jiffies;
+
+	add_timer(&t_dev->touchscreen_timer);	/*run*/
+
+	sysfs_create_group(&pdev->dev.kobj, &touchscreen_attr_group);
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	dev_info( &t_dev->i_dev->dev, "lf1000_ts: probe done ok\n");
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	return 0;
+
+err_free_devs:
+#ifdef CONFIG_TOUCHSCREEN_LF1000_PRESSURE
+	dev_crit( &t_dev->i_dev->dev, "lf1000_ts: probe error\n");
+#endif /*CONFIG_TOUCHSCREEN_LF1000_PRESSURE */
+	if (&t_dev->touchscreen_timer != NULL) {
+		t_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&t_dev->touchscreen_timer);
+	}
+	sysfs_remove_group(&pdev->dev.kobj, &touchscreen_attr_group);
+	input_free_device(t_dev->i_dev);
+	return error;
+}
+
+static int lf1000_ts_remove(struct platform_device *pdev)
+{
+	struct touch *t_dev = platform_get_drvdata(pdev);
+
+	if (&t_dev->touchscreen_timer != NULL) {
+		t_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&t_dev->touchscreen_timer);
+	}
+
+	destroy_workqueue(t_dev->touchscreen_tasks);
+
+	sysfs_remove_group(&pdev->dev.kobj, &touchscreen_attr_group);
+
+	input_unregister_device(t_dev->i_dev);
+	return 0;
+}
+
+/* fake release function to quiet "does not have a release()" warning */
+
+void lf1000_ts_release(struct device *dev)
+{
+}
+
+static struct platform_device lf1000_ts_device = {
+	.name		= "lf1000-touchscreen",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.release = lf1000_ts_release,
+	}
+};
+
+static struct platform_driver lf1000_ts_driver = {
+	.probe		= lf1000_ts_probe,
+	.remove		= lf1000_ts_remove,
+	.driver		= {
+		.name	= "lf1000-touchscreen",
+		.owner	= THIS_MODULE,
+		},
+};
+
+static int __init lf1000_ts_init(void)
+{
+	int ret;
+	ret = platform_device_register(&lf1000_ts_device);
+	ret = platform_driver_register(&lf1000_ts_driver);
+	return(ret);
+}
+
+static void __exit lf1000_ts_exit(void)
+{
+	platform_driver_unregister(&lf1000_ts_driver);
+	platform_device_unregister(&lf1000_ts_device);
+}
+
+module_init(lf1000_ts_init);
+module_exit(lf1000_ts_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("LF1000 Touchscreen driver");
+MODULE_LICENSE("GPL");
+
diff -ruaN linux-2.6.31/drivers/input/touchscreen/Makefile linux-2.6/drivers/input/touchscreen/Makefile
--- linux-2.6.31/drivers/input/touchscreen/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/input/touchscreen/Makefile	2011-01-04 15:07:20.000000000 -0800
@@ -40,3 +40,5 @@
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
+obj-$(CONFIG_TOUCHSCREEN_LF1000)	+= lf1000_ts.o
+obj-$(CONFIG_TOUCHSCREEN_LF1000)	+= lf1000_ts2.o
diff -ruaN linux-2.6.31/drivers/lf1000/didj-volume.c linux-2.6/drivers/lf1000/didj-volume.c
--- linux-2.6.31/drivers/lf1000/didj-volume.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/didj-volume.c	2012-11-19 14:49:51.000000000 -0800
@@ -0,0 +1,243 @@
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include <mach/gpio.h>
+#include <mach/adc.h>
+
+
+#define ADC_VARIATION	3
+#define VOLUME_SAMPLING_J		HZ / 10
+/*
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+define device
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+*/
+
+struct volume {
+	struct input_dev	*i_dev;
+
+	struct	timer_list        volume_timer;
+	struct	workqueue_struct *volume_tasks;
+	struct	work_struct       volume_work;	// check touchscreen
+
+	int	stop_timer;	          // non-zero = stop timer reload
+	int	sample_rate_in_jiffies;	  // sample rate
+	int adc_reading_last;
+	int adc_reading;
+	int adc_variation;
+
+} volume_dev;
+
+struct volume * v_dev = &volume_dev;
+
+
+/*
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+trigger event
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+*/
+static void get_volume(struct work_struct *work)
+{
+	int reading_diff;
+	v_dev->adc_reading = adc_GetReading(LF1000_ADC_VOLUMESENSE);
+	reading_diff = abs(v_dev->adc_reading - v_dev->adc_reading_last);
+
+	if (reading_diff > v_dev->adc_variation){
+		v_dev->adc_reading_last = v_dev->adc_reading;
+		input_report_abs(v_dev->i_dev, ABS_X, v_dev->adc_reading);
+		input_sync(v_dev->i_dev);
+	}
+}
+
+void volume_monitor_task(unsigned long data)
+{
+	struct volume *v_dev = (struct volume *)data;
+
+	if (!v_dev->stop_timer) {	// not stopping, reload timer
+		queue_work(v_dev->volume_tasks, &v_dev->volume_work);
+		v_dev->volume_timer.expires += v_dev->sample_rate_in_jiffies;
+		v_dev->volume_timer.function = volume_monitor_task;
+		v_dev->volume_timer.data = data;
+		add_timer(&v_dev->volume_timer);
+	}
+}
+
+
+/*
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+/sys/ attributes
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+*/
+
+static ssize_t show_name(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "Name is %s\n", __FILE__);
+}
+static DEVICE_ATTR(name, S_IRUSR|S_IRGRP|S_IROTH, show_name, NULL);
+
+
+static ssize_t show_adc_reading(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", adc_GetReading(LF1000_ADC_VOLUMESENSE));
+}
+static DEVICE_ATTR(adc_reading, S_IRUSR|S_IRGRP|S_IROTH, show_adc_reading, NULL);
+
+
+static ssize_t show_adc_reading_last(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", v_dev->adc_reading_last);
+}
+static DEVICE_ATTR(adc_reading_last, S_IRUSR|S_IRGRP|S_IROTH, show_adc_reading_last, NULL);
+
+
+static ssize_t show_adc_variation(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", v_dev->adc_variation);
+}
+static DEVICE_ATTR(adc_variation, S_IRUSR|S_IRGRP|S_IROTH, show_adc_variation, NULL);
+
+
+
+static struct attribute *volume_attributes[] = {
+	&dev_attr_name.attr,
+	&dev_attr_adc_reading.attr,
+	&dev_attr_adc_reading_last.attr,
+	&dev_attr_adc_variation.attr,
+	NULL
+};
+
+static struct attribute_group volume_attr_group = {
+	.attrs = volume_attributes
+};
+
+
+/*
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+module init exit probe etc
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+*/
+
+static int openlf_didj_vol_probe(struct platform_device *pdev)
+{
+	struct input_dev *i_dev;
+	int error;
+
+	i_dev = input_allocate_device();
+
+	if (!i_dev)  {
+		error = -ENOMEM;
+		goto err_free_devs;
+	}
+
+	i_dev->name		= "OpenLF Didj volume interface";
+	i_dev->phys		= "openlf/volume";
+	i_dev->id.bustype	= BUS_HOST;
+	i_dev->id.vendor	= 0x0001;
+	i_dev->id.product	= 0x0001;
+	i_dev->id.version	= 0x0001;
+	v_dev->i_dev		= i_dev;
+
+	v_dev->adc_reading_last = 0;
+	v_dev->adc_reading = adc_GetReading(LF1000_ADC_VOLUMESENSE);
+	v_dev->adc_variation = ADC_VARIATION;
+	v_dev->sample_rate_in_jiffies = VOLUME_SAMPLING_J;
+	sysfs_create_group(&pdev->dev.kobj, &volume_attr_group);
+
+	/* event types that we support */	
+	i_dev->evbit[0]			   = BIT(EV_ABS);
+
+	platform_set_drvdata(pdev, v_dev);
+	input_set_abs_params(i_dev, ABS_X, 0, 1023, 0, 0);
+	error = input_register_device(i_dev);
+	if(error)
+		goto err_free_devs;
+
+	v_dev->volume_tasks = create_singlethread_workqueue("didj-volume tasks");
+	INIT_WORK(&v_dev->volume_work, get_volume);
+
+	setup_timer(&v_dev->volume_timer, volume_monitor_task, (unsigned long)v_dev);
+	v_dev->volume_timer.expires = get_jiffies_64() + v_dev->sample_rate_in_jiffies;
+
+	add_timer(&v_dev->volume_timer);	/*run*/
+
+	dev_info( &v_dev->i_dev->dev, "openlf-didj-volume: probe done ok\n");
+
+	return 0;
+
+err_free_devs:
+	if (&v_dev->volume_timer != NULL) {
+		v_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&v_dev->volume_timer);
+	}
+	sysfs_remove_group(&pdev->dev.kobj, &volume_attr_group);
+	input_free_device(v_dev->i_dev);
+	return error;
+}
+
+
+static int openlf_didj_vol_remove(struct platform_device *pdev)
+{
+	struct volume *v_dev = platform_get_drvdata(pdev);
+
+	if (&v_dev->volume_timer != NULL) {
+		v_dev->stop_timer = 1;		// don't reload timer
+		del_timer_sync(&v_dev->volume_timer);
+	}
+
+	destroy_workqueue(v_dev->volume_tasks);
+
+	sysfs_remove_group(&pdev->dev.kobj, &volume_attr_group);
+
+	input_unregister_device(v_dev->i_dev);
+	return 0;
+}
+void openlf_didj_vol_release(struct device *dev)
+{
+}
+
+static struct platform_device openlf_didj_vol_device = {
+	.name			= "openlf-didj-volume",
+	.id				= -1,
+	.num_resources	= 0,
+	.dev			= {
+		.release = openlf_didj_vol_release,
+	}
+};
+
+static struct platform_driver openlf_didj_vol_driver = {
+	.probe		= openlf_didj_vol_probe,
+	.remove		= openlf_didj_vol_remove,
+	.driver		= {
+		.name	= "openlf-didj-volume",
+		.owner	= THIS_MODULE,
+		},
+};
+
+static int __init openlf_didj_vol_init(void)
+{
+	int ret;
+	ret = platform_device_register(&openlf_didj_vol_device);
+	ret = platform_driver_register(&openlf_didj_vol_driver);
+	return(ret);
+}
+
+static void __exit openlf_didj_vol_exit(void)
+{
+	platform_driver_unregister(&openlf_didj_vol_driver);
+	platform_device_unregister(&openlf_didj_vol_device);
+}
+
+module_init(openlf_didj_vol_init);
+module_exit(openlf_didj_vol_exit);
+
+MODULE_AUTHOR("Jason Pruitt");
+MODULE_DESCRIPTION("Monitor Didj Volume Slider");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/dpc.c linux-2.6/drivers/lf1000/dpc/dpc.c
--- linux-2.6.31/drivers/lf1000/dpc/dpc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/dpc.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,382 @@
+/* 
+ * drivers/lf1000/dpc/dpc.c
+ *
+ * LF1000 Display Controller (DPC) Driver 
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ * */
+
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#include "dpc.h"
+#include "ili9322.h" /* LCD controller */
+
+extern struct dpc_device dpc;
+
+int dpc_SetClock0(u8 source, u8 div, u8 delay, u8 out_inv, u8 out_en)
+{
+	void *base = dpc.mem;
+	u32 tmp;
+
+	if(source > 7 || delay > 6)
+		return -EINVAL;
+
+	tmp = ioread32(base+DPCCLKGEN0);
+	tmp &= ~((7<<CLKSRCSEL0)|(0x3F<<CLKDIV0)|(3<<OUTCLKDELAY0));
+
+	tmp |= (source<<CLKSRCSEL0);	/* clock source */
+	tmp |= ((0x3F&div)<<CLKDIV0);	/* clock divider */
+	tmp |= (delay<<OUTCLKDELAY0);	/* output clock delay */
+
+	out_inv ? BIT_SET(tmp,OUTCLKINV0) : BIT_CLR(tmp,OUTCLKINV0);
+	out_en ? BIT_SET(tmp,OUTCLKENB) : BIT_CLR(tmp,OUTCLKENB);
+
+	iowrite32(tmp,base+DPCCLKGEN0);
+	return 0;
+}
+
+void dpc_SetClockPClkMode(u8 mode)
+{
+	void *base = dpc.mem;
+	u32 tmp = ioread32(base+DPCCLKENB);
+
+	mode ? BIT_SET(tmp,_PCLKMODE) : BIT_CLR(tmp,_PCLKMODE);
+	iowrite32(tmp,base+DPCCLKENB);
+}
+
+int dpc_SetClock1( u8 source, u8 div, u8 delay, u8 out_inv )
+{
+	void *base = dpc.mem;
+	u32 tmp;
+
+	if( source > 7 || delay > 6 )
+		return -EINVAL;
+
+	tmp = ioread32(base+DPCCLKGEN1);
+	tmp &= ~((7<<CLKSRCSEL1)|(0x3F<<CLKDIV1)|(3<<OUTCLKDELAY1));
+
+	tmp |= (source<<CLKSRCSEL1);	/* clock source */
+	tmp |= ((0x3F&div)<<CLKDIV1);	/* clock divider */
+	tmp |= (delay<<OUTCLKDELAY1);	/* output clock delay */
+	out_inv ? BIT_SET(tmp,OUTCLKINV1) : BIT_CLR(tmp,OUTCLKINV1);
+
+	iowrite32(tmp,base+DPCCLKGEN1);
+	return 0;
+}
+
+void dpc_SetClockEnable(u8 en)
+{
+	void *base = dpc.mem;
+	u32 tmp = ioread32(base+DPCCLKENB);
+
+	en ? BIT_SET(tmp,_CLKGENENB) : BIT_CLR(tmp,_CLKGENENB);
+	iowrite32(tmp,base+DPCCLKENB);
+}
+
+void dpc_SetDPCEnable(void)
+{
+	void *base = dpc.mem;
+	u16 tmp = ioread16(base+DPCCTRL0);
+
+	BIT_SET(tmp,DPCENB);
+	BIT_CLR(tmp,_INTENB); /* disable VSYNC interrupt */
+	iowrite16(tmp,base+DPCCTRL0);
+}
+
+void dpc_SwapRB(u8 swap)
+{
+	u16 tmp = ioread16(dpc.mem+DPCCTRL1);
+
+	swap ? BIT_SET(tmp,SWAPRB) : BIT_CLR(tmp,SWAPRB);
+	iowrite16(tmp, dpc.mem+DPCCTRL1);
+}
+
+int dpc_SetMode(u8 format,
+		u8 interlace,
+		u8 invert_field,
+		u8 rgb_mode,
+		u8 swap_rb,
+		u8 ycorder,
+		u8 clip_yc,
+		u8 embedded_sync,
+		u8 clock)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	if(format >= 14 || ycorder > 3 || clock > 3)
+		return -EINVAL;
+
+	/* DPC Control 0 Register */
+	
+	tmp = ioread16(base+DPCCTRL0);
+	BIT_CLR(tmp,_INTPEND);
+
+	/* set flags */
+	interlace ? BIT_SET(tmp,SCANMODE) : BIT_CLR(tmp,SCANMODE);
+	invert_field ? BIT_SET(tmp,POLFIELD) : BIT_CLR(tmp,POLFIELD);
+	rgb_mode ? BIT_SET(tmp,RGBMODE) : BIT_CLR(tmp,RGBMODE);
+	embedded_sync ? BIT_SET(tmp,SEAVENB) : BIT_CLR(tmp,SEAVENB);
+
+	iowrite16(tmp,base+DPCCTRL0);
+
+	/* DPC Control 1 Register */
+
+	tmp = ioread16(base+DPCCTRL1);
+	tmp &= ~(0xAFFF);  /* clear all fields except reserved bits */ 
+	tmp |= ((ycorder<<YCORDER)|(format<<FORMAT));
+	clip_yc ?  BIT_CLR(tmp,YCRANGE) : BIT_SET(tmp,YCRANGE);
+	swap_rb ? BIT_SET(tmp,SWAPRB) : BIT_CLR(tmp,SWAPRB);
+	iowrite16(tmp,base+DPCCTRL1);
+
+	/* DPC Control 2 Register */
+
+	tmp = ioread16(base+DPCCTRL2);
+	tmp &= ~(3<<PADCLKSEL);
+	tmp |= (clock<<PADCLKSEL);
+	iowrite16(tmp,base+DPCCTRL2);
+
+	return 0;
+}
+
+int dpc_SetHSync(u32 avwidth, u32 hsw, u32 hfp, u32 hbp, u8 inv_hsync)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	if( avwidth + hfp + hsw + hbp > 65536 || hsw == 0 )
+		return -EINVAL;
+
+	iowrite16((u16)(hsw+hbp+hfp+avwidth-1),base+DPCHTOTAL);
+	iowrite16((u16)(hsw-1),base+DPCHSWIDTH);
+	iowrite16((u16)(hsw+hbp-1),base+DPCHASTART);
+	iowrite16((u16)(hsw+hbp+avwidth-1),base+DPCHAEND);
+
+	tmp = ioread16(base+DPCCTRL0);
+	BIT_CLR(tmp,_INTPEND);
+	if(inv_hsync)
+		BIT_SET(tmp,POLHSYNC);
+	else
+		BIT_CLR(tmp,POLHSYNC);
+	iowrite16(tmp,base+DPCCTRL0);
+
+	return 0;
+}
+
+int dpc_SetVSync(u32 avheight, u32 vsw, u32 vfp, u32 vbp, u8 inv_vsync,
+		u32 eavheight, u32 evsw, u32 evfp, u32 evbp)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	if( avheight+vfp+vsw+vbp > 65536 || avheight+evfp+evsw+evbp > 65536 ||
+		vsw == 0 || evsw == 0 )
+		return -EINVAL;
+
+	iowrite16((u16)(vsw+vbp+avheight+vfp-1),base+DPCVTOTAL);
+	iowrite16((u16)(vsw-1),base+DPCVSWIDTH);
+	iowrite16((u16)(vsw+vbp-1),base+DPCVASTART);
+	iowrite16((u16)(vsw+vbp+avheight-1),base+DPCVAEND);
+
+	iowrite16((u16)(evsw+evbp+eavheight+evfp-1),base+DPCEVTOTAL);
+	iowrite16((u16)(evsw-1),base+DPCEVSWIDTH);
+	iowrite16((u16)(evsw+evbp-1),base+DPCEVASTART);
+	iowrite16((u16)(evsw+evbp+eavheight-1),base+DPCEVAEND);
+
+	tmp = ioread16(base+DPCCTRL0);
+	BIT_CLR(tmp,_INTPEND);
+	inv_vsync ? BIT_SET(tmp,POLVSYNC) : BIT_CLR(tmp,POLVSYNC);
+	iowrite16(tmp,base+DPCCTRL0);
+	return 0;
+}
+
+void dpc_SetVSyncOffset(u16 vss_off, u16 vse_off, u16 evss_off, u16 evse_off)
+{
+	iowrite16(vse_off,dpc.mem+DPCVSEOFFSET);
+	iowrite16(vss_off,dpc.mem+DPCVSSOFFSET);
+	iowrite16(evse_off,dpc.mem+DPCEVSEOFFSET);
+	iowrite16(evss_off,dpc.mem+DPCEVSSOFFSET);
+}
+
+int dpc_SetDelay(u8 rgb, u8 hs, u8 vs, u8 de, u8 lp, u8 sp, u8 rev)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	if(rgb>=16 || hs>=16 || vs>=16 || de>=16 || lp>=16 || sp>=16 || rev>=16 )
+		return -EINVAL;
+
+	tmp = ioread16(base+DPCCTRL0);
+	tmp &= ~((1<<_INTPEND)|(0xF<<DELAYRGB));
+	tmp |= (rgb<<DELAYRGB);
+	iowrite16(tmp,base+DPCCTRL0);
+
+	iowrite16((u16)((de<<DELAYDE)|(vs<<DELAYVS)|(hs<<DELAYHS)),
+				base+DPCDELAY0);
+#ifdef CPU_MF2530F
+	iowrite16((u16)((rev<<DELAYREV)|(sp<<DELAYSP)|(lp<<DELAYLP)),
+				base+DPCDELAY1);
+#endif
+	return 0;
+}
+
+int dpc_SetDither(u8 r, u8 g, u8 b)
+{
+	u16 tmp;
+
+	if(r >= 4 || g >= 4 || b >= 4)
+		return -EINVAL;
+
+	tmp = ioread16(dpc.mem+DPCCTRL1);
+	tmp &= ~(0x3F);
+	tmp |= ((r<<RDITHER)|(g<<GDITHER)|(b<<BDITHER));
+	iowrite16(tmp,dpc.mem+DPCCTRL1);
+	return 0;
+}
+
+void dpc_SetIntEnb(u8 en)
+{
+	void *base = dpc.mem;
+	u16 tmp = ioread16(base+DPCCTRL0);
+
+	if(en)
+		BIT_SET(tmp,_INTENB);
+	else {
+		BIT_CLR(tmp,_INTENB);
+		BIT_CLR(tmp,_INTPEND);
+	}
+	iowrite16(tmp,base+DPCCTRL0);
+}
+
+void dpc_ResetEncoder(void)
+{
+	/* encoder reset sequence */
+	dpc_SetEncoderEnable(1);
+	udelay(100);
+	dpc_SetClockEnable(1);
+	udelay(100);
+	dpc_SetEncoderEnable(0);
+	udelay(100);
+	dpc_SetClockEnable(0);
+	udelay(100);
+	dpc_SetEncoderEnable(1);
+}
+
+void dpc_SetEncoderEnable(u8 en)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* encoder enable */
+	tmp = ioread16(base+DPCCTRL0);
+	BIT_CLR(tmp,_INTPEND);
+	en ? BIT_SET(tmp,DACENB) : BIT_CLR(tmp,DACENB); 
+	BIT_SET(tmp,ENCENB);
+	iowrite16(tmp,base+DPCCTRL0);
+
+	/* encoder timing config */
+	iowrite16(0x0007,base+VENCICNTL);
+}
+
+void dpc_SetEncoderPowerDown(u8 en)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* power down mode */
+	tmp = ioread16(base+VENCCTRLA);
+	en ? BIT_SET(tmp,7) : BIT_CLR(tmp,7);
+	iowrite16(tmp,base+VENCCTRLA);
+
+	/* DAC output enable */
+	tmp = (en) ? 0x0000 : 0x0001;
+	iowrite16(tmp,base+VENCDACSEL);
+}
+
+void dpc_SetEncoderMode(u8 fmt, u8 ped)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* NTSC mode with pedestal */
+	tmp = ioread16(base+VENCCTRLA);
+	BIT_SET(tmp,6);
+	BIT_CLR(tmp,5);
+	BIT_CLR(tmp,4);
+	BIT_SET(tmp,3);
+	iowrite16(tmp,base+VENCCTRLA);
+}
+
+void dpc_SetEncoderFSCAdjust(u16 fsc)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* color burst frequency adjust */
+	tmp = fsc;
+	iowrite16(tmp >> 8,base+VENCFSCADJH);
+	iowrite16(tmp & 0xFF, base+VENCFSCADJL);
+	
+}
+
+void dpc_SetEncoderBandwidth(u16 ybw, u16 cbw)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* luma/chroma bandwidth */
+	tmp = (cbw << 2) | ybw;
+	iowrite16(tmp,base+VENCCTRLB);
+}
+
+void dpc_SetEncoderColor(u16 sch, u16 hue, u16 sat, u16 cnt, u16 brt)
+{
+	void *base = dpc.mem;
+
+	/* color phase, hue, saturation, contrast, brightness */
+	iowrite16(sch,base+VENCSCH);
+	iowrite16(hue,base+VENCHUE);
+	iowrite16(sat,base+VENCSAT);
+	iowrite16(cnt,base+VENCCRT);
+	iowrite16(brt,base+VENCBRT);
+}
+
+void dpc_SetEncoderTiming(u16 hs, u16 he, u16 vs, u16 ve)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* horizontal start/end, vertical start/end */
+	tmp = ((he-1) >> 8) & 0x7;
+	iowrite16(tmp,base+VENCHSVS0);
+	tmp = hs-1;
+	iowrite16(tmp,base+VENCHSOS);
+	tmp = he-1;
+	iowrite16(tmp,base+VENCHSOE);
+	tmp = vs;
+	iowrite16(tmp,base+VENCVSOS);
+	tmp = ve;
+	iowrite16(tmp,base+VENCVSOE);
+}
+
+void dpc_SetEncoderUpscaler(u16 src, u16 dst)
+{
+	void *base = dpc.mem;
+	u16 tmp;
+
+	/* horizontal upscaler */
+	tmp = src-1;
+	iowrite16(tmp,base+DPUPSCALECON2);
+	tmp = ((src-1) * (1 << 11)) / (dst-1);
+	iowrite16(tmp >> 8,base+DPUPSCALECON1);
+	iowrite16(((tmp & 0xFF) << 8) | 1,base+DPUPSCALECON0);
+}
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/dpc_config.h linux-2.6/drivers/lf1000/dpc/dpc_config.h
--- linux-2.6.31/drivers/lf1000/dpc/dpc_config.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/dpc_config.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,81 @@
+/* LF1000 Display Controller (DPC) Driver 
+ *
+ * dpc_config.h -- Device default configuration.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef DPC_CONFIG_H
+#define DPC_CONFIG_H
+
+#include <mach/gpio.h>
+
+/* Dual display support for TV output on 2nd DPC */
+#ifdef  CONFIG_LF1000_DPC_DUAL_DISPLAY
+#define DUAL_DISPLAY			1
+#endif
+
+#if defined(CONFIG_MACH_ME_LF1000) || defined(CONFIG_MACH_LF_LF1000)
+#define LCD_RESET_PORT			GPIO_PORT_ALV
+#define LCD_RESET_PIN			5
+#define LCD_nRESET_LEVEL		1
+#else
+#warning "LCD Reset Pin not set for this platform."
+#define LCD_RESET_PORT			GPIO_PORT_B
+#define LCD_RESET_PIN			31
+#define LCD_nRESET_LEVEL		1
+#endif
+
+#define DISPLAY_VID_PRI_OUTORDER	VID_ORDER_CbYCrY
+#define DISPLAY_VID_PRI_OUTPUT_FORMAT	VID_FORMAT_RGB888
+
+/* backlight settings */
+#if defined CONFIG_MACH_LF_LF1000 || defined CONFIG_MACH_ME_LF1000
+#define LCD_BACKLIGHT			PWM_CHAN1
+#else
+#define LCD_BACKLIGHT			PWM_CHAN0
+#endif
+#define LCD_BACKLIGHT_PERIOD		512
+
+/* timing and pin map */
+#define NUM_PVD_PINS 24
+#define DISPLAY_VID_PRI_VCLK_SOURCE		VID_VCLK_SOURCE_PLL1
+#define DISPLAY_VID_PRI_VCLK2_SOURCE		VID_VCLK_SOURCE_VCLK2
+#define DISPLAY_VID_PRI_SWAP_RGB		0
+#define DPC_DESIRED_CLOCK_HZ			6400000
+#define DISPLAY_VID_PRI_PAD_VCLK		VID_PADVCLK_nVCLK2
+#define DISPLAY_VID_PRI_VCLK_DELAY		0
+#define DISPLAY_VID_PRI_VCLK_INV		1
+#define DISPLAY_VID_PRI_VCLK_OUT_ENB		0
+#define DISPLAY_VID_PRI_VCLK2_DIV		0
+#define DISPLAY_VID_PRI_MAX_X_RESOLUTION	320
+#define DISPLAY_VID_PRI_MAX_Y_RESOLUTION	240
+#define DISPLAY_VID_PRI_HSYNC_SWIDTH		2
+#define DISPLAY_VID_PRI_HSYNC_FRONT_PORCH	50
+#define DISPLAY_VID_PRI_HSYNC_BACK_PORCH	36
+#define DISPLAY_VID_PRI_HSYNC_ACTIVEHIGH	0
+#define DISPLAY_VID_PRI_VSYNC_SWIDTH		1
+#define DISPLAY_VID_PRI_VSYNC_FRONT_PORCH	4
+#define DISPLAY_VID_PRI_VSYNC_BACK_PORCH	17
+#define DISPLAY_VID_PRI_VSYNC_ACTIVEHIGH	0
+
+
+/* PVD Pin/Port Map */
+static char pvd_pins[NUM_PVD_PINS] = {
+	GPIO_PIN0, GPIO_PIN1, GPIO_PIN2, GPIO_PIN3, GPIO_PIN4, GPIO_PIN5,
+	GPIO_PIN6, GPIO_PIN7, GPIO_PIN16, GPIO_PIN17, GPIO_PIN18, GPIO_PIN19,
+	GPIO_PIN20, GPIO_PIN21, GPIO_PIN22, GPIO_PIN23, GPIO_PIN24,
+	GPIO_PIN25, GPIO_PIN26, GPIO_PIN27, GPIO_PIN28, GPIO_PIN29, GPIO_PIN30,
+	GPIO_PIN31
+};
+
+static char pvd_ports[NUM_PVD_PINS] = {
+	GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A,
+	GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_A, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B,
+	GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, GPIO_PORT_B, 
+};
+
+
+#endif
+
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/dpc.h linux-2.6/drivers/lf1000/dpc/dpc.h
--- linux-2.6.31/drivers/lf1000/dpc/dpc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/dpc.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,143 @@
+/* 
+ * drivers/lf1000/dpc/dpc.h
+ *
+ * LF1000 Display Controller (DPC) Driver 
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef DPC_H
+#define DPC_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spi/spi.h>
+#include <asm/io.h>
+
+#include <mach/common.h>
+#include "dpc_hal.h"
+
+/* module-related definitions */
+
+#define DPC_MAJOR	252
+
+/* backlight levels, use virtual range [-128,127] */
+#define	BACKLIGHT_LEVEL_0	( -46 )
+#define	BACKLIGHT_LEVEL_1	( -11 )
+#define	BACKLIGHT_LEVEL_2	(  31 )
+#define	BACKLIGHT_LEVEL_3	(  72 )
+#define BACKLIGHT_LOGICAL_MIN	0
+#define BACKLIGHT_LOGICAL_DIM	1	// dim backlight
+#define BACKLIGHT_LOGICAL_MAX	3	// 4 backlight values total
+
+/* device-related definitions */
+
+struct dpc_device {
+	void *mem;
+	struct cdev *cdev;
+	dev_t dev;
+	int major;
+	struct proc_dir_entry *proc;
+	u16 backlight;
+	int backlight_logical;
+	int backlight_next;
+	u16 backlight_threshold;
+	struct platform_device *pdev;
+};
+
+/* hardware-related definitions */
+
+/* PCLK modes */
+enum
+{
+	PCLKMODE_ONLYWHENCPUACCESS,	/* Operate When CPU Acces */
+	PCLKMODE_ALWAYS,		/* Operate Always */
+};
+
+/* clock sources */
+enum {
+	VID_VCLK_SOURCE_PLL0	= 0,
+	VID_VCLK_SOURCE_PLL1	= 1,
+#ifdef CPU_MF2530F
+	VID_VCLK_SOURCE_PLL2	= 2,
+	VID_VCLK_SOURCE_PSVCLK	= 3,
+	VID_VCLK_SOURCE_nPSVCLK	= 4,
+#endif
+	VID_VCLK_SOURCE_XTI	= 5,
+#ifdef CPU_MF2530F
+	VID_VCLK_SOURCE_AVCLK	= 6,
+#endif
+	VID_VCLK_SOURCE_VCLK2	= 7,	/* clock generator 0 */
+};
+
+/* yc orders */
+enum {
+	VID_ORDER_CbYCrY	= 0,
+	VID_ORDER_CrYCbY	= 1,
+	VID_ORDER_YCbYCr	= 2,
+	VID_ORDER_YCrYCb	= 3
+};
+
+/* pad clocks */
+enum {
+	VID_PADVCLK_VCLK	= 0,
+	VID_PADVCLK_nVCLK	= 1,
+	VID_PADVCLK_VCLK2	= 2,
+	VID_PADVCLK_nVCLK2	= 3
+};
+
+/* RGB dithering mode. */
+enum DITHER
+{
+	DITHER_BYPASS		= 0,  /* bypass mode. */
+	DITHER_5BIT		= 2,  /* 8 bit -> 5 bit mode. */
+	DITHER_6BIT		= 3,  /* 8 bit -> 6 bit mode. */
+};
+
+/* video formats */
+enum {
+	VID_FORMAT_RGB555	= 0,
+	VID_FORMAT_RGB565	= 1,
+	VID_FORMAT_RGB666	= 2,
+	VID_FORMAT_RGB888	= 3,
+	VID_FORMAT_MRGB555A	= 4,
+	VID_FORMAT_MRGB555B	= 5,
+	VID_FORMAT_MRGB565	= 6,
+	VID_FORMAT_MRGB666	= 7,
+	VID_FORMAT_MRGB888A	= 8,
+	VID_FORMAT_MRGB888B	= 9,
+	VID_FORMAT_CCIR656	= 10,
+	VID_FORMAT_CCIR601A	= 12,
+	VID_FORMAT_CCIR601B	= 13,
+};
+
+int dpc_SetClock0(u8 source, u8 div, u8 delay, u8 out_inv, u8 out_en);
+int dpc_SetClock1(u8 source, u8 div, u8 delay, u8 out_inv);
+void dpc_SetClockPClkMode(u8 mode);
+void dpc_SetClockEnable(u8 en);
+void dpc_SetDPCEnable(void);
+int dpc_SetMode(u8 format, u8 interlace, u8 invert_field, u8 rgb_mode,
+		u8 swap_rb, u8 ycorder, u8 clip_yc, u8 embedded_sync, u8 clock);
+int dpc_SetHSync(u32 avwidth, u32 hsw, u32 hfp, u32 hbp, u8 inv_hsync );
+int dpc_SetVSync(u32 avheight, u32 vsw, u32 vfp, u32 vbp, u8 inv_vsync,
+		 u32 eavheight, u32 evsw, u32 evfp, u32 evbp );
+void dpc_SetVSyncOffset(u16 vss_off, u16 vse_off, u16 evss_off, u16 evse_off);
+int dpc_SetDelay(u8 rgb, u8 hs, u8 vs, u8 de, u8 lp, u8 sp, u8 rev);
+int dpc_SetDither(u8 r, u8 g, u8 b);
+void dpc_SetIntEnb(u8 en);
+void dpc_SwapRB(u8 swap);
+void dpc_SetContrast(struct spi_device *spi, u8 contrast);
+void dpc_SetBrightness(struct spi_device *spi, u8 brightness);
+int dpc_GetContrast(struct spi_device *spi);
+int dpc_GetBrightness(struct spi_device *spi);
+void dpc_ResetEncoder(void);
+void dpc_SetEncoderEnable(u8 en);
+void dpc_SetEncoderPowerDown(u8 en);
+void dpc_SetEncoderMode(u8 fmt, u8 ped);
+void dpc_SetEncoderFSCAdjust(u16 fsc);
+void dpc_SetEncoderBandwidth(u16 ybw, u16 cbw);
+void dpc_SetEncoderColor(u16 sch, u16 hue, u16 sat, u16 cnt, u16 brt);
+void dpc_SetEncoderTiming(u16 hs, u16 he, u16 vs, u16 ve);
+void dpc_SetEncoderUpscaler(u16 src, u16 dst);
+
+#endif
+
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/dpc_hal.h linux-2.6/drivers/lf1000/dpc/dpc_hal.h
--- linux-2.6.31/drivers/lf1000/dpc/dpc_hal.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/dpc_hal.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,144 @@
+/* LF1000 Display Controller (DPC) Driver 
+ *
+ * dpc_hal.h -- DPC hardware abstraction.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef DHC_HAL_H
+#define DHC_HAL_H
+
+#include <mach/platform.h>
+
+/* DPC registers as offsets from DPC_BASE */
+
+#define DPCHTOTAL		0x07C
+#define DPCHSWIDTH		0x07E
+#define DPCHASTART		0x080
+#define DPCHAEND		0x082
+#define DPCVTOTAL		0x084
+#define DPCVSWIDTH		0x086
+#define DPCVASTART		0x088
+#define DPCVAEND		0x08A
+#define DPCCTRL0		0x08C
+#define DPCCTRL1		0x08E
+#define DPCEVTOTAL		0x090
+#define DPCEVSWIDTH		0x092
+#define DPCEVASTART		0x094
+#define DPCEVAEND		0x096
+#define DPCCTRL2		0x098
+#ifdef CPU_LF1000
+#define DPCVSEOFFSET		0x09A
+#define DPCVSSOFFSET		0x09C
+#define DPCEVSEOFFSET		0x09E
+#define DPCEVSSOFFSET		0x0A0
+#define DPCDELAY0		0x0A2
+#define DPRNUMGENCON0		0x0AA
+#define DPRNUMGENCON1		0x0AC
+#define DPRNUMGENCON2		0x0AC
+#define DPCFDTADDR		0x0B0
+#define DPCFRDITHERVALUE	0x0B2
+#define DPCFGFITHERVALUE	0x0B4
+#define DPCFBDITHERVALUE	0x0B6
+#elif defined CPU_MF2530F
+#define DPCVSEOFFSET		0x09E
+#define DPCVSSOFFSET		0x0A0
+#define DPCEVSEOFFSET		0x0A2
+#define DPCEVSSOFFSET		0x0A4
+#define DPCDELAY0		0x0A6
+#define DPCDELAY1		0x0A8
+#endif
+#define DPCCLKENB		0x1C0
+#define DPCCLKGEN0		0x1C4
+#define DPCCLKGEN1		0x1C8
+
+/* DPC registers for internal video encoder as offsets from DPC_BASE */
+
+#define VENCCTRLA		0x002 
+#define VENCCTRLB		0x004 
+#define VENCSCH 		0x008 
+#define VENCHUE 		0x00A 
+#define VENCSAT 		0x00C 
+#define VENCCRT 		0x00E 
+#define VENCBRT 		0x010 
+#define VENCFSCADJH		0x012 
+#define VENCFSCADJL		0x014 
+#define VENCDACSEL		0x020 
+#define VENCICNTL		0x040 
+#define VENCHSVS0		0x048 
+#define VENCHSOS		0x04A 
+#define VENCHSOE		0x04C 
+#define VENCVSOS		0x04E 
+#define VENCVSOE		0x050  
+#define DPUPSCALECON0	0x0A4
+#define DPUPSCALECON1	0x0A6
+#define DPUPSCALECON2	0x0A8
+
+/* DPC CONTROL 0 REGISTER (DPCCTRL0) */
+#define DPCENB		15
+#define ENCENB		14
+#define DACENB		13
+#define RGBMODE		12
+#define _INTENB		11
+#define _INTPEND	10
+#define SCANMODE	9
+#define SEAVENB		8
+#define DELAYRGB	4
+#ifdef CPU_MF2530F
+#define POLREV		3
+#endif
+#define POLFIELD	2
+#define POLVSYNC	1
+#define POLHSYNC	0
+
+/* DPC CONTROL 1 REGISTER (DPCCTRL1) */
+#define SWAPRB		15
+#define YCRANGE		13
+#define FORMAT		8
+#define YCORDER		6
+#define BDITHER		4
+#define GDITHER		2
+#define RDITHER		0
+
+/* DPC CONTROL 2 REGISTER (DPCCTRL2) */
+#ifdef CPU_LF1000
+#define CPCYC		12	/* STN LCD CP (Shift Clock) Cycle, in VCLKs */
+#define STNLCDBITWIDTH	9	/* STN LCD bus bit width */
+#define LCDTYPE		8	/* 0: TFT or Video Encoder, 1: STN LCD */
+#else
+#define LBR		13
+#define PSENB		12
+#define SPRENB		11
+#define SPLENB		10
+#define LPENB		8
+#endif
+#define PADCLKSEL	0
+
+/* DPC CLOCK GENERATION ENABLE REGISTER (DPCCLKENB) */
+#define _PCLKMODE	3
+#define _CLKGENENB	2
+
+/* DPC CLOCK GENERATION CONTROL 0 REGISTER (DPCCLKGEN0) */
+#define OUTCLKENB	15
+#define OUTCLKDELAY0	12
+#define CLKDIV0		4
+#define CLKSRCSEL0	1
+#define OUTCLKINV0	0
+
+/* DPC CLOCK GENERATION CONTROL 1 REGISTER (DPCCLKGEN1) */
+#define OUTCLKDELAY1	12
+#define CLKDIV1		4
+#define CLKSRCSEL1	1
+#define OUTCLKINV1	0
+
+/* DPC SYNC DELAY 0 REGISTER (DPCDELAY0) */
+#define DELAYDE		8
+#define DELAYVS		4
+#define DELAYHS		0
+
+/* DPC SYNC DELAY 1 REGISTER (DPCDELAY1) */
+#define DELAYREV	8
+#define DELAYSP		4
+#define DELAYLP		0
+
+#endif
+
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/ili9322.c linux-2.6/drivers/lf1000/dpc/ili9322.c
--- linux-2.6.31/drivers/lf1000/dpc/ili9322.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/ili9322.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,287 @@
+/*
+ * drivers/lf1000/dpc/ili9322.c
+ *
+ * SPI slave driver for ILI9322 LCD chip.
+ *
+ * Copyright 2009 LeapFrog Enterprises Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include "ili9322.h"
+
+/*
+ * Register I/O primitive.
+ */
+static int spi_reg(struct spi_device *spi, u16 op)
+{
+	int ret;
+	struct spi_message m;
+	struct spi_transfer t;
+
+	union {
+		u16 txb;
+		u8 txbuf[2];
+	} tx;
+	union {
+		u16 rxb;
+		u8 rxbuf[2];
+	} rx;
+
+	tx.txb = op;
+
+	memset(&t, 0, sizeof(t));
+	t.tx_buf = &tx;
+	t.rx_buf = &rx;
+	t.len = 2;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	ret  = spi_sync(spi, &m);
+
+	if( ret < 0 )
+	{
+		return ret;
+	}
+
+	return rx.rxb;
+}
+
+/*
+ * Attribute helpers - public because of DPC ioctls
+ */
+void dpc_SetContrast(struct spi_device *spi, u8 contrast)
+{
+	spi_reg(spi, LCD_SET((CMD_CONTRAST|(contrast & 0xF))));
+}
+
+int dpc_GetContrast(struct spi_device *spi)
+{
+	return spi_reg(spi, LCD_GET(CMD_CONTRAST));
+}
+
+void dpc_SetBrightness(struct spi_device *spi, u8 brightness)
+{
+	spi_reg(spi, LCD_SET((CMD_BRIGHTNESS|(brightness & 0xFF))));
+}
+
+int dpc_GetBrightness(struct spi_device *spi)
+{
+	return spi_reg(spi, LCD_GET(CMD_BRIGHTNESS));
+}
+
+/*
+ * sysfs interface
+ */
+static ssize_t show_lcdid(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	int ret = -ENODEV;
+	struct spi_device *spi = (struct spi_device*)dev->platform_data;
+
+	if(spi != NULL)	
+		ret = spi_reg(spi, LCD_GET(CMD_CHIPID));
+
+	if(ret < 0)
+		return sprintf(buf, "%s", "error: chip ID not read.");
+	return sprintf(buf, "0x%0X\n", ret&0xff);
+}
+static DEVICE_ATTR(lcd_id, S_IRUSR|S_IRGRP, show_lcdid, NULL);
+
+static ssize_t show_brightness(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct spi_device *spi = (struct spi_device*)dev->platform_data;
+	int value;
+	if(spi == NULL)
+		return -ENODEV;
+	value = dpc_GetBrightness(spi);
+	value = (value < 0) ? 0 : (value & 0xFF) - 128;
+	return(sprintf(buf, "%d\n", value));
+}
+
+static ssize_t set_brightness(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int value;
+	struct spi_device *spi = (struct spi_device*)dev->platform_data;
+	if(spi == NULL)
+		return -ENODEV;
+	if(sscanf(buf, "%i", &value) != 1)
+		return -EINVAL;
+	if (value < -128 || value > 127)
+		return -EINVAL;
+	// convert virtual [-128,127] to physical [0,255]
+	value = value + 128;
+	dpc_SetBrightness(spi, value);
+	return(count);
+}
+
+static DEVICE_ATTR( brightness, S_IRUGO | S_IWUGO,
+	       	show_brightness, set_brightness);
+
+static ssize_t show_contrast(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct spi_device *spi = (struct spi_device*)dev->platform_data;
+	int value;
+
+	if(spi == NULL)
+		return -ENODEV;
+
+	value = dpc_GetContrast(spi);
+	// map physical [0,15] to virtual [-128,127]
+	value = (value < 0) ? 0 : ((value & 0xF) << 4) - 128;
+	return(sprintf(buf, "%d\n", value));
+}
+
+static ssize_t set_contrast(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int value;
+	struct spi_device *spi = (struct spi_device*)dev->platform_data;
+
+	if(spi == NULL)
+		return -ENODEV;
+	if(sscanf(buf, "%i", &value) != 1)
+		return -EINVAL;
+	if (value < -128 || value > 127)
+		return -EINVAL;
+	// map virtual [-128,127] to physcial [0,15]
+	value = (value + 128) >> 4;
+	dpc_SetContrast(spi, value);
+	return(count);
+}
+
+static DEVICE_ATTR( contrast, S_IRUGO | S_IWUGO,
+	       	show_contrast, set_contrast);
+
+static struct attribute *ili9322_attributes[] = {
+	&dev_attr_lcd_id.attr,
+	&dev_attr_brightness.attr,
+	&dev_attr_contrast.attr,
+	NULL
+};
+
+static struct attribute_group ili9322_attr_group = {
+	.attrs = ili9322_attributes
+};
+#ifdef CONFIG_PM
+static int ili9322_suspend(struct spi_device *spi, pm_message_t message)
+{
+	return 0;
+}
+
+static int ili9322_resume(struct spi_device *spi)
+{
+	return 0;
+}
+#else
+#define ili9322_suspend NULL
+#define ili9322_resume NULL
+#endif
+
+static int __devinit ili9322_probe(struct spi_device *spi)
+{
+	int ret;
+	struct platform_device *pdev = (struct platform_device *)spi->dev.platform_data;
+
+	/* 
+	 * Both the LF1000 DPC and the ili9322 want sysfs entries to control
+	 * brightness, contrast, etc.  platform_data of each points to spi
+	 */
+	pdev->dev.platform_data = spi;
+	spi->dev.platform_data = spi;
+
+	spi->bits_per_word = 16;
+	spi->master->setup(spi);
+
+	ret = spi_reg(spi, LCD_GET(CMD_CHIPID));
+	if(ret < 0)
+		printk(KERN_ERR "dpc: failed to read LCD chip ID: %d\n", ret);
+	else if((ret&0xff) != LCD_CHIP_ID) 
+		printk(KERN_ERR "dpc: expected LCD chip ID 0x%08X, got %08X\n",
+			LCD_CHIP_ID, ret&0xff);
+	else { /* program LCD preferred register settings */
+		/* Power Control : Normal display+HVDE Mode+Line Inversion */
+		ret = spi_reg(spi, LCD_SET((CMD_DISPLAY | 0x05)));
+		/* VCOM High Voltage : VREG1OUT x 0.87*/
+		ret = spi_reg(spi, LCD_SET((CMD_HIGHVOLTAGE | 0x32)));
+#if defined (CONFIG_LF1000_DPC_OVERRIDE_VIEWANGLE)
+		/* change viewing angle */
+		ret = spi_reg(spi, LCD_SET((CMD_VIEWANGLE |
+		               CONFIG_LF1000_DPC_OVERRIDE_VIEWABLE_VALUE)));
+#endif
+		/* VCOM AC Voltage : VREG1OUT x 1.06*/
+		ret = spi_reg(spi, LCD_SET((CMD_AMPLITUDE | 0x12)));
+		/* Gamma1 : Gamma Curve*/
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA1 | 0xA7)));
+		/* Gamma2 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA2 | 0x57)));
+		/* Gamma3 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA3 | 0x73)));
+		/* Gamma4 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA4 | 0x72)));
+		/* Gamma5 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA5 | 0x73)));
+		/* Gamma6 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA6 | 0x55)));
+		/* Gamma7 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA7 | 0x17)));
+		/* Gamma8 : */
+		ret = spi_reg(spi, LCD_SET((CMD_GAMMA8 | 0x62)));
+	}
+
+	/* pdev points to the LF1000 DPC to group sysfs stuff */
+
+	sysfs_create_group(&pdev->dev.kobj, &ili9322_attr_group);
+	sysfs_create_group(&spi->dev.kobj, &ili9322_attr_group);
+
+	return 0;
+}
+
+static int __devexit ili9322_remove(struct spi_device *spi)
+{
+	struct platform_device *pdev = (struct platform_device *)spi->dev.platform_data;
+
+	sysfs_remove_group(&pdev->dev.kobj, &ili9322_attr_group);
+	sysfs_remove_group(&spi->dev.kobj, &ili9322_attr_group);
+	return 0;
+}
+
+static struct spi_driver ili9322_driver = {
+	.driver = {
+		.name	= "ili9322",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ili9322_probe,
+	.remove		= __devexit_p(ili9322_remove),
+	.suspend	= ili9322_suspend,
+	.resume		= ili9322_resume,
+};
+
+static int __init ili9322_init(void)
+{
+	return spi_register_driver(&ili9322_driver);
+}
+module_init(ili9322_init);
+
+static void __exit ili9322_exit(void)
+{
+	spi_unregister_driver(&ili9322_driver);
+}
+module_exit(ili9322_exit);
+
+MODULE_DESCRIPTION("ILI9322 LCD SPI Driver");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/ili9322.h linux-2.6/drivers/lf1000/dpc/ili9322.h
--- linux-2.6.31/drivers/lf1000/dpc/ili9322.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/ili9322.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,31 @@
+/* ili9322.h -- hardware definitions for ILI9322 LCD controller 
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ */
+
+#ifndef ILI9322_H
+#define ILI9322_H
+
+#define LCD_CHIP_ID	0x96
+
+#define LCD_GET(x)	((x | 0x8000) & 0xFFFF)
+#define LCD_SET(x)	((x & ~(0x8000)) & 0xFFFF)
+
+#define CMD_CHIPID	0x0000
+#define CMD_AMPLITUDE	0x0100
+#define CMD_HIGHVOLTAGE	0x0200
+#define CMD_VIEWANGLE	0x0300
+#define CMD_DISPLAY	0x0B00
+#define CMD_CONTRAST	0x0E00
+#define CMD_BRIGHTNESS	0x0F00
+#define CMD_GAMMA1	0x1000
+#define CMD_GAMMA2	0x1100
+#define CMD_GAMMA3	0x1200
+#define CMD_GAMMA4	0x1300
+#define CMD_GAMMA5	0x1400
+#define CMD_GAMMA6	0x1500
+#define CMD_GAMMA7	0x1600
+#define CMD_GAMMA8	0X1700
+
+#endif
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/main.c linux-2.6/drivers/lf1000/dpc/main.c
--- linux-2.6.31/drivers/lf1000/dpc/main.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/main.c	2011-05-03 12:54:00.000000000 -0700
@@ -0,0 +1,853 @@
+/* 
+ * drivers/lf1000/dpc/main.c
+ *
+ * LF1000 Display Controller (DPC) Driver 
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * Note: this driver is deprecated.  Do not add any functionality to it.
+ *  - DPC support has been moved to arch/arm/mach-lf1000/screen.c
+ *  - TODO: move backlight stuff to a backlight driver,
+ *          ie: drivers/video/backlight, and clean it up
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/lf1000/dpc_ioctl.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/pwm.h>
+#include <mach/gpio.h>
+
+#include "dpc_hal.h"
+#include "dpc.h"
+#include "dpc_config.h"
+
+/* backlight logical to virtual mapping */
+int backlight_l2v[] =
+ {BACKLIGHT_LEVEL_0, BACKLIGHT_LEVEL_1, BACKLIGHT_LEVEL_2, BACKLIGHT_LEVEL_3};
+
+#define BACKLIGHT_L2V_INDEX_MAX  ( sizeof(backlight_l2v) / sizeof(int)  - 1 )
+
+/* device private data */
+struct dpc_device dpc = {
+	.mem = NULL,
+	.cdev = NULL,
+	.dev = 0,
+	.major = DPC_MAJOR,
+	.backlight = 0,
+	.backlight_threshold = 0,  // min PWM value that turns LEDs on
+	.backlight_logical =  1,   // initial setting, to match bootstrap */
+	.backlight_next = 1,	/* next button direction -1=down, 1=up */
+	.pdev = NULL,
+};
+
+// forward declarations used in sysfs
+int getBacklightVirt(void);
+int setBacklightVirt(int virtValue);
+int getBacklight(void);
+int setBacklight(unsigned long arg);
+int setBacklightNext(void);
+
+/*******************
+ * sysfs Interface *
+ *******************/
+#ifdef CONFIG_LF1000_DPC_DEBUG
+static ssize_t show_registers(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t len = 0;
+	u32 mem = dpc.mem;
+	int n;
+
+	for (n = 0; n < 2; n++, dpc.mem += 0x400)
+	{
+	len += sprintf(buf+len, "DPCHTOTAL   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCHTOTAL), DPCHTOTAL);
+	len += sprintf(buf+len, "DPCHSWIDTH  = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCHSWIDTH), DPCHSWIDTH);
+	len += sprintf(buf+len, "DPCHASTART  = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCHASTART), DPCHASTART);
+	len += sprintf(buf+len, "DPCHAEND    = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCHAEND), DPCHAEND);
+	len += sprintf(buf+len, "DPCVTOTAL   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVTOTAL), DPCVTOTAL);
+	len += sprintf(buf+len, "DPCVSWIDTH  = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVSWIDTH), DPCVSWIDTH);
+	len += sprintf(buf+len, "DPCVASTART  = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVASTART), DPCVASTART);
+	len += sprintf(buf+len, "DPCVAEND    = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVAEND), DPCVAEND);
+	len += sprintf(buf+len, "DPCCTRL0    = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCCTRL0), DPCCTRL0);
+	len += sprintf(buf+len, "DPCCTRL1    = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCCTRL1), DPCCTRL1);
+	len += sprintf(buf+len, "DPCEVTOTAL  = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVTOTAL), DPCEVTOTAL);
+	len += sprintf(buf+len, "DPCEVSWIDTH = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVSWIDTH), DPCEVSWIDTH);
+	len += sprintf(buf+len, "DPCEVASTART = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVASTART), DPCEVASTART);	
+	len += sprintf(buf+len, "DPCEVAEND   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVAEND), DPCEVAEND);	
+	len += sprintf(buf+len, "DPCCTRL2    = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCCTRL2), DPCCTRL2);
+	len += sprintf(buf+len, "DPCVSEOFFSET= 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVSEOFFSET), DPCVSEOFFSET);
+	len += sprintf(buf+len, "DPCVSSOFFSET= 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCVSSOFFSET), DPCVSSOFFSET);
+	len += sprintf(buf+len, "DPCEVSEOFFSET=0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVSEOFFSET), DPCEVSEOFFSET);
+	len += sprintf(buf+len, "DPCEVSSOFFSET=0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCEVSSOFFSET), DPCEVSSOFFSET);
+	len += sprintf(buf+len, "DPCDELAY0   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPCDELAY0), DPCDELAY0);
+	len += sprintf(buf+len, "DPCCLKENB   = 0x%08X @ 0x%04X\n",
+			ioread32(dpc.mem+DPCCLKENB), DPCCLKENB);
+	len += sprintf(buf+len, "DPCCLKGEN0  = 0x%08X @ 0x%04X\n",
+			ioread32(dpc.mem+DPCCLKGEN0), DPCCLKGEN0);
+	len += sprintf(buf+len, "DPCCLKGEN1  = 0x%08X @ 0x%04X\n",
+			ioread32(dpc.mem+DPCCLKGEN1), DPCCLKGEN1);
+	len += sprintf(buf+len, "VENCCTRLA   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+VENCCTRLA), VENCCTRLA);
+	len += sprintf(buf+len, "VENCCTRLB   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+VENCCTRLB), VENCCTRLB);
+	len += sprintf(buf+len, "DPUPSCALECON0   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPUPSCALECON0), DPUPSCALECON0);
+	len += sprintf(buf+len, "DPUPSCALECON1   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPUPSCALECON1), DPUPSCALECON1);
+	len += sprintf(buf+len, "DPUPSCALECON2   = 0x%04X @ 0x%04X\n",
+			ioread16(dpc.mem+DPUPSCALECON2), DPUPSCALECON2);
+	}
+	dpc.mem = mem;
+
+	return len;
+}
+static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+#endif
+
+static ssize_t show_backlight(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	int virtValue = getBacklightVirt();
+	return(sprintf(buf, "%d\n", virtValue));
+}
+
+static ssize_t set_backlight(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int virtValue;
+	if(sscanf(buf, "%i", &virtValue) != 1)
+		return -EINVAL;
+	if (virtValue < -128 || virtValue > 127)
+		return -EINVAL;
+	if(0 > setBacklightVirt(virtValue))
+	return -EINVAL;
+	return(count);
+}
+
+static DEVICE_ATTR( backlight, S_IRUGO | S_IWUGO, 
+		    show_backlight, set_backlight);
+
+static ssize_t show_backlight_logical(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return(sprintf(buf, "%d\n", dpc.backlight_logical));
+}
+
+static ssize_t set_backlight_logical(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int temp;
+	if(sscanf(buf, "%i", &temp) != 1)
+		return -EINVAL;
+	if (temp < 0 || temp > BACKLIGHT_L2V_INDEX_MAX)
+		return -EINVAL;
+	dpc.backlight_logical = temp;
+	if (0 > setBacklightVirt(backlight_l2v[dpc.backlight_logical]))
+		return -EINVAL;
+	return(count);
+}
+
+static DEVICE_ATTR( backlight_logical, S_IRUGO | S_IWUGO, 
+		    show_backlight_logical, set_backlight_logical);
+
+static ssize_t show_backlight_next(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return(sprintf(buf, "%d\n", dpc.backlight_next));
+}
+
+static ssize_t set_backlight_next(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	if (0 > setBacklightNext())
+		return -EINVAL;
+	return(count);
+}
+
+static DEVICE_ATTR( backlight_next, S_IRUGO | S_IWUGO, 
+		    show_backlight_next, set_backlight_next);
+
+static ssize_t show_physical_backlight(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	int physicalValue = getBacklight();
+	return(sprintf(buf, "%d\n", physicalValue));
+}
+
+static ssize_t set_physical_backlight(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int physicalValue;
+	if(sscanf(buf, "%i", &physicalValue) != 1)
+		return -EINVAL;
+	if (physicalValue < 0 || physicalValue > 511)
+		return -EINVAL;
+	if(0 > setBacklight(physicalValue))
+		return -EINVAL;
+	return(count);
+}
+
+static DEVICE_ATTR( physical_backlight, S_IRUGO | S_IWUGO, 
+		    show_physical_backlight, set_physical_backlight);
+
+static ssize_t show_backlight_threshold(struct device *dev, 
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	return(sprintf(buf, "%d\n", dpc.backlight_threshold));
+}
+
+static ssize_t set_backlight_threshold(struct device *dev, 
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int value, virtValue;
+	if(sscanf(buf, "%i", &value) != 1)
+		return -EINVAL;
+	if (value < 0 || value > 511)
+		return -EINVAL;
+	// update backlight using new threshold
+	virtValue = getBacklightVirt();
+	dpc.backlight_threshold = value;
+	setBacklightVirt(virtValue);
+	return(count);
+}
+
+static DEVICE_ATTR( backlight_threshold, S_IRUGO | S_IWUGO, 
+		    show_backlight_threshold, set_backlight_threshold);
+
+static struct attribute *dpc_attributes[] = {
+#ifdef CONFIG_LF1000_DPC_DEBUG
+	&dev_attr_registers.attr,
+#endif
+	&dev_attr_backlight.attr,
+	&dev_attr_backlight_logical.attr,
+	&dev_attr_backlight_next.attr,
+	&dev_attr_physical_backlight.attr,
+	&dev_attr_backlight_threshold.attr,
+	NULL
+};
+
+static struct attribute_group dpc_attr_group = {
+	.attrs = dpc_attributes
+};
+
+/********************************************************
+ * Set Backlight    					*
+ *     arg is between 0 and 511,			*
+ *     where 0 is dark and 511 is the brightest		*
+ ********************************************************/
+
+int setBacklight(unsigned long arg)
+{
+	int retval;
+
+	if(arg <= LCD_BACKLIGHT_PERIOD) {
+		retval = pwm_set_duty_cycle(LCD_BACKLIGHT, arg);
+		if(retval == 0)
+			dpc.backlight = arg;
+		else
+			retval = -EFAULT;
+	} else {
+		retval = -EFAULT;
+	}
+	return(retval);
+}
+
+/********************
+ * Get Backlight    *
+ ********************/
+
+int getBacklight(void)
+{
+	return(dpc.backlight);
+}
+
+/****************************************
+* Set Backlight, using virtual range	*
+*   value is a signed byte with zero in	*
+*   the middle of the supported range	*
+*   Adjust based on board version	*
+****************************************/
+
+int setBacklightVirt(int virtValue)
+{
+	int physValue;
+
+	// on the Dev board the physical range is [140,511]
+	if (gpio_have_gpio_dev())
+		physValue = ((virtValue * 373) / 256) + 326 +
+			dpc.backlight_threshold;
+	// on Didj, and later, the physical range is [0,511]
+	else
+		physValue = (virtValue * 2) + 256 + dpc.backlight_threshold;
+	// clip value to be between 0 and 511
+	if (physValue < 0)
+		physValue = 0;
+	else if (physValue > 511)
+		physValue = 511;
+	return(setBacklight(physValue));
+}
+
+/****************************************
+* Get Backlight, using virtual range	*
+*   value is a signed byte with zero in *
+*   the middle of the supported range	*
+*   Adjust based on board version	*
+****************************************/
+
+int getBacklightVirt(void)
+{
+	int physValue = getBacklight();
+	int virtValue;
+
+	// on the Dev Board the physical range is [140,511]
+	if (gpio_have_gpio_dev()) {
+		virtValue = ((physValue - 326 - dpc.backlight_threshold)
+				* 256) / 373;
+		// fixup fixed point math truncation error
+		if (virtValue < 0) virtValue--;
+		else if (virtValue > 0) virtValue++;
+		else {	// virtValue is zero, two special cases
+			if (physValue == 325) virtValue = -1;
+			if (physValue == 327) virtValue = 1;
+		}
+	}
+	// on Didj, and later, the physical range is [0,511]
+	else
+		virtValue = (physValue - 256 - dpc.backlight_threshold) / 2;
+
+	return(virtValue);
+}
+
+/*
+ * setBacklightNext()
+ * Advance backlight in response to the 'brightness' button press
+ */
+
+int setBacklightNext(void)
+{
+	int temp;
+
+	temp = dpc.backlight_logical + dpc.backlight_next; // step up or down
+
+	if (temp < 0) {					// too low, go up
+		temp = 1;				// bottom + 1
+		dpc.backlight_next = 1;			// going up
+	} else if (temp > BACKLIGHT_L2V_INDEX_MAX) {	// too high, go down
+		temp = BACKLIGHT_L2V_INDEX_MAX - 1;	// top - 1
+		dpc.backlight_next = -1;		// going down
+	}
+
+	dpc.backlight_logical = temp;
+	return(setBacklightVirt(backlight_l2v[dpc.backlight_logical]));
+}
+EXPORT_SYMBOL(setBacklightNext);
+
+
+/********************
+ * Character Device *
+ ********************/
+
+int dpc_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+					  unsigned long arg)
+{
+	int retval = 0;
+	void __user *argp = (void __user *)arg;
+	union dpc_cmd c;
+
+	switch(cmd) {
+		case DPC_IOCTINTENB:
+		dpc_SetIntEnb(arg);
+		break;
+
+		case DPC_IOCSHSYNC:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct hsync_cmd)))
+			return -EFAULT;
+		retval = dpc_SetHSync(c.hsync.avwidth, 
+				      c.hsync.hsw,
+				      c.hsync.hfp,
+				      c.hsync.hbp,
+				      c.hsync.inv_hsync);
+		break;
+
+		case DPC_IOCSVSYNC:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct vsync_cmd)))
+			return -EFAULT;
+		retval = dpc_SetVSync(c.vsync.avheight,
+				      c.vsync.vsw,
+				      c.vsync.vfp,
+				      c.vsync.vbp,
+				      c.vsync.inv_vsync,
+				      c.vsync.eavheight,
+				      c.vsync.evsw,
+				      c.vsync.evfp,
+				      c.vsync.evbp);
+		break;
+
+		case DPC_IOCSCLOCK0:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct clock0_cmd)))
+			return -EFAULT;
+		retval = dpc_SetClock0(c.clock0.source, 
+				       c.clock0.div, 
+				       c.clock0.delay, 
+				       c.clock0.out_inv, 
+				       c.clock0.out_en);
+		break;
+
+		case DPC_IOCSCLOCK1:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct clock1_cmd)))
+			return -EFAULT;
+		retval = dpc_SetClock1(c.clock1.source, 
+				       c.clock1.div, 
+				       c.clock1.delay, 
+				       c.clock1.out_inv);
+		break;
+
+		case DPC_IOCSMODE:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct mode_cmd)))
+			return -EFAULT;
+		retval = dpc_SetMode(c.mode.format,
+				     c.mode.interlace,
+				     c.mode.invert_field,
+				     c.mode.rgb_mode,
+				     c.mode.swap_rb,
+				     c.mode.ycorder,
+				     c.mode.clip_yc,
+				     c.mode.embedded_sync,
+				     c.mode.clock);
+		break;
+
+		case DPC_IOCTSWAPRB:
+		dpc_SwapRB(arg);
+		break;
+
+		case DPC_IOCTCONTRAST:
+		//dpc_SetContrast(dpc.pdev->dev.platform_data, arg);
+		break;
+
+		case DPC_IOCQCONTRAST:
+		//retval = dpc_GetContrast(dpc.pdev->dev.platform_data);
+		//retval = (retval < 0) ? 0 : (retval & 0xF);
+		retval = 0;
+		break;
+
+		case DPC_IOCTBRIGHTNESS:
+		//dpc_SetBrightness(dpc.pdev->dev.platform_data, arg);
+		break;
+
+		case DPC_IOCQBRIGHTNESS:
+		//retval = dpc_GetBrightness(dpc.pdev->dev.platform_data);
+		//retval = (retval < 0) ? 0 : (retval & 0xFF);
+		retval = 0;
+		break;
+
+		case DPC_IOCTBACKLIGHT:
+		retval = setBacklight(arg);
+		break;
+
+		case DPC_IOCQBACKLIGHT:
+		retval = getBacklight();
+		break;
+
+		case DPC_IOCTBACKLIGHTVIRT:
+		retval = setBacklightVirt(arg);
+		break;
+
+		case DPC_IOCQBACKLIGHTVIRT:
+		retval = getBacklightVirt();
+		copy_to_user(argp, &retval, sizeof(retval));
+		retval = 0;
+		break;
+
+		default:
+		return -ENOTTY;
+	}
+
+	return retval;
+}
+
+struct file_operations dpc_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = dpc_ioctl,
+};
+
+#define LFP100_ADDR	0xCC
+
+static bool have_i2c_backlight(void)
+{
+	struct i2c_adapter* i2c;
+	struct i2c_msg i2c_messages[2];
+	u8 buf[2];
+
+	i2c = i2c_get_adapter(0);
+	if (!i2c)
+		return 0;
+	
+	buf[0] = 0; /* chip ID */
+	buf[1] = 0;
+
+	/* write portion */
+	i2c_messages[0].addr = LFP100_ADDR;
+	i2c_messages[0].buf = buf;
+	i2c_messages[0].len = 1;
+	i2c_messages[0].flags = 0; /* write */
+
+	/* read portion */
+	i2c_messages[1].addr = LFP100_ADDR;
+	i2c_messages[1].buf = buf;
+	i2c_messages[1].len = 2;
+	i2c_messages[1].flags = I2C_M_RD;
+
+	if (i2c_transfer(i2c, i2c_messages, 2) < 0) {
+		i2c_put_adapter(i2c);
+		return 0;
+	}
+
+	i2c_put_adapter(i2c);
+	return ((buf[1] & 0xF0) == 0x00);
+}
+
+static void init_pwm_backlight(void)
+{
+	gpio_configure_pin(lf1000_l2p_port(LED_ENA),lf1000_l2p_pin(LED_ENA),
+		GPIO_GPIOFN, 1, 0, 1);
+	gpio_set_cur(lf1000_l2p_port(LED_ENA), lf1000_l2p_pin(LED_ENA),
+		GPIO_CURRENT_8MA);
+
+	if (pwm_get_clock_rate() < 1) {
+		dev_err(&dpc.pdev->dev, "PWM clock not set up?\n");
+		dpc.backlight = 0;
+		return;
+	}
+
+	pwm_configure_pin(LCD_BACKLIGHT);
+	pwm_set_prescale(LCD_BACKLIGHT, 1);
+	pwm_set_polarity(LCD_BACKLIGHT, POL_BYP);
+	pwm_set_period(LCD_BACKLIGHT, LCD_BACKLIGHT_PERIOD);
+
+	/* initial backlight setting, try to match bootstrap */
+	setBacklightVirt(backlight_l2v[dpc.backlight_logical]);
+}
+
+/********************
+ * Module Functions *
+ ********************/
+
+static int lf1000_dpc_probe(struct platform_device *pdev)
+{
+	int ret;
+	int i;
+	int div;
+	struct resource *res;
+
+	printk(KERN_INFO "lf1000-dpc driver\n");
+
+	dpc.pdev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk(KERN_ERR "dpc: failed to get resource\n");
+		return -ENXIO;
+	}
+
+	div = lf1000_CalcDivider(get_pll_freq(PLL1), DPC_DESIRED_CLOCK_HZ);
+	if(div < 0) {
+		printk(KERN_ERR "dpc: failed to get a clock divider!\n");
+		return -EFAULT;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1, 
+		"lf1000_dpc")) {
+		printk(KERN_ERR "dpc: failed to map DPC region.");
+		return -EBUSY;
+	}
+
+	dpc.mem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(dpc.mem == NULL) {
+		printk(KERN_ERR "dpc: failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	/* configure LCD interface pins */
+	for(i = 0; i < NUM_PVD_PINS; i++)
+		gpio_configure_pin(pvd_ports[i], pvd_pins[i], GPIO_ALT1, 
+				1, 0, 0);
+	
+	/* set up and enable the DPC only if it wasn't already enabled */
+	if (!(ioread16(dpc.mem+DPCCTRL0) & (1<<DPCENB))) {
+		printk(KERN_INFO "dpc: DPC not enabled, do config+enable\n");
+		dpc_SetClockPClkMode(PCLKMODE_ONLYWHENCPUACCESS);
+		dpc_SetClock0(DISPLAY_VID_PRI_VCLK_SOURCE, 
+			      div > 0 ? (div-1) : 0, 
+			      DISPLAY_VID_PRI_VCLK_DELAY,
+			      DISPLAY_VID_PRI_VCLK_INV,	
+			      DISPLAY_VID_PRI_VCLK_OUT_ENB);
+		dpc_SetClock1(DISPLAY_VID_PRI_VCLK2_SOURCE,
+			      DISPLAY_VID_PRI_VCLK2_DIV,
+			      0,	/* outclk delay */
+			      1);	/* outclk inv */
+		dpc_SetClockEnable(1);
+		ret = dpc_SetMode(DISPLAY_VID_PRI_OUTPUT_FORMAT,
+				  0, 	/* interlace */
+				  0, 	/* invert field */
+				  1,	/* RGB mode */
+				  DISPLAY_VID_PRI_SWAP_RGB,
+				  DISPLAY_VID_PRI_OUTORDER,
+				  0,	/* clip YC */
+				  0,	/* embedded sync */
+				  DISPLAY_VID_PRI_PAD_VCLK);
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set display mode\n");
+		dpc_SetDither(DITHER_BYPASS, DITHER_BYPASS, DITHER_BYPASS);
+		ret = dpc_SetHSync(DISPLAY_VID_PRI_MAX_X_RESOLUTION,
+				   DISPLAY_VID_PRI_HSYNC_SWIDTH,
+				   DISPLAY_VID_PRI_HSYNC_FRONT_PORCH,
+				   DISPLAY_VID_PRI_HSYNC_BACK_PORCH,
+				   DISPLAY_VID_PRI_HSYNC_ACTIVEHIGH );
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set HSync\n");
+		ret = dpc_SetVSync(DISPLAY_VID_PRI_MAX_Y_RESOLUTION,
+				   DISPLAY_VID_PRI_VSYNC_SWIDTH,
+				   DISPLAY_VID_PRI_VSYNC_FRONT_PORCH,
+				   DISPLAY_VID_PRI_VSYNC_BACK_PORCH,
+				   DISPLAY_VID_PRI_VSYNC_ACTIVEHIGH,
+				   1, 1, 1, 1);
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set VSync\n");
+		dpc_SetDelay(0, 7, 7, 7, 4, 4, 4);
+		dpc_SetVSyncOffset(1, 1, 1, 1);
+		dpc_SetDPCEnable();
+	}
+
+	if (gpio_have_tvout()) {
+		/* 2nd DPC register set for TV out */
+		dpc.mem += 0x400;
+		dpc_SetClockPClkMode(PCLKMODE_ONLYWHENCPUACCESS);
+		dpc_SetClock0(VID_VCLK_SOURCE_XTI,
+			      0, 	/* vidclk divider */ 
+			      0, 	/* vidclk delay */
+			      0, 	/* vidclk invert */	
+			      DISPLAY_VID_PRI_VCLK_OUT_ENB);
+		dpc_SetClock1(VID_VCLK_SOURCE_VCLK2, 
+			      1, 	/* vidclk2 divider */
+			      0,	/* outclk delay */
+			      0); 	/* outclk inv */
+		dpc_SetClockEnable(1);
+		ret = dpc_SetMode(VID_FORMAT_CCIR601B,
+				  1,  	/* interlace */
+				  0, 	/* invert field */
+				  0, 	/* RGB mode */
+				  0, 	/* swap RB */
+				  VID_ORDER_CbYCrY, /* YC order */
+				  1, 	/* clip YC */
+				  0,	/* embedded sync */
+				  DISPLAY_VID_PRI_PAD_VCLK);
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set display mode\n");
+		dpc_SetDither(DITHER_BYPASS, DITHER_BYPASS, DITHER_BYPASS);
+		ret = dpc_SetHSync(720, /* active horizontal */
+		  		   33, 	/* sync width */
+				   24, 	/* front porch */
+			  	   81, 	/* back porch */
+			  	   0); 	/* polarity */
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set HSync\n");
+		ret = dpc_SetVSync(240, /* active odd field */
+			  	   3, 	/* sync width */
+			  	   3, 	/* front porch */
+			  	   16, 	/* back porch */
+			  	   0, 	/* polarity */
+			  	   240, /* active even field */
+			  	   3, 	/* sync width */
+			  	   4, 	/* front porch */
+			  	   16); /* back porch */
+		if(ret < 0)
+			printk(KERN_ALERT "dpc: failed to set VSync\n");
+		dpc_SetDelay(0, 4, 4, 4, 4, 4, 4);
+		dpc_SetVSyncOffset(0, 0, 0, 0);
+	
+		/* Internal video encoder for TV out */
+		dpc_ResetEncoder();
+		dpc_SetEncoderEnable(1);
+		dpc_SetEncoderPowerDown(1);
+		dpc_SetEncoderMode(0, 1);
+		dpc_SetEncoderFSCAdjust(0);
+		dpc_SetEncoderBandwidth(0, 0);
+		dpc_SetEncoderColor(0, 0, 0, 0, 0);
+		dpc_SetEncoderTiming(64, 1716, 0, 3);
+		dpc_SetEncoderUpscaler(320, 720);
+		dpc_SetEncoderPowerDown(0);
+	
+		/* 2nd DPC is master when running TV + LCD out */
+		dpc_SetDPCEnable();
+		dpc_SetClockEnable(1);
+	
+		/* Switch back to 1st DPC register set for LCD out */
+		dpc.mem -= 0x400;
+	}
+	
+	ret = register_chrdev(dpc.major, "dpc", &dpc_fops);
+	if(ret < 0) {
+		printk(KERN_ALERT "dpc: failed to get a device\n");
+		goto fail_dev;
+	}
+	if(dpc.major == 0) dpc.major = ret;
+
+	dpc.cdev = cdev_alloc();
+	dpc.cdev->owner = THIS_MODULE;
+	dpc.cdev->ops = &dpc_fops;
+	ret = cdev_add(dpc.cdev, 0, 1);
+	if(ret < 0) {
+		printk(KERN_ALERT "dpc: failed to create character device\n");
+		goto fail_add;
+	}
+
+	if (!have_i2c_backlight())
+		init_pwm_backlight();
+
+	/* on older boards, make sure LCD is not in reset */
+	if (gpio_have_gpio_dev()) {
+		gpio_configure_pin(lf1000_l2p_port(LCD_RESET),
+		lf1000_l2p_pin(LCD_RESET), GPIO_GPIOFN, 1, 0, LCD_nRESET_LEVEL);
+	}
+
+	if (dpc.backlight)
+		sysfs_create_group(&pdev->dev.kobj, &dpc_attr_group);
+
+	return 0;
+
+fail_add:
+	unregister_chrdev(dpc.major, "dpc");
+fail_dev:
+	iounmap(dpc.mem);
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	return ret;
+}
+
+static int lf1000_dpc_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	u16 tmp = ioread16(dpc.mem+DPCCTRL0);
+
+	printk(KERN_INFO "dpc: removing...\n");
+
+	dpc.pdev = NULL;
+
+	BIT_CLR(tmp, DPCENB);
+
+	unregister_chrdev(dpc.major, "dpc");
+	if(dpc.cdev != NULL)
+		cdev_del(dpc.cdev);
+
+	if(dpc.mem != NULL)
+		iounmap(dpc.mem);
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	if (dpc.backlight)
+		sysfs_remove_group(&pdev->dev.kobj, &dpc_attr_group);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_dpc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int lf1000_dpc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lf1000_dpc_suspend	NULL
+#define lf1000_dpc_resume	NULL
+#endif
+
+static struct platform_driver lf1000_dpc_driver = {
+	.probe		= lf1000_dpc_probe,
+	.remove		= lf1000_dpc_remove,
+	.suspend	= lf1000_dpc_suspend,
+	.resume		= lf1000_dpc_resume,
+	.driver		= {
+		.name = "lf1000-dpc",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init dpc_init(void)
+{
+	return platform_driver_register(&lf1000_dpc_driver);
+}
+
+static void __exit dpc_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_dpc_driver);
+}
+
+module_init(dpc_init);
+module_exit(dpc_cleanup);
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_VERSION("1:1.1");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/Makefile linux-2.6/drivers/lf1000/dpc/Makefile
--- linux-2.6.31/drivers/lf1000/dpc/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+lf1000-dpc-objs := main.o dpc.o
+
+obj-$(CONFIG_LF1000_DPC)		+= lf1000-dpc.o
diff -ruaN linux-2.6.31/drivers/lf1000/dpc/README linux-2.6/drivers/lf1000/dpc/README
--- linux-2.6.31/drivers/lf1000/dpc/README	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/dpc/README	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,51 @@
+###############################################################################
+# LF1000 Display Controller (DPC) Driver                                      #
+#                                                                             #
+# 04/28/2007 by Andrey Yurovsky <andrey@cozybit.com>                          #
+###############################################################################
+
+This is the DPC driver documentation.  The DPC driver supports the LF1000's
+Display Controller (DPC) as well as providing general LCD control such as 
+external LCD controller settings and backlight control.
+
+0) Contents:
+   1) Building and Installing
+   2) Creating /dev/dpc Device
+   3) Application Interface
+   4) Debugging
+
+1) Building and Installing
+
+This driver can be built as a module or as part of the kernel by using the
+kernel build system.  Select the CONFIG_L1000_DPC option to build it.  Note 
+that this driver depends on the GPIO, SPI, and PWM drivers.
+
+2) Creating /dev/dpc Device
+
+You may need to create the /dev/dpc device during initial installation.  To do
+so, you must know the DPC's major number (DPC_MAJOR in dpc.h).  For example, 
+to create the device with a major number 252:
+
+$ mknod /dev/dpc c 252 0
+$ chmod a+rw /dev/dpc
+
+3) Application Interface
+
+DPC configuration from user space is done through ioctl() calls.  See
+include/linux/lf1000/dpc_ioctl.h for more information.
+
+4) Debugging
+
+The DPC driver allows the DPC registers to be inspected at any time by
+reading a file in /proc.  This capability is available only if the driver was
+built for a kernel with CONFIG_PROC_FS enabled.  First, ensure that /proc is
+mounted:
+
+$ mount /proc
+
+The /proc/driver directory contains a 'dpc' file.  You may read the file with 
+the 'cat' command, for example:
+
+$ cat /proc/driver/dpc
+
+Refer to the LF1000 data book for DPC register definitions.
diff -ruaN linux-2.6.31/drivers/lf1000/ga3d.c linux-2.6/drivers/lf1000/ga3d.c
--- linux-2.6.31/drivers/lf1000/ga3d.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/ga3d.c	2011-01-04 14:21:31.000000000 -0800
@@ -0,0 +1,188 @@
+/* drivers/lf1000/ga3d.c
+ *
+ * Copyright 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * LF1000 3D accelerator driver 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+
+#define GA3D_MAJOR 	249	
+
+struct ga3d_device {
+	void __iomem *mem;
+	struct cdev *cdev;
+	dev_t dev;
+	int major;
+	struct proc_dir_entry *proc;
+};
+
+/* device private data */
+static struct ga3d_device ga3d = {
+	.mem = NULL,
+	.cdev = NULL,
+	.major = GA3D_MAJOR,
+};
+
+/*******************************
+ * character device operations *
+ *******************************/
+
+static int ga3d_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static void ga3d_vma_open(struct vm_area_struct *vma)
+{
+	/* printk(KERN_DEBUG "ga3d: vma_open virt:%lX, phs %lX\n",
+	       vma->vm_start, vma->vm_pgoff<<PAGE_SHIFT); */
+}
+
+static void ga3d_vma_close(struct vm_area_struct *vma)
+{
+	/* printk(KERN_DEBUG "ga3d: vma_close\n"); */
+}
+
+static struct vm_operations_struct ga3d_vm_ops = {
+	.open  = ga3d_vma_open,
+	.close = ga3d_vma_close,
+};
+
+static int ga3d_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+	
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_ops = &ga3d_vm_ops;
+	vma->vm_flags |= VM_IO;
+	
+	ret = io_remap_pfn_range(vma,
+				 vma->vm_start, 
+				 0xc001a000>>PAGE_SHIFT,
+				 vma->vm_end - vma->vm_start, 
+				 vma->vm_page_prot);
+	if(ret < 0) {
+		printk(KERN_ALERT "ga3d: failed to mmap\n");
+		return -EAGAIN;
+	}
+	
+	ga3d_vma_open(vma);
+	return 0;
+}
+
+static struct file_operations ga3d_fops = {
+	.owner = THIS_MODULE,
+	.open  = ga3d_open,
+	.mmap = ga3d_mmap,
+};
+
+/*********************
+ *  module functions *
+ *********************/
+
+static int lf1000_ga3d_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1,
+				"lf1000-ga3d")) {
+		dev_err(&pdev->dev, "failed to map region.");
+		return -EBUSY;
+	}
+
+	ga3d.mem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(ga3d.mem == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	ret = register_chrdev(ga3d.major, "ga3d", &ga3d_fops);
+	if(ret < 0) {
+		dev_err(&pdev->dev, "failed to get a device\n");
+		goto fail_dev;
+	}
+	if(ga3d.major == 0) ga3d.major = ret;
+
+	ga3d.cdev = cdev_alloc();
+	ga3d.cdev->owner = THIS_MODULE;
+	ga3d.cdev->ops = &ga3d_fops;
+	ret = cdev_add(ga3d.cdev, 0, 1);
+	if(ret < 0) {
+		dev_err(&pdev->dev, "failed to create character device\n");
+		goto fail_add;
+	}
+
+	return 0;
+
+fail_add:
+	unregister_chrdev(ga3d.major, "ga3d");
+fail_dev:
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return ret;
+}
+
+static int lf1000_ga3d_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	unregister_chrdev(ga3d.major, "ga3d");
+	if(ga3d.cdev != NULL)
+		cdev_del(ga3d.cdev);
+	
+	if(ga3d.mem != NULL)
+		iounmap(ga3d.mem);
+
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_ga3d_driver = {
+	.probe		= lf1000_ga3d_probe,
+	.remove		= lf1000_ga3d_remove,
+	.driver		= {
+		.name	= "lf1000-ga3d",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init ga3d_init(void)
+{
+	return platform_driver_register(&lf1000_ga3d_driver);
+}
+
+static void __exit ga3d_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_ga3d_driver);
+}
+
+module_init(ga3d_init);
+module_exit(ga3d_cleanup);
+MODULE_AUTHOR("Brian Cavagnolo, Andrey Yurovsky");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/idct.c linux-2.6/drivers/lf1000/idct.c
--- linux-2.6.31/drivers/lf1000/idct.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/idct.c	2011-01-04 14:24:41.000000000 -0800
@@ -0,0 +1,238 @@
+/* LF1000 IDCT Macro Block Decoder driver 
+ *
+ * main.c -- Main driver functionality.
+ *
+ * Brian Cavagnolo <brian@cozybit.com>
+ * Andrey Yurovsky <andrey@cozybit.com>
+ * Dave Milici <dmilici@leapfrog.com>
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+
+/* Register offsets */
+#define IDCT_BUF_DATA           (0x00)
+#define IDCT_CONTROL            (0x80)
+#define IDCT_INT_ENB            (0x84)
+#define IDCT_INT_PEND           (0x88)
+#define IDCT_CLK_ENB            (0x7C0)
+
+#define IDCT_MAJOR      248
+
+struct idct_device {
+	void __iomem *mem;
+	struct cdev *cdev;
+	dev_t dev;
+	int major;
+	struct dentry *debug;
+};
+
+static struct idct_device idct = {
+	.mem = NULL,
+	.cdev = NULL,
+	.major = IDCT_MAJOR,
+};
+
+static void idct_reg(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct idct_device *dev = s->private;
+
+	seq_printf(s, "%10s:\t0x%08X\n", nm, readl(dev->mem + reg));
+}
+
+static int idct_show_registers(struct seq_file *s, void *v)
+{
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x04);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x08);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x0C);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x10);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x14);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x18);
+	idct_reg(s, "BUF_DATA", IDCT_BUF_DATA + 0x1C);
+	idct_reg(s, "CONTROL",	IDCT_CONTROL);
+	idct_reg(s, "INT_ENB",	IDCT_INT_ENB);
+	idct_reg(s, "INT_PEND", IDCT_INT_PEND);
+	idct_reg(s, "CLK_ENB",	IDCT_CLK_ENB);
+
+	return 0;
+}
+
+static int lf1000_idct_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, idct_show_registers, inode->i_private);
+}
+
+static const struct file_operations lf1000_idct_regs_fops = {
+	.owner          = THIS_MODULE,
+	.open           = lf1000_idct_regs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+/*******************************
+ * character device operations *
+ *******************************/
+
+static int idct_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static void idct_vma_open(struct vm_area_struct *vma)
+{
+}
+
+static void idct_vma_close(struct vm_area_struct *vma)
+{
+}
+
+static struct vm_operations_struct idct_vm_ops = {
+	.open  = idct_vma_open,
+	.close = idct_vma_close,
+};
+
+static int idct_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+	
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_ops = &idct_vm_ops;
+	vma->vm_flags |= VM_IO;
+	
+	ret = io_remap_pfn_range(vma,
+				 vma->vm_start, 
+				 0xC000F800>>PAGE_SHIFT,
+				 vma->vm_end - vma->vm_start, 
+				 vma->vm_page_prot);
+	if(ret < 0)
+		return -EAGAIN;
+	
+	idct_vma_open(vma);
+	return 0;
+}
+
+static struct file_operations idct_fops = {
+	.owner = THIS_MODULE,
+	.open  = idct_open,
+	.mmap = idct_mmap,
+};
+
+/*********************
+ *  module functions *
+ *********************/
+
+static int lf1000_idct_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1,
+				"lf1000-idct")) {
+		dev_err(&pdev->dev, "failed to map region.");
+		return -EBUSY;
+	}
+
+	idct.mem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(idct.mem == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	ret = register_chrdev(idct.major, "idct", &idct_fops);
+	if(ret < 0) {
+		dev_err(&pdev->dev, "failed to get a device\n");
+		goto fail_dev;
+	}
+	if(idct.major == 0) idct.major = ret;
+
+	idct.cdev = cdev_alloc();
+	idct.cdev->owner = THIS_MODULE;
+	idct.cdev->ops = &idct_fops;
+	ret = cdev_add(idct.cdev, 0, 1);
+	if(ret < 0) {
+		dev_err(&pdev->dev, "failed to create character device\n");
+		goto fail_add;
+	}
+
+	idct.debug = debugfs_create_dir("lf1000-idct", NULL);
+	if (!idct.debug || IS_ERR(idct.debug))
+		idct.debug = NULL;
+	else
+		debugfs_create_file("registers", S_IRUSR, idct.debug, &idct,
+				&lf1000_idct_regs_fops);
+
+	return 0;
+
+fail_add:
+	unregister_chrdev(idct.major, "idct");
+fail_dev:
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return ret;
+}
+
+static int lf1000_idct_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (idct.debug) {
+		debugfs_remove_recursive(idct.debug);
+		idct.debug = NULL;
+	}
+
+	unregister_chrdev(idct.major, "idct");
+	if(idct.cdev != NULL)
+		cdev_del(idct.cdev);
+	
+	if(idct.mem != NULL)
+		iounmap(idct.mem);
+
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_idct_driver = {
+	.probe		= lf1000_idct_probe,
+	.remove		= lf1000_idct_remove,
+	.driver		= {
+		.name	= "lf1000-idct",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init idct_init(void)
+{
+	return platform_driver_register(&lf1000_idct_driver);
+}
+
+static void __exit idct_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_idct_driver);
+}
+
+module_init(idct_init);
+module_exit(idct_cleanup);
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/Kconfig linux-2.6/drivers/lf1000/Kconfig
--- linux-2.6.31/drivers/lf1000/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/Kconfig	2012-11-16 11:58:05.000000000 -0800
@@ -0,0 +1,114 @@
+#
+# LF1000 devices
+#
+
+if ARCH_LF1000
+
+menu "LF1000 devices"
+
+config LFCART
+	tristate "LeapFrog Cartridge bus support"
+	default n
+	depends on ARCH_LF1000
+	---help---
+	This option enables the LeapFrog cartridge bus.
+
+config DIDJ_VOLUME
+	tristate "Didj volume support for new kernels."
+	default n
+	depends on ARCH_LF1000
+	---help---
+	This option enables Didj volume slider event.
+
+config GPSP_WARM
+	tristate "WARM module for gpsp."
+	default n
+	depends on ARCH_LF1000
+	---help---
+	This option enables the warm module.
+
+config LF1000_DPC
+	tristate "Device driver for LF1000 Display Controller"
+	depends on ARCH_LF1000
+	---help---
+	  This option enables device driver support for LF1000 Display 
+	  Controller.
+	  If unsure, say Y.
+
+config LF1000_DPC_OVERRIDE_VIEWANGLE
+	bool "LF1000 Display Controller Override Default View Angle"
+	depends on ARCH_LF1000 && LF1000_DPC
+	default n
+	---help---
+	This option enables adjusting the default LCD Viewing Angle
+	If unsure, say N.
+
+config LF1000_DPC_OVERRIDE_VIEWANGLE_VALUE
+	int "Viewing Angle Value"
+	depends on LF1000_DPC_OVERRIDE_VIEWANGLE
+	default 4
+	---help---
+	LCD Viewing Angle Value
+	
+config LF1000_DPC_DEBUG
+	bool "LF1000 Display Controller debugging"
+	depends on ARCH_LF1000 && LF1000_DPC
+	default n
+	---help---
+	This option enables some debugging features for the LF1000 Display
+	Controller.  
+	If unsure, say N.
+
+config LF1000_MLC
+	tristate "Device driver for LF1000 Multi Layer Controller"
+	depends on ARCH_LF1000
+	---help---
+	This option enables device driver support for LF1000 Multi Layer 
+	Controller.
+
+	If unsure, say Y.
+
+config LF1000_MLC_DEBUG
+	bool "LF1000 Multi Layer Controller Debugging"
+	depends on ARCH_LF1000 && LF1000_MLC
+	default n
+	---help---
+	This option enables additional debugging for the LF1000 Multi Layer
+	Controller driver.
+	If unsure, say N.
+
+config LF1000_MLC_RESERVE_MEMORY
+	int "LF1000 Multi Layer Controller Frame Buffer Reserve Memory"
+	depends on ARCH_LF1000 && LF1000_MLC
+	default 14
+	---help---
+	This option sets the amount of RAM in MB to reserve for the frame buffer.
+	This memory is not available to the kernel.  The total amount of RAM detected
+	at boot time minus this number is used to generate the "mem=XM" command line
+	argument.  If unsure, use the default.
+
+config LF1000_GA3D
+	tristate "Device driver for LF1000 Graphics Accelerator 3D"
+	depends on ARCH_LF1000
+	---help---
+	  This option enables device driver support for LF1000 Graphics Accelerator 3D.
+
+	  If unsure, say Y.
+
+config LF1000_IDCT
+	tristate "Device driver for LF1000 IDCT Macro Block Decoder"
+	depends on ARCH_LF1000
+	---help---
+	  This option enables device driver support for LF1000 IDCT Macro Block Decoder.
+
+	  If unsure, say Y.
+
+config LF1000_ATAP
+	bool "ATAP mode kernel and bootstrap"
+	default n
+	---help---
+	This option enables MFCART for all cartridges and always turns on ECC.
+
+endmenu
+
+endif
diff -ruaN linux-2.6.31/drivers/lf1000/lfcart.c linux-2.6/drivers/lf1000/lfcart.c
--- linux-2.6.31/drivers/lf1000/lfcart.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/lfcart.c	2011-01-04 14:18:40.000000000 -0800
@@ -0,0 +1,188 @@
+/* drivers/lf1000/lfcart.c - LeapFrog Cartridge "bus"
+ *
+ * Copyright (c) 2010 Leapfrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <mach/gpio.h>
+#include <mach/nand.h> /* TODO: move defs out */
+
+enum lfcart_state {
+	LFCART_IDLE,
+	LFCART_INSERTING,
+	LFCART_REMOVING,
+};
+
+struct lfcart_priv {
+	bool			inserted;
+	bool			run;
+	struct device		cartridge;
+	enum lfcart_state	state;
+	unsigned		debounce, debounce_level;
+	struct task_struct 	*detect_thread;
+	struct semaphore	detect_thread_done;
+
+	struct dentry		*debug;
+};
+
+static struct bus_type lfcart_bus_type;
+
+static int lfcart_match_device(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static struct device_attribute lfcart_dev_attrs[] = {
+	__ATTR_NULL,
+};
+
+static struct bus_type lfcart_bus_type = {
+	.name		= "lfcart",
+	.dev_attrs	= lfcart_dev_attrs,
+	.match		= lfcart_match_device,
+};
+
+/*
+ * Cartridge detection
+ */
+
+static void lfcart_report_insert(struct lfcart_priv *priv)
+{
+	device_initialize(&priv->cartridge);
+	dev_set_name(&priv->cartridge, "cartridge");
+	priv->cartridge.bus = &lfcart_bus_type;
+	device_add(&priv->cartridge);
+
+	dev_dbg(&priv->cartridge, "inserted\n");
+}
+
+static void lfcart_report_remove(struct lfcart_priv *priv)
+{
+	dev_dbg(&priv->cartridge, "removed\n");
+	device_del(&priv->cartridge);
+	memset(&priv->cartridge, 0, sizeof(priv->cartridge));
+}
+
+static int lfcart_detect(void *data)
+{
+	struct lfcart_priv *priv = (struct lfcart_priv *)data;
+	int cur;
+
+	while (1) {
+		if (!priv->run) {
+			up(&priv->detect_thread_done);
+			do_exit(0);
+		}
+
+		cur = !gpio_get_val(NAND_CART_DETECT_PORT,
+				NAND_CART_DETECT_PIN);
+
+		switch (priv->state) {
+			case LFCART_IDLE:
+				if (cur != priv->inserted)
+					priv->state = cur ?
+						LFCART_INSERTING :
+						LFCART_REMOVING;
+				break;
+			case LFCART_INSERTING:
+				if (cur)
+					priv->debounce++;
+				else {
+					priv->debounce = 0;
+					priv->state = LFCART_IDLE;
+				}
+				break;
+			case LFCART_REMOVING:
+				if (!cur)
+					priv->debounce++;
+				else {
+					priv->debounce = 0;
+					priv->state = LFCART_IDLE;
+				}
+				break;
+		}
+
+		if (priv->state > LFCART_IDLE &&
+				priv->debounce >= priv->debounce_level) {
+
+			if (cur)
+				lfcart_report_insert(priv);
+			else
+				lfcart_report_remove(priv);
+
+			priv->state = LFCART_IDLE;
+			priv->debounce = 0;
+			priv->inserted = cur;
+		}
+
+		msleep(60);
+	}
+
+	return 0;
+}
+
+/*
+ * Module
+ */
+
+static struct lfcart_priv *lfcart = NULL;
+
+int __init lfcart_init(void)
+{
+	int ret;
+
+	lfcart = kzalloc(sizeof(struct lfcart_priv), GFP_KERNEL);
+	if (!lfcart)
+		return -ENOMEM;
+	lfcart->debounce_level = 5;
+
+	gpio_configure_pin(NAND_CART_DETECT_PORT, NAND_CART_DETECT_PIN,
+			GPIO_GPIOFN, 0, 0, 0);
+
+	ret = bus_register(&lfcart_bus_type);
+	if (ret)
+		return ret;
+
+	sema_init(&lfcart->detect_thread_done, 0);
+	lfcart->run = 1;
+	lfcart->detect_thread = kthread_run(lfcart_detect, (void *)lfcart,
+			"lfcart-detect");
+
+	lfcart->debug = debugfs_create_dir("lfcart", NULL);
+	if (IS_ERR(lfcart->debug))
+		lfcart->debug = NULL;
+
+	if (lfcart->debug)
+		debugfs_create_u32("debounce", S_IRWXUGO, lfcart->debug,
+				&lfcart->debounce_level);
+
+	return 0;
+}
+
+void __exit lfcart_exit(void)
+{
+	lfcart->run = 0;
+	down(&lfcart->detect_thread_done);
+	if (lfcart->inserted)
+		lfcart_report_remove(lfcart);
+	bus_unregister(&lfcart_bus_type);
+	if (lfcart->debug)
+		debugfs_remove(lfcart->debug);
+	kfree(lfcart);
+}
+
+module_init(lfcart_init);
+module_exit(lfcart_exit);
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/Makefile linux-2.6/drivers/lf1000/Makefile
--- linux-2.6.31/drivers/lf1000/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/Makefile	2012-11-16 11:57:57.000000000 -0800
@@ -0,0 +1,13 @@
+#
+# Makefile for the kernel LF1000 device drivers.
+#
+
+lf1000-ga3d-objs := ga3d.o
+
+obj-$(CONFIG_LF1000_GA3D)	+= lf1000-ga3d.o
+obj-$(CONFIG_LF1000_MLC)	+= mlc/
+obj-$(CONFIG_LF1000_DPC)	+= dpc/
+obj-$(CONFIG_LF1000_IDCT)	+= idct.o
+obj-$(CONFIG_LFCART)		+= lfcart.o
+obj-$(CONFIG_DIDJ_VOLUME)	+= didj-volume.o
+obj-$(CONFIG_GPSP_WARM)		+= warm/
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/main.c linux-2.6/drivers/lf1000/mlc/main.c
--- linux-2.6.31/drivers/lf1000/mlc/main.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/main.c	2011-01-04 15:10:46.000000000 -0800
@@ -0,0 +1,929 @@
+/* 
+ * drivers/lf1000/mlc/main.c
+ *
+ * LF1000 Multi-Layer Controller (MLC) Driver 
+ *
+ * Copyright 2007 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ *
+ * Note: this driver is deprecated.  Do not add any new functionality.
+ * - framebuffer functionality has been moved to drivers/video/lf1000fb.c
+ * - TODO: implement additional features as platform code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/lf1000/mlc_ioctl.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/mlc.h>
+
+#include "mlc_hal.h"
+#include "mlc_priv.h"
+#include "../dpc/dpc_config.h"
+
+/* device private data */
+struct mlc_device mlc = {
+	.mem = NULL,
+};
+
+/* 
+ * frame buffer memory
+ */
+
+#if !defined CONFIG_LF1000_MLC_RESERVE_MEMORY
+#warning Reserving 0 bytes for MLC frame buffer!
+#define CONFIG_LF1000_MLC_RESERVE_MEMORY 0
+#endif
+
+#define BYTES_PP		4
+#define FB_SIZE_BASE		(X_RESOLUTION*Y_RESOLUTION*BYTES_PP)
+#if (FB_SIZE_BASE % 4096) != 0
+#define FB_SIZE		((FB_SIZE_BASE/4096+1)*4096)
+#else
+#define FB_SIZE		FB_SIZE_BASE
+#endif
+
+#define SZ_1MB			(1024*1024)
+#define RESERVE			((CONFIG_LF1000_MLC_RESERVE_MEMORY)*SZ_1MB)
+
+/* 
+ * per-layer framebuffer organization for MagicEyes OpenGL support
+ */
+
+/* LF1000 YUV stride must be 4kB */
+#if (CONFIG_LF1000_MLC_RESERVE_MEMORY > 16)
+#if 1   // 16sep09pm Change OGL buffer to 15MB and increase YUV to 2 MB
+#define OGL_SIZE		(15 * SZ_1MB)	/* 15 MB on a 64MB system */
+#define RGB_SIZE		(RESERVE - OGL_SIZE - 2*SZ_1MB)
+#define YUV_SIZE		(RESERVE - OGL_SIZE - RGB_SIZE)
+#else   // repository version
+#define OGL_SIZE		(16 * SZ_1MB)	/* 16 MB on a 64MB system */
+#define RGB_SIZE		(RESERVE - OGL_SIZE - SZ_1MB)
+#define YUV_SIZE		(RESERVE - OGL_SIZE - RGB_SIZE)
+#endif  // 16sep09pm
+#else
+#define OGL_SIZE		(RESERVE - SZ_1MB) /* 13 MB on a 14MB system */
+#define RGB_SIZE		FB_SIZE /* 300kB */
+/* In reality, the YUV frame buffer must be Y_RESOLUTION*4kB.  We don't have
+ * enough memory to make this happen.  Instead, we let the YUV frame buffer
+ * encroach on the OGL frame buffer.  One day, we will probably have to solve
+ * this problem the right way.  For now, we just make it as big as possible,
+ * which is the amount of extra ram in our system minus the OGL and RGB
+ * regions.  The "extra ram" is 14MB (CONFIG_LF1000_MLC_RESERVE_MEMORY), which
+ * is removed from the kernel with the mem= argument.
+ */
+#define YUV_SIZE		(RESERVE - OGL_SIZE - RGB_SIZE) /* 724kB */
+#endif
+
+#define	RGB_BASE		0
+#define YUV_BASE		(RGB_BASE + RGB_SIZE)
+#define OGL_BASE		(YUV_BASE + YUV_SIZE)
+
+/* layer organization */
+#ifdef CPU_LF1000
+unsigned int fboffset[MLC_NUM_LAYERS] = {RGB_BASE, OGL_BASE, YUV_BASE};
+unsigned int fbsize[MLC_NUM_LAYERS] = {RGB_SIZE, OGL_SIZE, YUV_SIZE};
+#else
+unsigned int fboffset[MLC_NUM_LAYERS] = {RGB_BASE, OGL_BASE, RGB_BASE, YUV_BASE};
+unsigned int fbsize[MLC_NUM_LAYERS] = {RGB_SIZE, OGL_SIZE, RGB_SIZE, YUV_SIZE};
+#endif
+
+static u32 mlc_fb_addr;
+static u32 mlc_fb_size;
+
+/*******************
+ * sysfs Interface *
+ *******************/
+
+#ifdef CONFIG_LF1000_MLC_DEBUG
+static ssize_t show_top_registers(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	
+	len += sprintf(buf+len,"MLCCONTROLT   = 0x%08X\n",
+				   ioread32(mlc.mem+MLCCONTROLT));
+	len += sprintf(buf+len,"MLCSCREENSIZE = 0x%08X\n",
+				   ioread32(mlc.mem+MLCSCREENSIZE));
+	len += sprintf(buf+len,"MLCBGCOLOR    = 0x%08X\n",
+				   ioread32(mlc.mem+MLCBGCOLOR));
+	len += sprintf(buf+len,"MLCCLKENB     = 0x%08X\n", 
+				   ioread32(mlc.mem+MLCCLKENB));
+
+	return len; 
+}
+static DEVICE_ATTR(registers_top, S_IRUSR|S_IRGRP, show_top_registers, NULL);
+
+static ssize_t show_layer_registers(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	char x;
+	int layer;
+	void *base = mlc.mem;
+
+	for(layer = 0; layer < MLC_NUM_LAYERS; layer++) {
+		x = layer+'0';
+#if defined CPU_MF2530F
+		/* layer registers are evenly spaced */
+		base += layer*0x20;
+		len += sprintf(buf+len,"MLCLEFTOP%c      = 0x%08X\n", x,
+					   ioread32(base+MLCLEFTOP0));
+		len += sprintf(buf+len,"MLCRIGHTBOTTOM%c = 0x%08X\n", x,
+					   ioread32(base+MLCRIGHTBOTTOM0));
+		len += sprintf(buf+len,"MLCCONTROL%c     = 0x%08X\n", x,
+					   ioread32(base+MLCCONTROL0));
+		len += sprintf(buf+len,"MLCHSTRIDE%c     = 0x%08X\n", x,
+					   ioread32(base+MLCHSTRIDE0));
+		len += sprintf(buf+len,"MLCVSTRIDE%c     = 0x%08X\n", x,
+					   ioread32(base+MLCVSTRIDE0));
+		len += sprintf(buf+len,"MLCTPCOLOR%c     = 0x%08X\n", x,
+					   ioread32(base+MLCTPCOLOR0));
+		len += sprintf(buf+len,"MLCINVCOLOR%c    = 0x%08X\n", x,
+					   ioread32(base+MLCINVCOLOR0));
+		len += sprintf(buf+len,"MLCADDRESS%c     = 0x%08X\n", x,
+					   ioread32(base+MLCADDRESS0));
+#elif defined CPU_LF1000
+		/* LF1000 layer registers are not evenly spaced */
+		switch (layer) {
+		case 0:
+			len += sprintf(buf+len,"MLCCONTROL%c     = 0x%08X\n", 
+					x, ioread32(base+MLCCONTROL0));
+			len += sprintf(buf+len,"MLCHSTRIDE%c     = 0x%08X\n", 
+					x, ioread32(base+MLCHSTRIDE0));
+			len += sprintf(buf+len,"MLCVSTRIDE%c     = 0x%08X\n", 
+					x, ioread32(base+MLCVSTRIDE0));
+			len += sprintf(buf+len,"MLCADDRESS%c     = 0x%08X\n", 
+					x, ioread32(base+MLCADDRESS0));
+			break;
+		case 1:
+			len += sprintf(buf+len,"MLCCONTROL%c     = 0x%08X\n", 
+					x, ioread32(base+MLCCONTROL1));
+			len += sprintf(buf+len,"MLCHSTRIDE%c     = 0x%08X\n", 
+					x, ioread32(base+MLCHSTRIDE1));
+			len += sprintf(buf+len,"MLCVSTRIDE%c     = 0x%08X\n", 
+					x, ioread32(base+MLCVSTRIDE1));
+			len += sprintf(buf+len,"MLCADDRESS%c     = 0x%08X\n", 
+					x, ioread32(base+MLCADDRESS1));
+			break;
+		case 2:
+			len += sprintf(buf+len,"MLCCONTROL%c     = 0x%08X\n", 
+					x, ioread32(base+MLCCONTROL2));
+			len += sprintf(buf+len,"MLCVSTRIDE%c     = 0x%08X\n", 
+					x, ioread32(base+MLCVSTRIDE3));
+			len += sprintf(buf+len,"MLCADDRESS%c     = 0x%08X\n", 
+					x, ioread32(base+MLCADDRESS3));
+			break;
+		}
+#endif /* CPU_LF1000 */
+	}
+
+	return len;
+}
+static DEVICE_ATTR(registers_layer, S_IRUSR|S_IRGRP, 
+				show_layer_registers, NULL);
+
+
+static struct attribute *mlc_attributes[] = {
+	&dev_attr_registers_top.attr,
+	&dev_attr_registers_layer.attr,
+	NULL
+};
+
+static struct attribute_group mlc_attr_group = {
+	.attrs = mlc_attributes
+};
+#endif /* CONFIG_LF1000_MLC_DEBUG */
+
+/*******************************
+ * character device operations *
+ *******************************/
+
+int mlc_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+/* CAREFUL:
+ * This ioctl returns addresses which might be <0, so callers of this
+ * routine now test against -EFAULT.  Any other value is considered success.
+ *
+ * !! ADD NEW ERROR RETURN VALUES AT YOUR OWN PERIL !!
+ *
+ */
+int mlc_layer_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+					unsigned long arg)
+{
+	int retval = 0;
+	void __user *argp = (void __user *)arg;
+	union mlc_cmd c;
+	struct mlc_layer *layer;
+
+	layer = container_of(inode->i_cdev, struct mlc_layer, dev);
+
+	switch(cmd) {
+		case MLC_IOCTLAYEREN:
+		retval = mlc_SetLayerEnable(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetLayerEnable(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCQLAYEREN:
+		retval = mlc_GetLayerEnable(layer->id);
+		break;
+		
+		case MLC_IOCTADDRESS:
+		retval = mlc_SetAddress(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetAddress(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTADDRESSCB:
+		retval = mlc_SetAddressCb(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetAddressCb(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTADDRESSCR:
+		retval = mlc_SetAddressCr(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetAddressCr(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTLOCKSIZE:
+		retval = mlc_SetLockSize(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetLockSize(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTHSTRIDE:
+		retval = mlc_SetHStride(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetHStride(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTVSTRIDE:
+		retval = mlc_SetVStride(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetVStride(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCT3DENB:
+		retval = mlc_Set3DEnable(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_Set3DEnable(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTALPHA:
+		retval = mlc_SetTransparencyAlpha(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetTransparencyAlpha(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCQALPHA:
+		retval = mlc_GetTransparencyAlpha(layer->id);
+		break;
+
+		case MLC_IOCQFBSIZE:
+		if (layer->id > MLC_NUM_LAYERS)
+			return -EFAULT;
+		retval = fbsize[layer->id];
+		break;
+
+		case MLC_IOCTTPCOLOR:
+		retval = mlc_SetTransparencyColor(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetTransparencyColor(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCSPOSITION:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, 
+				  sizeof(struct position_cmd)))
+			return -EFAULT;
+		retval = mlc_SetPosition(layer->id,
+					 c.position.top,
+					 c.position.left,
+					 c.position.right,
+					 c.position.bottom);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetPosition(layer->id,
+						 c.position.top,
+						 c.position.left,
+						 c.position.right,
+						 c.position.bottom);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+#ifdef CPU_LF1000
+		case MLC_IOCSINVISIBLEAREA:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, 
+				  sizeof(struct position_cmd)))
+			return -EFAULT;
+		retval = mlc_SetLayerInvisibleArea(layer->id,
+						   c.position.top,
+					  	   c.position.left,
+					  	   c.position.right,
+					  	   c.position.bottom);
+		break;
+#endif 
+
+		case MLC_IOCTFORMAT:
+		retval = mlc_SetFormat(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetFormat(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTBLEND:
+		retval = mlc_SetBlendEnable(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetBlendEnable(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTTRANSP:
+		retval = mlc_SetTransparencyEnable(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetTransparencyEnable(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTINVERT:
+		retval = mlc_SetInvertEnable(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetInvertEnable(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTINVCOLOR:
+		retval = mlc_SetInvertColor(layer->id, arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetInvertColor(layer->id, arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTDIRTY:
+		retval = mlc_SetDirtyFlag(layer->id);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetDirtyFlag(layer->id);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCQDIRTY:
+		/* query 2nd MLC for proper sync on TV + LCD out */
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_GetDirtyFlag(layer->id);
+			mlc.mem -= 0x400;
+		} else {
+			retval = mlc_GetDirtyFlag(layer->id);
+		}
+		break;
+
+		case MLC_IOCGPOSITION:
+		if(!(_IOC_DIR(cmd) & _IOC_READ))
+			return -EFAULT;
+		retval = mlc_GetPosition(layer->id, 
+					 (struct mlc_layer_position *)&c);
+		if(retval < 0)
+			return retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct position_cmd)))
+			return -EFAULT;
+		break;
+
+#ifdef CPU_LF1000
+		case MLC_IOCGINVISIBLEAREA:
+		if(!(_IOC_DIR(cmd) & _IOC_READ))
+			return -EFAULT;
+		retval = mlc_GetLayerInvisibleArea(layer->id, 
+					(struct mlc_layer_position *)&c);
+		if(retval < 0)
+			return retval;
+		if(copy_to_user(argp, (void *)&c, sizeof(struct position_cmd)))
+			return -EFAULT;
+		break;
+#endif 
+
+		case MLC_IOCQHSTRIDE:
+		retval = mlc_GetHStride(layer->id);
+		break;
+
+		case MLC_IOCQVSTRIDE:
+		retval = mlc_GetVStride(layer->id);
+		break;
+
+		case MLC_IOCQFORMAT:
+		if(mlc_GetFormat(layer->id, &retval) < 0)
+			return -EFAULT;
+		break;
+
+		case MLC_IOCQADDRESS:
+		if(mlc_GetAddress(layer->id, &retval) < 0)
+			return -EFAULT;
+		break;
+
+		case MLC_IOCSOVERLAYSIZE:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, 
+				  sizeof(struct overlaysize_cmd)))
+			return -EFAULT;
+		retval = mlc_SetOverlaySize(layer->id,
+					    c.overlaysize.srcwidth,
+					    c.overlaysize.srcheight,
+					    c.overlaysize.dstwidth,
+					    c.overlaysize.dstheight);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetOverlaySize(layer->id,
+						    c.overlaysize.srcwidth,
+						    c.overlaysize.srcheight,
+						    c.overlaysize.dstwidth,
+						    c.overlaysize.dstheight);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCGOVERLAYSIZE:
+		if(!(_IOC_DIR(cmd) & _IOC_READ))
+			return -EFAULT;
+		retval = mlc_GetOverlaySize(layer->id, 
+					    (struct mlc_overlay_size *)&c);
+		if(retval < 0)
+			return retval;
+		if(copy_to_user(argp, (void *)&c, 
+				sizeof(struct overlaysize_cmd)))
+			return -EFAULT;
+		break;
+
+#ifdef CPU_LF1000
+		case MLC_IOCTINVISIBLE:
+		retval = mlc_SetLayerInvisibleAreaEnable(layer->id, arg);
+		break;
+#endif 
+
+#ifdef CPU_LF1000
+		case MLC_IOCQINVISIBLE:
+		retval = mlc_GetLayerInvisibleAreaEnable(layer->id);
+		break;
+#endif 
+
+		default:
+		return -EFAULT;
+	}
+
+	return retval;
+}
+
+int mlc_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+			  unsigned long arg)
+{
+	int retval = 0;
+	void __user *argp = (void __user *)arg;
+	union mlc_cmd c;
+
+	switch(cmd) {
+		case MLC_IOCTENABLE:
+		mlc_SetMLCEnable(arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			mlc_SetMLCEnable(arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTBACKGND:
+		mlc_SetBackground(arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			mlc_SetBackground(arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTPRIORITY:
+		retval = mlc_SetLayerPriority(arg);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetLayerPriority(arg);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCTTOPDIRTY:
+		mlc_SetTopDirtyFlag();
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			mlc_SetTopDirtyFlag();
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCSSCREENSIZE:
+		if(!(_IOC_DIR(cmd) & _IOC_WRITE))
+			return -EFAULT;
+		if(copy_from_user((void *)&c, argp, sizeof(struct screensize_cmd)))
+			return -EFAULT;
+		retval = mlc_SetScreenSize(c.screensize.width,
+					   c.screensize.height);
+		if (gpio_have_tvout()) {
+			mlc.mem += 0x400;
+			retval = mlc_SetScreenSize(c.screensize.width,
+						   c.screensize.height);
+			mlc.mem -= 0x400;
+		}
+		break;
+
+		case MLC_IOCQBACKGND:
+		retval = mlc_GetBackground();
+		break;
+
+		case MLC_IOCQPRIORITY:
+		retval = mlc_GetLayerPriority();
+		break;
+
+		case MLC_IOCGSCREENSIZE:
+		if(!(_IOC_DIR(cmd) & _IOC_READ))
+			return -EFAULT;
+		mlc_GetScreenSize((struct mlc_screen_size *)&c);
+		if(copy_to_user(argp, (void *)&c, sizeof(struct screensize_cmd)))
+			return -EFAULT;
+		break;
+
+		case MLC_IOCQADDRESS:
+		retval = mlc_fb_addr;
+		break;
+
+		case MLC_IOCQFBSIZE:
+		retval =  mlc_fb_size;
+		break;
+
+		default:
+		return -ENOTTY;
+	}
+
+	return retval;
+}
+
+static void mlc_layer_vma_open(struct vm_area_struct *vma)
+{
+	//printk(KERN_DEBUG "mlc: vma_open virt:%lX, phs %lX\n",
+	//		vma->vm_start, vma->vm_pgoff<<PAGE_SHIFT);
+}
+
+static void mlc_layer_vma_close(struct vm_area_struct *vma)
+{
+	//printk(KERN_DEBUG "mlc: vma_close\n");
+}
+
+struct vm_operations_struct mlc_layer_vm_ops = {
+	.open  = mlc_layer_vma_open,
+	.close = mlc_layer_vma_close,
+};
+
+static int mlc_layer_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_ops = &mlc_layer_vm_ops;
+	vma->vm_flags |= VM_IO;
+
+	ret = io_remap_pfn_range(vma,
+				 vma->vm_start, 
+				 vma->vm_pgoff, 
+				 vma->vm_end - vma->vm_start, 
+				 vma->vm_page_prot);
+	if(ret < 0) {
+		printk(KERN_ALERT "mlc: failed to mmap\n");
+		return -EAGAIN;
+	}
+
+	mlc_layer_vma_open(vma);
+	return 0;
+}
+
+static ssize_t mlc_layer_write(struct file *filp, const char __user *buf,
+				   size_t count, loff_t *f_pos)
+{
+	int ret;
+	struct mlc_layer *layer;
+
+	layer = container_of(filp->f_dentry->d_inode->i_cdev, 
+				 struct mlc_layer, dev);
+
+	if(*f_pos >= fbsize[layer->id])
+		return -EFAULT;
+
+	ret = copy_from_user(layer->fb + *f_pos, buf, count);
+	if(ret < 0)
+		return -EFAULT;
+
+	*f_pos += (count - ret);
+	return ret;
+}
+
+struct file_operations mlc_fops = {
+	.owner = THIS_MODULE,
+	.open  = mlc_open,
+	.ioctl = mlc_ioctl,
+};
+
+struct file_operations mlc_layer_fops = {
+	.owner = THIS_MODULE,
+	.write = mlc_layer_write,
+	.ioctl = mlc_layer_ioctl,
+	.mmap  = mlc_layer_mmap,
+};
+
+#ifdef CONFIG_PM
+static int lf1000_mlc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int lf1000_mlc_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lf1000_mlc_suspend	NULL
+#define lf1000_mlc_resume	NULL
+#endif
+
+/* Get MLC FB address and size from mlc_fb=ADDR,SIZE kernel cmd line arg */
+// module_param (mlc_fb_addr, ulong, 0400);
+// module_param (mlc_fb_size, ulong, 0400);
+static int __init mlc_fb_setup(char *str)
+{
+	char *s;
+	mlc_fb_addr = simple_strtol(str, &s, 0);
+	if (*s == ',')
+		mlc_fb_size = simple_strtol(s+1, &s, 0);
+	return 1;
+}
+
+__setup("mlc_fb=", mlc_fb_setup);
+
+static int lf1000_mlc_probe(struct platform_device *pdev)
+{
+	int ret;
+	int i;
+	int addr,format,hstride,vstride;
+	struct resource *res;
+	struct mlc_screen_size screen;
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);	
+	if(!res) {
+		printk(KERN_ERR "mlc: failed to get resource\n");
+		return -ENXIO;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1, 
+				"MLC" )) {
+		printk(KERN_ERR "mlc: failed to request mem region" );
+		return -EBUSY;
+	}
+
+	mlc.mem = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(mlc.mem == NULL) {
+		printk(KERN_ERR "mlc: failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	printk (KERN_NOTICE "*** MLC mlc_fb_addr=%08x size=%08x fb[0]=%08x ***\n",
+		mlc_fb_addr, mlc_fb_size, mlc_fb_addr+fboffset[0]);
+
+	for(i = 0; i < MLC_NUM_LAYERS; i++) {
+		mlc.layer[i].fb = ioremap_nocache(mlc_fb_addr+fboffset[i],
+						  fbsize[i]);
+		if(mlc.layer[i].fb == NULL) {
+			ret = -ENOMEM;
+			goto fail_remap_fb;
+		}
+	}
+	
+	/***********************
+ 	 * set up the hardware *
+ 	 ***********************/
+
+	/* MLC top layer is already setup by bootloader */
+	mlc_GetScreenSize(&screen);
+	printk (KERN_NOTICE "*** MLC screen size=%dx%d ***\n", screen.width, screen.height);
+	
+	mlc_SetClockMode(PCLKMODE_ONLYWHENCPUACCESS, BCLKMODE_DYNAMIC);
+	if (screen.width < X_RESOLUTION || screen.height < Y_RESOLUTION)
+		mlc_SetScreenSize(X_RESOLUTION, Y_RESOLUTION);
+	ret = mlc_SetLayerPriority(DISPLAY_VID_LAYER_PRIORITY);
+	if(ret < 0)
+		printk(KERN_ALERT "mlc: failed to set layer priority %08X\n",
+			   DISPLAY_VID_LAYER_PRIORITY);
+	mlc_SetFieldEnable(0);
+
+	for(i = 0; i < MLC_NUM_LAYERS; i++) {
+		mlc_SetAddress(i, mlc_fb_addr+fboffset[i]);
+		init_MUTEX_LOCKED(&mlc.layer[i].sem);
+	}
+	/* layer0 is already setup by bootloader */
+	mlc_GetAddress(0, &addr);
+	mlc_GetFormat(0, &format);
+	hstride = mlc_GetHStride(0);
+	vstride = mlc_GetVStride(0);
+	mlc_SetLayerEnable(0, true);
+	mlc_SetDirtyFlag(0);
+	mlc_SetBackground(0x000000);
+	mlc_SetMLCEnable(1);
+	mlc_SetTopDirtyFlag();
+	
+	/* 2nd MLC for 2nd DPC to TV out */
+	if (gpio_have_tvout()) {
+		mlc.mem += 0x400;
+		mlc_SetClockMode(PCLKMODE_ONLYWHENCPUACCESS, BCLKMODE_DYNAMIC);
+		mlc_SetScreenSize(X_RESOLUTION, Y_RESOLUTION);
+		ret = mlc_SetLayerPriority(DISPLAY_VID_LAYER_PRIORITY);
+		if(ret < 0)
+			printk(KERN_ALERT "mlc: failed to set layer priority %08X\n",
+				   DISPLAY_VID_LAYER_PRIORITY);
+		mlc_SetFieldEnable(0);
+		for(i = 0; i < MLC_NUM_LAYERS; i++) {
+			mlc_SetAddress(i, mlc_fb_addr+fboffset[i]);
+		}
+		mlc_SetFormat(0, format);
+		mlc_SetHStride(0, hstride);
+		mlc_SetVStride(0, vstride);
+		mlc_SetPosition(0, 0, 0, X_RESOLUTION, Y_RESOLUTION);
+		mlc_SetLayerEnable(0, true);
+		mlc_SetDirtyFlag(0);
+		mlc_SetBackground(0xFFFFFF);
+		mlc_SetMLCEnable(1);
+		mlc_SetTopDirtyFlag();
+		mlc.mem -= 0x400;
+	}
+	
+	/********************
+ 	 * register devices *
+ 	 ********************/
+
+	cdev_init(&mlc.dev, &mlc_fops);
+	mlc.dev.owner = THIS_MODULE;
+	mlc.dev.ops = &mlc_fops;
+	ret = cdev_add(&mlc.dev, MKDEV(MLC_MAJOR,0), 1);
+	if(ret < 0) {
+		printk(KERN_ERR "mlc: failed to create character device\n");
+		goto fail_add_dev;
+	}
+
+	for(i = 0; i < MLC_NUM_LAYERS; i++) {
+		cdev_init(&(mlc.layer[i].dev), &mlc_layer_fops);
+		mlc.layer[i].dev.owner = THIS_MODULE;
+		mlc.layer[i].dev.ops = &mlc_layer_fops;
+		mlc.layer[i].id = i;
+		ret = cdev_add(&mlc.layer[i].dev, MKDEV(MLC_LAYER_MAJOR,i), 1);
+		if(ret < 0) {
+			printk(KERN_ERR "mlc: failed to create layer dev %d\n",
+				i);
+			goto fail_add_layers;
+		}
+	}
+
+#ifdef CONFIG_LF1000_MLC_DEBUG
+	sysfs_create_group(&pdev->dev.kobj, &mlc_attr_group);
+#endif
+
+	return 0;
+
+fail_add_layers:
+	cdev_del(&mlc.dev); /* remove main MLC device */
+	for(i -= 1; i >= 0; i--) /* remove layer devices */
+		cdev_del(&mlc.layer[i].dev);
+	i = MLC_NUM_LAYERS; /* all frame buffers were remapped */
+fail_add_dev:
+fail_remap_fb:
+	iounmap(mlc.mem);
+	for(i -= 1; i > 0; i--) {/* release frame buffers that were remapped */
+		iounmap(mlc.layer[i].fb);
+		release_mem_region(mlc_fb_addr+fboffset[i], fbsize[i]);
+	}
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return ret;
+}
+
+static int lf1000_mlc_remove(struct platform_device *pdev)
+{
+	int i;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);	
+
+#ifdef CONFIG_LF1000_MLC_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &mlc_attr_group);
+#endif
+	cdev_del(&mlc.dev);
+	for(i = 0; i < MLC_NUM_LAYERS; i++) {
+		cdev_del(&(mlc.layer[i].dev));
+		iounmap(mlc.layer[i].fb);
+		release_mem_region(mlc_fb_addr+fboffset[i], fbsize[i]);
+	}
+
+	iounmap(mlc.mem);
+	release_mem_region(res->start, (res->end - res->start)+1);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_mlc_driver = {
+	.probe		= lf1000_mlc_probe,
+	.remove		= lf1000_mlc_remove,
+	.suspend	= lf1000_mlc_suspend,
+	.resume		= lf1000_mlc_resume,
+	.driver		= {
+		.name   = "lf1000-mlc",
+		.owner  = THIS_MODULE,
+	},
+};
+
+/**************************************
+ *  module initialization and cleanup *
+ **************************************/
+
+static int __init mlc_init(void)
+{
+	return platform_driver_register(&lf1000_mlc_driver);
+}
+
+static void __exit mlc_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_mlc_driver);
+}
+
+module_init(mlc_init);
+module_exit(mlc_cleanup);
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_VERSION("1:0.1");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/Makefile linux-2.6/drivers/lf1000/mlc/Makefile
--- linux-2.6.31/drivers/lf1000/mlc/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,6 @@
+#
+# Makefile for the linux kernel.
+#
+lf1000-mlc-objs := main.o mlc.o 
+
+obj-$(CONFIG_LF1000_MLC)		+= lf1000-mlc.o
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/mlc.c linux-2.6/drivers/lf1000/mlc/mlc.c
--- linux-2.6.31/drivers/lf1000/mlc/mlc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/mlc.c	2011-01-04 15:05:57.000000000 -0800
@@ -0,0 +1,810 @@
+/* 
+ * drivers/lf1000/mlc/mlc.c
+ *
+ * LF1000 Multi-Layer Controller (MLC) Driver 
+ *
+ * Copyright 2007 Leapfrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/mlc.h>
+#include <mach/common.h>
+
+#include "mlc_hal.h"
+#include "mlc_priv.h"
+
+extern struct mlc_device mlc;
+
+static void *SelectLayerControl(u8 layer)
+{
+	void *ctl = mlc.mem;
+
+	if(!mlc.mem) {
+		return 0;
+	}
+	switch(layer) {
+		case 0:
+		ctl += MLCCONTROL0;
+		break;
+		case 1:
+		ctl += MLCCONTROL1;
+		break;
+		case 2:
+		ctl += MLCCONTROL2;
+		break;
+		default:
+		return 0;
+	}
+
+	return ctl;
+}
+
+/****************
+ * API Routines *
+ ****************/
+
+int mlc_SetAddress(u8 layer, u32 addr)
+{
+	void *reg = NULL;
+
+	if(layer > MLC_NUM_LAYERS) 
+		return -EINVAL;
+
+	if(!mlc.mem)
+		return -ENOMEM;
+	
+#if 0	/* MCU registers need to be mapped */
+	if (layer == MLC_VIDEO_LAYER) {
+		u32 tmp = ioread32(MEMCONTROL);
+		if (addr & 0x20000000)
+			tmp |= 1;
+		else
+			tmp &= ~1;
+		iowrite32(tmp, MEMCONTROL);
+	}
+#endif		
+
+	switch(layer) {
+		case 0:
+		reg = mlc.mem+MLCADDRESS0;
+		break;
+		case 1:
+		reg = mlc.mem+MLCADDRESS1;
+		break;
+		case 2:
+		reg = mlc.mem+MLCADDRESS3; /* note: weird datasheet naming */
+		break;
+	}
+	iowrite32(addr, reg);
+	return 0;
+}
+
+int mlc_SetAddressCb(u8 layer, u32 addr)
+{
+	if (layer != MLC_VIDEO_LAYER) 
+		return -EINVAL;
+	iowrite32(addr, mlc.mem+MLCADDRESSCB);
+	return 0;
+}
+
+int mlc_SetAddressCr(u8 layer, u32 addr)
+{
+	if (layer != MLC_VIDEO_LAYER) 
+		return -EINVAL;
+	iowrite32(addr, mlc.mem+MLCADDRESSCR);
+	return 0;
+}
+
+int mlc_GetAddress(u8 layer, int *addr) /* FIXME */
+{
+	void *reg = NULL;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+	
+	switch(layer) {
+		case 0:
+		reg = mlc.mem+MLCADDRESS0;
+		break;
+		case 1:
+		reg = mlc.mem+MLCADDRESS1;
+		break;
+		case 2:
+		reg = mlc.mem+MLCADDRESS3; /* note: weird datasheet naming */
+		break;
+	}
+
+	*addr = ioread32(reg);
+	return 0;
+}
+
+int mlc_SetHStride(u8 layer, u32 hstride)
+{
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	hstride &= 0x7FFFFFFF;
+	iowrite32(hstride,mlc.mem+MLCHSTRIDE0+layer*0x34);
+	return 0;
+}
+
+int mlc_GetHStride(u8 layer)
+{
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	return ioread32(mlc.mem+MLCHSTRIDE0+layer*0x34);
+}
+
+int mlc_SetVStride(u8 layer, u32 vstride)
+{
+	void *reg = NULL;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	switch(layer) {
+		case 0:
+		reg = mlc.mem+MLCVSTRIDE0;
+		break;
+		case 1:
+		reg = mlc.mem+MLCVSTRIDE1;
+		break;
+		case 2:
+		reg = mlc.mem+MLCVSTRIDE3; /* note: weird datasheet naming */
+		break;
+	}
+
+	iowrite32(vstride, reg);
+	if (layer == MLC_VIDEO_LAYER) {
+		iowrite32(vstride, mlc.mem+MLCSTRIDECB);
+		iowrite32(vstride, mlc.mem+MLCSTRIDECR);
+	}
+	return 0;
+}
+
+int mlc_GetVStride(u8 layer)
+{
+	void *reg = NULL;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	switch(layer) {
+		case 0:
+		reg = mlc.mem+MLCVSTRIDE0;
+		break;
+		case 1:
+		reg = mlc.mem+MLCVSTRIDE1;
+		break;
+		case 2:
+		reg = mlc.mem+MLCVSTRIDE3; /* note: weird datasheet naming */
+		break;
+	}
+	return ioread32(reg);
+}
+
+int mlc_SetLockSize(u8 layer, u32 locksize)
+{
+	u32 tmp;
+	void *reg;
+
+	/* make sure we're working with a valid lock size */
+	if(!(locksize == 4 || locksize == 8 || locksize == 16))
+		return -EINVAL;
+
+	if(layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	tmp &= ~(3<<LOCKSIZE);
+	tmp |= ((locksize/8)<<LOCKSIZE);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetLockSize(u8 layer, int *locksize) /*FIXME*/
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer == MLC_VIDEO_LAYER || layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	*locksize = ((tmp & (3<<LOCKSIZE))>>LOCKSIZE)*8;
+	return 0;
+}
+
+int mlc_SetBlendEnable(u8 layer, u8 en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	en ? BIT_SET(tmp,BLENDENB) : BIT_CLR(tmp,BLENDENB);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetBlendEnable(u8 layer, int *en) /*FIXME*/
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	*en = IS_SET(tmp,BLENDENB) ? 1 : 0;
+	return 0;
+}
+
+int mlc_SetTransparencyEnable(u8 layer, u8 en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	en ? BIT_SET(tmp,TPENB) : BIT_CLR(tmp,TPENB);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetTransparencyEnable(u8 layer, int *en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+
+	tmp = ioread32(reg);
+	*en = IS_SET(tmp,TPENB) ? 1 : 0;
+	return 0;
+}
+
+int mlc_SetInvertEnable(u8 layer, u8 en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER) 
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+
+	tmp = ioread32(reg);
+	en ? BIT_SET(tmp,INVENB) : BIT_CLR(tmp,INVENB);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetInvertEnable(u8 layer, int *en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+
+	tmp = ioread32(reg);
+	*en = IS_SET(tmp,INVENB) ? 1 : 0;
+	return 0;
+}
+
+int mlc_SetTransparencyColor(u8 layer, u32 color)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer) + MLCTPCOLOR0 - MLCCONTROL0;
+
+	tmp = ioread32(reg);
+	tmp &= ~(0xFFFFFF<<TPCOLOR);
+	tmp |= ((0xFFFFFF & color)<<TPCOLOR);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetTransparencyColor(u8 layer, int *color)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer) + MLCTPCOLOR0 - MLCCONTROL0;
+	tmp = ioread32(reg);
+	*color = ((tmp & (0xFFFFFF<<TPCOLOR))>>TPCOLOR);
+	return 0;
+}
+
+int mlc_SetTransparencyAlpha(u8 layer, u8 alpha)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	if (layer == MLC_VIDEO_LAYER) 
+		reg = mlc.mem+MLCTPCOLOR3;
+	else
+		reg = mlc.mem+MLCTPCOLOR0+layer*0x34;
+
+	tmp = ioread32(reg);
+	tmp &= ~(0xF<<ALPHA);
+	tmp |= ((0xF & alpha)<<ALPHA);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetTransparencyAlpha(u8 layer)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	if (layer == MLC_VIDEO_LAYER) 
+		reg = mlc.mem+MLCTPCOLOR3;
+	else
+		reg = mlc.mem+MLCTPCOLOR0+layer*0x34;
+	
+	tmp = ioread32(reg);
+	return ((tmp & (0xF<<ALPHA))>>ALPHA);
+}
+
+int mlc_SetInvertColor(u8 layer, u32 color)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = mlc.mem+MLCINVCOLOR0+layer*0x34;
+	
+	tmp = ioread32(reg);
+	tmp &= ~(0xFFFFFF<<INVCOLOR);
+	tmp |= ((0xFFFFFF & color)<<INVCOLOR);
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetInvertColor(u8 layer, int *color)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = mlc.mem+MLCINVCOLOR0+layer*0x34;
+
+	tmp = ioread32(reg);
+	*color = ((tmp & (0xFFFFFF<<INVCOLOR))>>INVCOLOR);
+	return 0;
+}
+
+void mlc_SetTopDirtyFlag(void)
+{
+	u32 tmp = ioread32(mlc.mem+MLCCONTROLT);
+
+	BIT_SET(tmp,DITTYFLAG);
+	iowrite32(tmp,mlc.mem+MLCCONTROLT);
+}
+
+int mlc_Set3DEnable(u8 layer, u8 en)
+{
+	void *reg;
+	u32 tmp;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+
+	en ? BIT_SET(tmp,GRP3DENB) : BIT_CLR(tmp,GRP3DENB);
+	iowrite32(tmp, reg);
+	return 0;
+}
+
+int mlc_Get3DEnable(u8 layer, int *en) /*FIXME*/
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	*en = IS_SET(tmp,GRP3DENB) ? 1 : 0;
+	return 0;
+}
+
+void mlc_SetMLCEnable(u8 en)
+{
+	u32 tmp = ioread32(mlc.mem+MLCCONTROLT);
+
+	BIT_CLR(tmp,DITTYFLAG);
+
+	if(en) {
+		BIT_SET(tmp,PIXELBUFFER_PWD); 	/* power up */
+		iowrite32(tmp, mlc.mem+MLCCONTROLT);
+		BIT_SET(tmp,PIXELBUFFER_SLD); 	/* disable sleep */
+		iowrite32(tmp, mlc.mem+MLCCONTROLT);
+		BIT_SET(tmp,MLCENB);		/* enable */
+		iowrite32(tmp, mlc.mem+MLCCONTROLT);
+		BIT_SET(tmp,DITTYFLAG);
+	}
+	else {
+		BIT_CLR(tmp,MLCENB);		/* disable */
+		BIT_SET(tmp,DITTYFLAG);
+		iowrite32(tmp, mlc.mem+MLCCONTROLT);
+		do { /* wait for MLC to turn off */
+			tmp = ioread32(mlc.mem+MLCCONTROLT);
+		} while(IS_SET(tmp,DITTYFLAG));
+		BIT_CLR(tmp,PIXELBUFFER_SLD);	/* enable sleep */
+		iowrite32(tmp, mlc.mem+MLCCONTROLT);
+		BIT_CLR(tmp,PIXELBUFFER_PWD);	/* power down */
+	}
+
+	iowrite32(tmp,mlc.mem+MLCCONTROLT);
+}
+
+int mlc_SetScreenSize(u32 width, u32 height)
+{
+	if( width-1 >= 4096 || height-1 >= 4096 )
+		return -EINVAL;
+
+	iowrite32((((height-1)<<SCREENHEIGHT)|((width-1)<<SCREENWIDTH)),
+				mlc.mem+MLCSCREENSIZE);
+	return 0;
+}
+
+void mlc_GetScreenSize(struct mlc_screen_size *size)
+{
+	u32 tmp = ioread32(mlc.mem+MLCSCREENSIZE);
+
+	size->width  = ((tmp & (0x7FF<<SCREENWIDTH))>>SCREENWIDTH)+1;
+	size->height = ((tmp & (0x7FF<<SCREENHEIGHT))>>SCREENHEIGHT)+1;
+}
+
+void mlc_SetBackground(u32 color)
+{
+	iowrite32((0xFFFFFF & color),mlc.mem+MLCBGCOLOR);
+}
+
+u32 mlc_GetBackground(void)
+{
+	return ioread32(mlc.mem+MLCBGCOLOR);
+}
+
+void mlc_SetClockMode(u8 pclk, u8 bclk)
+{
+	u32 tmp = ioread32(mlc.mem+MLCCLKENB);
+
+	tmp &= ~(0xF);
+	tmp |= ((pclk<<_PCLKMODE)|(bclk<<BCLKMODE));
+	iowrite32(tmp,mlc.mem+MLCCLKENB);
+}
+
+int mlc_SetLayerPriority(u32 priority)
+{
+	u32 tmp;
+
+	if(priority >= VID_PRIORITY_INVALID)
+		return -EINVAL;
+
+	tmp = ioread32(mlc.mem+MLCCONTROLT);
+	tmp &= ~(0x3<<PRIORITY);
+	tmp |= (priority<<PRIORITY);
+	iowrite32(tmp,mlc.mem+MLCCONTROLT);
+	return 0;
+}
+
+u32 mlc_GetLayerPriority(void)
+{
+	u32 tmp = ioread32(mlc.mem+MLCCONTROLT);
+	return ((tmp & (0x3<<PRIORITY))>>PRIORITY);
+}
+
+void mlc_SetFieldEnable(u8 en)
+{
+	u32 tmp = ioread32(mlc.mem+MLCCONTROLT);
+	en ? BIT_SET(tmp,FIELDENB) : BIT_CLR(tmp,FIELDENB);
+	iowrite32(tmp,mlc.mem+MLCCONTROLT);
+}
+
+/* Note: on the LF1000, we can't set the format for the video layer */
+int mlc_SetFormat(u8 layer, enum RGBFMT format)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER || 
+			format > 0xFFFF)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	tmp &= ~(0xFFFF<<FORMAT); /* clear format bits */
+	tmp |= (format<<FORMAT); /* set format */
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetFormat(u8 layer, int *format)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	*format = ((tmp & (0xFFFF<<FORMAT))>>FORMAT);
+	return 0;
+}
+
+int mlc_SetPosition(u8 layer, s32 top, s32 left, s32 right, s32 bottom)
+{
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	right--;
+	bottom--;
+
+	top &= 0x7FF;
+	left &= 0x7FF;
+	right &= 0x7FF;
+	bottom &= 0x7FF;
+
+	iowrite32(((left<<LEFT)|(right<<RIGHT)),
+			mlc.mem+MLCLEFTRIGHT0+0x34*layer);
+	iowrite32(((top<<TOP)|(bottom<<BOTTOM)),
+			mlc.mem+MLCTOPBOTTOM0+0x34*layer);
+	return 0;
+}
+
+int mlc_GetPosition(u8 layer, struct mlc_layer_position *p)
+{
+	u32 tmp;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	tmp = ioread32(mlc.mem+MLCLEFTRIGHT0+0x34*layer);
+	p->left = ((tmp & (0x7FF<<LEFT))>>LEFT);
+	p->right  = ((tmp & (0x7FF<<RIGHT))>>RIGHT);
+
+	tmp = ioread32(mlc.mem+MLCTOPBOTTOM0+0x34*layer);
+	p->top  = ((tmp & (0x7FF<<TOP))>>TOP);
+	p->bottom = ((tmp & (0x7FF<<BOTTOM))>>BOTTOM);
+	
+	/* account for pre-decrement in mlc_SetPosition() */
+	p->right++;
+	p->bottom++;
+	
+	return 0;
+}
+
+int mlc_SetLayerEnable(u8 layer, u8 en)
+{
+	void *reg;
+	u32 tmp;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	BIT_SET(tmp,PALETTEPWD); /* power up */
+	iowrite32(tmp,reg);
+	en ? BIT_SET(tmp,PALETTESLD) : BIT_CLR(tmp,PALETTESLD); /* disable sleep mode */
+	iowrite32(tmp,reg);
+	en ? BIT_SET(tmp,LAYERENB) : BIT_CLR(tmp,LAYERENB);
+
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetLayerEnable(u8 layer)
+{
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+
+	return  !!IS_SET(ioread32(reg), LAYERENB);
+}
+
+int mlc_SetDirtyFlag(u8 layer)
+{
+	void *reg;
+	u32 tmp;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	BIT_SET(tmp,DIRTYFLAG);
+
+	iowrite32(tmp,reg);
+	return 0;
+}
+
+int mlc_GetDirtyFlag(u8 layer)
+{
+	void *reg;
+	u32 tmp, ret=false;
+
+	if(layer > MLC_NUM_LAYERS)
+		return -EINVAL;
+
+	reg = SelectLayerControl(layer);
+	tmp = ioread32(reg);
+	ret = IS_SET(tmp,DIRTYFLAG) ? 1 : 0;
+
+	return ret;
+}
+
+int mlc_SetOverlaySize(u8 layer, u32 srcwidth, u32 srcheight, u32 dstwidth, 
+		u32 dstheight)
+{
+	/* Enable adjusted ratio with bilinear filter for upscaling */
+	if (srcwidth < dstwidth)
+		iowrite32((1<<28) | (((srcwidth-1)<<11)/(dstwidth-1)), mlc.mem+MLCHSCALE);
+	else
+		iowrite32((srcwidth<<11)/(dstwidth), mlc.mem+MLCHSCALE);
+	/* Ditto for height which scales independently of width */
+	if (srcheight < dstheight)	
+		iowrite32((1<<28) | (((srcheight-1)<<11)/(dstheight-1)), mlc.mem+MLCVSCALE);
+	else
+		iowrite32((srcheight<<11)/(dstheight), mlc.mem+MLCVSCALE);
+	return 0;
+}
+
+int mlc_GetOverlaySize(u8 layer, struct mlc_overlay_size *psize)
+{
+	struct mlc_layer_position pos = {0, 0, 0, 0};
+	
+	u32 hscale = ioread32(mlc.mem+MLCHSCALE);
+	u32 vscale = ioread32(mlc.mem+MLCVSCALE);
+
+	/* Need destination size to derive source size from scaler ratio */
+	mlc_GetPosition(layer, &pos);
+	psize->dstwidth = pos.right - pos.left;
+	psize->dstheight = pos.bottom - pos.top;
+
+	if (hscale & (1<<28))
+		psize->srcwidth = (((hscale & ~(1<<28)) * (psize->dstwidth-1)) >> 11) + 1;
+	else
+		psize->srcwidth = (hscale * (psize->dstwidth) >> 11);
+
+	if (vscale & (1<<28))
+		psize->srcheight = (((vscale & ~(1<<28)) * (psize->dstheight-1)) >> 11) + 1;
+	else
+		psize->srcheight = (vscale * (psize->dstheight) >> 11);
+
+	return 0;
+}
+
+
+int mlc_SetLayerInvisibleAreaEnable(u8 layer, u8 en)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = mlc.mem+MLCLEFTRIGHT0_0+layer*0x34;
+	tmp = ioread32(reg);
+	en ? BIT_SET(tmp, UNVALIDENB) : BIT_CLR(tmp, UNVALIDENB);
+	iowrite32(tmp, reg);
+
+	return 0;
+}
+EXPORT_SYMBOL(mlc_SetLayerInvisibleAreaEnable);
+
+int mlc_GetLayerInvisibleAreaEnable(u8 layer)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	reg = mlc.mem+MLCLEFTRIGHT0_0+layer*0x34;
+	tmp = ioread32(reg);
+
+	return IS_SET(tmp, UNVALIDENB) ? 1 : 0;
+}
+EXPORT_SYMBOL(mlc_GetLayerInvisibleAreaEnable);
+
+int mlc_SetLayerInvisibleArea(u8 layer, s32 top, s32 left, s32 right, s32 bottom)
+{
+	u32 tmp;
+	void *reg;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	top &= 0x7FF;
+	left &= 0x7FF;
+	right &= 0x7FF;
+	bottom &= 0x7FF;
+
+	reg = mlc.mem+MLCLEFTRIGHT0_0+layer*0x34;
+	tmp = ioread32(reg);
+	tmp &= ~((0x7FF<<UNVALIDLEFT)|(0x7FF<<UNVALIDRIGHT));
+	tmp |= (left<<UNVALIDLEFT)|(right<<UNVALIDRIGHT);
+	iowrite32(tmp, reg);
+
+	reg = mlc.mem+MLCTOPBOTTOM0_0+layer*0x34;
+	tmp = ioread32(reg);
+	tmp &= ~((0x7FF<<UNVALIDTOP)|(0x7FF<<UNVALIDBOTTOM));
+	tmp |= (left<<UNVALIDTOP)|(right<<UNVALIDBOTTOM);
+	iowrite32(tmp, reg);
+
+	return 0;
+}
+EXPORT_SYMBOL(mlc_SetLayerInvisibleArea);
+
+int mlc_GetLayerInvisibleArea(u8 layer, struct mlc_layer_position *p)
+{
+	u32 tmp;
+
+	if(layer > MLC_NUM_LAYERS || layer == MLC_VIDEO_LAYER)
+		return -EINVAL;
+
+	tmp = ioread32(mlc.mem+MLCLEFTRIGHT0_0+0x34*layer);
+	p->left = ((tmp & (0x7FF<<LEFT))>>LEFT);
+	p->right  = ((tmp & (0x7FF<<RIGHT))>>RIGHT);
+
+	tmp = ioread32(mlc.mem+MLCTOPBOTTOM0_0+0x34*layer);
+	p->top  = ((tmp & (0x7FF<<TOP))>>TOP);
+	p->bottom = ((tmp & (0x7FF<<BOTTOM))>>BOTTOM);
+
+	return 0;
+}
+EXPORT_SYMBOL(mlc_GetLayerInvisibleArea);
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/mlc_hal.h linux-2.6/drivers/lf1000/mlc/mlc_hal.h
--- linux-2.6.31/drivers/lf1000/mlc/mlc_hal.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/mlc_hal.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,206 @@
+/*
+ * drivers/lf1000/mlc/mlc_hal.h
+ *
+ * LF1000 Multi-Layer Controller (MLC) Driver
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef MLC_HAL_H
+#define MLC_HAL_H
+
+/* MLC Registers as offsets */
+
+#define MLCCONTROLT		0x00
+#define MLCSCREENSIZE		0x04
+#define MLCBGCOLOR		0x08
+#ifdef CPU_LF1000
+	#define MLCLEFTRIGHT0	0x0C
+	#define MLCTOPBOTTOM0	0x10
+	#define MLCLEFTRIGHT0_0	0x14
+	#define MLCTOPBOTTOM0_0	0x18
+	#define MLCLEFTRIGHT0_1	0x1C
+	#define MLCTOPBOTTOM0_1 0x20
+	#define MLCCONTROL0	0x24
+	#define MLCHSTRIDE0	0x28
+	#define MLCVSTRIDE0	0x2C
+	#define MLCTPCOLOR0	0x30
+	#define MLCINVCOLOR0	0x34
+	#define MLCADDRESS0	0x38
+	#define MLCPALETTE0	0x3C
+	#define MLCLEFTRIGHT1	0x40
+	#define MLCTOPBOTTOM1	0x44
+	#define MLCLEFTRIGHT1_0	0x48
+	#define MLCTOPBOTTOM1_0	0x4C
+	#define MLCLEFTRIGHT1_1	0x50
+	#define MLCTOPBOTTOM1_1	0x54
+	#define MLCCONTROL1	0x58
+	#define MLCHSTRIDE1	0x5C
+	#define MLCVSTRIDE1	0x60
+	#define MLCTPCOLOR1	0x64
+	#define MLCINVCOLOR1	0x68
+	#define MLCADDRESS1	0x6C
+	#define MLCPALETTE1	0x70
+	#define MLCLEFTRIGHT2	0x74
+	#define MLCTOPBOTTOM2	0x78
+	#define MLCCONTROL2	0x7C
+	#define MLCVSTRIDE3	0x80	/* this is actually for Layer 2 */
+	#define MLCTPCOLOR3	0x84	/* this is actually for Layer 2 */
+	/*reserved		0x88*/
+	#define MLCADDRESS3	0x8C	/* this is actually for Layer 2 */
+	#define MLCADDRESSCB	0x90
+	#define MLCADDRESSCR	0x94
+	#define MLCSTRIDECB	0x98
+	#define MLCSTRIDECR	0x9C
+	#define MLCHSCALE	0xA0
+	#define MLCVSCALE	0xA4
+	#define MLCLUENH	0xA8
+	#define MLCCHENH0	0xAC
+	#define MLCCHENH1	0xB0
+	#define MLCCHENH2	0xB4
+	#define MLCCHENH3	0xB8
+	/* (reserved) */
+	#define MLCCLKENB	0x3C0
+#elif defined(CPU_MF2530F)
+	#define MLCLEFTOP0	0x0C
+	#define MLCRIGHTBOTTOM0	0x10
+	#define MLCCONTROL0	0x14
+	#define MLCHSTRIDE0	0x18
+	#define MLCVSTRIDE0	0x1C
+	#define MLCTPCOLOR0	0x20
+	#define MLCINVCOLOR0	0x24
+	#define MLCADDRESS0	0x28
+	#define MLCLEFTOP1	0x2C
+	#define MLCRIGHTBOTTOM1	0x30
+	#define MLCCONTROL1	0x34
+	#define MLCHSTRIDE1	0x38
+	#define MLCVSTRIDE1	0x3C
+	#define MLCTPCOLOR1	0x40
+	#define MLCINVCOLOR1	0x44
+	#define MLCADDRESS1	0x48
+	#define MLCLEFTOP2	0x4C
+	#define MLCRIGHTBOTTOM2	0x50
+	#define MLCCONTROL2	0x54
+	#define MLCHSTRIDE2	0x58
+	#define MLCVSTRIDE2	0x5C
+	#define MLCTPCOLOR2	0x60
+	#define MLCINVCOLOR2	0x64
+	#define MLCADDRESS2	0x68
+	#define MLCLEFTOP3	0x6C
+	#define MLCRIGHTBOTTOM3	0x70
+	#define MLCCONTROL3	0x74
+	#define MLCHSTRIDE3	0x78
+	#define MLCVSTRIDE3	0x7C
+	#define MLCTPCOLOR3	0x80
+	#define MLCADDRESS3	0x88
+	#define MLCADDRESSCB	0x8C
+	#define MLCADDRESSCR	0x90
+	#define MLCVSTRIDECB	0x94
+	#define MLCVSTRIDECR	0x98
+	#define MLCHSCALE	0x9C
+	#define MLCVSCALE	0xA0
+	#define MLCLUENH	0xA4
+	#define MLCCHENH0	0xA8
+	#define MLCCHENH1	0xAC
+	#define MLCCHENH2	0xB0
+	#define MLCCHENH3	0xB4 
+	/* (reserved) */
+	#define MLCCLKENB	0x1C0
+#else
+	#error "No CPU variant defined!"
+#endif
+
+
+/* MLC TOP CONTROL REGISTER (MLCCONTROLT) */
+#ifdef CPU_LF1000
+#define GRP3DADDRCHAN		12	/* primary or secondary address block*/
+#define GEALLOWEDSEL		12	/* select (two namings) */
+#define PIXELBUFFER_PWD		11	/* pixel buffer power on/off */
+#define PIXELBUFFER_SLD		10	/* pixel buffer sleep mode */
+#endif
+#define PRIORITY		8
+#define DITTYFLAG		3
+#define MLCENB			1
+#define FIELDENB		0
+
+/* MLC SCREEN SIZE REGISTER (MLCSCREENSIZE) */
+#define SCREENHEIGHT		16
+#define SCREENWIDTH		0
+
+/* MLC RGB Layer n Control Register (MLCCONTROLn) */
+#define FORMAT			16	/* see table 21-5 */
+#ifdef CPU_LF1000
+#define PALETTEPWD		15	/* layer n palette table on/off */
+#define PALETTESLD		14	/* layer n palette table sleep mode */
+#endif
+#define LOCKSIZE		12	/* memory read size */
+#define GRP3DENB		8	/* set layer as output of 3D core */
+#define LAYERENB		5	/* enable the layer */
+#define DIRTYFLAG		4
+#define BLENDENB		2
+#define INVENB			1
+#define TPENB			0
+
+#ifdef CPU_MF2530F
+/* MLC RGB LAYER n LEFT TOP REGISTER (MLCLEFTOPn) */
+#define TOP			16
+#define LEFT			0
+#endif
+
+#ifdef CPU_LF1000
+/* MLC RGB Layer n Left Right Register (MLCLEFTRIGHTn) */
+#define LEFT			16
+#define RIGHT			0
+#endif
+
+#ifdef CPU_MF2530F
+/* MLC RGB LAYER n RIGHT BOTTOM REGISTER (MLCRIGHTBOTTOMn) */
+#define RIGHT			16
+#define BOTTOM			0
+#endif
+
+#ifdef CPU_LF1000
+/* MLC RGB Layer n Top Bottom Register (MLCTOPBOTTOMn) */
+#define TOP			16
+#define BOTTOM			0
+#endif
+
+/* MLC RGB Layer n Unvalid Area 0 left right register (MLCLEFTRIGHT0_0) */
+#define UNVALIDENB		28
+#define UNVALIDLEFT		16
+#define UNVALIDRIGHT		0
+
+/* MLC RGB Layer n Unvalid Area 0 Top Bottom Register */
+#define UNVALIDTOP		16
+#define UNVALIDBOTTOM		0
+
+/* MLC Pallete Address Data (MLCPALETTEn) Register */
+#ifdef CPU_LF1000
+#define PALETTEADDR		24
+#define PALETTEDATA		0
+#endif
+
+/* MLC RGB LAYER n TRANSPARENCY COLOR REGISTER (MLCTPCOLORn) */
+#define ALPHA			28
+#define TPCOLOR			0
+
+/* MLC RGB LAYER n INVERSION COLOR REGISTER (MLCINVCOLORn) */
+#define INVCOLOR		0
+
+/* MLC CLOCK GENERATION ENABLE REGISTER (MLCCLKENB) */
+#define _PCLKMODE		3 /* FIXME: cleaner way to fix namespace? */
+#define BCLKMODE		0
+
+/* MLC Video layer Horizontal Scale (MLCHSCALE) Register */
+#ifdef CPU_LF1000
+#define HFILTERENB		28 /* bilinear filter enable */
+#endif
+#define HSCALE			0  /* horizonal scale ratio */
+
+/* MLC Video layer Vertical Scale (MLCVSCALE) Register */
+#ifdef CPU_LF1000
+#define VFILTERENB		28 /* bilinear filter enable */
+#endif
+#define VSCALE			0  /* vertical scale ratio */
+
+#endif
+
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/mlc_priv.h linux-2.6/drivers/lf1000/mlc/mlc_priv.h
--- linux-2.6.31/drivers/lf1000/mlc/mlc_priv.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/mlc_priv.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,33 @@
+/* 
+ * drivers/lf1000/mlc/mlc_priv.h
+ *
+ * LF1000 Multi-Layer Controller Driver
+ * 
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef MLC_PRIV_H
+#define MLC_PRIV_H
+
+#include <linux/cdev.h>
+#include <linux/semaphore.h>
+
+struct mlc_layer {
+	u8 id;
+	struct cdev dev;
+	void *fb;
+	struct semaphore sem;
+};
+
+struct mlc_device {
+	void *mem;				/* memory-mapped registers */
+	struct cdev dev;
+	struct mlc_layer layer[MLC_NUM_LAYERS];
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc;
+	struct proc_dir_entry *proc_layers;
+#endif
+	int lcd_id;
+};
+
+#endif
+
diff -ruaN linux-2.6.31/drivers/lf1000/mlc/README linux-2.6/drivers/lf1000/mlc/README
--- linux-2.6.31/drivers/lf1000/mlc/README	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/mlc/README	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,138 @@
+###############################################################################
+# LF1000 Multi-Layer Controller (MLC) Driver                                  #
+#                                                                             #
+# 04/28/2007 by Andrey Yurovsky <andrey@cozybit.com>                          #
+###############################################################################
+
+This is the MLC driver documentation.  Please note that the MLC driver requires
+that you build and load the DPC driver first.  See the README in the DPC driver
+directory for for information.
+
+0) Contents:
+   1) Building and Installing
+   2) Creating /dev/mlc Device
+   3) Creating /dev/layer Devices
+   4) Application Interface
+   5) Using 3D Mode
+   6) Debugging
+
+1) Building and Installing
+
+This driver can be built into the kernel or as a module using the kernel build
+system.  Use CONFIG_LF1000_MLC to select the MLC driver.  This driver must be
+built with a CPU variant defined (this is set up by defining a platform during
+your build).
+
+2) Creating /dev/mlc Device
+
+You may need to create the /dev/mlc device during initial installation.  To do
+so, you must know the MLC's major number (MLC_MAJOR in mlc.h).  
+For example, to create the device with a major number 251:
+
+$ mknod /dev/mlc c 251 0
+$ chmod a+rw /dev/mlc
+
+3) Creating /dev/layer Devices
+
+The driver provides devices for each MLC layer, /dev/layer0 through 
+/dev/layer3.  You may create them on initial installation using the
+MLC_LAYER_MAJOR number in mlc.h and minor numbers 0 through MLC_NUM_LAYERS-1 
+(corresponding to each layer).  For example:
+
+$ mknod -m 666 /dev/layer2 c 250 2
+
+creates the device node for layer2.
+
+4) Application Interface
+
+MLC and layer configuration from applications is possible through ioctl() 
+calls.  The 2D frame buffers may be written by using mmap() or write() calls on
+the /dev/layerN files.
+
+The included user applications (in lftest/lcd) can be used to control the MLC 
+and as examples for writing your own user space applications.  mlc-control 
+provides an interface to general MLC commands such as setting the background 
+color.  The layer-control program provides layer-specific commands such as 
+setting/getting the layer position, color format, and 3D mode. 
+
+Run them on the target without arguments to see a help screen:
+
+$ mlc-control
+$ layer-control
+
+For example, the background color for the MLC may be set as follows:
+
+$ mlc-control /dev/mlc set background FF0000
+$ mlc-control /dev/mlc set dirty
+
+The first command sets the color to red (0xFF0000).  This change is not 
+applied until the second command sets the top 'dirty' bit.  Note that the 
+'background' command takes six hex characters as in the above example, they
+represent RGB as RRGGBB.
+
+Layer control is done by passing the layer device to the layer-control program.
+For example, the following commands enable layer0, move it to the upper left
+hand corner of the screen with a width of 100 and height of 200, and apply the
+changes by setting the layer's 'dirty' bit:
+
+$ layer-control /dev/layer0 set enable on
+$ layer-control /dev/layer0 set position 0 0 100 200
+$ layer-control /dev/layer0 set dirty
+
+One can also issue 'get' commands for most ioctls, for example:
+
+$ layer-control /dev/layer1 get address
+
+retrieves the frame buffer address for layer1.  Also note that only the first
+letter of 'get' and 'set' is significant, so 'g' or 's' is fine (and easier to
+use in shell scripts).
+
+The mlc_ioctl.h file provides the MLC API to user applications (and it is
+included by mlc-control and layer-control).  The formats.h file provides lookup
+tables for MLC color names and is used my layer-control.
+
+5) Using 3D Mode
+
+To use a layer as a 3D layer, several options must be set via the ioctl
+interface.  You can also set them from the layer-control program.  Assuming you
+wish to use layer0 with the 3D engine, here is how to configure the layer with
+layer-control:
+
+ Set the color format to R5G6B5:
+ $ layer-control /dev/layer0 set format R5G6B5
+
+ Set the horizontal stride to 2 and the vertical stride to 4096:
+ $ layer-control /dev/layer0 set hstride 2
+ $ layer-control /dev/layer0 set vstride 4096
+
+ Enable 3D Mode for this layer:
+ $ layer-control /dev/layer0 set 3D on
+
+ Apply the changes:
+ $ layer-control /dev/layer0 set dirty
+
+Please refer to the LF1000 Data Book for details about configuring 3D layers. 
+The driver will not allow multiple layers to be marked for 3D Mode, if another 
+layer was marked for 3D, it will be unmarked when a different layer is marked.
+
+6) Debugging
+
+The MLC driver allows the MLC registers to be inspected at any time by
+reading files in /proc.  This capability is available only if the driver was
+built for a kernel with CONFIG_PROC_FS enabled.  First, ensure that /proc is
+mounted:
+
+$ mount /proc
+
+The /proc/driver directory contains the following files for MLC debugging:
+              
+mlc_layers
+mlc_top
+
+You may read these files with the 'cat' command, for example:
+
+$ cat /proc/driver/mlc_top
+
+The 'mlc_top' file provides the MLC Top Layer and general registers.  The 
+'mlc_layers' file provides the layer-specific registers.  Refer to the LF1000 
+data book for MLC register definitions.
diff -ruaN linux-2.6.31/drivers/lf1000/warm/lf1000_warm.c linux-2.6/drivers/lf1000/warm/lf1000_warm.c
--- linux-2.6.31/drivers/lf1000/warm/lf1000_warm.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/lf1000_warm.c	2012-11-16 12:02:57.000000000 -0800
@@ -0,0 +1,544 @@
+/*
+ * wARM - exporting ARM processor specific privileged services to userspace
+ * kernelspace part
+ *
+ * Author: Gravydas "notaz" Ignotas
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/seq_file.h>
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+#include <linux/uaccess.h>
+#else
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/uaccess.h>
+#define __user
+#define unlocked_ioctl ioctl
+#endif
+
+#define WARM_CODE
+#include "warm.h"
+#include "warm_ops.h"
+
+#ifndef CONFIG_PROC_FS
+#error need proc_fs
+#endif
+	
+#define WARM_VER "r2"
+#define PFX "wARM: "
+
+#define WARM_INFO(fmt, ...) \
+	if (verbose) \
+		pr_info(PFX fmt, ##__VA_ARGS__)
+
+#define MAX_CACHEOP_RANGE	16384
+
+/* assume RAM starts at phys addr 0 (this is really machine specific) */
+
+#define RAM_PHYS_START	0x00000000
+
+#define RAM_MAX_SIZE	0x10000000	/* 256M, try to be future proof */
+
+/* expected CPU id */
+#if   defined(CONFIG_CPU_ARM926T)
+#define EXPECTED_ID	0x069260
+#elif defined(CONFIG_CPU_ARM920T)
+#define EXPECTED_ID	0x029200
+#else
+#error "unsupported CPU"
+#endif
+
+extern unsigned long max_mapnr;
+
+/* "upper" physical memory, not seen by Linux and to be mmap'ed */
+static u32 uppermem_start;
+static u32 uppermem_end;
+
+static int verbose;
+
+static u32 *get_pgtable(void)
+{
+	u32 ttb;
+
+	/* get the pointer to the translation table base... */
+	asm ("mrc p15, 0, %0, c2, c0, 0" : "=r"(ttb));
+
+	return __va((ttb) & 0xffffc000);
+}
+
+static int do_set_cb_uppermem(int in_cb, int is_set)
+{
+	u32 *pgtable, *cpt;
+	int i, j, count = 0;
+	int bits = 0;
+
+	if (uppermem_end <= uppermem_start)
+		return -ENODEV;
+
+	if (in_cb & WCB_C_BIT)
+		bits |= 8;
+	if (in_cb & WCB_B_BIT)
+		bits |= 4;
+
+	pgtable = get_pgtable();
+
+	for (i = 0; i < 4096; i++)
+	{
+		if ((pgtable[i] & 3) != 1)
+			/* must be coarse page table */
+			continue;
+
+		cpt = __va(pgtable[i] & 0xfffffc00);
+
+		for (j = 0; j < 256; j++)
+		{
+			u32 addr, entry;
+
+			entry = cpt[j];
+			if (!(entry & 3))
+				/* fault */
+				continue;
+
+			addr = entry & 0xfffff000;
+			if (uppermem_start <= addr && addr < uppermem_end)
+			{
+				pr_debug(PFX "%s C&B bits %08x\n",
+					is_set ? "set" : "clear", entry);
+
+				if (is_set)
+					entry |= bits;
+				else
+					entry &= ~bits;
+
+				/* need to also set AP bits (so that no faults
+				 * happen and kernel doesn't touch this after us) */
+				if ((entry & 3) == 3)
+					entry |= 0x030;	/* tiny page */
+				else
+					entry |= 0xff0;
+
+				cpt[j] = entry;
+				count++;
+			}
+		}
+	}
+
+	warm_cop_clean_d();
+	warm_drain_wb_inval_tlb();
+
+	WARM_INFO("%c%c bit(s) %s for phys %08x-%08x (%d pages)\n",
+		bits & 8 ? 'c' : ' ', bits & 4 ? 'b' : ' ',
+		is_set ? "set" : "cleared",
+		uppermem_start, uppermem_end - 1, count);
+
+	return 0;
+}
+
+static int do_set_cb_virt(int in_cb, int is_set, u32 addr, u32 size)
+{
+	int count = 0, bits = 0;
+	u32 desc1, desc2;
+	u32 *pgtable, *cpt;
+	u32 start, end;
+	u32 mask;
+
+	if (in_cb & WCB_C_BIT)
+		bits |= 8;
+	if (in_cb & WCB_B_BIT)
+		bits |= 4;
+
+	mask = PAGE_SIZE - 1;
+	size += addr & mask;
+	size = (size + mask) & ~mask;
+
+	addr &= ~(PAGE_SIZE - 1);
+	start = addr;
+	end = addr + size;
+
+	pgtable = get_pgtable();
+
+	for (; addr < end; addr += PAGE_SIZE)
+	{
+		desc1 = pgtable[addr >> 20];
+
+		if ((desc1 & 3) != 1) {
+			printk(KERN_WARNING PFX "not coarse table? %08x %08x\n", desc1, addr);
+			return -EINVAL;
+		}
+
+		cpt = __va(desc1 & 0xfffffc00);
+		desc2 = cpt[(addr >> 12) & 0xff];
+		
+		if ((desc2 & 3) != 2) {
+			printk(KERN_WARNING PFX "not small page? %08x %08x\n", desc2, addr);
+			return -EINVAL;
+		}
+
+		if (is_set)
+			desc2 |= bits;
+		else
+			desc2 &= ~bits;
+		desc2 |= 0xff0;
+
+		cpt[(addr >> 12) & 0xff] = desc2;
+		count++;
+	}
+
+	warm_cop_clean_d();
+	warm_drain_wb_inval_tlb();
+
+	WARM_INFO("%c%c bit(s) %s virt %08x-%08x (%d pages)\n",
+		bits & 8 ? 'c' : ' ', bits & 4 ? 'b' : ' ',
+		is_set ? "set" : "cleared", start, end - 1, count);
+
+	return 0;
+}
+
+static int do_virt2phys(unsigned long *_addr)
+{
+	u32 addr = *_addr;
+	u32 desc1, desc2;
+	u32 *pgtable, *cpt;
+
+	pgtable = get_pgtable();
+	desc1 = pgtable[addr >> 20];
+
+	switch (desc1 & 3) {
+	case 1:	/* coarse table */
+		cpt = __va(desc1 & 0xfffffc00);
+		desc2 = cpt[(addr >> 12) & 0xff];
+		break;
+	case 2: /* 1MB section */
+		*_addr = (desc1 & 0xfff00000) | (addr & 0xfffff);
+		return 0;
+	case 3:	/* fine table */
+		cpt = __va(desc1 & 0xfffff000);
+		desc2 = cpt[(addr >> 10) & 0x3ff];
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	
+	switch (desc2 & 3) {
+	case 1:	/* large page */
+		*_addr = (desc2 & ~0xffff) | (addr & 0xffff);
+		break;
+	case 2:	/* small page */
+		*_addr = (desc2 & ~0x0fff) | (addr & 0x0fff);
+		break;
+	case 3:	/* tiny page */
+		*_addr = (desc2 & ~0x03ff) | (addr & 0x03ff);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int do_cache_ops_whole(int ops)
+{
+	if ((ops & (WOP_D_CLEAN|WOP_D_INVALIDATE)) == (WOP_D_CLEAN|WOP_D_INVALIDATE))
+		warm_cop_clean_inval_d();
+
+	else if (ops & WOP_D_CLEAN)
+		warm_cop_clean_d();
+
+	else if (ops & WOP_D_INVALIDATE) {
+		printk(KERN_WARNING PFX "invalidate without clean is dangerous!\n");
+		warm_cop_inval_d();
+	}
+
+	if (ops & WOP_I_INVALIDATE)
+		warm_cop_inval_i();
+	
+	warm_cop_drain_wb();
+	return 0;
+}
+
+static int do_cache_ops(int ops, u32 addr, u32 size)
+{
+	if (addr & 31) {
+		size += addr & 31;
+		addr &= ~31;
+	}
+
+	switch (ops) {
+	case WOP_D_CLEAN|WOP_D_INVALIDATE|WOP_I_INVALIDATE:
+		warm_cop_r_clean_d_inval_di(addr, size);
+		break;
+	case WOP_D_CLEAN|WOP_D_INVALIDATE:
+		warm_cop_r_clean_d_inval_d(addr, size);
+		break;
+	case WOP_D_CLEAN|WOP_I_INVALIDATE:
+		warm_cop_r_clean_d_inval_i(addr, size);
+		break;
+	case WOP_D_CLEAN:
+		warm_cop_r_clean_d(addr, size);
+		break;
+	case WOP_D_INVALIDATE|WOP_I_INVALIDATE:
+		warm_cop_r_inval_di(addr, size);
+		break;
+	case WOP_D_INVALIDATE:
+		warm_cop_r_inval_d(addr, size);
+		break;
+	case WOP_I_INVALIDATE:
+		warm_cop_r_inval_i(addr, size);
+		break;
+	default:
+		/* only drain wb */
+		break;
+	}
+
+	warm_cop_drain_wb();
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+static long warm_ioctl(struct file *file, unsigned int cmd, unsigned long __arg)
+#else
+static int warm_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long __arg)
+#endif
+{
+	void __user *arg = (void __user *) __arg;
+	union {
+		struct warm_cache_op wcop;
+		struct warm_change_cb ccb;
+		unsigned long addr;
+	} u;
+	long ret;
+
+	switch (cmd) {
+	case WARMC_CACHE_OP:
+		if (copy_from_user(&u.wcop, arg, sizeof(u.wcop)))
+			return -EFAULT;
+		if (u.wcop.ops & ~(WOP_D_CLEAN|WOP_D_INVALIDATE|WOP_I_INVALIDATE))
+			return -EINVAL;
+		if (u.wcop.size == (unsigned long)-1 ||
+				(u.wcop.size > MAX_CACHEOP_RANGE && !(u.wcop.ops & WOP_D_INVALIDATE)))
+			ret = do_cache_ops_whole(u.wcop.ops);
+		else
+			ret = do_cache_ops(u.wcop.ops, u.wcop.addr, u.wcop.size);
+		break;
+	case WARMC_CHANGE_CB:
+		if (copy_from_user(&u.ccb, arg, sizeof(u.ccb)))
+			return -EFAULT;
+		if (u.ccb.cb & ~(WCB_C_BIT|WCB_B_BIT))
+			return -EINVAL;
+		if (u.ccb.addr == 0 && u.ccb.size == 0)
+			ret = do_set_cb_uppermem(u.ccb.cb, u.ccb.is_set);
+		else
+			ret = do_set_cb_virt(u.ccb.cb, u.ccb.is_set, u.ccb.addr, u.ccb.size);
+		break;
+	case WARMC_VIRT2PHYS:
+		if (copy_from_user(&u.addr, arg, sizeof(u.addr)))
+			return -EFAULT;
+		ret = do_virt2phys(&u.addr);
+		if (copy_to_user(arg, &u.addr, sizeof(u.addr)))
+			return -EFAULT;
+		break;
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+
+	return ret;
+}
+
+static const char *warm_implementor_name(char code)
+{
+	switch (code) {
+	case 'A':
+		return "ARM";
+	case 'D':
+		return "DEC";
+	case 'i':
+		return "Intel";
+	case 'M':
+		return "Motorola - Freescale";
+	case 'V':
+		return "Marvell";
+	}
+	return "???";
+}
+
+static const char *warm_arch_name(int code)
+{
+	switch (code) {
+	case 1:
+		return "4";
+	case 2:
+		return "4T";
+	case 3:
+		return "5";
+	case 4:
+		return "5T";
+	case 5:
+		return "5TE";
+	case 6:
+		return "5TEJ";
+	case 7:
+		return "6";
+	}
+	return "?";
+}
+
+static int warm_cache_size(int code, int m)
+{
+	int base = 512;
+	if (m)
+		base = 768;
+	return base << code;
+}
+
+static int warm_cache_assoc(int code, int m)
+{
+	int base = 2;
+	if (code == 0)
+		return m ? 0 : 1;
+	if (m)
+		base = 3;
+	return base << (code - 1); 
+}
+
+static int warm_cache_line(int code)
+{
+	return 8 << code;
+}
+
+static int warm_seq_show(struct seq_file *seq, void *offset)
+{
+	u32 tmp;
+
+	seq_printf(seq, "wARM: " WARM_VER "\n");
+
+	/* ID codes */
+	asm ("mrc p15, 0, %0, c0, c0, 0" : "=r"(tmp));
+	seq_printf(seq, "ID: %08x\n", tmp);
+	if (tmp & 0x80000) {
+		/* revised format, not yet documented */
+	} else if ((tmp & 0xf000) == 0) {
+		/* pre-ARM7 */
+		seq_printf(seq, "Architecture: %d\n",
+				(tmp & 0xf00) == 0x600 ? 3 : 2);
+		seq_printf(seq, "Variant: %d%d0\n", (tmp & 0xf00) >> 8,
+				(tmp & 0xf0) >> 4);
+	} else {
+		seq_printf(seq, "Implementor: %c (%s)\n", tmp >> 24,
+				warm_implementor_name(tmp >> 24));
+		if ((tmp & 0xf000) == 7) {
+			seq_printf(seq, "Architecture: %s\n",
+				tmp & 0x800000 ? "4T" : "3");
+			seq_printf(seq, "Variant: 0x%x\n", (tmp & 0x7f0000) >> 16);
+		} else {
+			seq_printf(seq, "Architecture: %s\n",
+				warm_arch_name((tmp & 0x0f0000) >> 16));
+			seq_printf(seq, "Variant: 0x%x\n", (tmp & 0xf00000) >> 20);
+		}
+		seq_printf(seq, "Part number: 0x%x\n", (tmp & 0xfff0) >> 4);
+	}
+	seq_printf(seq, "Revision: 0x%x\n", tmp & 0xf);
+
+	/* cache type */
+	asm ("mrc p15, 0, %0, c0, c0, 1" : "=r"(tmp));
+	seq_printf(seq, "Cache ctype: 0x%x\n", (tmp & 0x1e000000) >> 25);
+	seq_printf(seq, "Cache unified: %s\n", (tmp & 0x01000000) ? "no" : "yes");
+	seq_printf(seq, "DCache size: %d\n",
+			warm_cache_size((tmp >> (6+12)) & 0xf, (tmp >> (2+12)) & 1));
+	seq_printf(seq, "DCache associativity: %d\n",
+			warm_cache_assoc((tmp >> (3+12)) & 7, (tmp >> (2+12)) & 1));
+	seq_printf(seq, "DCache line size: %d\n",
+			warm_cache_line((tmp >> (0+12)) & 3));
+	seq_printf(seq, "ICache size: %d\n",
+			warm_cache_size((tmp >> 6) & 0xf, (tmp >> 2) & 1));
+	seq_printf(seq, "ICache associativity: %d\n",
+			warm_cache_assoc((tmp >> 3) & 7, (tmp >> 2) & 1));
+	seq_printf(seq, "ICache line size: %d\n",
+			warm_cache_line((tmp >> 0) & 3));
+
+	return 0;
+}
+
+static int warm_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, warm_seq_show, NULL);
+}
+
+static int warm_close(struct inode *ino, struct file *file)
+{
+	return single_release(ino, file);
+}
+
+static const struct file_operations warm_fops = {
+	.owner	= THIS_MODULE,
+	.open	= warm_open,
+	.read	= seq_read,
+	.llseek	= seq_lseek,
+	.unlocked_ioctl = warm_ioctl,
+	.release = warm_close,
+};
+
+static int __init warm_module_init(void)
+{
+	struct proc_dir_entry *pret;
+	u32 cpuid;
+
+	asm ("mrc p15, 0, %0, c0, c0, 0" : "=r"(cpuid));
+	if ((cpuid & 0x0ffff0) != EXPECTED_ID) {
+		printk(KERN_ERR PFX "module was compiled for different CPU, aborting\n");
+		return -1;
+	}
+
+	pret = create_proc_entry("warm", S_IWUGO | S_IRUGO, NULL);
+	if (!pret) {
+		printk(KERN_ERR PFX "can't create proc entry\n");
+		return -1;
+	}
+
+	//pret->owner = THIS_MODULE;
+	pret->proc_fops = &warm_fops;
+
+	uppermem_start = RAM_PHYS_START + (max_mapnr << PAGE_SHIFT);
+	uppermem_end = RAM_PHYS_START + RAM_MAX_SIZE;
+
+	pr_info(PFX WARM_VER " loaded, ");
+	if (uppermem_end <= uppermem_start)
+		printk("no upper mem");
+	else
+		printk("upper mem %08x-%08x", uppermem_start, uppermem_end - 1);
+	printk("\n");
+
+	/* give time for /proc node to appear */
+	mdelay(200);
+
+	return 0;
+}
+
+static void __exit warm_module_exit(void)
+{
+	remove_proc_entry("warm", NULL);
+
+	pr_info(PFX "unloaded.\n");
+}
+
+module_init(warm_module_init);
+module_exit(warm_module_exit);
+
+module_param(verbose, int, 0644);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ARM processor services");
+MODULE_AUTHOR("Grazvydas Ignotas");
diff -ruaN linux-2.6.31/drivers/lf1000/warm/Makefile linux-2.6/drivers/lf1000/warm/Makefile
--- linux-2.6.31/drivers/lf1000/warm/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/Makefile	2012-11-16 12:15:32.000000000 -0800
@@ -0,0 +1,2 @@
+obj-$(CONFIG_GPSP_WARM)		+= warm.o
+warm-objs += lf1000_warm.o warm_ops.o
diff -ruaN linux-2.6.31/drivers/lf1000/warm/warm.c linux-2.6/drivers/lf1000/warm/warm.c
--- linux-2.6.31/drivers/lf1000/warm/warm.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/warm.c	2010-11-20 20:38:02.000000000 -0800
@@ -0,0 +1,254 @@
+/*
+ * wARM - exporting ARM processor specific privileged services to userspace
+ * userspace part
+ *
+ * Copyright (c) Gravydas "notaz" Ignotas, 2009
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the organization nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/utsname.h>
+#include <sys/syscall.h>
+#include <errno.h>
+
+#define WARM_CODE
+#include "warm.h"
+
+/* provided by glibc */
+extern long init_module(void *, unsigned long, const char *);
+extern long delete_module(const char *, unsigned int);
+
+static int warm_fd = -1;
+static int kernel_version;
+
+static void sys_cacheflush(void *start, void *end)
+{
+#ifdef __ARM_EABI__
+	/* EABI version */
+	int num = __ARM_NR_cacheflush;
+	__asm__("mov  r0, %0 ;"
+		"mov  r1, %1 ;"
+		"mov  r2, #0 ;"
+		"mov  r7, %2 ;"
+		"swi  0" : : "r" (start), "r" (end), "r" (num)
+			: "r0", "r1", "r2", "r3", "r7");
+#else
+	/* OABI */
+	__asm__("mov  r0, %0 ;"
+		"mov  r1, %1 ;"
+		"mov  r2, #0 ;"
+		"swi  %2" : : "r" (start), "r" (end), "i" __ARM_NR_cacheflush
+			: "r0", "r1", "r2", "r3");
+#endif
+}
+
+/* Those are here because system() occasionaly fails on Wiz
+ * with errno 12 for some unknown reason */
+static int manual_insmod_26(const char *fname, const char *opts)
+{
+	unsigned long len, read_len;
+	int ret = -1;
+	void *buff;
+	FILE *f;
+
+	f = fopen(fname, "rb");
+	if (f == NULL)
+		return -1;
+
+	fseek(f, 0, SEEK_END);
+	len = ftell(f);
+	fseek(f, 0, SEEK_SET);
+
+	buff = malloc(len);
+	if (buff == NULL)
+		goto fail0;
+
+	read_len = fread(buff, 1, len, f);
+	if (read_len != len) {
+		fprintf(stderr, "failed to read module\n");
+		goto fail1;
+	}
+
+	ret = init_module(buff, len, opts);
+
+fail1:
+	free(buff);
+fail0:
+	fclose(f);
+	return ret;
+}
+
+static int manual_rmmod(const char *name)
+{
+	return delete_module(name, O_NONBLOCK|O_EXCL);
+}
+
+int warm_init(void)
+{
+	struct utsname unm;
+	char buff1[32], buff2[128];
+	int ret;
+
+	memset(&unm, 0, sizeof(unm));
+	uname(&unm);
+
+	if (strlen(unm.release) < 3 || unm.release[1] != '.') {
+		fprintf(stderr, "unexpected version string: %s\n", unm.release);
+		goto fail;
+	}
+	kernel_version = ((unm.release[0] - '0') << 4) | (unm.release[2] - '0');
+
+	warm_fd = open("/proc/warm", O_RDWR);
+	if (warm_fd >= 0)
+		return 0;
+
+	snprintf(buff1, sizeof(buff1), "warm_%s.%s", unm.release, kernel_version >= 0x26 ? "ko" : "o");
+	snprintf(buff2, sizeof(buff2), "/sbin/insmod %s verbose=1", buff1);
+
+	/* try to insmod */
+	ret = system(buff2);
+	if (ret != 0) {
+		fprintf(stderr, "system/insmod failed: %d %d\n", ret, errno);
+		if (kernel_version >= 0x26) {
+			ret = manual_insmod_26(buff1, "verbose=1");
+			if (ret != 0)
+				fprintf(stderr, "manual insmod also failed: %d\n", ret);
+		}
+	}
+
+	warm_fd = open("/proc/warm", O_RDWR);
+	if (warm_fd >= 0)
+		return 0;
+
+fail:
+	fprintf(stderr, "wARM: can't init, acting as sys_cacheflush wrapper\n");
+	return -1;
+}
+
+void warm_finish(void)
+{
+	char name[32], cmd[64];
+	int ret;
+
+	if (warm_fd < 0)
+		return;
+
+	close(warm_fd);
+	warm_fd = -1;
+
+	if (kernel_version < 0x26) {
+		struct utsname unm;
+		memset(&unm, 0, sizeof(unm));
+		uname(&unm);
+		snprintf(name, sizeof(name), "warm_%s", unm.release);
+	}
+	else
+		strcpy(name, "warm");
+
+	snprintf(cmd, sizeof(cmd), "/sbin/rmmod %s", name);
+	ret = system(cmd);
+	if (ret != 0) {
+		fprintf(stderr, "system/rmmod failed: %d %d\n", ret, errno);
+		manual_rmmod(name);
+	}
+}
+
+int warm_cache_op_range(int op, void *addr, unsigned long size)
+{
+	struct warm_cache_op wop;
+	int ret;
+
+	if (warm_fd < 0) {
+		/* note that this won't work for warm_cache_op_all */
+		sys_cacheflush(addr, (char *)addr + size);
+		return -1;
+	}
+
+	wop.ops = op;
+	wop.addr = (unsigned long)addr;
+	wop.size = size;
+
+	ret = ioctl(warm_fd, WARMC_CACHE_OP, &wop);
+	if (ret != 0) {
+		perror("WARMC_CACHE_OP failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int warm_cache_op_all(int op)
+{
+	return warm_cache_op_range(op, NULL, (unsigned long)-1);
+}
+
+int warm_change_cb_range(int cb, int is_set, void *addr, unsigned long size)
+{
+	struct warm_change_cb ccb;
+	int ret;
+
+	if (warm_fd < 0)
+		return -1;
+	
+	ccb.addr = (unsigned long)addr;
+	ccb.size = size;
+	ccb.cb = cb;
+	ccb.is_set = is_set;
+
+	ret = ioctl(warm_fd, WARMC_CHANGE_CB, &ccb);
+	if (ret != 0) {
+		perror("WARMC_CHANGE_CB failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+int warm_change_cb_upper(int cb, int is_set)
+{
+	return warm_change_cb_range(cb, is_set, 0, 0);
+}
+
+unsigned long warm_virt2phys(const void *ptr)
+{
+	unsigned long ptrio;
+	int ret;
+
+	ptrio = (unsigned long)ptr;
+	ret = ioctl(warm_fd, WARMC_VIRT2PHYS, &ptrio);
+	if (ret != 0) {
+		perror("WARMC_VIRT2PHYS failed");
+		return (unsigned long)-1;
+	}
+
+	return ptrio;
+}
+
diff -ruaN linux-2.6.31/drivers/lf1000/warm/warm.h linux-2.6/drivers/lf1000/warm/warm.h
--- linux-2.6.31/drivers/lf1000/warm/warm.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/warm.h	2010-11-20 20:38:02.000000000 -0800
@@ -0,0 +1,100 @@
+/*
+ * wARM - exporting ARM processor specific privileged services to userspace
+ * library functions
+ *
+ * Copyright (c) Gravydas "notaz" Ignotas, 2009
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the organization nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __WARM_H__
+#define __WARM_H__ 1
+
+/* cache operations (warm_cache_op_*):
+ * o clean - write dirty data to memory, but also leave in cache.
+ * o invalidate - throw away everything in cache, losing dirty data.
+ *
+ * Write buffer is always drained, no ops will only drain WB
+ */
+#define WOP_D_CLEAN		(1 << 0)
+#define WOP_D_INVALIDATE	(1 << 1)
+#define WOP_I_INVALIDATE	(1 << 2)
+
+/* change C and B bits (warm_change_cb_*)
+ * if is_set in not zero, bits are set, else cleared.
+ * the address for range function is virtual address.
+ */
+#define WCB_C_BIT		(1 << 0)
+#define WCB_B_BIT		(1 << 1)
+
+#ifndef __ASSEMBLER__
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+int warm_init(void);
+
+int warm_cache_op_range(int ops, void *virt_addr, unsigned long size);
+int warm_cache_op_all(int ops);
+
+int warm_change_cb_upper(int cb, int is_set);
+int warm_change_cb_range(int cb, int is_set, void *virt_addr, unsigned long size);
+
+unsigned long warm_virt2phys(const void *ptr);
+
+void warm_finish(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* internal */
+#ifdef WARM_CODE
+
+#include <linux/ioctl.h>
+
+#define WARM_IOCTL_BASE 'A'
+
+struct warm_cache_op
+{
+	unsigned long addr;
+	unsigned long size;
+	int ops;
+};
+
+struct warm_change_cb
+{
+	unsigned long addr;
+	unsigned long size;
+	int cb;
+	int is_set;
+};
+
+#define WARMC_CACHE_OP	_IOW(WARM_IOCTL_BASE,  0, struct warm_cache_op)
+#define WARMC_CHANGE_CB	_IOW(WARM_IOCTL_BASE,  1, struct warm_change_cb)
+#define WARMC_VIRT2PHYS	_IOWR(WARM_IOCTL_BASE, 2, unsigned long)
+
+#endif /* WARM_CODE */
+#endif /* !__ASSEMBLER__ */
+#endif /* __WARM_H__ */
diff -ruaN linux-2.6.31/drivers/lf1000/warm/warm_ops.h linux-2.6/drivers/lf1000/warm/warm_ops.h
--- linux-2.6.31/drivers/lf1000/warm/warm_ops.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/warm_ops.h	2010-11-20 20:38:02.000000000 -0800
@@ -0,0 +1,17 @@
+#include <linux/kernel.h>
+
+void warm_cop_clean_inval_d(void);
+void warm_cop_clean_d(void);
+void warm_cop_inval_d(void);
+void warm_cop_inval_i(void);
+void warm_cop_drain_wb(void);
+
+void warm_cop_r_clean_d_inval_di(u32 addr, u32 size);
+void warm_cop_r_clean_d_inval_d(u32 addr, u32 size);
+void warm_cop_r_clean_d_inval_i(u32 addr, u32 size);
+void warm_cop_r_clean_d(u32 addr, u32 size);
+void warm_cop_r_inval_di(u32 addr, u32 size);
+void warm_cop_r_inval_d(u32 addr, u32 size);
+void warm_cop_r_inval_i(u32 addr, u32 size);
+
+void warm_drain_wb_inval_tlb(void);
diff -ruaN linux-2.6.31/drivers/lf1000/warm/warm_ops.S linux-2.6/drivers/lf1000/warm/warm_ops.S
--- linux-2.6.31/drivers/lf1000/warm/warm_ops.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/lf1000/warm/warm_ops.S	2010-11-20 20:38:02.000000000 -0800
@@ -0,0 +1,123 @@
+/*
+ * Cache operations
+ *
+ * Author: Gravydas "notaz" Ignotas
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef AUTOCONF_INCLUDED
+#include <linux/config.h>
+#endif
+
+#define CACHELINE_SZC #32
+
+#if !defined(CONFIG_CPU_ARM926T) && !defined(CONFIG_CPU_ARM920T)
+#error CPU not supported
+#endif
+
+.text
+.align 2
+
+.global warm_cop_clean_inval_d
+.global warm_cop_clean_d
+
+#ifdef CONFIG_CPU_ARM926T
+
+warm_cop_clean_inval_d:
+0:  mrc    p15, 0, r15, c7, c14, 3	@ test, clean and invalidate
+    bne    0b
+    bx     lr
+
+warm_cop_clean_d:
+0:  mrc    p15, 0, r15, c7, c10, 3	@ test and clean
+    bne    0b
+    bx     lr
+
+#else
+
+/* comes from Linux kernel code */
+.macro warm_cop_wholecache_dop crm
+    mov    r1,     #0x000000e0		@ 8 segments
+1:  orr    r3, r1, #0xfc000000		@ 64 entries
+2:  mcr    p15, 0, r3, c7, \crm, 2	@ D index op
+    subs   r3, r3, #1<<26
+    bcs    2b				@ entries 63 to 0
+    subs   r1, r1, #1<<5
+    bcs    1b				@ segments 7 to 0
+    bx     lr
+.endm
+
+warm_cop_clean_inval_d:
+    warm_cop_wholecache_dop c14
+
+warm_cop_clean_d:
+    warm_cop_wholecache_dop c10
+
+#endif
+
+.global warm_cop_inval_d
+warm_cop_inval_d:
+    mov    r0, #0
+    mcr    p15, 0, r0, c7, c6, 0
+    bx     lr
+
+
+.global warm_cop_inval_i
+warm_cop_inval_i:
+    mov    r0, #0
+    mcr    p15, 0, r0, c7, c5, 0
+    bx     lr
+
+
+.global warm_cop_drain_wb
+warm_cop_drain_wb:
+    mov    r0, #0
+    mcr    p15, 0, r0, c7, c10, 4
+    bx     lr
+
+
+#define R_CLEAN_INVAL_D \
+    mcr    p15, 0, r0, c7, c14, 1
+
+#define R_CLEAN_D \
+    mcr    p15, 0, r0, c7, c10, 1
+
+#define R_INVAL_D \
+    mcr    p15, 0, r0, c7, c6, 1
+
+#define R_INVAL_I \
+    mcr    p15, 0, r0, c7, c5, 1
+
+#define WARM_COP_MK_RANGE_FUNC(name,f1,f2)	\
+.global name					;\
+name:						;\
+    bic    r0, r0, CACHELINE_SZC-1		;\
+0:  f1						;\
+    f2						;\
+    add    r0, r0, CACHELINE_SZC		;\
+    subs   r1, r1, CACHELINE_SZC		;\
+    bgt    0b					;\
+    bx     lr
+
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_clean_d_inval_di, R_CLEAN_INVAL_D, R_INVAL_I)
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_clean_d_inval_d,  R_CLEAN_INVAL_D, )
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_clean_d_inval_i,  R_CLEAN_D,       R_INVAL_I)
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_clean_d,          R_CLEAN_D, )
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_inval_di,         R_INVAL_D, R_INVAL_I)
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_inval_d,          R_INVAL_D, )
+WARM_COP_MK_RANGE_FUNC(warm_cop_r_inval_i,          R_INVAL_I, )
+
+
+.global warm_drain_wb_inval_tlb
+warm_drain_wb_inval_tlb:
+    mov    r0, #0
+    mcr    p15, 0, r0, c7, c10, 4
+    mcr    p15, 0, r0, c8, c7, 0
+    bx     lr
+
+
+@ vim:filetype=armasm
+
diff -ruaN linux-2.6.31/drivers/Makefile linux-2.6/drivers/Makefile
--- linux-2.6.31/drivers/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -42,7 +42,7 @@
 obj-$(CONFIG_IDE)		+= ide/
 obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
-obj-y				+= net/
+# moved net/ to end of list.  It requires on LF1000 functionalityobj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
 obj-$(CONFIG_FIREWIRE)		+= firewire/
@@ -50,7 +50,7 @@
 obj-$(CONFIG_UIO)		+= uio/
 obj-y				+= cdrom/
 obj-y				+= auxdisplay/
-obj-$(CONFIG_MTD)		+= mtd/
+# mtd moved to end of list.  It requires lf1000 functionality
 obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_PCCARD)		+= pcmcia/
 obj-$(CONFIG_DIO)		+= dio/
@@ -65,17 +65,17 @@
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_USB_MUSB_HDRC)	+= usb/musb/
 obj-$(CONFIG_PCI)		+= usb/
-obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
+# usb gadget moved to end of list.  It requires lf1000 functionality.
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
-obj-$(CONFIG_INPUT)		+= input/
+# input moved to end of list.  It requires lf1000 functionality.
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
 obj-y				+= i2c/ media/
 obj-$(CONFIG_PPS)		+= pps/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
-obj-$(CONFIG_HWMON)		+= hwmon/
+# hwmon moved to end of list.  It requires lf1000 functionality
 obj-$(CONFIG_THERMAL)		+= thermal/
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
 obj-$(CONFIG_PHONE)		+= telephony/
@@ -110,3 +110,9 @@
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-$(CONFIG_ARCH_LF1000)	+= lf1000/
+obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
+obj-$(CONFIG_MTD)		+= mtd/
+obj-$(CONFIG_HWMON)		+= hwmon/
+obj-$(CONFIG_INPUT)		+= input/
+obj-y				+= net/
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_ctrl.c linux-2.6/drivers/media/video/uvc/uvc_ctrl.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_ctrl.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_ctrl.c	2011-01-04 14:35:07.000000000 -0800
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/videodev2.h>
@@ -23,9 +24,13 @@
 
 #include "uvcvideo.h"
 
-#define UVC_CTRL_NDATA		2
 #define UVC_CTRL_DATA_CURRENT	0
 #define UVC_CTRL_DATA_BACKUP	1
+#define UVC_CTRL_DATA_MIN	2
+#define UVC_CTRL_DATA_MAX	3
+#define UVC_CTRL_DATA_RES	4
+#define UVC_CTRL_DATA_DEF	5
+#define UVC_CTRL_DATA_LAST	6
 
 /* ------------------------------------------------------------------------
  * Controls
@@ -34,7 +39,7 @@
 static struct uvc_control_info uvc_ctrls[] = {
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_BRIGHTNESS_CONTROL,
+		.selector	= UVC_PU_BRIGHTNESS_CONTROL,
 		.index		= 0,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -42,7 +47,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_CONTRAST_CONTROL,
+		.selector	= UVC_PU_CONTRAST_CONTROL,
 		.index		= 1,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -50,7 +55,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_HUE_CONTROL,
+		.selector	= UVC_PU_HUE_CONTROL,
 		.index		= 2,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -58,7 +63,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_SATURATION_CONTROL,
+		.selector	= UVC_PU_SATURATION_CONTROL,
 		.index		= 3,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -66,7 +71,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_SHARPNESS_CONTROL,
+		.selector	= UVC_PU_SHARPNESS_CONTROL,
 		.index		= 4,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -74,7 +79,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_GAMMA_CONTROL,
+		.selector	= UVC_PU_GAMMA_CONTROL,
 		.index		= 5,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -82,7 +87,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_TEMPERATURE_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL,
 		.index		= 6,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -90,7 +95,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_COMPONENT_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,
 		.index		= 7,
 		.size		= 4,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -98,7 +103,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_BACKLIGHT_COMPENSATION_CONTROL,
+		.selector	= UVC_PU_BACKLIGHT_COMPENSATION_CONTROL,
 		.index		= 8,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -106,7 +111,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_GAIN_CONTROL,
+		.selector	= UVC_PU_GAIN_CONTROL,
 		.index		= 9,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -114,7 +119,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_POWER_LINE_FREQUENCY_CONTROL,
+		.selector	= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,
 		.index		= 10,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -122,7 +127,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_HUE_AUTO_CONTROL,
+		.selector	= UVC_PU_HUE_AUTO_CONTROL,
 		.index		= 11,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -130,7 +135,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,
 		.index		= 12,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -138,7 +143,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,
 		.index		= 13,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -146,7 +151,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_DIGITAL_MULTIPLIER_CONTROL,
+		.selector	= UVC_PU_DIGITAL_MULTIPLIER_CONTROL,
 		.index		= 14,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -154,7 +159,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,
+		.selector	= UVC_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,
 		.index		= 15,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -162,21 +167,21 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_ANALOG_VIDEO_STANDARD_CONTROL,
+		.selector	= UVC_PU_ANALOG_VIDEO_STANDARD_CONTROL,
 		.index		= 16,
 		.size		= 1,
 		.flags		= UVC_CONTROL_GET_CUR,
 	},
 	{
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_ANALOG_LOCK_STATUS_CONTROL,
+		.selector	= UVC_PU_ANALOG_LOCK_STATUS_CONTROL,
 		.index		= 17,
 		.size		= 1,
 		.flags		= UVC_CONTROL_GET_CUR,
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_SCANNING_MODE_CONTROL,
+		.selector	= UVC_CT_SCANNING_MODE_CONTROL,
 		.index		= 0,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -184,7 +189,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_AE_MODE_CONTROL,
+		.selector	= UVC_CT_AE_MODE_CONTROL,
 		.index		= 1,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -193,7 +198,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_AE_PRIORITY_CONTROL,
+		.selector	= UVC_CT_AE_PRIORITY_CONTROL,
 		.index		= 2,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -201,7 +206,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,
 		.index		= 3,
 		.size		= 4,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -209,7 +214,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_EXPOSURE_TIME_RELATIVE_CONTROL,
+		.selector	= UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL,
 		.index		= 4,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -217,7 +222,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_FOCUS_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_FOCUS_ABSOLUTE_CONTROL,
 		.index		= 5,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -225,7 +230,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_FOCUS_RELATIVE_CONTROL,
+		.selector	= UVC_CT_FOCUS_RELATIVE_CONTROL,
 		.index		= 6,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -233,7 +238,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_IRIS_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_IRIS_ABSOLUTE_CONTROL,
 		.index		= 7,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -241,7 +246,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_IRIS_RELATIVE_CONTROL,
+		.selector	= UVC_CT_IRIS_RELATIVE_CONTROL,
 		.index		= 8,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -249,7 +254,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ZOOM_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_ZOOM_ABSOLUTE_CONTROL,
 		.index		= 9,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -257,7 +262,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ZOOM_RELATIVE_CONTROL,
+		.selector	= UVC_CT_ZOOM_RELATIVE_CONTROL,
 		.index		= 10,
 		.size		= 3,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -265,7 +270,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_PANTILT_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_PANTILT_ABSOLUTE_CONTROL,
 		.index		= 11,
 		.size		= 8,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -273,7 +278,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_PANTILT_RELATIVE_CONTROL,
+		.selector	= UVC_CT_PANTILT_RELATIVE_CONTROL,
 		.index		= 12,
 		.size		= 4,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -281,7 +286,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ROLL_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_ROLL_ABSOLUTE_CONTROL,
 		.index		= 13,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -289,7 +294,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ROLL_RELATIVE_CONTROL,
+		.selector	= UVC_CT_ROLL_RELATIVE_CONTROL,
 		.index		= 14,
 		.size		= 2,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_RANGE
@@ -297,7 +302,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_FOCUS_AUTO_CONTROL,
+		.selector	= UVC_CT_FOCUS_AUTO_CONTROL,
 		.index		= 17,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -305,7 +310,7 @@
 	},
 	{
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_PRIVACY_CONTROL,
+		.selector	= UVC_CT_PRIVACY_CONTROL,
 		.index		= 18,
 		.size		= 1,
 		.flags		= UVC_CONTROL_SET_CUR | UVC_CONTROL_GET_CUR
@@ -332,13 +337,13 @@
 	__s8 zoom = (__s8)data[0];
 
 	switch (query) {
-	case GET_CUR:
+	case UVC_GET_CUR:
 		return (zoom == 0) ? 0 : (zoom > 0 ? data[2] : -data[2]);
 
-	case GET_MIN:
-	case GET_MAX:
-	case GET_RES:
-	case GET_DEF:
+	case UVC_GET_MIN:
+	case UVC_GET_MAX:
+	case UVC_GET_RES:
+	case UVC_GET_DEF:
 	default:
 		return data[2];
 	}
@@ -348,7 +353,7 @@
 	__s32 value, __u8 *data)
 {
 	data[0] = value == 0 ? 0 : (value > 0) ? 1 : 0xff;
-	data[2] = min(abs(value), 0xff);
+	data[2] = min((int)abs(value), 0xff);
 }
 
 static struct uvc_control_mapping uvc_ctrl_mappings[] = {
@@ -356,7 +361,7 @@
 		.id		= V4L2_CID_BRIGHTNESS,
 		.name		= "Brightness",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_BRIGHTNESS_CONTROL,
+		.selector	= UVC_PU_BRIGHTNESS_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -366,7 +371,7 @@
 		.id		= V4L2_CID_CONTRAST,
 		.name		= "Contrast",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_CONTRAST_CONTROL,
+		.selector	= UVC_PU_CONTRAST_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -376,7 +381,7 @@
 		.id		= V4L2_CID_HUE,
 		.name		= "Hue",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_HUE_CONTROL,
+		.selector	= UVC_PU_HUE_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -386,7 +391,7 @@
 		.id		= V4L2_CID_SATURATION,
 		.name		= "Saturation",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_SATURATION_CONTROL,
+		.selector	= UVC_PU_SATURATION_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -396,7 +401,7 @@
 		.id		= V4L2_CID_SHARPNESS,
 		.name		= "Sharpness",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_SHARPNESS_CONTROL,
+		.selector	= UVC_PU_SHARPNESS_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -406,7 +411,7 @@
 		.id		= V4L2_CID_GAMMA,
 		.name		= "Gamma",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_GAMMA_CONTROL,
+		.selector	= UVC_PU_GAMMA_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -416,7 +421,7 @@
 		.id		= V4L2_CID_BACKLIGHT_COMPENSATION,
 		.name		= "Backlight Compensation",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_BACKLIGHT_COMPENSATION_CONTROL,
+		.selector	= UVC_PU_BACKLIGHT_COMPENSATION_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -426,7 +431,7 @@
 		.id		= V4L2_CID_GAIN,
 		.name		= "Gain",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_GAIN_CONTROL,
+		.selector	= UVC_PU_GAIN_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -436,7 +441,7 @@
 		.id		= V4L2_CID_POWER_LINE_FREQUENCY,
 		.name		= "Power Line Frequency",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_POWER_LINE_FREQUENCY_CONTROL,
+		.selector	= UVC_PU_POWER_LINE_FREQUENCY_CONTROL,
 		.size		= 2,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_MENU,
@@ -448,7 +453,7 @@
 		.id		= V4L2_CID_HUE_AUTO,
 		.name		= "Hue, Auto",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_HUE_AUTO_CONTROL,
+		.selector	= UVC_PU_HUE_AUTO_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -458,7 +463,7 @@
 		.id		= V4L2_CID_EXPOSURE_AUTO,
 		.name		= "Exposure, Auto",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_AE_MODE_CONTROL,
+		.selector	= UVC_CT_AE_MODE_CONTROL,
 		.size		= 4,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_MENU,
@@ -470,7 +475,7 @@
 		.id		= V4L2_CID_EXPOSURE_AUTO_PRIORITY,
 		.name		= "Exposure, Auto Priority",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_AE_PRIORITY_CONTROL,
+		.selector	= UVC_CT_AE_PRIORITY_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -480,7 +485,7 @@
 		.id		= V4L2_CID_EXPOSURE_ABSOLUTE,
 		.name		= "Exposure (Absolute)",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL,
 		.size		= 32,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -490,7 +495,7 @@
 		.id		= V4L2_CID_AUTO_WHITE_BALANCE,
 		.name		= "White Balance Temperature, Auto",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -500,7 +505,7 @@
 		.id		= V4L2_CID_WHITE_BALANCE_TEMPERATURE,
 		.name		= "White Balance Temperature",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_TEMPERATURE_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -510,7 +515,7 @@
 		.id		= V4L2_CID_AUTO_WHITE_BALANCE,
 		.name		= "White Balance Component, Auto",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -520,7 +525,7 @@
 		.id		= V4L2_CID_BLUE_BALANCE,
 		.name		= "White Balance Blue Component",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_COMPONENT_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -530,7 +535,7 @@
 		.id		= V4L2_CID_RED_BALANCE,
 		.name		= "White Balance Red Component",
 		.entity		= UVC_GUID_UVC_PROCESSING,
-		.selector	= PU_WHITE_BALANCE_COMPONENT_CONTROL,
+		.selector	= UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL,
 		.size		= 16,
 		.offset		= 16,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -540,7 +545,7 @@
 		.id		= V4L2_CID_FOCUS_ABSOLUTE,
 		.name		= "Focus (absolute)",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_FOCUS_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_FOCUS_ABSOLUTE_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -550,7 +555,7 @@
 		.id		= V4L2_CID_FOCUS_AUTO,
 		.name		= "Focus, Auto",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_FOCUS_AUTO_CONTROL,
+		.selector	= UVC_CT_FOCUS_AUTO_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -560,7 +565,7 @@
 		.id		= V4L2_CID_ZOOM_ABSOLUTE,
 		.name		= "Zoom, Absolute",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ZOOM_ABSOLUTE_CONTROL,
+		.selector	= UVC_CT_ZOOM_ABSOLUTE_CONTROL,
 		.size		= 16,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -570,7 +575,7 @@
 		.id		= V4L2_CID_ZOOM_CONTINUOUS,
 		.name		= "Zoom, Continuous",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_ZOOM_RELATIVE_CONTROL,
+		.selector	= UVC_CT_ZOOM_RELATIVE_CONTROL,
 		.size		= 0,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_INTEGER,
@@ -582,7 +587,7 @@
 		.id		= V4L2_CID_PRIVACY,
 		.name		= "Privacy",
 		.entity		= UVC_GUID_UVC_CAMERA,
-		.selector	= CT_PRIVACY_CONTROL,
+		.selector	= UVC_CT_PRIVACY_CONTROL,
 		.size		= 1,
 		.offset		= 0,
 		.v4l2_type	= V4L2_CTRL_TYPE_BOOLEAN,
@@ -675,16 +680,16 @@
 static int uvc_entity_match_guid(struct uvc_entity *entity, __u8 guid[16])
 {
 	switch (UVC_ENTITY_TYPE(entity)) {
-	case ITT_CAMERA:
+	case UVC_ITT_CAMERA:
 		return memcmp(uvc_camera_guid, guid, 16) == 0;
 
-	case ITT_MEDIA_TRANSPORT_INPUT:
+	case UVC_ITT_MEDIA_TRANSPORT_INPUT:
 		return memcmp(uvc_media_transport_input_guid, guid, 16) == 0;
 
-	case VC_PROCESSING_UNIT:
+	case UVC_VC_PROCESSING_UNIT:
 		return memcmp(uvc_processing_guid, guid, 16) == 0;
 
-	case VC_EXTENSION_UNIT:
+	case UVC_VC_EXTENSION_UNIT:
 		return memcmp(entity->extension.guidExtensionCode,
 			      guid, 16) == 0;
 
@@ -729,7 +734,7 @@
 	}
 }
 
-struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 	__u32 v4l2_id, struct uvc_control_mapping **mapping)
 {
 	struct uvc_control *ctrl = NULL;
@@ -742,17 +747,7 @@
 	v4l2_id &= V4L2_CTRL_ID_MASK;
 
 	/* Find the control. */
-	__uvc_find_control(video->processing, v4l2_id, mapping, &ctrl, next);
-	if (ctrl && !next)
-		return ctrl;
-
-	list_for_each_entry(entity, &video->iterms, chain) {
-		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
-		if (ctrl && !next)
-			return ctrl;
-	}
-
-	list_for_each_entry(entity, &video->extensions, chain) {
+	list_for_each_entry(entity, &chain->entities, chain) {
 		__uvc_find_control(entity, v4l2_id, mapping, &ctrl, next);
 		if (ctrl && !next)
 			return ctrl;
@@ -765,24 +760,62 @@
 	return ctrl;
 }
 
-int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+static int uvc_ctrl_populate_cache(struct uvc_video_chain *chain,
+	struct uvc_control *ctrl)
+{
+	int ret;
+
+	if (ctrl->info->flags & UVC_CONTROL_GET_DEF) {
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_DEF, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF),
+				     ctrl->info->size);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (ctrl->info->flags & UVC_CONTROL_GET_MIN) {
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_MIN, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN),
+				     ctrl->info->size);
+		if (ret < 0)
+			return ret;
+	}
+	if (ctrl->info->flags & UVC_CONTROL_GET_MAX) {
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_MAX, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX),
+				     ctrl->info->size);
+		if (ret < 0)
+			return ret;
+	}
+	if (ctrl->info->flags & UVC_CONTROL_GET_RES) {
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_RES, ctrl->entity->id,
+				     chain->dev->intfnum, ctrl->info->selector,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES),
+				     ctrl->info->size);
+		if (ret < 0)
+			return ret;
+	}
+
+	ctrl->cached = 1;
+	return 0;
+}
+
+int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 	struct v4l2_queryctrl *v4l2_ctrl)
 {
 	struct uvc_control *ctrl;
 	struct uvc_control_mapping *mapping;
 	struct uvc_menu_info *menu;
 	unsigned int i;
-	__u8 *data;
 	int ret;
 
-	ctrl = uvc_find_control(video, v4l2_ctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, v4l2_ctrl->id, &mapping);
 	if (ctrl == NULL)
 		return -EINVAL;
 
-	data = kmalloc(ctrl->info->size, GFP_KERNEL);
-	if (data == NULL)
-		return -ENOMEM;
-
 	memset(v4l2_ctrl, 0, sizeof *v4l2_ctrl);
 	v4l2_ctrl->id = mapping->id;
 	v4l2_ctrl->type = mapping->v4l2_type;
@@ -792,12 +825,15 @@
 	if (!(ctrl->info->flags & UVC_CONTROL_SET_CUR))
 		v4l2_ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
 
+	if (!ctrl->cached) {
+		ret = uvc_ctrl_populate_cache(chain, ctrl);
+		if (ret < 0)
+			return ret;
+	}
+
 	if (ctrl->info->flags & UVC_CONTROL_GET_DEF) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_DEF, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
-			goto out;
-		v4l2_ctrl->default_value = mapping->get(mapping, GET_DEF, data);
+		v4l2_ctrl->default_value = mapping->get(mapping, UVC_GET_DEF,
+				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_DEF));
 	}
 
 	switch (mapping->v4l2_type) {
@@ -814,46 +850,37 @@
 			}
 		}
 
-		ret = 0;
-		goto out;
+		return 0;
 
 	case V4L2_CTRL_TYPE_BOOLEAN:
 		v4l2_ctrl->minimum = 0;
 		v4l2_ctrl->maximum = 1;
 		v4l2_ctrl->step = 1;
-		ret = 0;
-		goto out;
+		return 0;
+
+	case V4L2_CTRL_TYPE_BUTTON:
+		v4l2_ctrl->minimum = 0;
+		v4l2_ctrl->maximum = 0;
+		v4l2_ctrl->step = 0;
+		return 0;
 
 	default:
 		break;
 	}
 
-	if (ctrl->info->flags & UVC_CONTROL_GET_MIN) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_MIN, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
-			goto out;
-		v4l2_ctrl->minimum = mapping->get(mapping, GET_MIN, data);
-	}
-	if (ctrl->info->flags & UVC_CONTROL_GET_MAX) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_MAX, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
-			goto out;
-		v4l2_ctrl->maximum = mapping->get(mapping, GET_MAX, data);
-	}
-	if (ctrl->info->flags & UVC_CONTROL_GET_RES) {
-		if ((ret = uvc_query_ctrl(video->dev, GET_RES, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
-				data, ctrl->info->size)) < 0)
-			goto out;
-		v4l2_ctrl->step = mapping->get(mapping, GET_RES, data);
-	}
+	if (ctrl->info->flags & UVC_CONTROL_GET_MIN)
+		v4l2_ctrl->minimum = mapping->get(mapping, UVC_GET_MIN,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));
+
+	if (ctrl->info->flags & UVC_CONTROL_GET_MAX)
+		v4l2_ctrl->maximum = mapping->get(mapping, UVC_GET_MAX,
+				     uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));
+
+	if (ctrl->info->flags & UVC_CONTROL_GET_RES)
+		v4l2_ctrl->step = mapping->get(mapping, UVC_GET_RES,
+				  uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));
 
-	ret = 0;
-out:
-	kfree(data);
-	return ret;
+	return 0;
 }
 
 
@@ -881,9 +908,9 @@
  * (UVC_CTRL_DATA_BACKUP) for all dirty controls. Both functions release the
  * control lock.
  */
-int uvc_ctrl_begin(struct uvc_video_device *video)
+int uvc_ctrl_begin(struct uvc_video_chain *chain)
 {
-	return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS : 0;
+	return mutex_lock_interruptible(&chain->ctrl_mutex) ? -ERESTARTSYS : 0;
 }
 
 static int uvc_ctrl_commit_entity(struct uvc_device *dev,
@@ -912,7 +939,7 @@
 			continue;
 
 		if (!rollback)
-			ret = uvc_query_ctrl(dev, SET_CUR, ctrl->entity->id,
+			ret = uvc_query_ctrl(dev, UVC_SET_CUR, ctrl->entity->id,
 				dev->intfnum, ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
@@ -933,34 +960,24 @@
 	return 0;
 }
 
-int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback)
+int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback)
 {
 	struct uvc_entity *entity;
 	int ret = 0;
 
 	/* Find the control. */
-	ret = uvc_ctrl_commit_entity(video->dev, video->processing, rollback);
-	if (ret < 0)
-		goto done;
-
-	list_for_each_entry(entity, &video->iterms, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
-		if (ret < 0)
-			goto done;
-	}
-
-	list_for_each_entry(entity, &video->extensions, chain) {
-		ret = uvc_ctrl_commit_entity(video->dev, entity, rollback);
+	list_for_each_entry(entity, &chain->entities, chain) {
+		ret = uvc_ctrl_commit_entity(chain->dev, entity, rollback);
 		if (ret < 0)
 			goto done;
 	}
 
 done:
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
-int uvc_ctrl_get(struct uvc_video_device *video,
+int uvc_ctrl_get(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
@@ -969,13 +986,13 @@
 	unsigned int i;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0)
 		return -EINVAL;
 
 	if (!ctrl->loaded) {
-		ret = uvc_query_ctrl(video->dev, GET_CUR, ctrl->entity->id,
-				video->dev->intfnum, ctrl->info->selector,
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR, ctrl->entity->id,
+				chain->dev->intfnum, ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
 		if (ret < 0)
@@ -984,7 +1001,7 @@
 		ctrl->loaded = 1;
 	}
 
-	xctrl->value = mapping->get(mapping, GET_CUR,
+	xctrl->value = mapping->get(mapping, UVC_GET_CUR,
 		uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT));
 
 	if (mapping->v4l2_type == V4L2_CTRL_TYPE_MENU) {
@@ -1000,31 +1017,69 @@
 	return 0;
 }
 
-int uvc_ctrl_set(struct uvc_video_device *video,
+int uvc_ctrl_set(struct uvc_video_chain *chain,
 	struct v4l2_ext_control *xctrl)
 {
 	struct uvc_control *ctrl;
 	struct uvc_control_mapping *mapping;
-	s32 value = xctrl->value;
+	s32 value;
+	u32 step;
+	s32 min;
+	s32 max;
 	int ret;
 
-	ctrl = uvc_find_control(video, xctrl->id, &mapping);
+	ctrl = uvc_find_control(chain, xctrl->id, &mapping);
 	if (ctrl == NULL || (ctrl->info->flags & UVC_CONTROL_SET_CUR) == 0)
 		return -EINVAL;
 
-	if (mapping->v4l2_type == V4L2_CTRL_TYPE_MENU) {
-		if (value < 0 || value >= mapping->menu_count)
-			return -EINVAL;
-		value = mapping->menu_info[value].value;
+	/* Clamp out of range values. */
+	switch (mapping->v4l2_type) {
+	case V4L2_CTRL_TYPE_INTEGER:
+		if (!ctrl->cached) {
+			ret = uvc_ctrl_populate_cache(chain, ctrl);
+			if (ret < 0)
+				return ret;
+		}
+
+		min = mapping->get(mapping, UVC_GET_MIN,
+				   uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MIN));
+		max = mapping->get(mapping, UVC_GET_MAX,
+				   uvc_ctrl_data(ctrl, UVC_CTRL_DATA_MAX));
+		step = mapping->get(mapping, UVC_GET_RES,
+				    uvc_ctrl_data(ctrl, UVC_CTRL_DATA_RES));
+
+		xctrl->value = min + (xctrl->value - min + step/2) / step * step;
+		xctrl->value = clamp(xctrl->value, min, max);
+		value = xctrl->value;
+		break;
+
+	case V4L2_CTRL_TYPE_BOOLEAN:
+		xctrl->value = clamp(xctrl->value, 0, 1);
+		value = xctrl->value;
+		break;
+
+	case V4L2_CTRL_TYPE_MENU:
+		if (xctrl->value < 0 || xctrl->value >= mapping->menu_count)
+			return -ERANGE;
+		value = mapping->menu_info[xctrl->value].value;
+		break;
+
+	default:
+		value = xctrl->value;
+		break;
 	}
 
+	/* If the mapping doesn't span the whole UVC control, the current value
+	 * needs to be loaded from the device to perform the read-modify-write
+	 * operation.
+	 */
 	if (!ctrl->loaded && (ctrl->info->size * 8) != mapping->size) {
 		if ((ctrl->info->flags & UVC_CONTROL_GET_CUR) == 0) {
 			memset(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				0, ctrl->info->size);
 		} else {
-			ret = uvc_query_ctrl(video->dev, GET_CUR,
-				ctrl->entity->id, video->dev->intfnum,
+			ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
+				ctrl->entity->id, chain->dev->intfnum,
 				ctrl->info->selector,
 				uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
 				ctrl->info->size);
@@ -1035,6 +1090,7 @@
 		ctrl->loaded = 1;
 	}
 
+	/* Backup the current value in case we need to rollback later. */
 	if (!ctrl->dirty) {
 		memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
 		       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_CURRENT),
@@ -1053,7 +1109,7 @@
  * Dynamic controls
  */
 
-int uvc_xu_ctrl_query(struct uvc_video_device *video,
+int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 	struct uvc_xu_control *xctrl, int set)
 {
 	struct uvc_entity *entity;
@@ -1063,8 +1119,9 @@
 	int ret;
 
 	/* Find the extension unit. */
-	list_for_each_entry(entity, &video->extensions, chain) {
-		if (entity->id == xctrl->unit)
+	list_for_each_entry(entity, &chain->entities, chain) {
+		if (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT &&
+		    entity->id == xctrl->unit)
 			break;
 	}
 
@@ -1087,10 +1144,8 @@
 	}
 
 	if (!found) {
-		uvc_trace(UVC_TRACE_CONTROL,
-			"Control " UVC_GUID_FORMAT "/%u not found.\n",
-			UVC_GUID_ARGS(entity->extension.guidExtensionCode),
-			xctrl->selector);
+		uvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u not found.\n",
+			entity->extension.guidExtensionCode, xctrl->selector);
 		return -EINVAL;
 	}
 
@@ -1102,7 +1157,7 @@
 	    (!set && !(ctrl->info->flags & UVC_CONTROL_GET_CUR)))
 		return -EINVAL;
 
-	if (mutex_lock_interruptible(&video->ctrl_mutex))
+	if (mutex_lock_interruptible(&chain->ctrl_mutex))
 		return -ERESTARTSYS;
 
 	memcpy(uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
@@ -1115,9 +1170,9 @@
 		goto out;
 	}
 
-	ret = uvc_query_ctrl(video->dev, set ? SET_CUR : GET_CUR, xctrl->unit,
-			     video->dev->intfnum, xctrl->selector, data,
-			     xctrl->size);
+	ret = uvc_query_ctrl(chain->dev, set ? UVC_SET_CUR : UVC_GET_CUR,
+			     xctrl->unit, chain->dev->intfnum, xctrl->selector,
+			     data, xctrl->size);
 	if (ret < 0)
 		goto out;
 
@@ -1132,7 +1187,7 @@
 		       uvc_ctrl_data(ctrl, UVC_CTRL_DATA_BACKUP),
 		       xctrl->size);
 
-	mutex_unlock(&video->ctrl_mutex);
+	mutex_unlock(&chain->ctrl_mutex);
 	return ret;
 }
 
@@ -1166,9 +1221,9 @@
 			    (ctrl->info->flags & UVC_CONTROL_RESTORE) == 0)
 				continue;
 
-			printk(KERN_INFO "restoring control " UVC_GUID_FORMAT
-				"/%u/%u\n", UVC_GUID_ARGS(ctrl->info->entity),
-				ctrl->info->index, ctrl->info->selector);
+			printk(KERN_INFO "restoring control %pUl/%u/%u\n",
+				ctrl->info->entity, ctrl->info->index,
+				ctrl->info->selector);
 			ctrl->dirty = 1;
 		}
 
@@ -1211,7 +1266,7 @@
 	if (!found)
 		return;
 
-	if (UVC_ENTITY_TYPE(entity) == VC_EXTENSION_UNIT) {
+	if (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT) {
 		/* Check if the device control information and length match
 		 * the user supplied information.
 		 */
@@ -1219,48 +1274,46 @@
 		__le16 size;
 		__u8 inf;
 
-		if ((ret = uvc_query_ctrl(dev, GET_LEN, ctrl->entity->id,
-			dev->intfnum, info->selector, (__u8 *)&size, 2)) < 0) {
-			uvc_trace(UVC_TRACE_CONTROL, "GET_LEN failed on "
-				"control " UVC_GUID_FORMAT "/%u (%d).\n",
-				UVC_GUID_ARGS(info->entity), info->selector,
-				ret);
+		ret = uvc_query_ctrl(dev, UVC_GET_LEN, ctrl->entity->id,
+			dev->intfnum, info->selector, (__u8 *)&size, 2);
+		if (ret < 0) {
+			uvc_trace(UVC_TRACE_CONTROL,
+				"GET_LEN failed on control %pUl/%u (%d).\n",
+				info->entity, info->selector, ret);
 			return;
 		}
 
 		if (info->size != le16_to_cpu(size)) {
-			uvc_trace(UVC_TRACE_CONTROL, "Control " UVC_GUID_FORMAT
-				"/%u size doesn't match user supplied "
-				"value.\n", UVC_GUID_ARGS(info->entity),
-				info->selector);
+			uvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u size "
+				"doesn't match user supplied value.\n",
+				info->entity, info->selector);
 			return;
 		}
 
-		if ((ret = uvc_query_ctrl(dev, GET_INFO, ctrl->entity->id,
-			dev->intfnum, info->selector, &inf, 1)) < 0) {
-			uvc_trace(UVC_TRACE_CONTROL, "GET_INFO failed on "
-				"control " UVC_GUID_FORMAT "/%u (%d).\n",
-				UVC_GUID_ARGS(info->entity), info->selector,
-				ret);
+		ret = uvc_query_ctrl(dev, UVC_GET_INFO, ctrl->entity->id,
+			dev->intfnum, info->selector, &inf, 1);
+		if (ret < 0) {
+			uvc_trace(UVC_TRACE_CONTROL,
+				"GET_INFO failed on control %pUl/%u (%d).\n",
+				info->entity, info->selector, ret);
 			return;
 		}
 
 		flags = info->flags;
 		if (((flags & UVC_CONTROL_GET_CUR) && !(inf & (1 << 0))) ||
 		    ((flags & UVC_CONTROL_SET_CUR) && !(inf & (1 << 1)))) {
-			uvc_trace(UVC_TRACE_CONTROL, "Control "
-				UVC_GUID_FORMAT "/%u flags don't match "
-				"supported operations.\n",
-				UVC_GUID_ARGS(info->entity), info->selector);
+			uvc_trace(UVC_TRACE_CONTROL, "Control %pUl/%u flags "
+				"don't match supported operations.\n",
+				info->entity, info->selector);
 			return;
 		}
 	}
 
 	ctrl->info = info;
-	ctrl->data = kmalloc(ctrl->info->size * UVC_CTRL_NDATA, GFP_KERNEL);
-	uvc_trace(UVC_TRACE_CONTROL, "Added control " UVC_GUID_FORMAT "/%u "
-		"to device %s entity %u\n", UVC_GUID_ARGS(ctrl->info->entity),
-		ctrl->info->selector, dev->udev->devpath, entity->id);
+	ctrl->data = kmalloc(ctrl->info->size * UVC_CTRL_DATA_LAST, GFP_KERNEL);
+	uvc_trace(UVC_TRACE_CONTROL, "Added control %pUl/%u to device %s "
+		"entity %u\n", ctrl->info->entity, ctrl->info->selector,
+		dev->udev->devpath, entity->id);
 }
 
 /*
@@ -1286,17 +1339,16 @@
 			continue;
 
 		if (ctrl->selector == info->selector) {
-			uvc_trace(UVC_TRACE_CONTROL, "Control "
-				UVC_GUID_FORMAT "/%u is already defined.\n",
-				UVC_GUID_ARGS(info->entity), info->selector);
+			uvc_trace(UVC_TRACE_CONTROL,
+				"Control %pUl/%u is already defined.\n",
+				info->entity, info->selector);
 			ret = -EEXIST;
 			goto end;
 		}
 		if (ctrl->index == info->index) {
-			uvc_trace(UVC_TRACE_CONTROL, "Control "
-				UVC_GUID_FORMAT "/%u would overwrite index "
-				"%d.\n", UVC_GUID_ARGS(info->entity),
-				info->selector, info->index);
+			uvc_trace(UVC_TRACE_CONTROL,
+				"Control %pUl/%u would overwrite index %d.\n",
+				info->entity, info->selector, info->index);
 			ret = -EEXIST;
 			goto end;
 		}
@@ -1337,10 +1389,9 @@
 			continue;
 
 		if (info->size * 8 < mapping->size + mapping->offset) {
-			uvc_trace(UVC_TRACE_CONTROL, "Mapping '%s' would "
-				"overflow control " UVC_GUID_FORMAT "/%u\n",
-				mapping->name, UVC_GUID_ARGS(info->entity),
-				info->selector);
+			uvc_trace(UVC_TRACE_CONTROL,
+				"Mapping '%s' would overflow control %pUl/%u\n",
+				mapping->name, info->entity, info->selector);
 			ret = -EOVERFLOW;
 			goto end;
 		}
@@ -1359,9 +1410,9 @@
 
 		mapping->ctrl = info;
 		list_add_tail(&mapping->list, &info->mappings);
-		uvc_trace(UVC_TRACE_CONTROL, "Adding mapping %s to control "
-			UVC_GUID_FORMAT "/%u.\n", mapping->name,
-			UVC_GUID_ARGS(info->entity), info->selector);
+		uvc_trace(UVC_TRACE_CONTROL,
+			"Adding mapping %s to control %pUl/%u.\n",
+			mapping->name, info->entity, info->selector);
 
 		ret = 0;
 		break;
@@ -1383,6 +1434,7 @@
 		struct usb_device_id id;
 		u8 index;
 	} blacklist[] = {
+		{ { USB_DEVICE(0x13d3, 0x509b) }, 9 }, /* Gain */
 		{ { USB_DEVICE(0x1c4f, 0x3000) }, 6 }, /* WB Temperature */
 		{ { USB_DEVICE(0x5986, 0x0241) }, 2 }, /* Hue */
 	};
@@ -1391,14 +1443,14 @@
 	unsigned int size;
 	unsigned int i;
 
-	if (UVC_ENTITY_TYPE(entity) != VC_PROCESSING_UNIT)
+	if (UVC_ENTITY_TYPE(entity) != UVC_VC_PROCESSING_UNIT)
 		return;
 
 	controls = entity->processing.bmControls;
 	size = entity->processing.bControlSize;
 
 	for (i = 0; i < ARRAY_SIZE(blacklist); ++i) {
-		if (!usb_match_id(dev->intf, &blacklist[i].id))
+		if (!usb_match_one_id(dev->intf, &blacklist[i].id))
 			continue;
 
 		if (blacklist[i].index >= 8 * size ||
@@ -1427,13 +1479,13 @@
 		unsigned int bControlSize = 0, ncontrols = 0;
 		__u8 *bmControls = NULL;
 
-		if (UVC_ENTITY_TYPE(entity) == VC_EXTENSION_UNIT) {
+		if (UVC_ENTITY_TYPE(entity) == UVC_VC_EXTENSION_UNIT) {
 			bmControls = entity->extension.bmControls;
 			bControlSize = entity->extension.bControlSize;
-		} else if (UVC_ENTITY_TYPE(entity) == VC_PROCESSING_UNIT) {
+		} else if (UVC_ENTITY_TYPE(entity) == UVC_VC_PROCESSING_UNIT) {
 			bmControls = entity->processing.bmControls;
 			bControlSize = entity->processing.bControlSize;
-		} else if (UVC_ENTITY_TYPE(entity) == ITT_CAMERA) {
+		} else if (UVC_ENTITY_TYPE(entity) == UVC_ITT_CAMERA) {
 			bmControls = entity->camera.bmControls;
 			bControlSize = entity->camera.bControlSize;
 		}
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_driver.c linux-2.6/drivers/media/video/uvc/uvc_driver.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_driver.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_driver.c	2011-01-04 14:35:07.000000000 -0800
@@ -26,6 +26,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/videodev2.h>
 #include <linux/vmalloc.h>
@@ -43,9 +44,11 @@
 #define DRIVER_VERSION		"v0.1.0"
 #endif
 
+unsigned int uvc_clock_param = CLOCK_MONOTONIC;
 unsigned int uvc_no_drop_param;
-static unsigned int uvc_quirks_param;
+static unsigned int uvc_quirks_param = -1;
 unsigned int uvc_trace_param;
+unsigned int uvc_timeout_param = UVC_CTRL_STREAMING_TIMEOUT;
 
 /* ------------------------------------------------------------------------
  * Video formats
@@ -58,6 +61,11 @@
 		.fcc		= V4L2_PIX_FMT_YUYV,
 	},
 	{
+		.name		= "YUV 4:2:2 (YUYV)",
+		.guid		= UVC_GUID_FORMAT_YUY2_ISIGHT,
+		.fcc		= V4L2_PIX_FMT_YUYV,
+	},
+	{
 		.name		= "YUV 4:2:0 (NV12)",
 		.guid		= UVC_GUID_FORMAT_NV12,
 		.fcc		= V4L2_PIX_FMT_NV12,
@@ -248,36 +256,28 @@
 		entity = list_entry(&dev->entities, struct uvc_entity, list);
 
 	list_for_each_entry_continue(entity, &dev->entities, list) {
-		switch (UVC_ENTITY_TYPE(entity)) {
-		case TT_STREAMING:
-			if (entity->output.bSourceID == id)
+		for (i = 0; i < entity->bNrInPins; ++i)
+			if (entity->baSourceID[i] == id)
 				return entity;
-			break;
+	}
 
-		case VC_PROCESSING_UNIT:
-			if (entity->processing.bSourceID == id)
-				return entity;
-			break;
+	return NULL;
+}
 
-		case VC_SELECTOR_UNIT:
-			for (i = 0; i < entity->selector.bNrInPins; ++i)
-				if (entity->selector.baSourceID[i] == id)
-					return entity;
-			break;
+static struct uvc_streaming *uvc_stream_by_id(struct uvc_device *dev, int id)
+{
+	struct uvc_streaming *stream;
 
-		case VC_EXTENSION_UNIT:
-			for (i = 0; i < entity->extension.bNrInPins; ++i)
-				if (entity->extension.baSourceID[i] == id)
-					return entity;
-			break;
-		}
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->header.bTerminalLink == id)
+			return stream;
 	}
 
 	return NULL;
 }
 
 /* ------------------------------------------------------------------------
- * Descriptors handling
+ * Descriptors parsing
  */
 
 static int uvc_parse_format(struct uvc_device *dev,
@@ -297,9 +297,9 @@
 	format->index = buffer[3];
 
 	switch (buffer[2]) {
-	case VS_FORMAT_UNCOMPRESSED:
-	case VS_FORMAT_FRAME_BASED:
-		n = buffer[2] == VS_FORMAT_UNCOMPRESSED ? 27 : 28;
+	case UVC_VS_FORMAT_UNCOMPRESSED:
+	case UVC_VS_FORMAT_FRAME_BASED:
+		n = buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED ? 27 : 28;
 		if (buflen < n) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
@@ -316,25 +316,24 @@
 				sizeof format->name);
 			format->fcc = fmtdesc->fcc;
 		} else {
-			uvc_printk(KERN_INFO, "Unknown video format "
-				UVC_GUID_FORMAT "\n",
-				UVC_GUID_ARGS(&buffer[5]));
-			snprintf(format->name, sizeof format->name,
-				UVC_GUID_FORMAT, UVC_GUID_ARGS(&buffer[5]));
+			uvc_printk(KERN_INFO, "Unknown video format %pUl\n",
+				&buffer[5]);
+			snprintf(format->name, sizeof(format->name), "%pUl\n",
+				&buffer[5]);
 			format->fcc = 0;
 		}
 
 		format->bpp = buffer[21];
-		if (buffer[2] == VS_FORMAT_UNCOMPRESSED) {
-			ftype = VS_FRAME_UNCOMPRESSED;
+		if (buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED) {
+			ftype = UVC_VS_FRAME_UNCOMPRESSED;
 		} else {
-			ftype = VS_FRAME_FRAME_BASED;
+			ftype = UVC_VS_FRAME_FRAME_BASED;
 			if (buffer[27])
 				format->flags = UVC_FMT_FLAG_COMPRESSED;
 		}
 		break;
 
-	case VS_FORMAT_MJPEG:
+	case UVC_VS_FORMAT_MJPEG:
 		if (buflen < 11) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
@@ -347,10 +346,10 @@
 		format->fcc = V4L2_PIX_FMT_MJPEG;
 		format->flags = UVC_FMT_FLAG_COMPRESSED;
 		format->bpp = 0;
-		ftype = VS_FRAME_MJPEG;
+		ftype = UVC_VS_FRAME_MJPEG;
 		break;
 
-	case VS_FORMAT_DV:
+	case UVC_VS_FORMAT_DV:
 		if (buflen < 9) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
@@ -395,8 +394,8 @@
 		format->nframes = 1;
 		break;
 
-	case VS_FORMAT_MPEG2TS:
-	case VS_FORMAT_STREAM_BASED:
+	case UVC_VS_FORMAT_MPEG2TS:
+	case UVC_VS_FORMAT_STREAM_BASED:
 		/* Not supported yet. */
 	default:
 		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
@@ -414,9 +413,10 @@
 	/* Parse the frame descriptors. Only uncompressed, MJPEG and frame
 	 * based formats have frame descriptors.
 	 */
-	while (buflen > 2 && buffer[2] == ftype) {
+	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
+	       buffer[2] == ftype) {
 		frame = &format->frame[format->nframes];
-		if (ftype != VS_FRAME_FRAME_BASED)
+		if (ftype != UVC_VS_FRAME_FRAME_BASED)
 			n = buflen > 25 ? buffer[25] : 0;
 		else
 			n = buflen > 21 ? buffer[21] : 0;
@@ -436,7 +436,7 @@
 		frame->wHeight = get_unaligned_le16(&buffer[7]);
 		frame->dwMinBitRate = get_unaligned_le32(&buffer[9]);
 		frame->dwMaxBitRate = get_unaligned_le32(&buffer[13]);
-		if (ftype != VS_FRAME_FRAME_BASED) {
+		if (ftype != UVC_VS_FRAME_FRAME_BASED) {
 			frame->dwMaxVideoFrameBufferSize =
 				get_unaligned_le32(&buffer[17]);
 			frame->dwDefaultFrameInterval =
@@ -491,12 +491,14 @@
 		buffer += buffer[0];
 	}
 
-	if (buflen > 2 && buffer[2] == VS_STILL_IMAGE_FRAME) {
+	if (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
+	    buffer[2] == UVC_VS_STILL_IMAGE_FRAME) {
 		buflen -= buffer[0];
 		buffer += buffer[0];
 	}
 
-	if (buflen > 2 && buffer[2] == VS_COLORFORMAT) {
+	if (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
+	    buffer[2] == UVC_VS_COLORFORMAT) {
 		if (buflen < 6) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d COLORFORMAT error\n",
@@ -530,7 +532,7 @@
 	int ret = -EINVAL;
 
 	if (intf->cur_altsetting->desc.bInterfaceSubClass
-		!= SC_VIDEOSTREAMING) {
+		!= UVC_SC_VIDEOSTREAMING) {
 		uvc_trace(UVC_TRACE_DESCR, "device %d interface %d isn't a "
 			"video streaming interface\n", dev->udev->devnum,
 			intf->altsetting[0].desc.bInterfaceNumber);
@@ -551,6 +553,7 @@
 	}
 
 	mutex_init(&streaming->mutex);
+	streaming->dev = dev;
 	streaming->intf = usb_get_intf(intf);
 	streaming->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;
 
@@ -589,12 +592,12 @@
 
 	/* Parse the header descriptor. */
 	switch (buffer[2]) {
-	case VS_OUTPUT_HEADER:
+	case UVC_VS_OUTPUT_HEADER:
 		streaming->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
 		size = 9;
 		break;
 
-	case VS_INPUT_HEADER:
+	case UVC_VS_INPUT_HEADER:
 		streaming->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		size = 13;
 		break;
@@ -618,7 +621,7 @@
 
 	streaming->header.bNumFormats = p;
 	streaming->header.bEndpointAddress = buffer[6];
-	if (buffer[2] == VS_INPUT_HEADER) {
+	if (buffer[2] == UVC_VS_INPUT_HEADER) {
 		streaming->header.bmInfo = buffer[7];
 		streaming->header.bTerminalLink = buffer[8];
 		streaming->header.bStillCaptureMethod = buffer[9];
@@ -644,15 +647,15 @@
 	_buflen = buflen;
 
 	/* Count the format and frame descriptors. */
-	while (_buflen > 2 && _buffer[1] == CS_INTERFACE) {
+	while (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {
 		switch (_buffer[2]) {
-		case VS_FORMAT_UNCOMPRESSED:
-		case VS_FORMAT_MJPEG:
-		case VS_FORMAT_FRAME_BASED:
+		case UVC_VS_FORMAT_UNCOMPRESSED:
+		case UVC_VS_FORMAT_MJPEG:
+		case UVC_VS_FORMAT_FRAME_BASED:
 			nformats++;
 			break;
 
-		case VS_FORMAT_DV:
+		case UVC_VS_FORMAT_DV:
 			/* DV format has no frame descriptor. We will create a
 			 * dummy frame descriptor with a dummy frame interval.
 			 */
@@ -661,22 +664,22 @@
 			nintervals++;
 			break;
 
-		case VS_FORMAT_MPEG2TS:
-		case VS_FORMAT_STREAM_BASED:
+		case UVC_VS_FORMAT_MPEG2TS:
+		case UVC_VS_FORMAT_STREAM_BASED:
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 				"interface %d FORMAT %u is not supported.\n",
 				dev->udev->devnum,
 				alts->desc.bInterfaceNumber, _buffer[2]);
 			break;
 
-		case VS_FRAME_UNCOMPRESSED:
-		case VS_FRAME_MJPEG:
+		case UVC_VS_FRAME_UNCOMPRESSED:
+		case UVC_VS_FRAME_MJPEG:
 			nframes++;
 			if (_buflen > 25)
 				nintervals += _buffer[25] ? _buffer[25] : 3;
 			break;
 
-		case VS_FRAME_FRAME_BASED:
+		case UVC_VS_FRAME_FRAME_BASED:
 			nframes++;
 			if (_buflen > 21)
 				nintervals += _buffer[21] ? _buffer[21] : 3;
@@ -709,12 +712,12 @@
 	streaming->nformats = nformats;
 
 	/* Parse the format descriptors. */
-	while (buflen > 2 && buffer[1] == CS_INTERFACE) {
+	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {
 		switch (buffer[2]) {
-		case VS_FORMAT_UNCOMPRESSED:
-		case VS_FORMAT_MJPEG:
-		case VS_FORMAT_DV:
-		case VS_FORMAT_FRAME_BASED:
+		case UVC_VS_FORMAT_UNCOMPRESSED:
+		case UVC_VS_FORMAT_MJPEG:
+		case UVC_VS_FORMAT_DV:
+		case UVC_VS_FORMAT_FRAME_BASED:
 			format->frame = frame;
 			ret = uvc_parse_format(dev, streaming, format,
 				&interval, buffer, buflen);
@@ -736,6 +739,11 @@
 		buffer += buffer[0];
 	}
 
+	if (buflen)
+		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
+			"%d has %u bytes of trailing descriptor garbage.\n",
+			dev->udev->devnum, alts->desc.bInterfaceNumber, buflen);
+
 	/* Parse the alternate settings to find the maximum bandwidth. */
 	for (i = 0; i < intf->num_altsetting; ++i) {
 		struct usb_host_endpoint *ep;
@@ -751,7 +759,7 @@
 			streaming->maxpsize = psize;
 	}
 
-	list_add_tail(&streaming->list, &dev->streaming);
+	list_add_tail(&streaming->list, &dev->streams);
 	return 0;
 
 error:
@@ -763,6 +771,28 @@
 	return ret;
 }
 
+static struct uvc_entity *uvc_alloc_entity(u16 type, u8 id,
+		unsigned int num_pads, unsigned int extra_size)
+{
+	struct uvc_entity *entity;
+	unsigned int num_inputs;
+	unsigned int size;
+
+	num_inputs = (type & UVC_TERM_OUTPUT) ? num_pads : num_pads - 1;
+	size = sizeof(*entity) + extra_size + num_inputs;
+	entity = kzalloc(size, GFP_KERNEL);
+	if (entity == NULL)
+		return NULL;
+
+	entity->id = id;
+	entity->type = type;
+
+	entity->bNrInPins = num_inputs;
+	entity->baSourceID = ((__u8 *)entity) + sizeof(*entity) + extra_size;
+
+	return entity;
+}
+
 /* Parse vendor-specific extensions. */
 static int uvc_parse_vendor_control(struct uvc_device *dev,
 	const unsigned char *buffer, int buflen)
@@ -814,21 +844,18 @@
 			break;
 		}
 
-		unit = kzalloc(sizeof *unit + p + 2*n, GFP_KERNEL);
+		unit = uvc_alloc_entity(UVC_VC_EXTENSION_UNIT, buffer[3],
+					p + 1, 2*n);
 		if (unit == NULL)
 			return -ENOMEM;
 
-		unit->id = buffer[3];
-		unit->type = VC_EXTENSION_UNIT;
 		memcpy(unit->extension.guidExtensionCode, &buffer[4], 16);
 		unit->extension.bNumControls = buffer[20];
-		unit->extension.bNrInPins = get_unaligned_le16(&buffer[21]);
-		unit->extension.baSourceID = (__u8 *)unit + sizeof *unit;
-		memcpy(unit->extension.baSourceID, &buffer[22], p);
+		memcpy(unit->baSourceID, &buffer[22], p);
 		unit->extension.bControlSize = buffer[22+p];
-		unit->extension.bmControls = (__u8 *)unit + sizeof *unit + p;
-		unit->extension.bmControlsType = (__u8 *)unit + sizeof *unit
-					       + p + n;
+		unit->extension.bmControls = (__u8 *)unit + sizeof(*unit);
+		unit->extension.bmControlsType = (__u8 *)unit + sizeof(*unit)
+					       + n;
 		memcpy(unit->extension.bmControls, &buffer[23+p], 2*n);
 
 		if (buffer[24+p+2*n] != 0)
@@ -856,7 +883,7 @@
 	__u16 type;
 
 	switch (buffer[2]) {
-	case VC_HEADER:
+	case UVC_VC_HEADER:
 		n = buflen >= 12 ? buffer[11] : 0;
 
 		if (buflen < 12 || buflen < 12 + n) {
@@ -883,7 +910,7 @@
 		}
 		break;
 
-	case VC_INPUT_TERMINAL:
+	case UVC_VC_INPUT_TERMINAL:
 		if (buflen < 8) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 				"interface %d INPUT_TERMINAL error\n",
@@ -908,11 +935,11 @@
 		p = 0;
 		len = 8;
 
-		if (type == ITT_CAMERA) {
+		if (type == UVC_ITT_CAMERA) {
 			n = buflen >= 15 ? buffer[14] : 0;
 			len = 15;
 
-		} else if (type == ITT_MEDIA_TRANSPORT_INPUT) {
+		} else if (type == UVC_ITT_MEDIA_TRANSPORT_INPUT) {
 			n = buflen >= 9 ? buffer[8] : 0;
 			p = buflen >= 10 + n ? buffer[9+n] : 0;
 			len = 10;
@@ -925,14 +952,12 @@
 			return -EINVAL;
 		}
 
-		term = kzalloc(sizeof *term + n + p, GFP_KERNEL);
+		term = uvc_alloc_entity(type | UVC_TERM_INPUT, buffer[3],
+					1, n + p);
 		if (term == NULL)
 			return -ENOMEM;
 
-		term->id = buffer[3];
-		term->type = type | UVC_TERM_INPUT;
-
-		if (UVC_ENTITY_TYPE(term) == ITT_CAMERA) {
+		if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA) {
 			term->camera.bControlSize = n;
 			term->camera.bmControls = (__u8 *)term + sizeof *term;
 			term->camera.wObjectiveFocalLengthMin =
@@ -942,7 +967,8 @@
 			term->camera.wOcularFocalLength =
 				get_unaligned_le16(&buffer[12]);
 			memcpy(term->camera.bmControls, &buffer[15], n);
-		} else if (UVC_ENTITY_TYPE(term) == ITT_MEDIA_TRANSPORT_INPUT) {
+		} else if (UVC_ENTITY_TYPE(term) ==
+			   UVC_ITT_MEDIA_TRANSPORT_INPUT) {
 			term->media.bControlSize = n;
 			term->media.bmControls = (__u8 *)term + sizeof *term;
 			term->media.bTransportModeSize = p;
@@ -955,9 +981,9 @@
 		if (buffer[7] != 0)
 			usb_string(udev, buffer[7], term->name,
 				   sizeof term->name);
-		else if (UVC_ENTITY_TYPE(term) == ITT_CAMERA)
+		else if (UVC_ENTITY_TYPE(term) == UVC_ITT_CAMERA)
 			sprintf(term->name, "Camera %u", buffer[3]);
-		else if (UVC_ENTITY_TYPE(term) == ITT_MEDIA_TRANSPORT_INPUT)
+		else if (UVC_ENTITY_TYPE(term) == UVC_ITT_MEDIA_TRANSPORT_INPUT)
 			sprintf(term->name, "Media %u", buffer[3]);
 		else
 			sprintf(term->name, "Input %u", buffer[3]);
@@ -965,7 +991,7 @@
 		list_add_tail(&term->list, &dev->entities);
 		break;
 
-	case VC_OUTPUT_TERMINAL:
+	case UVC_VC_OUTPUT_TERMINAL:
 		if (buflen < 9) {
 			uvc_trace(UVC_TRACE_DESCR, "device %d videocontrol "
 				"interface %d OUTPUT_TERMINAL error\n",
@@ -985,13 +1011,12 @@
 			return 0;
 		}
 
-		term = kzalloc(sizeof *term, GFP_KERNEL);
+		term = uvc_alloc_entity(type | UVC_TERM_OUTPUT, buffer[3],
+					1, 0);
 		if (term == NULL)
 			return -ENOMEM;
 
-		term->id = buffer[3];
-		term->type = type | UVC_TERM_OUTPUT;
-		term->output.bSourceID = buffer[7];
+		memcpy(term->baSourceID, &buffer[7], 1);
 
 		if (buffer[8] != 0)
 			usb_string(udev, buffer[8], term->name,
@@ -1002,7 +1027,7 @@
 		list_add_tail(&term->list, &dev->entities);
 		break;
 
-	case VC_SELECTOR_UNIT:
+	case UVC_VC_SELECTOR_UNIT:
 		p = buflen >= 5 ? buffer[4] : 0;
 
 		if (buflen < 5 || buflen < 6 + p) {
@@ -1012,15 +1037,11 @@
 			return -EINVAL;
 		}
 
-		unit = kzalloc(sizeof *unit + p, GFP_KERNEL);
+		unit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, 0);
 		if (unit == NULL)
 			return -ENOMEM;
 
-		unit->id = buffer[3];
-		unit->type = buffer[2];
-		unit->selector.bNrInPins = buffer[4];
-		unit->selector.baSourceID = (__u8 *)unit + sizeof *unit;
-		memcpy(unit->selector.baSourceID, &buffer[5], p);
+		memcpy(unit->baSourceID, &buffer[5], p);
 
 		if (buffer[5+p] != 0)
 			usb_string(udev, buffer[5+p], unit->name,
@@ -1031,7 +1052,7 @@
 		list_add_tail(&unit->list, &dev->entities);
 		break;
 
-	case VC_PROCESSING_UNIT:
+	case UVC_VC_PROCESSING_UNIT:
 		n = buflen >= 8 ? buffer[7] : 0;
 		p = dev->uvc_version >= 0x0110 ? 10 : 9;
 
@@ -1042,13 +1063,11 @@
 			return -EINVAL;
 		}
 
-		unit = kzalloc(sizeof *unit + n, GFP_KERNEL);
+		unit = uvc_alloc_entity(buffer[2], buffer[3], 2, n);
 		if (unit == NULL)
 			return -ENOMEM;
 
-		unit->id = buffer[3];
-		unit->type = buffer[2];
-		unit->processing.bSourceID = buffer[4];
+		memcpy(unit->baSourceID, &buffer[4], 1);
 		unit->processing.wMaxMultiplier =
 			get_unaligned_le16(&buffer[5]);
 		unit->processing.bControlSize = buffer[7];
@@ -1066,7 +1085,7 @@
 		list_add_tail(&unit->list, &dev->entities);
 		break;
 
-	case VC_EXTENSION_UNIT:
+	case UVC_VC_EXTENSION_UNIT:
 		p = buflen >= 22 ? buffer[21] : 0;
 		n = buflen >= 24 + p ? buffer[22+p] : 0;
 
@@ -1077,19 +1096,15 @@
 			return -EINVAL;
 		}
 
-		unit = kzalloc(sizeof *unit + p + n, GFP_KERNEL);
+		unit = uvc_alloc_entity(buffer[2], buffer[3], p + 1, n);
 		if (unit == NULL)
 			return -ENOMEM;
 
-		unit->id = buffer[3];
-		unit->type = buffer[2];
 		memcpy(unit->extension.guidExtensionCode, &buffer[4], 16);
 		unit->extension.bNumControls = buffer[20];
-		unit->extension.bNrInPins = get_unaligned_le16(&buffer[21]);
-		unit->extension.baSourceID = (__u8 *)unit + sizeof *unit;
-		memcpy(unit->extension.baSourceID, &buffer[22], p);
+		memcpy(unit->baSourceID, &buffer[22], p);
 		unit->extension.bControlSize = buffer[22+p];
-		unit->extension.bmControls = (__u8 *)unit + sizeof *unit + p;
+		unit->extension.bmControls = (__u8 *)unit + sizeof *unit;
 		memcpy(unit->extension.bmControls, &buffer[23+p], n);
 
 		if (buffer[23+p+n] != 0)
@@ -1158,112 +1173,98 @@
 }
 
 /* ------------------------------------------------------------------------
- * USB probe and disconnect
- */
-
-/*
- * Unregister the video devices.
+ * UVC device scan
  */
-static void uvc_unregister_video(struct uvc_device *dev)
-{
-	if (dev->video.vdev) {
-		if (dev->video.vdev->minor == -1)
-			video_device_release(dev->video.vdev);
-		else
-			video_unregister_device(dev->video.vdev);
-		dev->video.vdev = NULL;
-	}
-}
 
 /*
  * Scan the UVC descriptors to locate a chain starting at an Output Terminal
  * and containing the following units:
  *
- * - one Output Terminal (USB Streaming or Display)
+ * - one or more Output Terminals (USB Streaming or Display)
  * - zero or one Processing Unit
- * - zero, one or mode single-input Selector Units
+ * - zero, one or more single-input Selector Units
  * - zero or one multiple-input Selector Units, provided all inputs are
  *   connected to input terminals
  * - zero, one or mode single-input Extension Units
  * - one or more Input Terminals (Camera, External or USB Streaming)
  *
- * A side forward scan is made on each detected entity to check for additional
- * extension units.
+ * The terminal and units must match on of the following structures:
+ *
+ * ITT_*(0) -> +---------+    +---------+    +---------+ -> TT_STREAMING(0)
+ * ...         | SU{0,1} | -> | PU{0,1} | -> | XU{0,n} |    ...
+ * ITT_*(n) -> +---------+    +---------+    +---------+ -> TT_STREAMING(n)
+ *
+ *                 +---------+    +---------+ -> OTT_*(0)
+ * TT_STREAMING -> | PU{0,1} | -> | XU{0,n} |    ...
+ *                 +---------+    +---------+ -> OTT_*(n)
+ *
+ * The Processing Unit and Extension Units can be in any order. Additional
+ * Extension Units connected to the main chain as single-unit branches are
+ * also supported. Single-input Selector Units are ignored.
  */
-static int uvc_scan_chain_entity(struct uvc_video_device *video,
+static int uvc_scan_chain_entity(struct uvc_video_chain *chain,
 	struct uvc_entity *entity)
 {
 	switch (UVC_ENTITY_TYPE(entity)) {
-	case VC_EXTENSION_UNIT:
+	case UVC_VC_EXTENSION_UNIT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- XU %d", entity->id);
 
-		if (entity->extension.bNrInPins != 1) {
+		if (entity->bNrInPins != 1) {
 			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has more "
 				"than 1 input pin.\n", entity->id);
 			return -1;
 		}
 
-		list_add_tail(&entity->chain, &video->extensions);
 		break;
 
-	case VC_PROCESSING_UNIT:
+	case UVC_VC_PROCESSING_UNIT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- PU %d", entity->id);
 
-		if (video->processing != NULL) {
+		if (chain->processing != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple "
 				"Processing Units in chain.\n");
 			return -1;
 		}
 
-		video->processing = entity;
+		chain->processing = entity;
 		break;
 
-	case VC_SELECTOR_UNIT:
+	case UVC_VC_SELECTOR_UNIT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- SU %d", entity->id);
 
 		/* Single-input selector units are ignored. */
-		if (entity->selector.bNrInPins == 1)
+		if (entity->bNrInPins == 1)
 			break;
 
-		if (video->selector != NULL) {
+		if (chain->selector != NULL) {
 			uvc_trace(UVC_TRACE_DESCR, "Found multiple Selector "
 				"Units in chain.\n");
 			return -1;
 		}
 
-		video->selector = entity;
+		chain->selector = entity;
 		break;
 
-	case ITT_VENDOR_SPECIFIC:
-	case ITT_CAMERA:
-	case ITT_MEDIA_TRANSPORT_INPUT:
+	case UVC_ITT_VENDOR_SPECIFIC:
+	case UVC_ITT_CAMERA:
+	case UVC_ITT_MEDIA_TRANSPORT_INPUT:
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT %d\n", entity->id);
 
-		list_add_tail(&entity->chain, &video->iterms);
 		break;
 
-	case TT_STREAMING:
-		if (uvc_trace_param & UVC_TRACE_PROBE)
-			printk(" <- IT %d\n", entity->id);
-
-		if (!UVC_ENTITY_IS_ITERM(entity)) {
-			uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
-				"terminal %u.\n", entity->id);
-			return -1;
-		}
-
-		if (video->sterm != NULL) {
-			uvc_trace(UVC_TRACE_DESCR, "Found multiple streaming "
-				"entities in chain.\n");
-			return -1;
+	case UVC_TT_STREAMING:
+		if (UVC_ENTITY_IS_ITERM(entity)) {
+			if (uvc_trace_param & UVC_TRACE_PROBE)
+				printk(" <- IT %d\n", entity->id);
+		} else {
+			if (uvc_trace_param & UVC_TRACE_PROBE)
+				printk(" OT %d", entity->id);
 		}
 
-		list_add_tail(&entity->chain, &video->iterms);
-		video->sterm = entity;
 		break;
 
 	default:
@@ -1272,10 +1273,11 @@
 		return -1;
 	}
 
+	list_add_tail(&entity->chain, &chain->entities);
 	return 0;
 }
 
-static int uvc_scan_chain_forward(struct uvc_video_device *video,
+static int uvc_scan_chain_forward(struct uvc_video_chain *chain,
 	struct uvc_entity *entity, struct uvc_entity *prev)
 {
 	struct uvc_entity *forward;
@@ -1286,28 +1288,51 @@
 	found = 0;
 
 	while (1) {
-		forward = uvc_entity_by_reference(video->dev, entity->id,
+		forward = uvc_entity_by_reference(chain->dev, entity->id,
 			forward);
 		if (forward == NULL)
 			break;
-
-		if (UVC_ENTITY_TYPE(forward) != VC_EXTENSION_UNIT ||
-		    forward == prev)
+		if (forward == prev)
 			continue;
 
-		if (forward->extension.bNrInPins != 1) {
-			uvc_trace(UVC_TRACE_DESCR, "Extension unit %d has "
-				"more than 1 input pin.\n", entity->id);
-			return -1;
-		}
+		switch (UVC_ENTITY_TYPE(forward)) {
+		case UVC_VC_EXTENSION_UNIT:
+			if (forward->bNrInPins != 1) {
+				uvc_trace(UVC_TRACE_DESCR, "Extension unit %d "
+					  "has more than 1 input pin.\n",
+					  entity->id);
+				return -EINVAL;
+			}
+
+			list_add_tail(&forward->chain, &chain->entities);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
 
-		list_add_tail(&forward->chain, &video->extensions);
-		if (uvc_trace_param & UVC_TRACE_PROBE) {
-			if (!found)
-				printk(" (-> XU");
+				printk(" XU %d", forward->id);
+				found = 1;
+			}
+			break;
+
+		case UVC_OTT_VENDOR_SPECIFIC:
+		case UVC_OTT_DISPLAY:
+		case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
+		case UVC_TT_STREAMING:
+			if (UVC_ENTITY_IS_ITERM(forward)) {
+				uvc_trace(UVC_TRACE_DESCR, "Unsupported input "
+					"terminal %u.\n", forward->id);
+				return -EINVAL;
+			}
 
-			printk(" %d", forward->id);
-			found = 1;
+			list_add_tail(&forward->chain, &chain->entities);
+			if (uvc_trace_param & UVC_TRACE_PROBE) {
+				if (!found)
+					printk(" (->");
+
+				printk(" OT %d", forward->id);
+				found = 1;
+			}
+			break;
 		}
 	}
 	if (found)
@@ -1316,35 +1341,33 @@
 	return 0;
 }
 
-static int uvc_scan_chain_backward(struct uvc_video_device *video,
-	struct uvc_entity *entity)
+static int uvc_scan_chain_backward(struct uvc_video_chain *chain,
+	struct uvc_entity **_entity)
 {
+	struct uvc_entity *entity = *_entity;
 	struct uvc_entity *term;
-	int id = -1, i;
+	int id = -EINVAL, i;
 
 	switch (UVC_ENTITY_TYPE(entity)) {
-	case VC_EXTENSION_UNIT:
-		id = entity->extension.baSourceID[0];
-		break;
-
-	case VC_PROCESSING_UNIT:
-		id = entity->processing.bSourceID;
+	case UVC_VC_EXTENSION_UNIT:
+	case UVC_VC_PROCESSING_UNIT:
+		id = entity->baSourceID[0];
 		break;
 
-	case VC_SELECTOR_UNIT:
+	case UVC_VC_SELECTOR_UNIT:
 		/* Single-input selector units are ignored. */
-		if (entity->selector.bNrInPins == 1) {
-			id = entity->selector.baSourceID[0];
+		if (entity->bNrInPins == 1) {
+			id = entity->baSourceID[0];
 			break;
 		}
 
 		if (uvc_trace_param & UVC_TRACE_PROBE)
 			printk(" <- IT");
 
-		video->selector = entity;
-		for (i = 0; i < entity->selector.bNrInPins; ++i) {
-			id = entity->selector.baSourceID[i];
-			term = uvc_entity_by_id(video->dev, id);
+		chain->selector = entity;
+		for (i = 0; i < entity->bNrInPins; ++i) {
+			id = entity->baSourceID[i];
+			term = uvc_entity_by_id(chain->dev, id);
 			if (term == NULL || !UVC_ENTITY_IS_ITERM(term)) {
 				uvc_trace(UVC_TRACE_DESCR, "Selector unit %d "
 					"input %d isn't connected to an "
@@ -1355,8 +1378,8 @@
 			if (uvc_trace_param & UVC_TRACE_PROBE)
 				printk(" %d", term->id);
 
-			list_add_tail(&term->chain, &video->iterms);
-			uvc_scan_chain_forward(video, term, entity);
+			list_add_tail(&term->chain, &chain->entities);
+			uvc_scan_chain_forward(chain, term, entity);
 		}
 
 		if (uvc_trace_param & UVC_TRACE_PROBE)
@@ -1364,130 +1387,258 @@
 
 		id = 0;
 		break;
+
+	case UVC_ITT_VENDOR_SPECIFIC:
+	case UVC_ITT_CAMERA:
+	case UVC_ITT_MEDIA_TRANSPORT_INPUT:
+	case UVC_OTT_VENDOR_SPECIFIC:
+	case UVC_OTT_DISPLAY:
+	case UVC_OTT_MEDIA_TRANSPORT_OUTPUT:
+	case UVC_TT_STREAMING:
+		id = UVC_ENTITY_IS_OTERM(entity) ? entity->baSourceID[0] : 0;
+		break;
 	}
 
-	return id;
+	if (id <= 0) {
+		*_entity = NULL;
+		return id;
+	}
+
+	entity = uvc_entity_by_id(chain->dev, id);
+	if (entity == NULL) {
+		uvc_trace(UVC_TRACE_DESCR, "Found reference to "
+			"unknown entity %d.\n", id);
+		return -EINVAL;
+	}
+
+	*_entity = entity;
+	return 0;
 }
 
-static int uvc_scan_chain(struct uvc_video_device *video)
+static int uvc_scan_chain(struct uvc_video_chain *chain,
+			  struct uvc_entity *term)
 {
 	struct uvc_entity *entity, *prev;
-	int id;
 
-	entity = video->oterm;
-	uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain: OT %d", entity->id);
+	uvc_trace(UVC_TRACE_PROBE, "Scanning UVC chain:");
 
-	if (UVC_ENTITY_TYPE(entity) == TT_STREAMING)
-		video->sterm = entity;
+	entity = term;
+	prev = NULL;
 
-	id = entity->output.bSourceID;
-	while (id != 0) {
-		prev = entity;
-		entity = uvc_entity_by_id(video->dev, id);
-		if (entity == NULL) {
+	while (entity != NULL) {
+		/* Entity must not be part of an existing chain */
+		if (entity->chain.next || entity->chain.prev) {
 			uvc_trace(UVC_TRACE_DESCR, "Found reference to "
-				"unknown entity %d.\n", id);
-			return -1;
+				"entity %d already in chain.\n", entity->id);
+			return -EINVAL;
 		}
 
 		/* Process entity */
-		if (uvc_scan_chain_entity(video, entity) < 0)
-			return -1;
+		if (uvc_scan_chain_entity(chain, entity) < 0)
+			return -EINVAL;
 
 		/* Forward scan */
-		if (uvc_scan_chain_forward(video, entity, prev) < 0)
-			return -1;
-
-		/* Stop when a terminal is found. */
-		if (!UVC_ENTITY_IS_UNIT(entity))
-			break;
+		if (uvc_scan_chain_forward(chain, entity, prev) < 0)
+			return -EINVAL;
 
 		/* Backward scan */
-		id = uvc_scan_chain_backward(video, entity);
-		if (id < 0)
-			return id;
+		prev = entity;
+		if (uvc_scan_chain_backward(chain, &entity) < 0)
+			return -EINVAL;
 	}
 
-	if (video->sterm == NULL) {
-		uvc_trace(UVC_TRACE_DESCR, "No streaming entity found in "
-			"chain.\n");
-		return -1;
+	return 0;
+}
+
+static unsigned int uvc_print_terms(struct list_head *terms, u16 dir,
+		char *buffer)
+{
+	struct uvc_entity *term;
+	unsigned int nterms = 0;
+	char *p = buffer;
+
+	list_for_each_entry(term, terms, chain) {
+		if (!UVC_ENTITY_IS_TERM(term) ||
+		    UVC_TERM_DIRECTION(term) != dir)
+			continue;
+
+		if (nterms)
+			p += sprintf(p, ",");
+		if (++nterms >= 4) {
+			p += sprintf(p, "...");
+			break;
+		}
+		p += sprintf(p, "%u", term->id);
 	}
 
-	return 0;
+	return p - buffer;
+}
+
+static const char *uvc_print_chain(struct uvc_video_chain *chain)
+{
+	static char buffer[43];
+	char *p = buffer;
+
+	p += uvc_print_terms(&chain->entities, UVC_TERM_INPUT, p);
+	p += sprintf(p, " -> ");
+	uvc_print_terms(&chain->entities, UVC_TERM_OUTPUT, p);
+
+	return buffer;
 }
 
 /*
- * Register the video devices.
- *
- * The driver currently supports a single video device per control interface
- * only. The terminal and units must match the following structure:
- *
- * ITT_* -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> TT_STREAMING
- * TT_STREAMING -> VC_PROCESSING_UNIT -> VC_EXTENSION_UNIT{0,n} -> OTT_*
+ * Scan the device for video chains and register video devices.
  *
- * The Extension Units, if present, must have a single input pin. The
- * Processing Unit and Extension Units can be in any order. Additional
- * Extension Units connected to the main chain as single-unit branches are
- * also supported.
+ * Chains are scanned starting at their output terminals and walked backwards.
  */
-static int uvc_register_video(struct uvc_device *dev)
+static int uvc_scan_device(struct uvc_device *dev)
 {
-	struct video_device *vdev;
+	struct uvc_video_chain *chain;
 	struct uvc_entity *term;
-	int found = 0, ret;
 
-	/* Check if the control interface matches the structure we expect. */
 	list_for_each_entry(term, &dev->entities, list) {
-		struct uvc_streaming *streaming;
-
-		if (!UVC_ENTITY_IS_TERM(term) || !UVC_ENTITY_IS_OTERM(term))
+		if (!UVC_ENTITY_IS_OTERM(term))
 			continue;
 
-		memset(&dev->video, 0, sizeof dev->video);
-		mutex_init(&dev->video.ctrl_mutex);
-		INIT_LIST_HEAD(&dev->video.iterms);
-		INIT_LIST_HEAD(&dev->video.extensions);
-		dev->video.oterm = term;
-		dev->video.dev = dev;
-		if (uvc_scan_chain(&dev->video) < 0)
+		/* If the terminal is already included in a chain, skip it.
+		 * This can happen for chains that have multiple output
+		 * terminals, where all output terminals beside the first one
+		 * will be inserted in the chain in forward scans.
+		 */
+		if (term->chain.next || term->chain.prev)
 			continue;
 
-		list_for_each_entry(streaming, &dev->streaming, list) {
-			if (streaming->header.bTerminalLink ==
-			    dev->video.sterm->id) {
-				dev->video.streaming = streaming;
-				found = 1;
-				break;
-			}
+		chain = kzalloc(sizeof(*chain), GFP_KERNEL);
+		if (chain == NULL)
+			return -ENOMEM;
+
+		INIT_LIST_HEAD(&chain->entities);
+		mutex_init(&chain->ctrl_mutex);
+		chain->dev = dev;
+
+		if (uvc_scan_chain(chain, term) < 0) {
+			kfree(chain);
+			continue;
 		}
 
-		if (found)
-			break;
+		uvc_trace(UVC_TRACE_PROBE, "Found a valid video chain (%s).\n",
+			  uvc_print_chain(chain));
+
+		list_add_tail(&chain->list, &dev->chains);
 	}
 
-	if (!found) {
+	if (list_empty(&dev->chains)) {
 		uvc_printk(KERN_INFO, "No valid video chain found.\n");
 		return -1;
 	}
 
-	if (uvc_trace_param & UVC_TRACE_PROBE) {
-		uvc_printk(KERN_INFO, "Found a valid video chain (");
-		list_for_each_entry(term, &dev->video.iterms, chain) {
-			printk("%d", term->id);
-			if (term->chain.next != &dev->video.iterms)
-				printk(",");
-		}
-		printk(" -> %d).\n", dev->video.oterm->id);
+	return 0;
+}
+
+/* ------------------------------------------------------------------------
+ * Video device registration and unregistration
+ */
+
+/*
+ * Delete the UVC device.
+ *
+ * Called by the kernel when the last reference to the uvc_device structure
+ * is released.
+ *
+ * As this function is called after or during disconnect(), all URBs have
+ * already been canceled by the USB core. There is no need to kill the
+ * interrupt URB manually.
+ */
+static void uvc_delete(struct uvc_device *dev)
+{
+	struct list_head *p, *n;
+
+	usb_put_intf(dev->intf);
+	usb_put_dev(dev->udev);
+
+	uvc_status_cleanup(dev);
+	uvc_ctrl_cleanup_device(dev);
+
+	list_for_each_safe(p, n, &dev->chains) {
+		struct uvc_video_chain *chain;
+		chain = list_entry(p, struct uvc_video_chain, list);
+		kfree(chain);
 	}
 
-	/* Initialize the video buffers queue. */
-	uvc_queue_init(&dev->video.queue, dev->video.streaming->type);
+	list_for_each_safe(p, n, &dev->entities) {
+		struct uvc_entity *entity;
+		entity = list_entry(p, struct uvc_entity, list);
+		kfree(entity);
+	}
+
+	list_for_each_safe(p, n, &dev->streams) {
+		struct uvc_streaming *streaming;
+		streaming = list_entry(p, struct uvc_streaming, list);
+		usb_driver_release_interface(&uvc_driver.driver,
+			streaming->intf);
+		usb_put_intf(streaming->intf);
+		kfree(streaming->format);
+		kfree(streaming->header.bmaControls);
+		kfree(streaming);
+	}
+
+	kfree(dev);
+}
+
+static void uvc_release(struct video_device *vdev)
+{
+	struct uvc_streaming *stream = video_get_drvdata(vdev);
+	struct uvc_device *dev = stream->dev;
+
+	video_device_release(vdev);
+
+	/* Decrement the registered streams count and delete the device when it
+	 * reaches zero.
+	 */
+	if (atomic_dec_and_test(&dev->nstreams))
+		uvc_delete(dev);
+}
+
+/*
+ * Unregister the video devices.
+ */
+static void uvc_unregister_video(struct uvc_device *dev)
+{
+	struct uvc_streaming *stream;
+
+	/* Unregistering all video devices might result in uvc_delete() being
+	 * called from inside the loop if there's no open file handle. To avoid
+	 * that, increment the stream count before iterating over the streams
+	 * and decrement it when done.
+	 */
+	atomic_inc(&dev->nstreams);
+
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->vdev == NULL)
+			continue;
+
+		video_unregister_device(stream->vdev);
+		stream->vdev = NULL;
+	}
+
+	/* Decrement the stream count and call uvc_delete explicitly if there
+	 * are no stream left.
+	 */
+	if (atomic_dec_and_test(&dev->nstreams))
+		uvc_delete(dev);
+}
+
+static int uvc_register_video(struct uvc_device *dev,
+		struct uvc_streaming *stream)
+{
+	struct video_device *vdev;
+	int ret;
 
 	/* Initialize the streaming interface with default streaming
 	 * parameters.
 	 */
-	if ((ret = uvc_video_init(&dev->video)) < 0) {
+	ret = uvc_video_init(stream);
+	if (ret < 0) {
 		uvc_printk(KERN_ERR, "Failed to initialize the device "
 			"(%d).\n", ret);
 		return ret;
@@ -1495,83 +1646,88 @@
 
 	/* Register the device with V4L. */
 	vdev = video_device_alloc();
-	if (vdev == NULL)
-		return -1;
+	if (vdev == NULL) {
+		uvc_printk(KERN_ERR, "Failed to allocate video device (%d).\n",
+			   ret);
+		return -ENOMEM;
+	}
 
 	/* We already hold a reference to dev->udev. The video device will be
 	 * unregistered before the reference is released, so we don't need to
 	 * get another one.
 	 */
 	vdev->parent = &dev->intf->dev;
-	vdev->minor = -1;
 	vdev->fops = &uvc_fops;
-	vdev->release = video_device_release;
+	vdev->release = uvc_release;
 	strlcpy(vdev->name, dev->name, sizeof vdev->name);
 
 	/* Set the driver data before calling video_register_device, otherwise
 	 * uvc_v4l2_open might race us.
 	 */
-	dev->video.vdev = vdev;
-	video_set_drvdata(vdev, &dev->video);
+	stream->vdev = vdev;
+	video_set_drvdata(vdev, stream);
 
-	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
-		dev->video.vdev = NULL;
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret < 0) {
+		uvc_printk(KERN_ERR, "Failed to register video device (%d).\n",
+			   ret);
+		stream->vdev = NULL;
 		video_device_release(vdev);
-		return -1;
+		return ret;
 	}
 
+	atomic_inc(&dev->nstreams);
 	return 0;
 }
 
 /*
- * Delete the UVC device.
- *
- * Called by the kernel when the last reference to the uvc_device structure
- * is released.
- *
- * Unregistering the video devices is done here because every opened instance
- * must be closed before the device can be unregistered. An alternative would
- * have been to use another reference count for uvc_v4l2_open/uvc_release, and
- * unregister the video devices on disconnect when that reference count drops
- * to zero.
- *
- * As this function is called after or during disconnect(), all URBs have
- * already been canceled by the USB core. There is no need to kill the
- * interrupt URB manually.
+ * Register all video devices in all chains.
  */
-void uvc_delete(struct kref *kref)
+static int uvc_register_terms(struct uvc_device *dev,
+	struct uvc_video_chain *chain)
 {
-	struct uvc_device *dev = container_of(kref, struct uvc_device, kref);
-	struct list_head *p, *n;
+	struct uvc_streaming *stream;
+	struct uvc_entity *term;
+	int ret;
 
-	/* Unregister the video device. */
-	uvc_unregister_video(dev);
-	usb_put_intf(dev->intf);
-	usb_put_dev(dev->udev);
+	list_for_each_entry(term, &chain->entities, chain) {
+		if (UVC_ENTITY_TYPE(term) != UVC_TT_STREAMING)
+			continue;
 
-	uvc_status_cleanup(dev);
-	uvc_ctrl_cleanup_device(dev);
+		stream = uvc_stream_by_id(dev, term->id);
+		if (stream == NULL) {
+			uvc_printk(KERN_INFO, "No streaming interface found "
+				   "for terminal %u.", term->id);
+			continue;
+		}
 
-	list_for_each_safe(p, n, &dev->entities) {
-		struct uvc_entity *entity;
-		entity = list_entry(p, struct uvc_entity, list);
-		kfree(entity);
+		stream->chain = chain;
+		ret = uvc_register_video(dev, stream);
+		if (ret < 0)
+			return ret;
 	}
 
-	list_for_each_safe(p, n, &dev->streaming) {
-		struct uvc_streaming *streaming;
-		streaming = list_entry(p, struct uvc_streaming, list);
-		usb_driver_release_interface(&uvc_driver.driver,
-			streaming->intf);
-		usb_put_intf(streaming->intf);
-		kfree(streaming->format);
-		kfree(streaming->header.bmaControls);
-		kfree(streaming);
+	return 0;
+}
+
+static int uvc_register_chains(struct uvc_device *dev)
+{
+	struct uvc_video_chain *chain;
+	int ret;
+
+	list_for_each_entry(chain, &dev->chains, list) {
+		ret = uvc_register_terms(dev, chain);
+		if (ret < 0)
+			return ret;
 	}
 
-	kfree(dev);
+	return 0;
 }
 
+/* ------------------------------------------------------------------------
+ * USB probe, disconnect, suspend and resume
+ */
+
 static int uvc_probe(struct usb_interface *intf,
 		     const struct usb_device_id *id)
 {
@@ -1592,14 +1748,16 @@
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&dev->entities);
-	INIT_LIST_HEAD(&dev->streaming);
-	kref_init(&dev->kref);
+	INIT_LIST_HEAD(&dev->chains);
+	INIT_LIST_HEAD(&dev->streams);
+	atomic_set(&dev->nstreams, 0);
 	atomic_set(&dev->users, 0);
 
 	dev->udev = usb_get_dev(udev);
 	dev->intf = usb_get_intf(intf);
 	dev->intfnum = intf->cur_altsetting->desc.bInterfaceNumber;
-	dev->quirks = id->driver_info | uvc_quirks_param;
+	dev->quirks = (uvc_quirks_param == -1)
+		    ? id->driver_info : uvc_quirks_param;
 
 	if (udev->product != NULL)
 		strlcpy(dev->name, udev->product, sizeof dev->name);
@@ -1622,9 +1780,9 @@
 		le16_to_cpu(udev->descriptor.idVendor),
 		le16_to_cpu(udev->descriptor.idProduct));
 
-	if (uvc_quirks_param != 0) {
-		uvc_printk(KERN_INFO, "Forcing device quirks 0x%x by module "
-			"parameter for testing purpose.\n", uvc_quirks_param);
+	if (dev->quirks != id->driver_info) {
+		uvc_printk(KERN_INFO, "Forcing device quirks to 0x%x by module "
+			"parameter for testing purpose.\n", dev->quirks);
 		uvc_printk(KERN_INFO, "Please report required quirks to the "
 			"linux-uvc-devel mailing list.\n");
 	}
@@ -1633,8 +1791,12 @@
 	if (uvc_ctrl_init_device(dev) < 0)
 		goto error;
 
-	/* Register the video devices. */
-	if (uvc_register_video(dev) < 0)
+	/* Scan the device for video chains. */
+	if (uvc_scan_device(dev) < 0)
+		goto error;
+
+	/* Register video devices. */
+	if (uvc_register_chains(dev) < 0)
 		goto error;
 
 	/* Save our data pointer in the interface data. */
@@ -1651,7 +1813,7 @@
 	return 0;
 
 error:
-	kref_put(&dev->kref, uvc_delete);
+	uvc_unregister_video(dev);
 	return -ENODEV;
 }
 
@@ -1664,54 +1826,48 @@
 	 */
 	usb_set_intfdata(intf, NULL);
 
-	if (intf->cur_altsetting->desc.bInterfaceSubClass == SC_VIDEOSTREAMING)
+	if (intf->cur_altsetting->desc.bInterfaceSubClass ==
+	    UVC_SC_VIDEOSTREAMING)
 		return;
 
-	/* uvc_v4l2_open() might race uvc_disconnect(). A static driver-wide
-	 * lock is needed to prevent uvc_disconnect from releasing its
-	 * reference to the uvc_device instance after uvc_v4l2_open() received
-	 * the pointer to the device (video_devdata) but before it got the
-	 * chance to increase the reference count (kref_get).
-	 *
-	 * Note that the reference can't be released with the lock held,
-	 * otherwise a AB-BA deadlock can occur with videodev_lock that
-	 * videodev acquires in videodev_open() and video_unregister_device().
-	 */
-	mutex_lock(&uvc_driver.open_mutex);
 	dev->state |= UVC_DEV_DISCONNECTED;
-	mutex_unlock(&uvc_driver.open_mutex);
 
-	kref_put(&dev->kref, uvc_delete);
+	uvc_unregister_video(dev);
 }
 
 static int uvc_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Suspending interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
 
 	/* Controls are cached on the fly so they don't need to be saved. */
-	if (intf->cur_altsetting->desc.bInterfaceSubClass == SC_VIDEOCONTROL)
+	if (intf->cur_altsetting->desc.bInterfaceSubClass ==
+	    UVC_SC_VIDEOCONTROL)
 		return uvc_status_suspend(dev);
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_suspend(stream);
 	}
 
-	return uvc_video_suspend(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Suspend: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int __uvc_resume(struct usb_interface *intf, int reset)
 {
 	struct uvc_device *dev = usb_get_intfdata(intf);
+	struct uvc_streaming *stream;
 
 	uvc_trace(UVC_TRACE_SUSPEND, "Resuming interface %u\n",
 		intf->cur_altsetting->desc.bInterfaceNumber);
 
-	if (intf->cur_altsetting->desc.bInterfaceSubClass == SC_VIDEOCONTROL) {
+	if (intf->cur_altsetting->desc.bInterfaceSubClass ==
+	    UVC_SC_VIDEOCONTROL) {
 		if (reset) {
 			int ret = uvc_ctrl_resume_device(dev);
 
@@ -1722,13 +1878,14 @@
 		return uvc_status_resume(dev);
 	}
 
-	if (dev->video.streaming->intf != intf) {
-		uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB "
-				"interface mismatch.\n");
-		return -EINVAL;
+	list_for_each_entry(stream, &dev->streams, list) {
+		if (stream->intf == intf)
+			return uvc_video_resume(stream);
 	}
 
-	return uvc_video_resume(&dev->video);
+	uvc_trace(UVC_TRACE_SUSPEND, "Resume: video streaming USB interface "
+			"mismatch.\n");
+	return -EINVAL;
 }
 
 static int uvc_resume(struct usb_interface *intf)
@@ -1742,6 +1899,45 @@
 }
 
 /* ------------------------------------------------------------------------
+ * Module parameters
+ */
+
+static int uvc_clock_param_get(char *buffer, struct kernel_param *kp)
+{
+	if (uvc_clock_param == CLOCK_MONOTONIC)
+		return sprintf(buffer, "CLOCK_MONOTONIC");
+	else
+		return sprintf(buffer, "CLOCK_REALTIME");
+}
+
+static int uvc_clock_param_set(const char *val, struct kernel_param *kp)
+{
+	if (strncasecmp(val, "clock_", strlen("clock_")) == 0)
+		val += strlen("clock_");
+
+	if (strcasecmp(val, "monotonic") == 0)
+		uvc_clock_param = CLOCK_MONOTONIC;
+	else if (strcasecmp(val, "realtime") == 0)
+		uvc_clock_param = CLOCK_REALTIME;
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+module_param_call(clock, uvc_clock_param_set, uvc_clock_param_get,
+		  &uvc_clock_param, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(clock, "Video buffers timestamp clock");
+module_param_named(nodrop, uvc_no_drop_param, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(nodrop, "Don't drop incomplete frames");
+module_param_named(quirks, uvc_quirks_param, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(quirks, "Forced device quirks");
+module_param_named(trace, uvc_trace_param, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(trace, "Trace level bitmask");
+module_param_named(timeout, uvc_timeout_param, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(timeout, "Streaming control requests timeout");
+
+/* ------------------------------------------------------------------------
  * Driver initialization and cleanup
  */
 
@@ -1751,6 +1947,15 @@
  * though they are compliant.
  */
 static struct usb_device_id uvc_ids[] = {
+	/* Genius eFace 2025 */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor		= 0x0458,
+	  .idProduct		= 0x706e,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_QUIRK_PROBE_MINMAX },
 	/* Microsoft Lifecam NX-6000 */
 	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -1880,7 +2085,8 @@
 	  .bInterfaceClass	= USB_CLASS_VIDEO,
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
-	  .driver_info		= UVC_QUIRK_PROBE_MINMAX },
+	  .driver_info		= UVC_QUIRK_PROBE_MINMAX
+				| UVC_QUIRK_PROBE_DEF },
 	/* Syntek (HP Spartan) */
 	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -1943,7 +2149,8 @@
 	  .bInterfaceClass	= USB_CLASS_VIDEO,
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
-	  .driver_info		= UVC_QUIRK_PROBE_EXTRAFIELDS },
+	  .driver_info		= UVC_QUIRK_PROBE_MINMAX
+				| UVC_QUIRK_PROBE_EXTRAFIELDS },
 	/* Ecamm Pico iMage */
 	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -1973,6 +2180,15 @@
 	  .bInterfaceSubClass	= 1,
 	  .bInterfaceProtocol	= 0,
 	  .driver_info		= UVC_QUIRK_STATUS_INTERVAL },
+	/* MSI StarCam 370i */
+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
+				| USB_DEVICE_ID_MATCH_INT_INFO,
+	  .idVendor		= 0x1b3b,
+	  .idProduct		= 0x2951,
+	  .bInterfaceClass	= USB_CLASS_VIDEO,
+	  .bInterfaceSubClass	= 1,
+	  .bInterfaceProtocol	= 0,
+	  .driver_info		= UVC_QUIRK_PROBE_MINMAX },
 	/* SiGma Micro USB Web Camera */
 	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -2009,7 +2225,6 @@
 
 	INIT_LIST_HEAD(&uvc_driver.devices);
 	INIT_LIST_HEAD(&uvc_driver.controls);
-	mutex_init(&uvc_driver.open_mutex);
 	mutex_init(&uvc_driver.ctrl_mutex);
 
 	uvc_ctrl_init();
@@ -2028,13 +2243,6 @@
 module_init(uvc_init);
 module_exit(uvc_cleanup);
 
-module_param_named(nodrop, uvc_no_drop_param, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(nodrop, "Don't drop incomplete frames");
-module_param_named(quirks, uvc_quirks_param, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(quirks, "Forced device quirks");
-module_param_named(trace, uvc_trace_param, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(trace, "Trace level bitmask");
-
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_isight.c linux-2.6/drivers/media/video/uvc/uvc_isight.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_isight.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_isight.c	2011-01-04 14:35:07.000000000 -0800
@@ -99,7 +99,7 @@
 	return 0;
 }
 
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf)
 {
 	int ret, i;
@@ -120,7 +120,7 @@
 		 * processes the data of the first payload of the new frame.
 		 */
 		do {
-			ret = isight_decode(&video->queue, buf,
+			ret = isight_decode(&stream->queue, buf,
 					urb->transfer_buffer +
 					urb->iso_frame_desc[i].offset,
 					urb->iso_frame_desc[i].actual_length);
@@ -130,7 +130,8 @@
 
 			if (buf->state == UVC_BUF_STATE_DONE ||
 			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							buf);
 		} while (ret == -EAGAIN);
 	}
 }
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_queue.c linux-2.6/drivers/media/video/uvc/uvc_queue.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_queue.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_queue.c	2011-01-04 14:35:07.000000000 -0800
@@ -59,9 +59,9 @@
  *    returns immediately.
  *
  *    When the buffer is full, the completion handler removes it from the irq
- *    queue, marks it as ready (UVC_BUF_STATE_DONE) and wakes its wait queue.
+ *    queue, marks it as done (UVC_BUF_STATE_DONE) and wakes its wait queue.
  *    At that point, any process waiting on the buffer will be woken up. If a
- *    process tries to dequeue a buffer after it has been marked ready, the
+ *    process tries to dequeue a buffer after it has been marked done, the
  *    dequeing will succeed immediately.
  *
  * 2. Buffers are queued, user is waiting on a buffer and the device gets
@@ -78,12 +78,14 @@
  *
  */
 
-void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type)
+void uvc_queue_init(struct uvc_video_queue *queue, enum v4l2_buf_type type,
+		    int drop_corrupted)
 {
 	mutex_init(&queue->mutex);
 	spin_lock_init(&queue->irqlock);
 	INIT_LIST_HEAD(&queue->mainqueue);
 	INIT_LIST_HEAD(&queue->irqqueue);
+	queue->flags = drop_corrupted ? UVC_QUEUE_DROP_CORRUPTED : 0;
 	queue->type = type;
 }
 
@@ -201,6 +203,7 @@
 		break;
 	case UVC_BUF_STATE_QUEUED:
 	case UVC_BUF_STATE_ACTIVE:
+	case UVC_BUF_STATE_READY:
 		v4l2_buf->flags |= V4L2_BUF_FLAG_QUEUED;
 		break;
 	case UVC_BUF_STATE_IDLE:
@@ -295,13 +298,15 @@
 {
 	if (nonblocking) {
 		return (buf->state != UVC_BUF_STATE_QUEUED &&
-			buf->state != UVC_BUF_STATE_ACTIVE)
+			buf->state != UVC_BUF_STATE_ACTIVE &&
+			buf->state != UVC_BUF_STATE_READY)
 			? 0 : -EAGAIN;
 	}
 
 	return wait_event_interruptible(buf->wait,
 		buf->state != UVC_BUF_STATE_QUEUED &&
-		buf->state != UVC_BUF_STATE_ACTIVE);
+		buf->state != UVC_BUF_STATE_ACTIVE &&
+		buf->state != UVC_BUF_STATE_READY);
 }
 
 /*
@@ -348,6 +353,7 @@
 	case UVC_BUF_STATE_IDLE:
 	case UVC_BUF_STATE_QUEUED:
 	case UVC_BUF_STATE_ACTIVE:
+	case UVC_BUF_STATE_READY:
 	default:
 		uvc_trace(UVC_TRACE_CAPTURE, "[E] Invalid buffer state %u "
 			"(driver bug?).\n", buf->state);
@@ -427,8 +433,10 @@
 		uvc_queue_cancel(queue, 0);
 		INIT_LIST_HEAD(&queue->mainqueue);
 
-		for (i = 0; i < queue->count; ++i)
+		for (i = 0; i < queue->count; ++i) {
+			queue->buffer[i].error = 0;
 			queue->buffer[i].state = UVC_BUF_STATE_IDLE;
+		}
 
 		queue->flags &= ~UVC_QUEUE_STREAMING;
 	}
@@ -480,15 +488,17 @@
 	struct uvc_buffer *nextbuf;
 	unsigned long flags;
 
-	if ((queue->flags & UVC_QUEUE_DROP_INCOMPLETE) &&
-	    buf->buf.length != buf->buf.bytesused) {
+	if ((queue->flags & UVC_QUEUE_DROP_CORRUPTED) && buf->error) {
 		buf->state = UVC_BUF_STATE_QUEUED;
 		buf->buf.bytesused = 0;
+		buf->error = 0;
 		return buf;
 	}
 
 	spin_lock_irqsave(&queue->irqlock, flags);
 	list_del(&buf->queue);
+	buf->error = 0;
+	buf->state = UVC_BUF_STATE_DONE;
 	if (!list_empty(&queue->irqqueue))
 		nextbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,
 					   queue);
@@ -497,7 +507,6 @@
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 
 	buf->buf.sequence = queue->sequence++;
-	do_gettimeofday(&buf->buf.timestamp);
 
 	wake_up(&buf->wait);
 	return nextbuf;
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_status.c linux-2.6/drivers/media/video/uvc/uvc_status.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_status.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_status.c	2011-01-04 14:35:07.000000000 -0800
@@ -13,6 +13,7 @@
 
 #include <linux/kernel.h>
 #include <linux/input.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/usb/input.h>
 
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_v4l2.c linux-2.6/drivers/media/video/uvc/uvc_v4l2.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_v4l2.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_v4l2.c	2011-01-04 14:35:07.000000000 -0800
@@ -15,6 +15,7 @@
 #include <linux/version.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/videodev2.h>
 #include <linux/vmalloc.h>
@@ -40,7 +41,7 @@
  * table for the controls that can be mapped directly, and handle the others
  * manually.
  */
-static int uvc_v4l2_query_menu(struct uvc_video_device *video,
+static int uvc_v4l2_query_menu(struct uvc_video_chain *chain,
 	struct v4l2_querymenu *query_menu)
 {
 	struct uvc_menu_info *menu_info;
@@ -49,7 +50,7 @@
 	u32 index = query_menu->index;
 	u32 id = query_menu->id;
 
-	ctrl = uvc_find_control(video, query_menu->id, &mapping);
+	ctrl = uvc_find_control(chain, query_menu->id, &mapping);
 	if (ctrl == NULL || mapping->v4l2_type != V4L2_CTRL_TYPE_MENU)
 		return -EINVAL;
 
@@ -103,7 +104,7 @@
 	return interval;
 }
 
-static int uvc_v4l2_try_format(struct uvc_video_device *video,
+static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt, struct uvc_streaming_control *probe,
 	struct uvc_format **uvc_format, struct uvc_frame **uvc_frame)
 {
@@ -116,7 +117,7 @@
 	int ret = 0;
 	__u8 *fcc;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	fcc = (__u8 *)&fmt->fmt.pix.pixelformat;
@@ -126,8 +127,8 @@
 			fmt->fmt.pix.width, fmt->fmt.pix.height);
 
 	/* Check if the hardware supports the requested format. */
-	for (i = 0; i < video->streaming->nformats; ++i) {
-		format = &video->streaming->format[i];
+	for (i = 0; i < stream->nformats; ++i) {
+		format = &stream->format[i];
 		if (format->fcc == fmt->fmt.pix.pixelformat)
 			break;
 	}
@@ -191,12 +192,13 @@
 	 * developers test their webcams with the Linux driver as well as with
 	 * the Windows driver).
 	 */
-	if (video->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
+	if (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
 		probe->dwMaxVideoFrameSize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
 	/* Probe the device. */
-	if ((ret = uvc_probe_video(video, probe)) < 0)
+	ret = uvc_probe_video(stream, probe);
+	if (ret < 0)
 		goto done;
 
 	fmt->fmt.pix.width = frame->wWidth;
@@ -216,13 +218,13 @@
 	return ret;
 }
 
-static int uvc_v4l2_get_format(struct uvc_video_device *video,
+static int uvc_v4l2_get_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
-	struct uvc_format *format = video->streaming->cur_format;
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_format *format = stream->cur_format;
+	struct uvc_frame *frame = stream->cur_frame;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	if (format == NULL || frame == NULL)
@@ -233,14 +235,14 @@
 	fmt->fmt.pix.height = frame->wHeight;
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
 	fmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;
-	fmt->fmt.pix.sizeimage = video->streaming->ctrl.dwMaxVideoFrameSize;
+	fmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
 	return 0;
 }
 
-static int uvc_v4l2_set_format(struct uvc_video_device *video,
+static int uvc_v4l2_set_format(struct uvc_streaming *stream,
 	struct v4l2_format *fmt)
 {
 	struct uvc_streaming_control probe;
@@ -248,39 +250,39 @@
 	struct uvc_frame *frame;
 	int ret;
 
-	if (fmt->type != video->streaming->type)
+	if (fmt->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_allocated(&video->queue))
+	if (uvc_queue_allocated(&stream->queue))
 		return -EBUSY;
 
-	ret = uvc_v4l2_try_format(video, fmt, &probe, &format, &frame);
+	ret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);
 	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
+	memcpy(&stream->ctrl, &probe, sizeof probe);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	return 0;
 }
 
-static int uvc_v4l2_get_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
 	uint32_t numerator, denominator;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	numerator = video->streaming->ctrl.dwFrameInterval;
+	numerator = stream->ctrl.dwFrameInterval;
 	denominator = 10000000;
 	uvc_simplify_fraction(&numerator, &denominator, 8, 333);
 
 	memset(parm, 0, sizeof *parm);
-	parm->type = video->streaming->type;
+	parm->type = stream->type;
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 		parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
 		parm->parm.capture.capturemode = 0;
 		parm->parm.capture.timeperframe.numerator = numerator;
@@ -297,19 +299,19 @@
 	return 0;
 }
 
-static int uvc_v4l2_set_streamparm(struct uvc_video_device *video,
+static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 		struct v4l2_streamparm *parm)
 {
-	struct uvc_frame *frame = video->streaming->cur_frame;
+	struct uvc_frame *frame = stream->cur_frame;
 	struct uvc_streaming_control probe;
 	struct v4l2_fract timeperframe;
 	uint32_t interval;
 	int ret;
 
-	if (parm->type != video->streaming->type)
+	if (parm->type != stream->type)
 		return -EINVAL;
 
-	if (uvc_queue_streaming(&video->queue))
+	if (uvc_queue_streaming(&stream->queue))
 		return -EBUSY;
 
 	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
@@ -317,7 +319,7 @@
 	else
 		timeperframe = parm->parm.output.timeperframe;
 
-	memcpy(&probe, &video->streaming->ctrl, sizeof probe);
+	memcpy(&probe, &stream->ctrl, sizeof probe);
 	interval = uvc_fraction_to_interval(timeperframe.numerator,
 		timeperframe.denominator);
 
@@ -326,10 +328,11 @@
 	probe.dwFrameInterval = uvc_try_frame_interval(frame, interval);
 
 	/* Probe the device with the new settings. */
-	if ((ret = uvc_probe_video(video, &probe)) < 0)
+	ret = uvc_probe_video(stream, &probe);
+	if (ret < 0)
 		return ret;
 
-	memcpy(&video->streaming->ctrl, &probe, sizeof probe);
+	memcpy(&stream->ctrl, &probe, sizeof probe);
 
 	/* Return the actual frame period. */
 	timeperframe.numerator = probe.dwFrameInterval;
@@ -362,43 +365,36 @@
  * unprivileged state. Only a single instance can be in a privileged state at
  * a given time. Trying to perform an operation that requires privileges will
  * automatically acquire the required privileges if possible, or return -EBUSY
- * otherwise. Privileges are dismissed when closing the instance.
+ * otherwise. Privileges are dismissed when closing the instance or when
+ * freeing the video buffers using VIDIOC_REQBUFS.
  *
  * Operations that require privileges are:
  *
  * - VIDIOC_S_INPUT
  * - VIDIOC_S_PARM
  * - VIDIOC_S_FMT
- * - VIDIOC_TRY_FMT
  * - VIDIOC_REQBUFS
  */
 static int uvc_acquire_privileges(struct uvc_fh *handle)
 {
-	int ret = 0;
-
 	/* Always succeed if the handle is already privileged. */
 	if (handle->state == UVC_HANDLE_ACTIVE)
 		return 0;
 
 	/* Check if the device already has a privileged handle. */
-	mutex_lock(&uvc_driver.open_mutex);
-	if (atomic_inc_return(&handle->device->active) != 1) {
-		atomic_dec(&handle->device->active);
-		ret = -EBUSY;
-		goto done;
+	if (atomic_inc_return(&handle->stream->active) != 1) {
+		atomic_dec(&handle->stream->active);
+		return -EBUSY;
 	}
 
 	handle->state = UVC_HANDLE_ACTIVE;
-
-done:
-	mutex_unlock(&uvc_driver.open_mutex);
-	return ret;
+	return 0;
 }
 
 static void uvc_dismiss_privileges(struct uvc_fh *handle)
 {
 	if (handle->state == UVC_HANDLE_ACTIVE)
-		atomic_dec(&handle->device->active);
+		atomic_dec(&handle->stream->active);
 
 	handle->state = UVC_HANDLE_PASSIVE;
 }
@@ -414,67 +410,61 @@
 
 static int uvc_v4l2_open(struct file *file)
 {
-	struct uvc_video_device *video;
+	struct uvc_streaming *stream;
 	struct uvc_fh *handle;
 	int ret = 0;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");
-	mutex_lock(&uvc_driver.open_mutex);
-	video = video_drvdata(file);
+	stream = video_drvdata(file);
 
-	if (video->dev->state & UVC_DEV_DISCONNECTED) {
-		ret = -ENODEV;
-		goto done;
-	}
+	if (stream->dev->state & UVC_DEV_DISCONNECTED)
+		return -ENODEV;
 
-	ret = usb_autopm_get_interface(video->dev->intf);
+	ret = usb_autopm_get_interface(stream->dev->intf);
 	if (ret < 0)
-		goto done;
+		return ret;
 
 	/* Create the device handle. */
 	handle = kzalloc(sizeof *handle, GFP_KERNEL);
 	if (handle == NULL) {
-		usb_autopm_put_interface(video->dev->intf);
-		ret = -ENOMEM;
-		goto done;
+		usb_autopm_put_interface(stream->dev->intf);
+		return -ENOMEM;
 	}
 
-	if (atomic_inc_return(&video->dev->users) == 1) {
-		if ((ret = uvc_status_start(video->dev)) < 0) {
-			usb_autopm_put_interface(video->dev->intf);
-			atomic_dec(&video->dev->users);
+	if (atomic_inc_return(&stream->dev->users) == 1) {
+		ret = uvc_status_start(stream->dev);
+		if (ret < 0) {
+			usb_autopm_put_interface(stream->dev->intf);
+			atomic_dec(&stream->dev->users);
 			kfree(handle);
-			goto done;
+			return ret;
 		}
 	}
 
-	handle->device = video;
+	handle->chain = stream->chain;
+	handle->stream = stream;
 	handle->state = UVC_HANDLE_PASSIVE;
 	file->private_data = handle;
 
-	kref_get(&video->dev->kref);
-
-done:
-	mutex_unlock(&uvc_driver.open_mutex);
-	return ret;
+	return 0;
 }
 
 static int uvc_v4l2_release(struct file *file)
 {
-	struct uvc_video_device *video = video_drvdata(file);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");
 
 	/* Only free resources if this is a privileged handle. */
 	if (uvc_has_privileges(handle)) {
-		uvc_video_enable(video, 0);
+		uvc_video_enable(stream, 0);
 
-		mutex_lock(&video->queue.mutex);
-		if (uvc_free_buffers(&video->queue) < 0)
+		mutex_lock(&stream->queue.mutex);
+		if (uvc_free_buffers(&stream->queue) < 0)
 			uvc_printk(KERN_ERR, "uvc_v4l2_release: Unable to "
 					"free buffers.\n");
-		mutex_unlock(&video->queue.mutex);
+		mutex_unlock(&stream->queue.mutex);
 	}
 
 	/* Release the file handle. */
@@ -482,19 +472,19 @@
 	kfree(handle);
 	file->private_data = NULL;
 
-	if (atomic_dec_return(&video->dev->users) == 0)
-		uvc_status_stop(video->dev);
+	if (atomic_dec_return(&stream->dev->users) == 0)
+		uvc_status_stop(stream->dev);
 
-	usb_autopm_put_interface(video->dev->intf);
-	kref_put(&video->dev->kref, uvc_delete);
+	usb_autopm_put_interface(stream->dev->intf);
 	return 0;
 }
 
 static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
 	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_video_chain *chain = handle->chain;
+	struct uvc_streaming *stream = handle->stream;
 	long ret = 0;
 
 	switch (cmd) {
@@ -506,10 +496,10 @@
 		memset(cap, 0, sizeof *cap);
 		strlcpy(cap->driver, "uvcvideo", sizeof cap->driver);
 		strlcpy(cap->card, vdev->name, sizeof cap->card);
-		usb_make_path(video->dev->udev,
+		usb_make_path(stream->dev->udev,
 			      cap->bus_info, sizeof(cap->bus_info));
 		cap->version = DRIVER_VERSION_NUMBER;
-		if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
 			cap->capabilities = V4L2_CAP_VIDEO_CAPTURE
 					  | V4L2_CAP_STREAMING;
 		else
@@ -520,7 +510,7 @@
 
 	/* Get, Set & Query control */
 	case VIDIOC_QUERYCTRL:
-		return uvc_query_v4l2_ctrl(video, arg);
+		return uvc_query_v4l2_ctrl(chain, arg);
 
 	case VIDIOC_G_CTRL:
 	{
@@ -530,12 +520,12 @@
 		memset(&xctrl, 0, sizeof xctrl);
 		xctrl.id = ctrl->id;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		ret = uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_ctrl_get(video, &xctrl);
-		uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_get(chain, &xctrl);
+		uvc_ctrl_rollback(chain);
 		if (ret >= 0)
 			ctrl->value = xctrl.value;
 		break;
@@ -550,21 +540,23 @@
 		xctrl.id = ctrl->id;
 		xctrl.value = ctrl->value;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		ret = uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_ctrl_set(video, &xctrl);
+		ret = uvc_ctrl_set(chain, &xctrl);
 		if (ret < 0) {
-			uvc_ctrl_rollback(video);
+			uvc_ctrl_rollback(chain);
 			return ret;
 		}
-		ret = uvc_ctrl_commit(video);
+		ret = uvc_ctrl_commit(chain);
+		if (ret == 0)
+			ctrl->value = xctrl.value;
 		break;
 	}
 
 	case VIDIOC_QUERYMENU:
-		return uvc_v4l2_query_menu(video, arg);
+		return uvc_v4l2_query_menu(chain, arg);
 
 	case VIDIOC_G_EXT_CTRLS:
 	{
@@ -572,20 +564,20 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-	       ret = uvc_ctrl_begin(video);
-	       if (ret < 0)
+		ret = uvc_ctrl_begin(chain);
+		if (ret < 0)
 			return ret;
 
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_get(video, ctrl);
+			ret = uvc_ctrl_get(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
 		}
 		ctrls->error_idx = 0;
-		ret = uvc_ctrl_rollback(video);
+		ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
@@ -596,14 +588,14 @@
 		struct v4l2_ext_control *ctrl = ctrls->controls;
 		unsigned int i;
 
-		ret = uvc_ctrl_begin(video);
+		ret = uvc_ctrl_begin(chain);
 		if (ret < 0)
 			return ret;
 
 		for (i = 0; i < ctrls->count; ++ctrl, ++i) {
-			ret = uvc_ctrl_set(video, ctrl);
+			ret = uvc_ctrl_set(chain, ctrl);
 			if (ret < 0) {
-				uvc_ctrl_rollback(video);
+				uvc_ctrl_rollback(chain);
 				ctrls->error_idx = i;
 				return ret;
 			}
@@ -612,31 +604,35 @@
 		ctrls->error_idx = 0;
 
 		if (cmd == VIDIOC_S_EXT_CTRLS)
-			ret = uvc_ctrl_commit(video);
+			ret = uvc_ctrl_commit(chain);
 		else
-			ret = uvc_ctrl_rollback(video);
+			ret = uvc_ctrl_rollback(chain);
 		break;
 	}
 
 	/* Get, Set & Enum input */
 	case VIDIOC_ENUMINPUT:
 	{
-		const struct uvc_entity *selector = video->selector;
+		const struct uvc_entity *selector = chain->selector;
 		struct v4l2_input *input = arg;
 		struct uvc_entity *iterm = NULL;
 		u32 index = input->index;
 		int pin = 0;
 
 		if (selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (index != 0)
 				return -EINVAL;
-			iterm = list_first_entry(&video->iterms,
-					struct uvc_entity, chain);
+			list_for_each_entry(iterm, &chain->entities, chain) {
+				if (UVC_ENTITY_IS_ITERM(iterm))
+					break;
+			}
 			pin = iterm->id;
-		} else if (pin < selector->selector.bNrInPins) {
-			pin = selector->selector.baSourceID[index];
-			list_for_each_entry(iterm, video->iterms.next, chain) {
+		} else if (pin < selector->bNrInPins) {
+			pin = selector->baSourceID[index];
+			list_for_each_entry(iterm, &chain->entities, chain) {
+				if (!UVC_ENTITY_IS_ITERM(iterm))
+					continue;
 				if (iterm->id == pin)
 					break;
 			}
@@ -648,7 +644,7 @@
 		memset(input, 0, sizeof *input);
 		input->index = index;
 		strlcpy(input->name, iterm->name, sizeof input->name);
-		if (UVC_ENTITY_TYPE(iterm) == ITT_CAMERA)
+		if (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)
 			input->type = V4L2_INPUT_TYPE_CAMERA;
 		break;
 	}
@@ -657,15 +653,15 @@
 	{
 		u8 input;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			*(int *)arg = 0;
 			break;
 		}
 
-		ret = uvc_query_ctrl(video->dev, GET_CUR, video->selector->id,
-			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
-			&input, 1);
+		ret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,
+			chain->selector->id, chain->dev->intfnum,
+			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 		if (ret < 0)
 			return ret;
 
@@ -680,19 +676,19 @@
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		if (video->selector == NULL ||
-		    (video->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
+		if (chain->selector == NULL ||
+		    (chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {
 			if (input != 1)
 				return -EINVAL;
 			break;
 		}
 
-		if (input == 0 || input > video->selector->selector.bNrInPins)
+		if (input == 0 || input > chain->selector->bNrInPins)
 			return -EINVAL;
 
-		return uvc_query_ctrl(video->dev, SET_CUR, video->selector->id,
-			video->dev->intfnum, SU_INPUT_SELECT_CONTROL,
-			&input, 1);
+		return uvc_query_ctrl(chain->dev, UVC_SET_CUR,
+			chain->selector->id, chain->dev->intfnum,
+			UVC_SU_INPUT_SELECT_CONTROL, &input, 1);
 	}
 
 	/* Try, Get, Set & Enum format */
@@ -703,15 +699,15 @@
 		enum v4l2_buf_type type = fmt->type;
 		__u32 index = fmt->index;
 
-		if (fmt->type != video->streaming->type ||
-		    fmt->index >= video->streaming->nformats)
+		if (fmt->type != stream->type ||
+		    fmt->index >= stream->nformats)
 			return -EINVAL;
 
 		memset(fmt, 0, sizeof(*fmt));
 		fmt->index = index;
 		fmt->type = type;
 
-		format = &video->streaming->format[fmt->index];
+		format = &stream->format[fmt->index];
 		fmt->flags = 0;
 		if (format->flags & UVC_FMT_FLAG_COMPRESSED)
 			fmt->flags |= V4L2_FMT_FLAG_COMPRESSED;
@@ -726,20 +722,17 @@
 	{
 		struct uvc_streaming_control probe;
 
-		if ((ret = uvc_acquire_privileges(handle)) < 0)
-			return ret;
-
-		return uvc_v4l2_try_format(video, arg, &probe, NULL, NULL);
+		return uvc_v4l2_try_format(stream, arg, &probe, NULL, NULL);
 	}
 
 	case VIDIOC_S_FMT:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_format(video, arg);
+		return uvc_v4l2_set_format(stream, arg);
 
 	case VIDIOC_G_FMT:
-		return uvc_v4l2_get_format(video, arg);
+		return uvc_v4l2_get_format(stream, arg);
 
 	/* Frame size enumeration */
 	case VIDIOC_ENUM_FRAMESIZES:
@@ -750,10 +743,10 @@
 		int i;
 
 		/* Look for the given pixel format */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fsize->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -779,10 +772,10 @@
 		int i;
 
 		/* Look for the given pixel format and frame size */
-		for (i = 0; i < video->streaming->nformats; i++) {
-			if (video->streaming->format[i].fcc ==
+		for (i = 0; i < stream->nformats; i++) {
+			if (stream->format[i].fcc ==
 					fival->pixel_format) {
-				format = &video->streaming->format[i];
+				format = &stream->format[i];
 				break;
 			}
 		}
@@ -832,21 +825,21 @@
 
 	/* Get & Set streaming parameters */
 	case VIDIOC_G_PARM:
-		return uvc_v4l2_get_streamparm(video, arg);
+		return uvc_v4l2_get_streamparm(stream, arg);
 
 	case VIDIOC_S_PARM:
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		return uvc_v4l2_set_streamparm(video, arg);
+		return uvc_v4l2_set_streamparm(stream, arg);
 
 	/* Cropping and scaling */
 	case VIDIOC_CROPCAP:
 	{
 		struct v4l2_cropcap *ccap = arg;
-		struct uvc_frame *frame = video->streaming->cur_frame;
+		struct uvc_frame *frame = stream->cur_frame;
 
-		if (ccap->type != video->streaming->type)
+		if (ccap->type != stream->type)
 			return -EINVAL;
 
 		ccap->bounds.left = 0;
@@ -870,19 +863,22 @@
 	{
 		struct v4l2_requestbuffers *rb = arg;
 		unsigned int bufsize =
-			video->streaming->ctrl.dwMaxVideoFrameSize;
+			stream->ctrl.dwMaxVideoFrameSize;
 
-		if (rb->type != video->streaming->type ||
+		if (rb->type != stream->type ||
 		    rb->memory != V4L2_MEMORY_MMAP)
 			return -EINVAL;
 
 		if ((ret = uvc_acquire_privileges(handle)) < 0)
 			return ret;
 
-		ret = uvc_alloc_buffers(&video->queue, rb->count, bufsize);
+		ret = uvc_alloc_buffers(&stream->queue, rb->count, bufsize);
 		if (ret < 0)
 			return ret;
 
+		if (ret == 0)
+			uvc_dismiss_privileges(handle);
+
 		rb->count = ret;
 		ret = 0;
 		break;
@@ -892,39 +888,40 @@
 	{
 		struct v4l2_buffer *buf = arg;
 
-		if (buf->type != video->streaming->type)
+		if (buf->type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_query_buffer(&video->queue, buf);
+		return uvc_query_buffer(&stream->queue, buf);
 	}
 
 	case VIDIOC_QBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_queue_buffer(&video->queue, arg);
+		return uvc_queue_buffer(&stream->queue, arg);
 
 	case VIDIOC_DQBUF:
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_dequeue_buffer(&video->queue, arg,
+		return uvc_dequeue_buffer(&stream->queue, arg,
 			file->f_flags & O_NONBLOCK);
 
 	case VIDIOC_STREAMON:
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		if ((ret = uvc_video_enable(video, 1)) < 0)
+		ret = uvc_video_enable(stream, 1);
+		if (ret < 0)
 			return ret;
 		break;
 	}
@@ -933,13 +930,13 @@
 	{
 		int *type = arg;
 
-		if (*type != video->streaming->type)
+		if (*type != stream->type)
 			return -EINVAL;
 
 		if (!uvc_has_privileges(handle))
 			return -EBUSY;
 
-		return uvc_video_enable(video, 0);
+		return uvc_video_enable(stream, 0);
 	}
 
 	/* Analog video standards make no sense for digital cameras. */
@@ -1013,10 +1010,10 @@
 	}
 
 	case UVCIOC_CTRL_GET:
-		return uvc_xu_ctrl_query(video, arg, 0);
+		return uvc_xu_ctrl_query(chain, arg, 0);
 
 	case UVCIOC_CTRL_SET:
-		return uvc_xu_ctrl_query(video, arg, 1);
+		return uvc_xu_ctrl_query(chain, arg, 1);
 
 	default:
 		if ((ret = v4l_compat_translate_ioctl(file, cmd, arg,
@@ -1045,7 +1042,7 @@
 		    size_t count, loff_t *ppos)
 {
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_read: not implemented.\n");
-	return -ENODEV;
+	return -EINVAL;
 }
 
 /*
@@ -1063,14 +1060,16 @@
 	buffer->vma_use_count--;
 }
 
-static struct vm_operations_struct uvc_vm_ops = {
+static const struct vm_operations_struct uvc_vm_ops = {
 	.open		= uvc_vm_open,
 	.close		= uvc_vm_close,
 };
 
 static int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *uninitialized_var(buffer);
 	struct page *page;
 	unsigned long addr, start, size;
@@ -1082,15 +1081,15 @@
 	start = vma->vm_start;
 	size = vma->vm_end - vma->vm_start;
 
-	mutex_lock(&video->queue.mutex);
+	mutex_lock(&queue->mutex);
 
-	for (i = 0; i < video->queue.count; ++i) {
-		buffer = &video->queue.buffer[i];
+	for (i = 0; i < queue->count; ++i) {
+		buffer = &queue->buffer[i];
 		if ((buffer->buf.m.offset >> PAGE_SHIFT) == vma->vm_pgoff)
 			break;
 	}
 
-	if (i == video->queue.count || size != video->queue.buf_size) {
+	if (i == queue->count || size != queue->buf_size) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -1100,8 +1099,9 @@
 	 * device. It also prevents the region from being core dumped.
 	 */
 	vma->vm_flags |= VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
-	addr = (unsigned long)video->queue.mem + buffer->buf.m.offset;
+	addr = (unsigned long)queue->mem + buffer->buf.m.offset;
 	while (size > 0) {
 		page = vmalloc_to_page((void *)addr);
 		if ((ret = vm_insert_page(vma, start, page)) < 0)
@@ -1117,17 +1117,18 @@
 	uvc_vm_open(vma);
 
 done:
-	mutex_unlock(&video->queue.mutex);
+	mutex_unlock(&queue->mutex);
 	return ret;
 }
 
 static unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)
 {
-	struct uvc_video_device *video = video_drvdata(file);
+	struct uvc_fh *handle = (struct uvc_fh *)file->private_data;
+	struct uvc_streaming *stream = handle->stream;
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");
 
-	return uvc_queue_poll(&video->queue, file, wait);
+	return uvc_queue_poll(&stream->queue, file, wait);
 }
 
 const struct v4l2_file_operations uvc_fops = {
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvc_video.c linux-2.6/drivers/media/video/uvc/uvc_video.c
--- linux-2.6.31/drivers/media/video/uvc/uvc_video.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvc_video.c	2011-05-12 17:22:20.000000000 -0700
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/videodev2.h>
 #include <linux/vmalloc.h>
@@ -61,7 +62,7 @@
 	return 0;
 }
 
-static void uvc_fixup_video_ctrl(struct uvc_video_device *video,
+static void uvc_fixup_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl)
 {
 	struct uvc_format *format;
@@ -69,10 +70,10 @@
 	unsigned int i;
 
 	if (ctrl->bFormatIndex <= 0 ||
-	    ctrl->bFormatIndex > video->streaming->nformats)
+	    ctrl->bFormatIndex > stream->nformats)
 		return;
 
-	format = &video->streaming->format[ctrl->bFormatIndex - 1];
+	format = &stream->format[ctrl->bFormatIndex - 1];
 
 	for (i = 0; i < format->nframes; ++i) {
 		if (format->frame[i].bFrameIndex == ctrl->bFrameIndex) {
@@ -86,12 +87,13 @@
 
 	if (!(format->flags & UVC_FMT_FLAG_COMPRESSED) ||
 	     (ctrl->dwMaxVideoFrameSize == 0 &&
-	      video->dev->uvc_version < 0x0110))
+	      stream->dev->uvc_version < 0x0110))
 		ctrl->dwMaxVideoFrameSize =
 			frame->dwMaxVideoFrameBufferSize;
 
-	if (video->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
-	    video->streaming->intf->num_altsetting > 1) {
+	if (!(format->flags & UVC_FMT_FLAG_COMPRESSED) &&
+	    stream->dev->quirks & UVC_QUIRK_FIX_BANDWIDTH &&
+	    stream->intf->num_altsetting > 1) {
 		u32 interval;
 		u32 bandwidth;
 
@@ -108,7 +110,7 @@
 		bandwidth = frame->wWidth * frame->wHeight / 8 * format->bpp;
 		bandwidth *= 10000000 / interval + 1;
 		bandwidth /= 1000;
-		if (video->dev->udev->speed == USB_SPEED_HIGH)
+		if (stream->dev->udev->speed == USB_SPEED_HIGH)
 			bandwidth /= 8;
 		bandwidth += 12;
 
@@ -116,40 +118,44 @@
 	}
 }
 
-static int uvc_get_video_ctrl(struct uvc_video_device *video,
+static int uvc_get_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe, __u8 query)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
+	if ((stream->dev->quirks & UVC_QUIRK_PROBE_DEF) &&
+			query == UVC_GET_DEF)
+		return -EIO;
+
 	data = kmalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
 
-	ret = __uvc_query_ctrl(video->dev, query, 0, video->streaming->intfnum,
-		probe ? VS_PROBE_CONTROL : VS_COMMIT_CONTROL, data, size,
-		UVC_CTRL_STREAMING_TIMEOUT);
+	ret = __uvc_query_ctrl(stream->dev, query, 0, stream->intfnum,
+		probe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,
+		size, uvc_timeout_param);
 
-	if ((query == GET_MIN || query == GET_MAX) && ret == 2) {
+	if ((query == UVC_GET_MIN || query == UVC_GET_MAX) && ret == 2) {
 		/* Some cameras, mostly based on Bison Electronics chipsets,
 		 * answer a GET_MIN or GET_MAX request with the wCompQuality
 		 * field only.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_MINMAX, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_MINMAX, "UVC non "
 			"compliance - GET_MIN/MAX(PROBE) incorrectly "
 			"supported. Enabling workaround.\n");
-		memset(ctrl, 0, sizeof ctrl);
+		memset(ctrl, 0, sizeof *ctrl);
 		ctrl->wCompQuality = le16_to_cpup((__le16 *)data);
 		ret = 0;
 		goto out;
-	} else if (query == GET_DEF && probe == 1 && ret != size) {
+	} else if (query == UVC_GET_DEF && probe == 1 && ret != size) {
 		/* Many cameras don't support the GET_DEF request on their
 		 * video probe control. Warn once and return, the caller will
 		 * fall back to GET_CUR.
 		 */
-		uvc_warn_once(video->dev, UVC_WARN_PROBE_DEF, "UVC non "
+		uvc_warn_once(stream->dev, UVC_WARN_PROBE_DEF, "UVC non "
 			"compliance - GET_DEF(PROBE) not supported. "
 			"Enabling workaround.\n");
 		ret = -EIO;
@@ -181,7 +187,7 @@
 		ctrl->bMinVersion = data[32];
 		ctrl->bMaxVersion = data[33];
 	} else {
-		ctrl->dwClockFrequency = video->dev->clock_frequency;
+		ctrl->dwClockFrequency = stream->dev->clock_frequency;
 		ctrl->bmFramingInfo = 0;
 		ctrl->bPreferedVersion = 0;
 		ctrl->bMinVersion = 0;
@@ -192,7 +198,7 @@
 	 * dwMaxPayloadTransferSize fields. Try to get the value from the
 	 * format and frame descriptors.
 	 */
-	uvc_fixup_video_ctrl(video, ctrl);
+	uvc_fixup_video_ctrl(stream, ctrl);
 	ret = 0;
 
 out:
@@ -200,14 +206,14 @@
 	return ret;
 }
 
-static int uvc_set_video_ctrl(struct uvc_video_device *video,
+static int uvc_set_video_ctrl(struct uvc_streaming *stream,
 	struct uvc_streaming_control *ctrl, int probe)
 {
 	__u8 *data;
 	__u16 size;
 	int ret;
 
-	size = video->dev->uvc_version >= 0x0110 ? 34 : 26;
+	size = stream->dev->uvc_version >= 0x0110 ? 34 : 26;
 	data = kzalloc(size, GFP_KERNEL);
 	if (data == NULL)
 		return -ENOMEM;
@@ -232,10 +238,9 @@
 		data[33] = ctrl->bMaxVersion;
 	}
 
-	ret = __uvc_query_ctrl(video->dev, SET_CUR, 0,
-		video->streaming->intfnum,
-		probe ? VS_PROBE_CONTROL : VS_COMMIT_CONTROL, data, size,
-		UVC_CTRL_STREAMING_TIMEOUT);
+	ret = __uvc_query_ctrl(stream->dev, UVC_SET_CUR, 0, stream->intfnum,
+		probe ? UVC_VS_PROBE_CONTROL : UVC_VS_COMMIT_CONTROL, data,
+		size, uvc_timeout_param);
 	if (ret != size) {
 		uvc_printk(KERN_ERR, "Failed to set UVC %s control : "
 			"%d (exp. %u).\n", probe ? "probe" : "commit",
@@ -247,7 +252,7 @@
 	return ret;
 }
 
-int uvc_probe_video(struct uvc_video_device *video,
+int uvc_probe_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
 	struct uvc_streaming_control probe_min, probe_max;
@@ -255,7 +260,7 @@
 	unsigned int i;
 	int ret;
 
-	mutex_lock(&video->streaming->mutex);
+	mutex_lock(&stream->mutex);
 
 	/* Perform probing. The device should adjust the requested values
 	 * according to its capabilities. However, some devices, namely the
@@ -264,15 +269,16 @@
 	 * that reason, if the needed bandwidth exceeds the maximum available
 	 * bandwidth, try to lower the quality.
 	 */
-	if ((ret = uvc_set_video_ctrl(video, probe, 1)) < 0)
+	ret = uvc_set_video_ctrl(stream, probe, 1);
+	if (ret < 0)
 		goto done;
 
 	/* Get the minimum and maximum values for compression settings. */
-	if (!(video->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
-		ret = uvc_get_video_ctrl(video, &probe_min, 1, GET_MIN);
+	if (!(stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX)) {
+		ret = uvc_get_video_ctrl(stream, &probe_min, 1, UVC_GET_MIN);
 		if (ret < 0)
 			goto done;
-		ret = uvc_get_video_ctrl(video, &probe_max, 1, GET_MAX);
+		ret = uvc_get_video_ctrl(stream, &probe_max, 1, UVC_GET_MAX);
 		if (ret < 0)
 			goto done;
 
@@ -280,18 +286,21 @@
 	}
 
 	for (i = 0; i < 2; ++i) {
-		if ((ret = uvc_set_video_ctrl(video, probe, 1)) < 0 ||
-		    (ret = uvc_get_video_ctrl(video, probe, 1, GET_CUR)) < 0)
+		ret = uvc_set_video_ctrl(stream, probe, 1);
+		if (ret < 0)
+			goto done;
+		ret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);
+		if (ret < 0)
 			goto done;
 
-		if (video->streaming->intf->num_altsetting == 1)
+		if (stream->intf->num_altsetting == 1)
 			break;
 
 		bandwidth = probe->dwMaxPayloadTransferSize;
-		if (bandwidth <= video->streaming->maxpsize)
+		if (bandwidth <= stream->maxpsize)
 			break;
 
-		if (video->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
+		if (stream->dev->quirks & UVC_QUIRK_PROBE_MINMAX) {
 			ret = -ENOSPC;
 			goto done;
 		}
@@ -304,14 +313,14 @@
 	}
 
 done:
-	mutex_unlock(&video->streaming->mutex);
+	mutex_unlock(&stream->mutex);
 	return ret;
 }
 
-int uvc_commit_video(struct uvc_video_device *video,
+int uvc_commit_video(struct uvc_streaming *stream,
 	struct uvc_streaming_control *probe)
 {
-	return uvc_set_video_ctrl(video, probe, 0);
+	return uvc_set_video_ctrl(stream, probe, 0);
 }
 
 /* ------------------------------------------------------------------------
@@ -363,7 +372,7 @@
  * to be called with a NULL buf parameter. uvc_video_decode_data and
  * uvc_video_decode_end will never be called with a NULL buffer.
  */
-static int uvc_video_decode_start(struct uvc_video_device *video,
+static int uvc_video_decode_start(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	__u8 fid;
@@ -389,28 +398,38 @@
 	 * NULL.
 	 */
 	if (buf == NULL) {
-		video->last_fid = fid;
+		stream->last_fid = fid;
 		return -ENODATA;
 	}
 
 	/* Synchronize to the input stream by waiting for the FID bit to be
 	 * toggled when the the buffer state is not UVC_BUF_STATE_ACTIVE.
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will always be in sync.
 	 *
-	 * If the device doesn't toggle the FID bit, invert video->last_fid
+	 * If the device doesn't toggle the FID bit, invert stream->last_fid
 	 * when the EOF bit is set to force synchronisation on the next packet.
 	 */
 	if (buf->state != UVC_BUF_STATE_ACTIVE) {
-		if (fid == video->last_fid) {
+		struct timespec ts;
+
+		if (fid == stream->last_fid) {
 			uvc_trace(UVC_TRACE_FRAME, "Dropping payload (out of "
 				"sync).\n");
-			if ((video->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
+			if ((stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID) &&
 			    (data[1] & UVC_STREAM_EOF))
-				video->last_fid ^= UVC_STREAM_FID;
+				stream->last_fid ^= UVC_STREAM_FID;
 			return -ENODATA;
 		}
 
+		if (uvc_clock_param == CLOCK_MONOTONIC)
+			ktime_get_ts(&ts);
+		else
+			ktime_get_real_ts(&ts);
+
+		buf->buf.timestamp.tv_sec = ts.tv_sec;
+		buf->buf.timestamp.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
+
 		/* TODO: Handle PTS and SCR. */
 		buf->state = UVC_BUF_STATE_ACTIVE;
 	}
@@ -422,7 +441,7 @@
 	 * last payload can be lost anyway). We thus must check if the FID has
 	 * been toggled.
 	 *
-	 * video->last_fid is initialized to -1, so the first isochronous
+	 * stream->last_fid is initialized to -1, so the first isochronous
 	 * frame will never trigger an end of frame detection.
 	 *
 	 * Empty buffers (bytesused == 0) don't trigger end of frame detection
@@ -430,22 +449,22 @@
 	 * avoids detecting end of frame conditions at FID toggling if the
 	 * previous payload had the EOF bit set.
 	 */
-	if (fid != video->last_fid && buf->buf.bytesused != 0) {
+	if (fid != stream->last_fid && buf->buf.bytesused != 0) {
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (FID bit "
 				"toggled).\n");
-		buf->state = UVC_BUF_STATE_DONE;
+		buf->state = UVC_BUF_STATE_READY;
 		return -EAGAIN;
 	}
 
-	video->last_fid = fid;
+	stream->last_fid = fid;
 
 	return data[0];
 }
 
-static void uvc_video_decode_data(struct uvc_video_device *video,
+static void uvc_video_decode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int maxlen, nbytes;
 	void *mem;
 
@@ -462,11 +481,11 @@
 	/* Complete the current frame if the buffer size was exceeded. */
 	if (len > maxlen) {
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (overflow).\n");
-		buf->state = UVC_BUF_STATE_DONE;
+		buf->state = UVC_BUF_STATE_READY;
 	}
 }
 
-static void uvc_video_decode_end(struct uvc_video_device *video,
+static void uvc_video_decode_end(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, const __u8 *data, int len)
 {
 	/* Mark the buffer as done if the EOF marker is set. */
@@ -474,9 +493,9 @@
 		uvc_trace(UVC_TRACE_FRAME, "Frame complete (EOF found).\n");
 		if (data[0] == len)
 			uvc_trace(UVC_TRACE_FRAME, "EOF in empty payload.\n");
-		buf->state = UVC_BUF_STATE_DONE;
-		if (video->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
-			video->last_fid ^= UVC_STREAM_FID;
+		buf->state = UVC_BUF_STATE_READY;
+		if (stream->dev->quirks & UVC_QUIRK_STREAM_NO_FID)
+			stream->last_fid ^= UVC_STREAM_FID;
 	}
 }
 
@@ -491,26 +510,26 @@
  * uvc_video_encode_data is called for every URB and copies the data from the
  * video buffer to the transfer buffer.
  */
-static int uvc_video_encode_header(struct uvc_video_device *video,
+static int uvc_video_encode_header(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
 	data[0] = 2;	/* Header length */
 	data[1] = UVC_STREAM_EOH | UVC_STREAM_EOF
-		| (video->last_fid & UVC_STREAM_FID);
+		| (stream->last_fid & UVC_STREAM_FID);
 	return 2;
 }
 
-static int uvc_video_encode_data(struct uvc_video_device *video,
+static int uvc_video_encode_data(struct uvc_streaming *stream,
 		struct uvc_buffer *buf, __u8 *data, int len)
 {
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_video_queue *queue = &stream->queue;
 	unsigned int nbytes;
 	void *mem;
 
 	/* Copy video data to the URB buffer. */
 	mem = queue->mem + buf->buf.m.offset + queue->buf_used;
 	nbytes = min((unsigned int)len, buf->buf.bytesused - queue->buf_used);
-	nbytes = min(video->bulk.max_payload_size - video->bulk.payload_size,
+	nbytes = min(stream->bulk.max_payload_size - stream->bulk.payload_size,
 			nbytes);
 	memcpy(data, mem, nbytes);
 
@@ -526,8 +545,8 @@
 /*
  * Completion handler for video URBs.
  */
-static void uvc_video_decode_isoc(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_isoc(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int ret, i;
@@ -536,37 +555,46 @@
 		if (urb->iso_frame_desc[i].status < 0) {
 			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 				"lost (%d).\n", urb->iso_frame_desc[i].status);
+			/* Mark the buffer as faulty. */
+			if (buf != NULL)
+				buf->error = 1;
 			continue;
 		}
 
 		/* Decode the payload header. */
 		mem = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
 		do {
-			ret = uvc_video_decode_start(video, buf, mem,
+			ret = uvc_video_decode_start(stream, buf, mem,
 				urb->iso_frame_desc[i].actual_length);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		if (ret < 0)
 			continue;
 
 		/* Decode the payload data. */
-		uvc_video_decode_data(video, buf, mem + ret,
+		uvc_video_decode_data(stream, buf, mem + ret,
 			urb->iso_frame_desc[i].actual_length - ret);
 
 		/* Process the header again. */
-		uvc_video_decode_end(video, buf, mem,
+		uvc_video_decode_end(stream, buf, mem,
 			urb->iso_frame_desc[i].actual_length);
 
-		if (buf->state == UVC_BUF_STATE_DONE ||
-		    buf->state == UVC_BUF_STATE_ERROR)
-			buf = uvc_queue_next_buffer(&video->queue, buf);
+		if (buf->state == UVC_BUF_STATE_READY) {
+			if (buf->buf.length != buf->buf.bytesused &&
+			    !(stream->cur_format->flags &
+			      UVC_FMT_FLAG_COMPRESSED))
+				buf->error = 1;
+
+			buf = uvc_queue_next_buffer(&stream->queue, buf);
+		}
 	}
 }
 
-static void uvc_video_decode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_decode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem;
 	int len, ret;
@@ -576,24 +604,25 @@
 
 	mem = urb->transfer_buffer;
 	len = urb->actual_length;
-	video->bulk.payload_size += len;
+	stream->bulk.payload_size += len;
 
 	/* If the URB is the first of its payload, decode and save the
 	 * header.
 	 */
-	if (video->bulk.header_size == 0 && !video->bulk.skip_payload) {
+	if (stream->bulk.header_size == 0 && !stream->bulk.skip_payload) {
 		do {
-			ret = uvc_video_decode_start(video, buf, mem, len);
+			ret = uvc_video_decode_start(stream, buf, mem, len);
 			if (ret == -EAGAIN)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		} while (ret == -EAGAIN);
 
 		/* If an error occured skip the rest of the payload. */
 		if (ret < 0 || buf == NULL) {
-			video->bulk.skip_payload = 1;
+			stream->bulk.skip_payload = 1;
 		} else {
-			memcpy(video->bulk.header, mem, ret);
-			video->bulk.header_size = ret;
+			memcpy(stream->bulk.header, mem, ret);
+			stream->bulk.header_size = ret;
 
 			mem += ret;
 			len -= ret;
@@ -606,33 +635,33 @@
 	 */
 
 	/* Process video data. */
-	if (!video->bulk.skip_payload && buf != NULL)
-		uvc_video_decode_data(video, buf, mem, len);
+	if (!stream->bulk.skip_payload && buf != NULL)
+		uvc_video_decode_data(stream, buf, mem, len);
 
 	/* Detect the payload end by a URB smaller than the maximum size (or
 	 * a payload size equal to the maximum) and process the header again.
 	 */
 	if (urb->actual_length < urb->transfer_buffer_length ||
-	    video->bulk.payload_size >= video->bulk.max_payload_size) {
-		if (!video->bulk.skip_payload && buf != NULL) {
-			uvc_video_decode_end(video, buf, video->bulk.header,
-				video->bulk.payload_size);
-			if (buf->state == UVC_BUF_STATE_DONE ||
-			    buf->state == UVC_BUF_STATE_ERROR)
-				buf = uvc_queue_next_buffer(&video->queue, buf);
+	    stream->bulk.payload_size >= stream->bulk.max_payload_size) {
+		if (!stream->bulk.skip_payload && buf != NULL) {
+			uvc_video_decode_end(stream, buf, stream->bulk.header,
+				stream->bulk.payload_size);
+			if (buf->state == UVC_BUF_STATE_READY)
+				buf = uvc_queue_next_buffer(&stream->queue,
+							    buf);
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.skip_payload = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.skip_payload = 0;
+		stream->bulk.payload_size = 0;
 	}
 }
 
-static void uvc_video_encode_bulk(struct urb *urb,
-	struct uvc_video_device *video, struct uvc_buffer *buf)
+static void uvc_video_encode_bulk(struct urb *urb, struct uvc_streaming *stream,
+	struct uvc_buffer *buf)
 {
 	u8 *mem = urb->transfer_buffer;
-	int len = video->urb_size, ret;
+	int len = stream->urb_size, ret;
 
 	if (buf == NULL) {
 		urb->transfer_buffer_length = 0;
@@ -640,40 +669,40 @@
 	}
 
 	/* If the URB is the first of its payload, add the header. */
-	if (video->bulk.header_size == 0) {
-		ret = uvc_video_encode_header(video, buf, mem, len);
-		video->bulk.header_size = ret;
-		video->bulk.payload_size += ret;
+	if (stream->bulk.header_size == 0) {
+		ret = uvc_video_encode_header(stream, buf, mem, len);
+		stream->bulk.header_size = ret;
+		stream->bulk.payload_size += ret;
 		mem += ret;
 		len -= ret;
 	}
 
 	/* Process video data. */
-	ret = uvc_video_encode_data(video, buf, mem, len);
+	ret = uvc_video_encode_data(stream, buf, mem, len);
 
-	video->bulk.payload_size += ret;
+	stream->bulk.payload_size += ret;
 	len -= ret;
 
-	if (buf->buf.bytesused == video->queue.buf_used ||
-	    video->bulk.payload_size == video->bulk.max_payload_size) {
-		if (buf->buf.bytesused == video->queue.buf_used) {
-			video->queue.buf_used = 0;
-			buf->state = UVC_BUF_STATE_DONE;
-			uvc_queue_next_buffer(&video->queue, buf);
-			video->last_fid ^= UVC_STREAM_FID;
+	if (buf->buf.bytesused == stream->queue.buf_used ||
+	    stream->bulk.payload_size == stream->bulk.max_payload_size) {
+		if (buf->buf.bytesused == stream->queue.buf_used) {
+			stream->queue.buf_used = 0;
+			buf->state = UVC_BUF_STATE_READY;
+			uvc_queue_next_buffer(&stream->queue, buf);
+			stream->last_fid ^= UVC_STREAM_FID;
 		}
 
-		video->bulk.header_size = 0;
-		video->bulk.payload_size = 0;
+		stream->bulk.header_size = 0;
+		stream->bulk.payload_size = 0;
 	}
 
-	urb->transfer_buffer_length = video->urb_size - len;
+	urb->transfer_buffer_length = stream->urb_size - len;
 }
 
 static void uvc_video_complete(struct urb *urb)
 {
-	struct uvc_video_device *video = urb->context;
-	struct uvc_video_queue *queue = &video->queue;
+	struct uvc_streaming *stream = urb->context;
+	struct uvc_video_queue *queue = &stream->queue;
 	struct uvc_buffer *buf = NULL;
 	unsigned long flags;
 	int ret;
@@ -687,7 +716,7 @@
 			"completion handler.\n", urb->status);
 
 	case -ENOENT:		/* usb_kill_urb() called. */
-		if (video->frozen)
+		if (stream->frozen)
 			return;
 
 	case -ECONNRESET:	/* usb_unlink_urb() called. */
@@ -702,7 +731,7 @@
 				       queue);
 	spin_unlock_irqrestore(&queue->irqlock, flags);
 
-	video->decode(urb, video, buf);
+	stream->decode(urb, stream, buf);
 
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
 		uvc_printk(KERN_ERR, "Failed to resubmit video URB (%d).\n",
@@ -713,19 +742,19 @@
 /*
  * Free transfer buffers.
  */
-static void uvc_free_urb_buffers(struct uvc_video_device *video)
+static void uvc_free_urb_buffers(struct uvc_streaming *stream)
 {
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if (video->urb_buffer[i]) {
-			usb_buffer_free(video->dev->udev, video->urb_size,
-				video->urb_buffer[i], video->urb_dma[i]);
-			video->urb_buffer[i] = NULL;
+		if (stream->urb_buffer[i]) {
+			usb_buffer_free(stream->dev->udev, stream->urb_size,
+				stream->urb_buffer[i], stream->urb_dma[i]);
+			stream->urb_buffer[i] = NULL;
 		}
 	}
 
-	video->urb_size = 0;
+	stream->urb_size = 0;
 }
 
 /*
@@ -739,15 +768,15 @@
  *
  * Return the number of allocated packets on success or 0 when out of memory.
  */
-static int uvc_alloc_urb_buffers(struct uvc_video_device *video,
+static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 	unsigned int size, unsigned int psize, gfp_t gfp_flags)
 {
 	unsigned int npackets;
 	unsigned int i;
 
 	/* Buffers are already allocated, bail out. */
-	if (video->urb_size)
-		return video->urb_size / psize;
+	if (stream->urb_size)
+		return stream->urb_size / psize;
 
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
 	 * payloads accross multiple URBs.
@@ -759,50 +788,56 @@
 	/* Retry allocations until one succeed. */
 	for (; npackets > 1; npackets /= 2) {
 		for (i = 0; i < UVC_URBS; ++i) {
-			video->urb_buffer[i] = usb_buffer_alloc(
-				video->dev->udev, psize * npackets,
-				gfp_flags | __GFP_NOWARN, &video->urb_dma[i]);
-			if (!video->urb_buffer[i]) {
-				uvc_free_urb_buffers(video);
+			stream->urb_size = psize * npackets;
+			stream->urb_buffer[i] = usb_buffer_alloc(
+				stream->dev->udev, stream->urb_size,
+				gfp_flags | __GFP_NOWARN, &stream->urb_dma[i]);
+			if (!stream->urb_buffer[i]) {
+				uvc_free_urb_buffers(stream);
 				break;
 			}
 		}
 
 		if (i == UVC_URBS) {
-			video->urb_size = psize * npackets;
+			uvc_trace(UVC_TRACE_VIDEO, "Allocated %u URB buffers "
+				"of %ux%u bytes each.\n", UVC_URBS, npackets,
+				psize);
 			return npackets;
 		}
 	}
 
+	uvc_trace(UVC_TRACE_VIDEO, "Failed to allocate URB buffers (%u bytes "
+		"per packet).\n", psize);
 	return 0;
 }
 
 /*
  * Uninitialize isochronous/bulk URBs and free transfer buffers.
  */
-static void uvc_uninit_video(struct uvc_video_device *video, int free_buffers)
+static void uvc_uninit_video(struct uvc_streaming *stream, int free_buffers)
 {
 	struct urb *urb;
 	unsigned int i;
 
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((urb = video->urb[i]) == NULL)
+		urb = stream->urb[i];
+		if (urb == NULL)
 			continue;
 
 		usb_kill_urb(urb);
 		usb_free_urb(urb);
-		video->urb[i] = NULL;
+		stream->urb[i] = NULL;
 	}
 
 	if (free_buffers)
-		uvc_free_urb_buffers(video);
+		uvc_free_urb_buffers(stream);
 }
 
 /*
  * Initialize isochronous URBs and allocate transfer buffers. The packet size
  * is given by the endpoint.
  */
-static int uvc_init_video_isoc(struct uvc_video_device *video,
+static int uvc_init_video_isoc(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -812,9 +847,9 @@
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize);
 	psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
-	size = video->streaming->ctrl.dwMaxVideoFrameSize;
+	size = stream->ctrl.dwMaxVideoFrameSize;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
@@ -823,18 +858,18 @@
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(npackets, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		urb->dev = video->dev->udev;
-		urb->context = video;
-		urb->pipe = usb_rcvisocpipe(video->dev->udev,
+		urb->dev = stream->dev->udev;
+		urb->context = stream;
+		urb->pipe = usb_rcvisocpipe(stream->dev->udev,
 				ep->desc.bEndpointAddress);
 		urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;
 		urb->interval = ep->desc.bInterval;
-		urb->transfer_buffer = video->urb_buffer[i];
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_buffer = stream->urb_buffer[i];
+		urb->transfer_dma = stream->urb_dma[i];
 		urb->complete = uvc_video_complete;
 		urb->number_of_packets = npackets;
 		urb->transfer_buffer_length = size;
@@ -844,7 +879,7 @@
 			urb->iso_frame_desc[j].length = psize;
 		}
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -854,7 +889,7 @@
  * Initialize bulk URBs and allocate transfer buffers. The packet size is
  * given by the endpoint.
  */
-static int uvc_init_video_bulk(struct uvc_video_device *video,
+static int uvc_init_video_bulk(struct uvc_streaming *stream,
 	struct usb_host_endpoint *ep, gfp_t gfp_flags)
 {
 	struct urb *urb;
@@ -863,39 +898,39 @@
 	u32 size;
 
 	psize = le16_to_cpu(ep->desc.wMaxPacketSize) & 0x07ff;
-	size = video->streaming->ctrl.dwMaxPayloadTransferSize;
-	video->bulk.max_payload_size = size;
+	size = stream->ctrl.dwMaxPayloadTransferSize;
+	stream->bulk.max_payload_size = size;
 
-	npackets = uvc_alloc_urb_buffers(video, size, psize, gfp_flags);
+	npackets = uvc_alloc_urb_buffers(stream, size, psize, gfp_flags);
 	if (npackets == 0)
 		return -ENOMEM;
 
 	size = npackets * psize;
 
 	if (usb_endpoint_dir_in(&ep->desc))
-		pipe = usb_rcvbulkpipe(video->dev->udev,
+		pipe = usb_rcvbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 	else
-		pipe = usb_sndbulkpipe(video->dev->udev,
+		pipe = usb_sndbulkpipe(stream->dev->udev,
 				       ep->desc.bEndpointAddress);
 
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		size = 0;
 
 	for (i = 0; i < UVC_URBS; ++i) {
 		urb = usb_alloc_urb(0, gfp_flags);
 		if (urb == NULL) {
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return -ENOMEM;
 		}
 
-		usb_fill_bulk_urb(urb, video->dev->udev, pipe,
-			video->urb_buffer[i], size, uvc_video_complete,
-			video);
+		usb_fill_bulk_urb(urb, stream->dev->udev, pipe,
+			stream->urb_buffer[i], size, uvc_video_complete,
+			stream);
 		urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;
-		urb->transfer_dma = video->urb_dma[i];
+		urb->transfer_dma = stream->urb_dma[i];
 
-		video->urb[i] = urb;
+		stream->urb[i] = urb;
 	}
 
 	return 0;
@@ -904,60 +939,79 @@
 /*
  * Initialize isochronous/bulk URBs and allocate transfer buffers.
  */
-static int uvc_init_video(struct uvc_video_device *video, gfp_t gfp_flags)
+static int uvc_init_video(struct uvc_streaming *stream, gfp_t gfp_flags)
 {
-	struct usb_interface *intf = video->streaming->intf;
-	struct usb_host_interface *alts;
-	struct usb_host_endpoint *ep = NULL;
-	int intfnum = video->streaming->intfnum;
-	unsigned int bandwidth, psize, i;
+	struct usb_interface *intf = stream->intf;
+	struct usb_host_endpoint *ep;
+	unsigned int i;
 	int ret;
 
-	video->last_fid = -1;
-	video->bulk.header_size = 0;
-	video->bulk.skip_payload = 0;
-	video->bulk.payload_size = 0;
+	stream->last_fid = -1;
+	stream->bulk.header_size = 0;
+	stream->bulk.skip_payload = 0;
+	stream->bulk.payload_size = 0;
 
 	if (intf->num_altsetting > 1) {
+		struct usb_host_endpoint *best_ep = NULL;
+		unsigned int best_psize = 3 * 1024;
+		unsigned int bandwidth;
+		unsigned int uninitialized_var(altsetting);
+		int intfnum = stream->intfnum;
+
 		/* Isochronous endpoint, select the alternate setting. */
-		bandwidth = video->streaming->ctrl.dwMaxPayloadTransferSize;
+		bandwidth = stream->ctrl.dwMaxPayloadTransferSize;
 
 		if (bandwidth == 0) {
-			uvc_printk(KERN_WARNING, "device %s requested null "
-				"bandwidth, defaulting to lowest.\n",
-				video->vdev->name);
+			uvc_trace(UVC_TRACE_VIDEO, "Device requested null "
+				"bandwidth, defaulting to lowest.\n");
 			bandwidth = 1;
+		} else {
+			uvc_trace(UVC_TRACE_VIDEO, "Device requested %u "
+				"B/frame bandwidth.\n", bandwidth);
 		}
 
 		for (i = 0; i < intf->num_altsetting; ++i) {
+			struct usb_host_interface *alts;
+			unsigned int psize;
+
 			alts = &intf->altsetting[i];
 			ep = uvc_find_endpoint(alts,
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 			if (ep == NULL)
 				continue;
 
 			/* Check if the bandwidth is high enough. */
 			psize = le16_to_cpu(ep->desc.wMaxPacketSize);
 			psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
-			if (psize >= bandwidth)
-				break;
+			if (psize >= bandwidth && psize <= best_psize) {
+				altsetting = i;
+				best_psize = psize;
+				best_ep = ep;
+			}
 		}
 
-		if (i >= intf->num_altsetting)
+		if (best_ep == NULL) {
+			uvc_trace(UVC_TRACE_VIDEO, "No fast enough alt setting "
+				"for requested bandwidth.\n");
 			return -EIO;
+		}
 
-		if ((ret = usb_set_interface(video->dev->udev, intfnum, i)) < 0)
+		uvc_trace(UVC_TRACE_VIDEO, "Selecting alternate setting %u "
+			"(%u B/frame bandwidth).\n", altsetting, best_psize);
+
+		ret = usb_set_interface(stream->dev->udev, intfnum, altsetting);
+		if (ret < 0)
 			return ret;
 
-		ret = uvc_init_video_isoc(video, ep, gfp_flags);
+		ret = uvc_init_video_isoc(stream, best_ep, gfp_flags);
 	} else {
 		/* Bulk endpoint, proceed to URB initialization. */
 		ep = uvc_find_endpoint(&intf->altsetting[0],
-				video->streaming->header.bEndpointAddress);
+				stream->header.bEndpointAddress);
 		if (ep == NULL)
 			return -EIO;
 
-		ret = uvc_init_video_bulk(video, ep, gfp_flags);
+		ret = uvc_init_video_bulk(stream, ep, gfp_flags);
 	}
 
 	if (ret < 0)
@@ -965,10 +1019,11 @@
 
 	/* Submit the URBs. */
 	for (i = 0; i < UVC_URBS; ++i) {
-		if ((ret = usb_submit_urb(video->urb[i], gfp_flags)) < 0) {
+		ret = usb_submit_urb(stream->urb[i], gfp_flags);
+		if (ret < 0) {
 			uvc_printk(KERN_ERR, "Failed to submit URB %u "
 					"(%d).\n", i, ret);
-			uvc_uninit_video(video, 1);
+			uvc_uninit_video(stream, 1);
 			return ret;
 		}
 	}
@@ -987,14 +1042,14 @@
  * video buffers in any way. We mark the device as frozen to make sure the URB
  * completion handler won't try to cancel the queue when we kill the URBs.
  */
-int uvc_video_suspend(struct uvc_video_device *video)
+int uvc_video_suspend(struct uvc_streaming *stream)
 {
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	video->frozen = 1;
-	uvc_uninit_video(video, 0);
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	stream->frozen = 1;
+	uvc_uninit_video(stream, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 	return 0;
 }
 
@@ -1006,22 +1061,24 @@
  * buffers, making sure userspace applications are notified of the problem
  * instead of waiting forever.
  */
-int uvc_video_resume(struct uvc_video_device *video)
+int uvc_video_resume(struct uvc_streaming *stream)
 {
 	int ret;
 
-	video->frozen = 0;
+	stream->frozen = 0;
 
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0) {
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0) {
+		uvc_queue_enable(&stream->queue, 0);
 		return ret;
 	}
 
-	if (!uvc_queue_streaming(&video->queue))
+	if (!uvc_queue_streaming(&stream->queue))
 		return 0;
 
-	if ((ret = uvc_init_video(video, GFP_NOIO)) < 0)
-		uvc_queue_enable(&video->queue, 0);
+	ret = uvc_init_video(stream, GFP_NOIO);
+	if (ret < 0)
+		uvc_queue_enable(&stream->queue, 0);
 
 	return ret;
 }
@@ -1040,47 +1097,53 @@
  *
  * This function is called before registering the device with V4L.
  */
-int uvc_video_init(struct uvc_video_device *video)
+int uvc_video_init(struct uvc_streaming *stream)
 {
-	struct uvc_streaming_control *probe = &video->streaming->ctrl;
+	struct uvc_streaming_control *probe = &stream->ctrl;
 	struct uvc_format *format = NULL;
 	struct uvc_frame *frame = NULL;
 	unsigned int i;
 	int ret;
 
-	if (video->streaming->nformats == 0) {
+	if (stream->nformats == 0) {
 		uvc_printk(KERN_INFO, "No supported video formats found.\n");
 		return -EINVAL;
 	}
 
+	atomic_set(&stream->active, 0);
+
+	/* Initialize the video buffers queue. */
+	uvc_queue_init(&stream->queue, stream->type, !uvc_no_drop_param);
+
 	/* Alternate setting 0 should be the default, yet the XBox Live Vision
 	 * Cam (and possibly other devices) crash or otherwise misbehave if
 	 * they don't receive a SET_INTERFACE request before any other video
 	 * control request.
 	 */
-	usb_set_interface(video->dev->udev, video->streaming->intfnum, 0);
+	usb_set_interface(stream->dev->udev, stream->intfnum, 0);
 
 	/* Set the streaming probe control with default streaming parameters
 	 * retrieved from the device. Webcams that don't suport GET_DEF
 	 * requests on the probe control will just keep their current streaming
 	 * parameters.
 	 */
-	if (uvc_get_video_ctrl(video, probe, 1, GET_DEF) == 0)
-		uvc_set_video_ctrl(video, probe, 1);
+	if (uvc_get_video_ctrl(stream, probe, 1, UVC_GET_DEF) == 0)
+		uvc_set_video_ctrl(stream, probe, 1);
 
 	/* Initialize the streaming parameters with the probe control current
 	 * value. This makes sure SET_CUR requests on the streaming commit
 	 * control will always use values retrieved from a successful GET_CUR
 	 * request on the probe control, as required by the UVC specification.
 	 */
-	if ((ret = uvc_get_video_ctrl(video, probe, 1, GET_CUR)) < 0)
+	ret = uvc_get_video_ctrl(stream, probe, 1, UVC_GET_CUR);
+	if (ret < 0)
 		return ret;
 
 	/* Check if the default format descriptor exists. Use the first
 	 * available format otherwise.
 	 */
-	for (i = video->streaming->nformats; i > 0; --i) {
-		format = &video->streaming->format[i-1];
+	for (i = stream->nformats; i > 0; --i) {
+		format = &stream->format[i-1];
 		if (format->index == probe->bFormatIndex)
 			break;
 	}
@@ -1105,21 +1168,20 @@
 	probe->bFormatIndex = format->index;
 	probe->bFrameIndex = frame->bFrameIndex;
 
-	video->streaming->cur_format = format;
-	video->streaming->cur_frame = frame;
-	atomic_set(&video->active, 0);
+	stream->cur_format = format;
+	stream->cur_frame = frame;
 
 	/* Select the video decoding function */
-	if (video->streaming->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		if (video->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
-			video->decode = uvc_video_decode_isight;
-		else if (video->streaming->intf->num_altsetting > 1)
-			video->decode = uvc_video_decode_isoc;
+	if (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		if (stream->dev->quirks & UVC_QUIRK_BUILTIN_ISIGHT)
+			stream->decode = uvc_video_decode_isight;
+		else if (stream->intf->num_altsetting > 1)
+			stream->decode = uvc_video_decode_isoc;
 		else
-			video->decode = uvc_video_decode_bulk;
+			stream->decode = uvc_video_decode_bulk;
 	} else {
-		if (video->streaming->intf->num_altsetting == 1)
-			video->decode = uvc_video_encode_bulk;
+		if (stream->intf->num_altsetting == 1)
+			stream->decode = uvc_video_encode_bulk;
 		else {
 			uvc_printk(KERN_INFO, "Isochronous endpoints are not "
 				"supported for video output devices.\n");
@@ -1133,31 +1195,26 @@
 /*
  * Enable or disable the video stream.
  */
-int uvc_video_enable(struct uvc_video_device *video, int enable)
+int uvc_video_enable(struct uvc_streaming *stream, int enable)
 {
 	int ret;
 
 	if (!enable) {
-		uvc_uninit_video(video, 1);
-		usb_set_interface(video->dev->udev,
-			video->streaming->intfnum, 0);
-		uvc_queue_enable(&video->queue, 0);
+		uvc_uninit_video(stream, 1);
+		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
+		uvc_queue_enable(&stream->queue, 0);
 		return 0;
 	}
 
-	if ((video->streaming->cur_format->flags & UVC_FMT_FLAG_COMPRESSED) ||
-	    uvc_no_drop_param)
-		video->queue.flags &= ~UVC_QUEUE_DROP_INCOMPLETE;
-	else
-		video->queue.flags |= UVC_QUEUE_DROP_INCOMPLETE;
-
-	if ((ret = uvc_queue_enable(&video->queue, 1)) < 0)
+	ret = uvc_queue_enable(&stream->queue, 1);
+	if (ret < 0)
 		return ret;
 
 	/* Commit the streaming parameters. */
-	if ((ret = uvc_commit_video(video, &video->streaming->ctrl)) < 0)
+	ret = uvc_commit_video(stream, &stream->ctrl);
+	if (ret < 0)
 		return ret;
 
-	return uvc_init_video(video, GFP_KERNEL);
+	return uvc_init_video(stream, GFP_NOWAIT);
 }
 
diff -ruaN linux-2.6.31/drivers/media/video/uvc/uvcvideo.h linux-2.6/drivers/media/video/uvc/uvcvideo.h
--- linux-2.6.31/drivers/media/video/uvc/uvcvideo.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/media/video/uvc/uvcvideo.h	2011-05-12 17:22:20.000000000 -0700
@@ -67,168 +67,26 @@
 #ifdef __KERNEL__
 
 #include <linux/poll.h>
+#include <linux/usb/video.h>
 
 /* --------------------------------------------------------------------------
  * UVC constants
  */
 
-#define SC_UNDEFINED			0x00
-#define SC_VIDEOCONTROL			0x01
-#define SC_VIDEOSTREAMING		0x02
-#define SC_VIDEO_INTERFACE_COLLECTION	0x03
-
-#define PC_PROTOCOL_UNDEFINED		0x00
-
-#define CS_UNDEFINED			0x20
-#define CS_DEVICE			0x21
-#define CS_CONFIGURATION		0x22
-#define CS_STRING			0x23
-#define CS_INTERFACE			0x24
-#define CS_ENDPOINT			0x25
-
-/* VideoControl class specific interface descriptor */
-#define VC_DESCRIPTOR_UNDEFINED		0x00
-#define VC_HEADER			0x01
-#define VC_INPUT_TERMINAL		0x02
-#define VC_OUTPUT_TERMINAL		0x03
-#define VC_SELECTOR_UNIT		0x04
-#define VC_PROCESSING_UNIT		0x05
-#define VC_EXTENSION_UNIT		0x06
-
-/* VideoStreaming class specific interface descriptor */
-#define VS_UNDEFINED			0x00
-#define VS_INPUT_HEADER			0x01
-#define VS_OUTPUT_HEADER		0x02
-#define VS_STILL_IMAGE_FRAME		0x03
-#define VS_FORMAT_UNCOMPRESSED		0x04
-#define VS_FRAME_UNCOMPRESSED		0x05
-#define VS_FORMAT_MJPEG			0x06
-#define VS_FRAME_MJPEG			0x07
-#define VS_FORMAT_MPEG2TS		0x0a
-#define VS_FORMAT_DV			0x0c
-#define VS_COLORFORMAT			0x0d
-#define VS_FORMAT_FRAME_BASED		0x10
-#define VS_FRAME_FRAME_BASED		0x11
-#define VS_FORMAT_STREAM_BASED		0x12
-
-/* Endpoint type */
-#define EP_UNDEFINED			0x00
-#define EP_GENERAL			0x01
-#define EP_ENDPOINT			0x02
-#define EP_INTERRUPT			0x03
-
-/* Request codes */
-#define RC_UNDEFINED			0x00
-#define SET_CUR				0x01
-#define GET_CUR				0x81
-#define GET_MIN				0x82
-#define GET_MAX				0x83
-#define GET_RES				0x84
-#define GET_LEN				0x85
-#define GET_INFO			0x86
-#define GET_DEF				0x87
-
-/* VideoControl interface controls */
-#define VC_CONTROL_UNDEFINED		0x00
-#define VC_VIDEO_POWER_MODE_CONTROL	0x01
-#define VC_REQUEST_ERROR_CODE_CONTROL	0x02
-
-/* Terminal controls */
-#define TE_CONTROL_UNDEFINED		0x00
-
-/* Selector Unit controls */
-#define SU_CONTROL_UNDEFINED		0x00
-#define SU_INPUT_SELECT_CONTROL		0x01
-
-/* Camera Terminal controls */
-#define CT_CONTROL_UNDEFINED				0x00
-#define CT_SCANNING_MODE_CONTROL			0x01
-#define CT_AE_MODE_CONTROL				0x02
-#define CT_AE_PRIORITY_CONTROL				0x03
-#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL		0x04
-#define CT_EXPOSURE_TIME_RELATIVE_CONTROL		0x05
-#define CT_FOCUS_ABSOLUTE_CONTROL			0x06
-#define CT_FOCUS_RELATIVE_CONTROL			0x07
-#define CT_FOCUS_AUTO_CONTROL				0x08
-#define CT_IRIS_ABSOLUTE_CONTROL			0x09
-#define CT_IRIS_RELATIVE_CONTROL			0x0a
-#define CT_ZOOM_ABSOLUTE_CONTROL			0x0b
-#define CT_ZOOM_RELATIVE_CONTROL			0x0c
-#define CT_PANTILT_ABSOLUTE_CONTROL			0x0d
-#define CT_PANTILT_RELATIVE_CONTROL			0x0e
-#define CT_ROLL_ABSOLUTE_CONTROL			0x0f
-#define CT_ROLL_RELATIVE_CONTROL			0x10
-#define CT_PRIVACY_CONTROL				0x11
-
-/* Processing Unit controls */
-#define PU_CONTROL_UNDEFINED				0x00
-#define PU_BACKLIGHT_COMPENSATION_CONTROL		0x01
-#define PU_BRIGHTNESS_CONTROL				0x02
-#define PU_CONTRAST_CONTROL				0x03
-#define PU_GAIN_CONTROL					0x04
-#define PU_POWER_LINE_FREQUENCY_CONTROL			0x05
-#define PU_HUE_CONTROL					0x06
-#define PU_SATURATION_CONTROL				0x07
-#define PU_SHARPNESS_CONTROL				0x08
-#define PU_GAMMA_CONTROL				0x09
-#define PU_WHITE_BALANCE_TEMPERATURE_CONTROL		0x0a
-#define PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL	0x0b
-#define PU_WHITE_BALANCE_COMPONENT_CONTROL		0x0c
-#define PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL		0x0d
-#define PU_DIGITAL_MULTIPLIER_CONTROL			0x0e
-#define PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL		0x0f
-#define PU_HUE_AUTO_CONTROL				0x10
-#define PU_ANALOG_VIDEO_STANDARD_CONTROL		0x11
-#define PU_ANALOG_LOCK_STATUS_CONTROL			0x12
-
-#define LXU_MOTOR_PANTILT_RELATIVE_CONTROL		0x01
-#define LXU_MOTOR_PANTILT_RESET_CONTROL			0x02
-#define LXU_MOTOR_FOCUS_MOTOR_CONTROL			0x03
-
-/* VideoStreaming interface controls */
-#define VS_CONTROL_UNDEFINED		0x00
-#define VS_PROBE_CONTROL		0x01
-#define VS_COMMIT_CONTROL		0x02
-#define VS_STILL_PROBE_CONTROL		0x03
-#define VS_STILL_COMMIT_CONTROL		0x04
-#define VS_STILL_IMAGE_TRIGGER_CONTROL	0x05
-#define VS_STREAM_ERROR_CODE_CONTROL	0x06
-#define VS_GENERATE_KEY_FRAME_CONTROL	0x07
-#define VS_UPDATE_FRAME_SEGMENT_CONTROL	0x08
-#define VS_SYNC_DELAY_CONTROL		0x09
-
-#define TT_VENDOR_SPECIFIC		0x0100
-#define TT_STREAMING			0x0101
-
-/* Input Terminal types */
-#define ITT_VENDOR_SPECIFIC		0x0200
-#define ITT_CAMERA			0x0201
-#define ITT_MEDIA_TRANSPORT_INPUT	0x0202
-
-/* Output Terminal types */
-#define OTT_VENDOR_SPECIFIC		0x0300
-#define OTT_DISPLAY			0x0301
-#define OTT_MEDIA_TRANSPORT_OUTPUT	0x0302
-
-/* External Terminal types */
-#define EXTERNAL_VENDOR_SPECIFIC	0x0400
-#define COMPOSITE_CONNECTOR		0x0401
-#define SVIDEO_CONNECTOR		0x0402
-#define COMPONENT_CONNECTOR		0x0403
-
 #define UVC_TERM_INPUT			0x0000
 #define UVC_TERM_OUTPUT			0x8000
+#define UVC_TERM_DIRECTION(term)	((term)->type & 0x8000)
 
 #define UVC_ENTITY_TYPE(entity)		((entity)->type & 0x7fff)
 #define UVC_ENTITY_IS_UNIT(entity)	(((entity)->type & 0xff00) == 0)
 #define UVC_ENTITY_IS_TERM(entity)	(((entity)->type & 0xff00) != 0)
 #define UVC_ENTITY_IS_ITERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_INPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_INPUT)
 #define UVC_ENTITY_IS_OTERM(entity) \
-	(((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
+	(UVC_ENTITY_IS_TERM(entity) && \
+	((entity)->type & 0x8000) == UVC_TERM_OUTPUT)
 
-#define UVC_STATUS_TYPE_CONTROL		1
-#define UVC_STATUS_TYPE_STREAMING	2
 
 /* ------------------------------------------------------------------------
  * GUIDs
@@ -249,25 +107,15 @@
 	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
 	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02}
 
-#define UVC_GUID_LOGITECH_DEV_INFO \
-	{0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, \
-	 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x1e}
-#define UVC_GUID_LOGITECH_USER_HW \
-	{0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, \
-	 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x1f}
-#define UVC_GUID_LOGITECH_VIDEO \
-	{0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, \
-	 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x50}
-#define UVC_GUID_LOGITECH_MOTOR \
-	{0x82, 0x06, 0x61, 0x63, 0x70, 0x50, 0xab, 0x49, \
-	 0xb8, 0xcc, 0xb3, 0x85, 0x5e, 0x8d, 0x22, 0x56}
-
 #define UVC_GUID_FORMAT_MJPEG \
 	{ 'M',  'J',  'P',  'G', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 #define UVC_GUID_FORMAT_YUY2 \
 	{ 'Y',  'U',  'Y',  '2', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+#define UVC_GUID_FORMAT_YUY2_ISIGHT \
+	{ 'Y',  'U',  'Y',  '2', 0x00, 0x00, 0x10, 0x00, \
+	 0x80, 0x00, 0x00, 0x00, 0x00, 0x38, 0x9b, 0x71}
 #define UVC_GUID_FORMAT_NV12 \
 	{ 'N',  'V',  '1',  '2', 0x00, 0x00, 0x10, 0x00, \
 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
@@ -295,7 +143,7 @@
 #define DRIVER_VERSION_NUMBER	KERNEL_VERSION(0, 1, 0)
 
 /* Number of isochronous URBs. */
-#define UVC_URBS		5
+#define UVC_URBS		2
 /* Maximum number of packets per URB. */
 #define UVC_MAX_PACKETS		32
 /* Maximum number of video buffers. */
@@ -304,7 +152,7 @@
 #define UVC_MAX_STATUS_SIZE	16
 
 #define UVC_CTRL_CONTROL_TIMEOUT	300
-#define UVC_CTRL_STREAMING_TIMEOUT	1000
+#define UVC_CTRL_STREAMING_TIMEOUT	5000
 
 /* Devices quirks */
 #define UVC_QUIRK_STATUS_INTERVAL	0x00000001
@@ -314,6 +162,7 @@
 #define UVC_QUIRK_STREAM_NO_FID		0x00000010
 #define UVC_QUIRK_IGNORE_SELECTOR_UNIT	0x00000020
 #define UVC_QUIRK_FIX_BANDWIDTH		0x00000080
+#define UVC_QUIRK_PROBE_DEF		0x00000100
 
 /* Format flags */
 #define UVC_FMT_FLAG_COMPRESSED		0x00000001
@@ -396,7 +245,8 @@
 			   uvc_control_info. */
 	__u8 dirty : 1,
 	     loaded : 1,
-	     modified : 1;
+	     modified : 1,
+	     cached : 1;
 
 	__u8 *data;
 };
@@ -447,11 +297,9 @@
 		} media;
 
 		struct {
-			__u8  bSourceID;
 		} output;
 
 		struct {
-			__u8  bSourceID;
 			__u16 wMaxMultiplier;
 			__u8  bControlSize;
 			__u8  *bmControls;
@@ -459,21 +307,20 @@
 		} processing;
 
 		struct {
-			__u8  bNrInPins;
-			__u8  *baSourceID;
 		} selector;
 
 		struct {
 			__u8  guidExtensionCode[16];
 			__u8  bNumControls;
-			__u8  bNrInPins;
-			__u8  *baSourceID;
 			__u8  bControlSize;
 			__u8  *bmControls;
 			__u8  *bmControlsType;
 		} extension;
 	};
 
+	__u8 bNrInPins;
+	__u8 *baSourceID;
+
 	unsigned int ncontrols;
 	struct uvc_control *controls;
 };
@@ -518,32 +365,13 @@
 	__u8 bTriggerUsage;
 };
 
-struct uvc_streaming {
-	struct list_head list;
-
-	struct usb_interface *intf;
-	int intfnum;
-	__u16 maxpsize;
-
-	struct uvc_streaming_header header;
-	enum v4l2_buf_type type;
-
-	unsigned int nformats;
-	struct uvc_format *format;
-
-	struct uvc_streaming_control ctrl;
-	struct uvc_format *cur_format;
-	struct uvc_frame *cur_frame;
-
-	struct mutex mutex;
-};
-
 enum uvc_buffer_state {
 	UVC_BUF_STATE_IDLE	= 0,
 	UVC_BUF_STATE_QUEUED	= 1,
 	UVC_BUF_STATE_ACTIVE	= 2,
-	UVC_BUF_STATE_DONE	= 3,
-	UVC_BUF_STATE_ERROR	= 4,
+	UVC_BUF_STATE_READY	= 3,
+	UVC_BUF_STATE_DONE	= 4,
+	UVC_BUF_STATE_ERROR	= 5,
 };
 
 struct uvc_buffer {
@@ -555,11 +383,12 @@
 	struct list_head queue;
 	wait_queue_head_t wait;
 	enum uvc_buffer_state state;
+	unsigned int error;
 };
 
 #define UVC_QUEUE_STREAMING		(1 << 0)
 #define UVC_QUEUE_DISCONNECTED		(1 << 1)
-#define UVC_QUEUE_DROP_INCOMPLETE	(1 << 2)
+#define UVC_QUEUE_DROP_CORRUPTED	(1 << 2)
 
 struct uvc_video_queue {
 	enum v4l2_buf_type type;
@@ -579,26 +408,43 @@
 	struct list_head irqqueue;
 };
 
-struct uvc_video_device {
+struct uvc_video_chain {
+	struct uvc_device *dev;
+	struct list_head list;
+
+	struct list_head entities;		/* All entities */
+	struct uvc_entity *processing;		/* Processing unit */
+	struct uvc_entity *selector;		/* Selector unit */
+
+	struct mutex ctrl_mutex;
+};
+
+struct uvc_streaming {
+	struct list_head list;
 	struct uvc_device *dev;
 	struct video_device *vdev;
+	struct uvc_video_chain *chain;
 	atomic_t active;
-	unsigned int frozen : 1;
 
-	struct list_head iterms;		/* Input terminals */
-	struct uvc_entity *oterm;		/* Output terminal */
-	struct uvc_entity *sterm;		/* USB streaming terminal */
-	struct uvc_entity *processing;
-	struct uvc_entity *selector;
-	struct list_head extensions;
-	struct mutex ctrl_mutex;
+	struct usb_interface *intf;
+	int intfnum;
+	__u16 maxpsize;
 
-	struct uvc_video_queue queue;
+	struct uvc_streaming_header header;
+	enum v4l2_buf_type type;
+
+	unsigned int nformats;
+	struct uvc_format *format;
 
-	/* Video streaming object, must always be non-NULL. */
-	struct uvc_streaming *streaming;
+	struct uvc_streaming_control ctrl;
+	struct uvc_format *cur_format;
+	struct uvc_frame *cur_frame;
+
+	struct mutex mutex;
 
-	void (*decode) (struct urb *urb, struct uvc_video_device *video,
+	unsigned int frozen : 1;
+	struct uvc_video_queue queue;
+	void (*decode) (struct urb *urb, struct uvc_streaming *video,
 			struct uvc_buffer *buf);
 
 	/* Context data used by the bulk completion handler. */
@@ -631,7 +477,6 @@
 	char name[32];
 
 	enum uvc_device_state state;
-	struct kref kref;
 	struct list_head list;
 	atomic_t users;
 
@@ -640,8 +485,11 @@
 	__u32 clock_frequency;
 
 	struct list_head entities;
+	struct list_head chains;
 
-	struct uvc_video_device video;
+	/* Video Streaming interfaces */
+	struct list_head streams;
+	atomic_t nstreams;
 
 	/* Status Interrupt Endpoint */
 	struct usb_host_endpoint *int_ep;
@@ -649,9 +497,6 @@
 	__u8 *status;
 	struct input_dev *input;
 	char input_phys[64];
-
-	/* Video Streaming interfaces */
-	struct list_head streaming;
 };
 
 enum uvc_handle_state {
@@ -660,15 +505,14 @@
 };
 
 struct uvc_fh {
-	struct uvc_video_device *device;
+	struct uvc_video_chain *chain;
+	struct uvc_streaming *stream;
 	enum uvc_handle_state state;
 };
 
 struct uvc_driver {
 	struct usb_driver driver;
 
-	struct mutex open_mutex;	/* protects from open/disconnect race */
-
 	struct list_head devices;	/* struct uvc_device list */
 	struct list_head controls;	/* struct uvc_control_info list */
 	struct mutex ctrl_mutex;	/* protects controls and devices
@@ -689,12 +533,15 @@
 #define UVC_TRACE_FRAME		(1 << 7)
 #define UVC_TRACE_SUSPEND	(1 << 8)
 #define UVC_TRACE_STATUS	(1 << 9)
+#define UVC_TRACE_VIDEO		(1 << 10)
 
 #define UVC_WARN_MINMAX		0
 #define UVC_WARN_PROBE_DEF	1
 
+extern unsigned int uvc_clock_param;
 extern unsigned int uvc_no_drop_param;
 extern unsigned int uvc_trace_param;
+extern unsigned int uvc_timeout_param;
 
 #define uvc_trace(flag, msg...) \
 	do { \
@@ -711,27 +558,16 @@
 #define uvc_printk(level, msg...) \
 	printk(level "uvcvideo: " msg)
 
-#define UVC_GUID_FORMAT "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-" \
-			"%02x%02x%02x%02x%02x%02x"
-#define UVC_GUID_ARGS(guid) \
-	(guid)[3],  (guid)[2],  (guid)[1],  (guid)[0], \
-	(guid)[5],  (guid)[4], \
-	(guid)[7],  (guid)[6], \
-	(guid)[8],  (guid)[9], \
-	(guid)[10], (guid)[11], (guid)[12], \
-	(guid)[13], (guid)[14], (guid)[15]
-
 /* --------------------------------------------------------------------------
  * Internal functions.
  */
 
 /* Core driver */
 extern struct uvc_driver uvc_driver;
-extern void uvc_delete(struct kref *kref);
 
 /* Video buffers queue management. */
 extern void uvc_queue_init(struct uvc_video_queue *queue,
-		enum v4l2_buf_type type);
+		enum v4l2_buf_type type, int drop_corrupted);
 extern int uvc_alloc_buffers(struct uvc_video_queue *queue,
 		unsigned int nbuffers, unsigned int buflength);
 extern int uvc_free_buffers(struct uvc_video_queue *queue);
@@ -757,13 +593,13 @@
 extern const struct v4l2_file_operations uvc_fops;
 
 /* Video */
-extern int uvc_video_init(struct uvc_video_device *video);
-extern int uvc_video_suspend(struct uvc_video_device *video);
-extern int uvc_video_resume(struct uvc_video_device *video);
-extern int uvc_video_enable(struct uvc_video_device *video, int enable);
-extern int uvc_probe_video(struct uvc_video_device *video,
+extern int uvc_video_init(struct uvc_streaming *stream);
+extern int uvc_video_suspend(struct uvc_streaming *stream);
+extern int uvc_video_resume(struct uvc_streaming *stream);
+extern int uvc_video_enable(struct uvc_streaming *stream, int enable);
+extern int uvc_probe_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *probe);
-extern int uvc_commit_video(struct uvc_video_device *video,
+extern int uvc_commit_video(struct uvc_streaming *stream,
 		struct uvc_streaming_control *ctrl);
 extern int uvc_query_ctrl(struct uvc_device *dev, __u8 query, __u8 unit,
 		__u8 intfnum, __u8 cs, void *data, __u16 size);
@@ -777,9 +613,9 @@
 extern int uvc_status_resume(struct uvc_device *dev);
 
 /* Controls */
-extern struct uvc_control *uvc_find_control(struct uvc_video_device *video,
+extern struct uvc_control *uvc_find_control(struct uvc_video_chain *chain,
 		__u32 v4l2_id, struct uvc_control_mapping **mapping);
-extern int uvc_query_v4l2_ctrl(struct uvc_video_device *video,
+extern int uvc_query_v4l2_ctrl(struct uvc_video_chain *chain,
 		struct v4l2_queryctrl *v4l2_ctrl);
 
 extern int uvc_ctrl_add_info(struct uvc_control_info *info);
@@ -789,23 +625,23 @@
 extern int uvc_ctrl_resume_device(struct uvc_device *dev);
 extern void uvc_ctrl_init(void);
 
-extern int uvc_ctrl_begin(struct uvc_video_device *video);
-extern int __uvc_ctrl_commit(struct uvc_video_device *video, int rollback);
-static inline int uvc_ctrl_commit(struct uvc_video_device *video)
+extern int uvc_ctrl_begin(struct uvc_video_chain *chain);
+extern int __uvc_ctrl_commit(struct uvc_video_chain *chain, int rollback);
+static inline int uvc_ctrl_commit(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 0);
+	return __uvc_ctrl_commit(chain, 0);
 }
-static inline int uvc_ctrl_rollback(struct uvc_video_device *video)
+static inline int uvc_ctrl_rollback(struct uvc_video_chain *chain)
 {
-	return __uvc_ctrl_commit(video, 1);
+	return __uvc_ctrl_commit(chain, 1);
 }
 
-extern int uvc_ctrl_get(struct uvc_video_device *video,
+extern int uvc_ctrl_get(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
-extern int uvc_ctrl_set(struct uvc_video_device *video,
+extern int uvc_ctrl_set(struct uvc_video_chain *chain,
 		struct v4l2_ext_control *xctrl);
 
-extern int uvc_xu_ctrl_query(struct uvc_video_device *video,
+extern int uvc_xu_ctrl_query(struct uvc_video_chain *chain,
 		struct uvc_xu_control *ctrl, int set);
 
 /* Utility functions */
@@ -817,7 +653,7 @@
 		struct usb_host_interface *alts, __u8 epaddr);
 
 /* Quirks support */
-void uvc_video_decode_isight(struct urb *urb, struct uvc_video_device *video,
+void uvc_video_decode_isight(struct urb *urb, struct uvc_streaming *stream,
 		struct uvc_buffer *buf);
 
 #endif /* __KERNEL__ */
diff -ruaN linux-2.6.31/drivers/mmc/card/Kconfig linux-2.6/drivers/mmc/card/Kconfig
--- linux-2.6.31/drivers/mmc/card/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/card/Kconfig	2011-02-04 12:25:28.000000000 -0800
@@ -50,3 +50,15 @@
 
 	  This driver is only of interest to those developing or
 	  testing a host driver. Most people should say N here.
+
+config SM2683LT
+	tristate "Silicon Motion SM2683LT programming driver"
+	default n
+	help
+	  Say Y here to enable the SM2683LT programming driver support.
+	  This provides a simple device driver which you can use to program
+	  the SD controller's firmware onto the attached NAND.  This
+	  requires a corresponding userspace utility and firmware binaries.
+
+	  The MMC block device driver cannot be used simultaneously with this
+	  driver.
diff -ruaN linux-2.6.31/drivers/mmc/card/Makefile linux-2.6/drivers/mmc/card/Makefile
--- linux-2.6.31/drivers/mmc/card/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/card/Makefile	2011-02-04 12:25:28.000000000 -0800
@@ -12,3 +12,4 @@
 
 obj-$(CONFIG_SDIO_UART)		+= sdio_uart.o
 
+obj-$(CONFIG_SM2683LT)		+= sm2683lt.o
diff -ruaN linux-2.6.31/drivers/mmc/card/sm2683lt.c linux-2.6/drivers/mmc/card/sm2683lt.c
--- linux-2.6.31/drivers/mmc/card/sm2683lt.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mmc/card/sm2683lt.c	2011-03-17 09:29:43.000000000 -0700
@@ -0,0 +1,453 @@
+/*
+ * Programming driver for Silicon Motion SM2683LT
+ *
+ * Provides one ioctl as an SD-command pass-through, and another to control
+ * "card" (SD-controller + attached NAND) power.
+ *
+ * Copyright (c) 2011 LeapFrog Enterprises, Inc.
+ *
+ */
+
+#include <linux/moduleparam.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/kdev_t.h>
+#include <linux/cdev.h>
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/sm2683lt_ioctl.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#define MAX(x, y) (x > y ? x : y)
+
+#define DRIVER_NAME	"sm2683lt"
+
+/*
+ * Use dynamic major number if none specified.
+ */
+static int sm2683lt_major =   0;
+
+module_param(sm2683lt_major, int, S_IRUGO);
+
+struct sm2683lt_dev {
+	struct cdev cdev;
+	dev_t devno;
+
+	int init_level;
+
+	struct mmc_card *card;
+};
+
+static struct sm2683lt_dev sm2683lt_device;
+
+
+/*
+ * Wait for the card to finish the busy state.  Similar to
+ * mmc-block:get_card_status() and mmc-test:mmc_test_wait_busy()
+ * TODO: use mmc_ops:mmc_send_status() instead
+ */
+static int sm2683lt_wait_busy(struct mmc_card *card)
+{
+	int ret;
+	unsigned int busy;
+	struct mmc_command cmd;
+
+	busy = 0;
+	do {
+		memset(&cmd, 0, sizeof(struct mmc_command));
+
+		cmd.opcode = MMC_SEND_STATUS;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+		ret = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (ret)
+			break;
+
+		if (!(busy++ & 0xF) && !(cmd.resp[0] & R1_READY_FOR_DATA)) {
+			printk(KERN_INFO "%s: Warning: %s still busy.\n",
+				mmc_hostname(card->host), DRIVER_NAME);
+		}
+	} while (!(cmd.resp[0] & R1_READY_FOR_DATA));
+
+        return ret;
+}
+
+/*
+ * Complete a data read or write command.  Similar to
+ * mmc-test:mmc_test_buffer_transfer().
+ * TODO: sanity checks for data size ( N * 512 bytes ).
+ */
+static int sm2683lt_data_xfer(struct mmc_card *card, struct mmc_command *cmd, struct sd_command *sd_cmd)
+{
+	int retval = 0;
+
+	struct mmc_request mrq;
+	struct mmc_command stop;
+	struct mmc_data data;
+
+	struct scatterlist sg;
+	void *buf;
+
+	buf = kmalloc(sd_cmd->data_len, GFP_KERNEL);
+	if(buf == NULL)
+		return -ENOMEM;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+	memset(&data, 0, sizeof(struct mmc_data));
+	memset(&stop, 0, sizeof(struct mmc_command));
+
+	mrq.cmd = cmd;
+	mrq.data = &data;
+
+	sg_init_one(&sg, buf, sd_cmd->data_len);
+
+	data.blksz = 512;
+	data.blocks = sd_cmd->data_len / 512;
+
+	/*
+	 * The stop command (CMD12) must be included in the mrq instead of in
+	 * the userspace struct sd_command list.  Without the stop command in
+	 * the mrq, the _MULTIPLE_ command fails with a timeout because the
+	 * sm2683lt_wait_busy() below reads a response[0] of 0x000e0000
+	 * (programming state, not ready) instead of 0x00090000 (transfer
+	 * state, ready).
+	 *
+	 * Note: Our host controller driver, mes_sdhc, automatically issues a
+	 * STOP command along with any _MULTIPLE_ commands, so this command is
+	 * actually ignored on our platform.
+	 */
+
+	if( (sd_cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) ||
+	    (sd_cmd->opcode == MMC_READ_MULTIPLE_BLOCK ) )
+	{
+		mrq.stop = &stop;
+		stop.opcode =  MMC_STOP_TRANSMISSION;
+		stop.arg = 0;
+		stop.flags = MMC_RSP_R1B | MMC_CMD_AC;
+	}
+
+	if(sd_cmd->opcode == MMC_WRITE_BLOCK || sd_cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK)
+	{
+		/* fetch input payload */
+		retval = __copy_from_user(buf, (void __user *)sd_cmd->data.write_data, sd_cmd->data_len);
+		data.flags = MMC_DATA_WRITE;
+		if(retval)
+			goto out;
+	}
+	else
+	{
+		data.flags = MMC_DATA_READ;
+	}
+	data.sg = &sg;
+	data.sg_len = 1;
+
+	mmc_set_data_timeout(mrq.data, card);
+
+	mmc_wait_for_req(card->host, &mrq);
+
+	if (cmd->error)
+	{
+		retval = cmd->error;
+		goto out;
+	}
+	if (data.error)
+	{
+		retval = data.error;
+		goto out;
+	}
+
+	retval = sm2683lt_wait_busy(card);
+	if(retval)
+		goto out;
+
+	if(data.flags == MMC_DATA_READ)
+	{
+		/* deliver output results */
+		retval = __copy_to_user((void __user *)sd_cmd->data.read_data, buf, sd_cmd->data_len);
+	}
+
+out:
+	kfree(buf);
+	return retval;
+}
+
+/*
+ * Generic SD-command parser and dispatcher.
+ */
+static int sd_execute_command(struct mmc_card *card, struct sd_command *sd_cmd)
+{
+	int i, retval;
+	struct mmc_command cmd;
+
+	/* extract user-supplied parameters */
+	cmd.opcode	= sd_cmd->opcode;
+	cmd.arg		= sd_cmd->arg;
+	for(i = 0; i < ARRAY_SIZE(cmd.resp); i++)
+	{
+		cmd.resp[i]	= sd_cmd->resp[i];
+	}
+	cmd.flags	= sd_cmd->flags;
+	cmd.retries	= sd_cmd->retries;
+	cmd.error	= sd_cmd->error;
+
+	/* execute SD command */
+	switch(cmd.opcode) {
+	case MMC_WRITE_BLOCK:
+	case MMC_WRITE_MULTIPLE_BLOCK:
+	case MMC_READ_SINGLE_BLOCK:
+	case MMC_READ_MULTIPLE_BLOCK:
+		retval = sm2683lt_data_xfer(card, &cmd, sd_cmd);
+		break;
+	default:
+		retval = mmc_wait_for_cmd(card->host, &cmd, cmd.retries);
+	}
+	
+	/* propagate status back to user */
+	for(i = 0; i < ARRAY_SIZE(sd_cmd->resp); i++)
+	{
+		sd_cmd->resp[i]	= cmd.resp[i];
+	}
+	sd_cmd->error	= cmd.error;
+
+	return retval;
+}
+
+/*
+ * Handle power toggling.  Make sure to drive SD bus pins low
+ * before/during/after VCC is removed so chip isn't "IO-powered."
+ * We use MMC ios.power_mode to achieve this.  Note that the mes_sdhc host
+ * doesn't provide VCC control, but on Madrid we have a separate gpio for
+ * switching "card" power.
+ */
+static int sd_set_power(struct mmc_card *card, const int set)
+{
+	int retval = 0;
+	struct mmc_ios ios;
+
+	memcpy(&ios, &card->host->ios, sizeof(struct mmc_ios));
+
+	if(set)
+	{
+		/* restore device power / restore bus pins */
+		ios.power_mode = MMC_POWER_UP;
+		card->host->ops->set_ios(card->host, &ios);
+
+		/* restore clock */
+		ios.power_mode = MMC_POWER_ON;
+		card->host->ops->set_ios(card->host, &ios);
+	}
+	else
+	{
+		ios.power_mode = MMC_POWER_OFF;
+
+		/* stop clock, drive bus low, cut device power */
+		card->host->ops->set_ios(card->host, &ios);
+	}
+
+	return retval;
+}
+
+/* TODO: enforce singleton access pattern? */
+static int sm2683lt_open(struct inode *inode, struct file *filp)
+{
+	struct sm2683lt_dev *dev;
+	struct mmc_card *card;
+
+	dev = container_of(inode->i_cdev, struct sm2683lt_dev, cdev);
+	filp->private_data = dev; /* for other methods */
+
+	if(!(card = dev->card))
+		return -ENXIO;
+
+	if(!card->host)
+		return -ENXIO;
+
+	/* maintain exclusive access to host controller */
+	mmc_claim_host(card->host);
+
+	return 0;
+}
+
+static int sm2683lt_release(struct inode *inode, struct file *filp)
+{
+	struct sm2683lt_dev *dev;
+	struct mmc_card *card;
+
+	dev = filp->private_data;
+	card = dev->card;
+	
+	mmc_release_host(card->host);
+
+	return 0;
+}
+
+static int sm2683lt_ioctl(struct inode *inode, struct file *filp,
+                 unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	struct sm2683lt_dev *dev;
+	struct mmc_card *card;
+	struct sd_command sd_cmd;
+
+	dev = filp->private_data;
+	card = dev->card;
+
+	if(_IOC_TYPE(cmd) != SM2683LT_IOC_MAGIC)
+		return -ENOTTY;
+
+	if(_IOC_DIR(cmd) & _IOC_READ)
+		retval = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		retval = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	if(retval)
+		return -EFAULT;
+
+	switch(cmd) {
+
+	  case SM2683LT_SD_COMMAND:
+		retval = __copy_from_user(&sd_cmd, (struct sd_command __user *)arg, sizeof(struct sd_command));
+		if(!retval)
+			retval = sd_execute_command(card, &sd_cmd);
+		if(!retval)
+			retval = __copy_to_user((struct sd_command __user *)arg, &sd_cmd, sizeof(struct sd_command));
+		break;
+
+	  case SM2683LT_SET_POWER:
+		retval = sd_set_power(card, arg);
+		break;
+ 
+	  default:
+		return -ENOTTY;
+	}
+	return retval;
+}
+
+static struct file_operations sm2683lt_fops = {
+	.owner =    THIS_MODULE,
+	.ioctl =    sm2683lt_ioctl,
+	.open =     sm2683lt_open,
+	.release =  sm2683lt_release,
+};
+
+static int sm2683lt_probe(struct mmc_card *card)
+{
+	sm2683lt_device.card = card;
+
+	printk(KERN_INFO "%s, %s, %s, %s\n", DRIVER_NAME,
+	 mmc_hostname(card->host), mmc_card_id(card), mmc_card_name(card));
+
+	return 0;
+}
+
+static void sm2683lt_remove(struct mmc_card *card)
+{
+	sm2683lt_device.card = NULL;
+}
+
+#ifdef CONFIG_PM
+static int sm2683lt_suspend(struct mmc_card *card, pm_message_t state)
+{
+	return 0;
+}
+
+static int sm2683lt_resume(struct mmc_card *card)
+{
+	return 0;
+}
+#else
+#define	sm2683lt_suspend	NULL
+#define sm2683lt_resume		NULL
+#endif
+
+static struct mmc_driver sm2683lt_driver = {
+	.drv		= {
+		.name	= DRIVER_NAME,
+	},
+	.probe		= sm2683lt_probe,
+	.remove		= sm2683lt_remove,
+	.suspend	= sm2683lt_suspend,
+	.resume		= sm2683lt_resume,
+};
+
+static void __exit sd_sm2683lt_exit(void)
+{
+	dev_t devno = MKDEV(sm2683lt_major, 0);
+
+	switch(sm2683lt_device.init_level) {
+	case 2: cdev_del(&sm2683lt_device.cdev);
+	case 1: mmc_unregister_driver(&sm2683lt_driver);
+	case 0: break;
+	}
+
+	unregister_chrdev_region(devno, 1);
+}
+
+static int __init sd_sm2683lt_init(void)
+{
+	int result;
+	dev_t devno = 0;
+
+	sm2683lt_device.init_level = 0;
+	sm2683lt_device.card = NULL;
+
+	/*
+	 * Ask for a dynamic major unless directed otherwise at load time.
+	 */
+	if (sm2683lt_major) {
+		devno = MKDEV(sm2683lt_major, 0);
+		result = register_chrdev_region(devno, 1, "sm2683lt");
+	} else {
+		result = alloc_chrdev_region(&devno, 0, 1, "sm2683lt");
+		sm2683lt_major = MAJOR(devno);
+	}
+	if (result < 0) {
+		printk(KERN_WARNING "sm2683lt: can't get major %d\n", sm2683lt_major);
+		return result;
+	}
+
+	/* Register w/mmc bus */
+	result = mmc_register_driver(&sm2683lt_driver);
+	if (result) {
+		printk(KERN_NOTICE "Error %d registering sm2683lt", result);
+		goto fail;
+	}
+
+	sm2683lt_device.init_level = 1;
+
+        /* Initialize device structure */
+	cdev_init(&sm2683lt_device.cdev, &sm2683lt_fops);
+	sm2683lt_device.cdev.owner = THIS_MODULE;
+	sm2683lt_device.cdev.ops = &sm2683lt_fops;
+	result = cdev_add (&sm2683lt_device.cdev, devno, 1);
+	if (result) {
+		printk(KERN_NOTICE "Error %d adding sm2683lt", result);
+		goto fail;
+	}
+
+	sm2683lt_device.init_level = 2;
+
+	return 0;
+
+  fail:
+	sd_sm2683lt_exit();
+	return result;
+}
+
+module_init(sd_sm2683lt_init);
+module_exit(sd_sm2683lt_exit);
+
+MODULE_DESCRIPTION("SM2683LT SD Controller device driver");
+MODULE_ALIAS("sd:" DRIVER_NAME);
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/mmc/core/core.c linux-2.6/drivers/mmc/core/core.c
--- linux-2.6.31/drivers/mmc/core/core.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/core.c	2011-01-04 14:09:27.000000000 -0800
@@ -48,6 +48,22 @@
 module_param(use_spi_crc, bool, 0);
 
 /*
+ * We normally treat cards as removed during suspend if they are not
+ * known to be on a non-removable bus, to avoid the risk of writing
+ * back data to a different card after resume.  Allow this to be
+ * overridden if necessary.
+ */
+#ifdef CONFIG_MMC_UNSAFE_RESUME
+int mmc_assume_removable;
+#else
+int mmc_assume_removable = 1;
+#endif
+module_param_named(removable, mmc_assume_removable, bool, 0644);
+MODULE_PARM_DESC(
+	removable,
+	"MMC/SD cards are removable and may be removed during suspend");
+
+/*
  * Internal function. Schedule delayed work in the MMC work queue.
  */
 static int mmc_schedule_delayed_work(struct delayed_work *work,
@@ -344,6 +360,101 @@
 EXPORT_SYMBOL(mmc_align_data_size);
 
 /**
+ *	mmc_host_enable - enable a host.
+ *	@host: mmc host to enable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_enable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (host->nesting_cnt++)
+		return 0;
+
+	cancel_delayed_work_sync(&host->disable);
+
+	if (host->enabled)
+		return 0;
+
+	if (host->ops->enable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->enable(host);
+		host->en_dis_recurs = 0;
+
+		if (err) {
+			pr_debug("%s: enable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+	}
+	host->enabled = 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_host_enable);
+
+static int mmc_host_do_disable(struct mmc_host *host, int lazy)
+{
+	if (host->ops->disable) {
+		int err;
+
+		host->en_dis_recurs = 1;
+		err = host->ops->disable(host, lazy);
+		host->en_dis_recurs = 0;
+
+		if (err < 0) {
+			pr_debug("%s: disable error %d\n",
+				 mmc_hostname(host), err);
+			return err;
+		}
+		if (err > 0) {
+			unsigned long delay = msecs_to_jiffies(err);
+
+			mmc_schedule_delayed_work(&host->disable, delay);
+		}
+	}
+	host->enabled = 0;
+	return 0;
+}
+
+/**
+ *	mmc_host_disable - disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_disable(struct mmc_host *host)
+{
+	int err;
+
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	err = mmc_host_do_disable(host, 0);
+	return err;
+}
+EXPORT_SYMBOL(mmc_host_disable);
+
+/**
  *	__mmc_claim_host - exclusively claim a host
  *	@host: mmc host to claim
  *	@abort: whether or not the operation should be aborted
@@ -366,25 +477,111 @@
 	while (1) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		stop = abort ? atomic_read(abort) : 0;
-		if (stop || !host->claimed)
+		if (stop || !host->claimed || host->claimer == current)
 			break;
 		spin_unlock_irqrestore(&host->lock, flags);
 		schedule();
 		spin_lock_irqsave(&host->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
-	if (!stop)
+	if (!stop) {
 		host->claimed = 1;
-	else
+		host->claimer = current;
+		host->claim_cnt += 1;
+	} else
 		wake_up(&host->wq);
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
+	if (!stop)
+		mmc_host_enable(host);
 	return stop;
 }
 
 EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
+ *	mmc_try_claim_host - try exclusively to claim a host
+ *	@host: mmc host to claim
+ *
+ *	Returns %1 if the host is claimed, %0 otherwise.
+ */
+int mmc_try_claim_host(struct mmc_host *host)
+{
+	int claimed_host = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!host->claimed || host->claimer == current) {
+		host->claimed = 1;
+		host->claimer = current;
+		host->claim_cnt += 1;
+		claimed_host = 1;
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+	return claimed_host;
+}
+EXPORT_SYMBOL(mmc_try_claim_host);
+
+static void mmc_do_release_host(struct mmc_host *host)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (--host->claim_cnt) {
+		/* Release for nested claim */
+		spin_unlock_irqrestore(&host->lock, flags);
+	} else {
+		host->claimed = 0;
+		host->claimer = NULL;
+		spin_unlock_irqrestore(&host->lock, flags);
+		wake_up(&host->wq);
+	}
+}
+
+void mmc_host_deeper_disable(struct work_struct *work)
+{
+	struct mmc_host *host =
+		container_of(work, struct mmc_host, disable.work);
+
+	/* If the host is claimed then we do not want to disable it anymore */
+	if (!mmc_try_claim_host(host))
+		return;
+	mmc_host_do_disable(host, 1);
+	mmc_do_release_host(host);
+}
+
+/**
+ *	mmc_host_lazy_disable - lazily disable a host.
+ *	@host: mmc host to disable
+ *
+ *	Hosts that support power saving can use the 'enable' and 'disable'
+ *	methods to exit and enter power saving states. For more information
+ *	see comments for struct mmc_host_ops.
+ */
+int mmc_host_lazy_disable(struct mmc_host *host)
+{
+	if (!(host->caps & MMC_CAP_DISABLE))
+		return 0;
+
+	if (host->en_dis_recurs)
+		return 0;
+
+	if (--host->nesting_cnt)
+		return 0;
+
+	if (!host->enabled)
+		return 0;
+
+	if (host->disable_delay) {
+		mmc_schedule_delayed_work(&host->disable,
+				msecs_to_jiffies(host->disable_delay));
+		return 0;
+	} else
+		return mmc_host_do_disable(host, 1);
+}
+EXPORT_SYMBOL(mmc_host_lazy_disable);
+
+/**
  *	mmc_release_host - release a host
  *	@host: mmc host to release
  *
@@ -393,15 +590,11 @@
  */
 void mmc_release_host(struct mmc_host *host)
 {
-	unsigned long flags;
-
 	WARN_ON(!host->claimed);
 
-	spin_lock_irqsave(&host->lock, flags);
-	host->claimed = 0;
-	spin_unlock_irqrestore(&host->lock, flags);
+	mmc_host_lazy_disable(host);
 
-	wake_up(&host->wq);
+	mmc_do_release_host(host);
 }
 
 EXPORT_SYMBOL(mmc_release_host);
@@ -687,7 +880,13 @@
  */
 static void mmc_power_up(struct mmc_host *host)
 {
-	int bit = fls(host->ocr_avail) - 1;
+	int bit;
+
+	/* If ocr is set, we use it */
+	if (host->ocr)
+		bit = ffs(host->ocr) - 1;
+	else
+		bit = fls(host->ocr_avail) - 1;
 
 	host->ios.vdd = bit;
 	if (mmc_host_is_spi(host)) {
@@ -856,7 +1055,7 @@
 {
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
-	u32 ocr;
+	u32 ocr = 0;
 	int err;
 
 	mmc_bus_get(host);
@@ -947,6 +1146,8 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 #endif
 
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
@@ -958,6 +1159,8 @@
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
 		mmc_release_host(host);
+		mmc_bus_put(host);
+		return;
 	}
 	mmc_bus_put(host);
 
@@ -966,6 +1169,80 @@
 	mmc_power_off(host);
 }
 
+void mmc_power_save_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	if (host->bus_ops->power_save)
+		host->bus_ops->power_save(host);
+
+	mmc_bus_put(host);
+
+	mmc_power_off(host);
+}
+EXPORT_SYMBOL(mmc_power_save_host);
+
+void mmc_power_restore_host(struct mmc_host *host)
+{
+	mmc_bus_get(host);
+
+	if (!host->bus_ops || host->bus_dead || !host->bus_ops->power_restore) {
+		mmc_bus_put(host);
+		return;
+	}
+
+	mmc_power_up(host);
+	host->bus_ops->power_restore(host);
+
+	mmc_bus_put(host);
+}
+EXPORT_SYMBOL(mmc_power_restore_host);
+
+int mmc_card_awake(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->awake(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_awake);
+
+int mmc_card_sleep(struct mmc_host *host)
+{
+	int err = -ENOSYS;
+
+	mmc_bus_get(host);
+
+	if (host->bus_ops && !host->bus_dead && host->bus_ops->awake)
+		err = host->bus_ops->sleep(host);
+
+	mmc_bus_put(host);
+
+	return err;
+}
+EXPORT_SYMBOL(mmc_card_sleep);
+
+int mmc_card_can_sleep(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+
+	if (card && mmc_card_mmc(card) && card->ext_csd.rev >= 3)
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL(mmc_card_can_sleep);
+
 #ifdef CONFIG_PM
 
 /**
@@ -975,27 +1252,36 @@
  */
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
+	int err = 0;
+
+	if (host->caps & MMC_CAP_DISABLE)
+		cancel_delayed_work(&host->disable);
 	cancel_delayed_work(&host->detect);
 	mmc_flush_scheduled_work();
 
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		if (host->bus_ops->suspend)
-			host->bus_ops->suspend(host);
-		if (!host->bus_ops->resume) {
+			err = host->bus_ops->suspend(host);
+		if (err == -ENOSYS || !host->bus_ops->resume) {
+			/*
+			 * We simply "remove" the card in this case.
+			 * It will be redetected on resume.
+			 */
 			if (host->bus_ops->remove)
 				host->bus_ops->remove(host);
-
 			mmc_claim_host(host);
 			mmc_detach_bus(host);
 			mmc_release_host(host);
+			err = 0;
 		}
 	}
 	mmc_bus_put(host);
 
-	mmc_power_off(host);
+	if (!err)
+		mmc_power_off(host);
 
-	return 0;
+	return err;
 }
 
 EXPORT_SYMBOL(mmc_suspend_host);
@@ -1006,12 +1292,26 @@
  */
 int mmc_resume_host(struct mmc_host *host)
 {
+	int err = 0;
+
 	mmc_bus_get(host);
 	if (host->bus_ops && !host->bus_dead) {
 		mmc_power_up(host);
 		mmc_select_voltage(host, host->ocr);
 		BUG_ON(!host->bus_ops->resume);
-		host->bus_ops->resume(host);
+		err = host->bus_ops->resume(host);
+		if (err) {
+			printk(KERN_WARNING "%s: error %d during resume "
+					    "(card was removed?)\n",
+					    mmc_hostname(host), err);
+			if (host->bus_ops->remove)
+				host->bus_ops->remove(host);
+			mmc_claim_host(host);
+			mmc_detach_bus(host);
+			mmc_release_host(host);
+			/* no need to bother upper layers */
+			err = 0;
+		}
 	}
 	mmc_bus_put(host);
 
@@ -1021,7 +1321,7 @@
 	 */
 	mmc_detect_change(host, 1);
 
-	return 0;
+	return err;
 }
 
 EXPORT_SYMBOL(mmc_resume_host);
diff -ruaN linux-2.6.31/drivers/mmc/core/core.h linux-2.6/drivers/mmc/core/core.h
--- linux-2.6.31/drivers/mmc/core/core.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/core.h	2011-01-04 14:03:00.000000000 -0800
@@ -16,10 +16,14 @@
 #define MMC_CMD_RETRIES        3
 
 struct mmc_bus_ops {
+	int (*awake)(struct mmc_host *);
+	int (*sleep)(struct mmc_host *);
 	void (*remove)(struct mmc_host *);
 	void (*detect)(struct mmc_host *);
-	void (*suspend)(struct mmc_host *);
-	void (*resume)(struct mmc_host *);
+	int (*suspend)(struct mmc_host *);
+	int (*resume)(struct mmc_host *);
+	void (*power_save)(struct mmc_host *);
+	void (*power_restore)(struct mmc_host *);
 };
 
 void mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops);
@@ -50,7 +54,9 @@
 int mmc_attach_sd(struct mmc_host *host, u32 ocr);
 int mmc_attach_sdio(struct mmc_host *host, u32 ocr);
 
+/* Module parameters */
 extern int use_spi_crc;
+extern int mmc_assume_removable;
 
 /* Debugfs information for hosts and cards */
 void mmc_add_host_debugfs(struct mmc_host *host);
diff -ruaN linux-2.6.31/drivers/mmc/core/debugfs.c linux-2.6/drivers/mmc/core/debugfs.c
--- linux-2.6.31/drivers/mmc/core/debugfs.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/debugfs.c	2011-01-04 14:03:00.000000000 -0800
@@ -240,7 +240,7 @@
 	return 0;
 }
 
-static struct file_operations mmc_dbg_ext_csd_fops = {
+static const struct file_operations mmc_dbg_ext_csd_fops = {
 	.open		= mmc_ext_csd_open,
 	.read		= mmc_ext_csd_read,
 	.release	= mmc_ext_csd_release,
diff -ruaN linux-2.6.31/drivers/mmc/core/host.c linux-2.6/drivers/mmc/core/host.c
--- linux-2.6.31/drivers/mmc/core/host.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/host.c	2011-01-04 14:03:00.000000000 -0800
@@ -83,6 +83,7 @@
 	spin_lock_init(&host->lock);
 	init_waitqueue_head(&host->wq);
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
+	INIT_DELAYED_WORK_DEFERRABLE(&host->disable, mmc_host_deeper_disable);
 
 	/*
 	 * By default, hosts do not support SGIO or large requests.
diff -ruaN linux-2.6.31/drivers/mmc/core/host.h linux-2.6/drivers/mmc/core/host.h
--- linux-2.6.31/drivers/mmc/core/host.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/host.h	2011-01-04 14:03:00.000000000 -0800
@@ -14,5 +14,7 @@
 int mmc_register_host_class(void);
 void mmc_unregister_host_class(void);
 
+void mmc_host_deeper_disable(struct work_struct *work);
+
 #endif
 
diff -ruaN linux-2.6.31/drivers/mmc/core/mmc.c linux-2.6/drivers/mmc/core/mmc.c
--- linux-2.6.31/drivers/mmc/core/mmc.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/mmc.c	2011-01-04 14:03:00.000000000 -0800
@@ -160,7 +160,6 @@
 {
 	int err;
 	u8 *ext_csd;
-	unsigned int ext_csd_struct;
 
 	BUG_ON(!card);
 
@@ -180,11 +179,11 @@
 
 	err = mmc_send_ext_csd(card, ext_csd);
 	if (err) {
-		/*
-		 * We all hosts that cannot perform the command
-		 * to fail more gracefully
-		 */
-		if (err != -EINVAL)
+		/* If the host or the card can't do the switch,
+		 * fail more gracefully. */
+		if ((err != -EINVAL)
+		 && (err != -ENOSYS)
+		 && (err != -EFAULT))
 			goto out;
 
 		/*
@@ -207,16 +206,16 @@
 		goto out;
 	}
 
-	ext_csd_struct = ext_csd[EXT_CSD_REV];
-	if (ext_csd_struct > 3) {
+	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
+	if (card->ext_csd.rev > 5) {
 		printk(KERN_ERR "%s: unrecognised EXT_CSD structure "
 			"version %d\n", mmc_hostname(card->host),
-			ext_csd_struct);
+			card->ext_csd.rev);
 		err = -EINVAL;
 		goto out;
 	}
 
-	if (ext_csd_struct >= 2) {
+	if (card->ext_csd.rev >= 2) {
 		card->ext_csd.sectors =
 			ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
 			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
@@ -241,6 +240,15 @@
 		goto out;
 	}
 
+	if (card->ext_csd.rev >= 3) {
+		u8 sa_shift = ext_csd[EXT_CSD_S_A_TIMEOUT];
+
+		/* Sleep / awake timeout in 100ns units */
+		if (sa_shift > 0 && sa_shift <= 0x17)
+			card->ext_csd.sa_timeout =
+					1 << ext_csd[EXT_CSD_S_A_TIMEOUT];
+	}
+
 out:
 	kfree(ext_csd);
 
@@ -276,7 +284,7 @@
 	.attrs = mmc_std_attrs,
 };
 
-static struct attribute_group *mmc_attr_groups[] = {
+static const struct attribute_group *mmc_attr_groups[] = {
 	&mmc_std_attr_group,
 	NULL,
 };
@@ -408,12 +416,17 @@
 		(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 			EXT_CSD_HS_TIMING, 1);
-		if (err)
+		if (err && err != -EBADMSG)
 			goto free_card;
 
-		mmc_card_set_highspeed(card);
-
-		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+		if (err) {
+			printk(KERN_WARNING "%s: switch to highspeed failed\n",
+			       mmc_hostname(card->host));
+			err = 0;
+		} else {
+			mmc_card_set_highspeed(card);
+			mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+		}
 	}
 
 	/*
@@ -448,10 +461,17 @@
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				 EXT_CSD_BUS_WIDTH, ext_csd_bit);
 
-		if (err)
+		if (err && err != -EBADMSG)
 			goto free_card;
 
-		mmc_set_bus_width(card->host, bus_width);
+		if (err) {
+			printk(KERN_WARNING "%s: switch to bus width %d "
+			       "failed\n", mmc_hostname(card->host),
+			       1 << bus_width);
+			err = 0;
+		} else {
+			mmc_set_bus_width(card->host, bus_width);
+		}
 	}
 
 	if (!oldcard)
@@ -507,12 +527,10 @@
 	}
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
 /*
  * Suspend callback from host.
  */
-static void mmc_suspend(struct mmc_host *host)
+static int mmc_suspend(struct mmc_host *host)
 {
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -522,6 +540,8 @@
 		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
+
+	return 0;
 }
 
 /*
@@ -530,7 +550,7 @@
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static void mmc_resume(struct mmc_host *host)
+static int mmc_resume(struct mmc_host *host)
 {
 	int err;
 
@@ -541,30 +561,78 @@
 	err = mmc_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
-	if (err) {
-		mmc_remove(host);
+	return err;
+}
 
-		mmc_claim_host(host);
-		mmc_detach_bus(host);
-		mmc_release_host(host);
+static void mmc_power_restore(struct mmc_host *host)
+{
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_claim_host(host);
+	mmc_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+}
+
+static int mmc_sleep(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+	int err = -ENOSYS;
+
+	if (card && card->ext_csd.rev >= 3) {
+		err = mmc_card_sleepawake(host, 1);
+		if (err < 0)
+			pr_debug("%s: Error %d while putting card into sleep",
+				 mmc_hostname(host), err);
 	}
 
+	return err;
 }
 
-#else
+static int mmc_awake(struct mmc_host *host)
+{
+	struct mmc_card *card = host->card;
+	int err = -ENOSYS;
 
-#define mmc_suspend NULL
-#define mmc_resume NULL
+	if (card && card->ext_csd.rev >= 3) {
+		err = mmc_card_sleepawake(host, 0);
+		if (err < 0)
+			pr_debug("%s: Error %d while awaking sleeping card",
+				 mmc_hostname(host), err);
+	}
 
-#endif
+	return err;
+}
 
 static const struct mmc_bus_ops mmc_ops = {
+	.awake = mmc_awake,
+	.sleep = mmc_sleep,
+	.remove = mmc_remove,
+	.detect = mmc_detect,
+	.suspend = NULL,
+	.resume = NULL,
+	.power_restore = mmc_power_restore,
+};
+
+static const struct mmc_bus_ops mmc_ops_unsafe = {
+	.awake = mmc_awake,
+	.sleep = mmc_sleep,
 	.remove = mmc_remove,
 	.detect = mmc_detect,
 	.suspend = mmc_suspend,
 	.resume = mmc_resume,
+	.power_restore = mmc_power_restore,
 };
 
+static void mmc_attach_bus_ops(struct mmc_host *host)
+{
+	const struct mmc_bus_ops *bus_ops;
+
+	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
+		bus_ops = &mmc_ops_unsafe;
+	else
+		bus_ops = &mmc_ops;
+	mmc_attach_bus(host, bus_ops);
+}
+
 /*
  * Starting point for MMC card init.
  */
@@ -575,7 +643,7 @@
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_ops);
+	mmc_attach_bus_ops(host);
 
 	/*
 	 * We need to get OCR a different way for SPI.
diff -ruaN linux-2.6.31/drivers/mmc/core/mmc_ops.c linux-2.6/drivers/mmc/core/mmc_ops.c
--- linux-2.6.31/drivers/mmc/core/mmc_ops.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/mmc_ops.c	2011-01-04 14:03:00.000000000 -0800
@@ -57,6 +57,42 @@
 	return _mmc_select_card(host, NULL);
 }
 
+int mmc_card_sleepawake(struct mmc_host *host, int sleep)
+{
+	struct mmc_command cmd;
+	struct mmc_card *card = host->card;
+	int err;
+
+	if (sleep)
+		mmc_deselect_cards(host);
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SLEEP_AWAKE;
+	cmd.arg = card->rca << 16;
+	if (sleep)
+		cmd.arg |= 1 << 15;
+
+	cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+	err = mmc_wait_for_cmd(host, &cmd, 0);
+	if (err)
+		return err;
+
+	/*
+	 * If the host does not wait while the card signals busy, then we will
+	 * will have to wait the sleep/awake timeout.  Note, we cannot use the
+	 * SEND_STATUS command to poll the status because that command (and most
+	 * others) is invalid while the card sleeps.
+	 */
+	if (!(host->caps & MMC_CAP_WAIT_WHILE_BUSY))
+		mmc_delay(DIV_ROUND_UP(card->ext_csd.sa_timeout, 10000));
+
+	if (!sleep)
+		err = mmc_select_card(card);
+
+	return err;
+}
+
 int mmc_go_idle(struct mmc_host *host)
 {
 	int err;
@@ -354,6 +390,7 @@
 {
 	int err;
 	struct mmc_command cmd;
+	u32 status;
 
 	BUG_ON(!card);
 	BUG_ON(!card->host);
@@ -371,6 +408,28 @@
 	if (err)
 		return err;
 
+	/* Must check status to be sure of no errors */
+	do {
+		err = mmc_send_status(card, &status);
+		if (err)
+			return err;
+		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+			break;
+		if (mmc_host_is_spi(card->host))
+			break;
+	} while (R1_CURRENT_STATE(status) == 7);
+
+	if (mmc_host_is_spi(card->host)) {
+		if (status & R1_SPI_ILLEGAL_COMMAND)
+			return -EBADMSG;
+	} else {
+		if (status & 0xFDFFA000)
+			printk(KERN_WARNING "%s: unexpected status %#x after "
+			       "switch", mmc_hostname(card->host), status);
+		if (status & R1_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+
 	return 0;
 }
 
diff -ruaN linux-2.6.31/drivers/mmc/core/mmc_ops.h linux-2.6/drivers/mmc/core/mmc_ops.h
--- linux-2.6.31/drivers/mmc/core/mmc_ops.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/mmc_ops.h	2011-01-04 14:03:00.000000000 -0800
@@ -25,6 +25,7 @@
 int mmc_send_cid(struct mmc_host *host, u32 *cid);
 int mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp);
 int mmc_spi_set_crc(struct mmc_host *host, int use_crc);
+int mmc_card_sleepawake(struct mmc_host *host, int sleep);
 
 #endif
 
diff -ruaN linux-2.6.31/drivers/mmc/core/sd.c linux-2.6/drivers/mmc/core/sd.c
--- linux-2.6.31/drivers/mmc/core/sd.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/sd.c	2011-01-04 14:03:00.000000000 -0800
@@ -210,11 +210,11 @@
 
 	err = mmc_sd_switch(card, 0, 0, 1, status);
 	if (err) {
-		/*
-		 * We all hosts that cannot perform the command
-		 * to fail more gracefully
-		 */
-		if (err != -EINVAL)
+		/* If the host or the card can't do the switch,
+		 * fail more gracefully. */
+		if ((err != -EINVAL)
+		 && (err != -ENOSYS)
+		 && (err != -EFAULT))
 			goto out;
 
 		printk(KERN_WARNING "%s: problem reading switch "
@@ -314,7 +314,7 @@
 	.attrs = sd_std_attrs,
 };
 
-static struct attribute_group *sd_attr_groups[] = {
+static const struct attribute_group *sd_attr_groups[] = {
 	&sd_std_attr_group,
 	NULL,
 };
@@ -561,12 +561,10 @@
 	}
 }
 
-#ifdef CONFIG_MMC_UNSAFE_RESUME
-
 /*
  * Suspend callback from host.
  */
-static void mmc_sd_suspend(struct mmc_host *host)
+static int mmc_sd_suspend(struct mmc_host *host)
 {
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -576,6 +574,8 @@
 		mmc_deselect_cards(host);
 	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_release_host(host);
+
+	return 0;
 }
 
 /*
@@ -584,7 +584,7 @@
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static void mmc_sd_resume(struct mmc_host *host)
+static int mmc_sd_resume(struct mmc_host *host)
 {
 	int err;
 
@@ -595,30 +595,44 @@
 	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
-	if (err) {
-		mmc_sd_remove(host);
-
-		mmc_claim_host(host);
-		mmc_detach_bus(host);
-		mmc_release_host(host);
-	}
-
+	return err;
 }
 
-#else
-
-#define mmc_sd_suspend NULL
-#define mmc_sd_resume NULL
-
-#endif
+static void mmc_sd_power_restore(struct mmc_host *host)
+{
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	mmc_claim_host(host);
+	mmc_sd_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+}
 
 static const struct mmc_bus_ops mmc_sd_ops = {
 	.remove = mmc_sd_remove,
 	.detect = mmc_sd_detect,
+	.suspend = NULL,
+	.resume = NULL,
+	.power_restore = mmc_sd_power_restore,
+};
+
+static const struct mmc_bus_ops mmc_sd_ops_unsafe = {
+	.remove = mmc_sd_remove,
+	.detect = mmc_sd_detect,
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
+	.power_restore = mmc_sd_power_restore,
 };
 
+static void mmc_sd_attach_bus_ops(struct mmc_host *host)
+{
+	const struct mmc_bus_ops *bus_ops;
+
+	if (host->caps & MMC_CAP_NONREMOVABLE || !mmc_assume_removable)
+		bus_ops = &mmc_sd_ops_unsafe;
+	else
+		bus_ops = &mmc_sd_ops;
+	mmc_attach_bus(host, bus_ops);
+}
+
 /*
  * Starting point for SD card init.
  */
@@ -629,7 +643,7 @@
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	mmc_attach_bus(host, &mmc_sd_ops);
+	mmc_sd_attach_bus_ops(host);
 
 	/*
 	 * We need to get OCR a different way for SPI.
diff -ruaN linux-2.6.31/drivers/mmc/core/sdio_bus.c linux-2.6/drivers/mmc/core/sdio_bus.c
--- linux-2.6.31/drivers/mmc/core/sdio_bus.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/sdio_bus.c	2011-01-04 14:03:00.000000000 -0800
@@ -20,9 +20,6 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
-#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
-#define to_sdio_driver(d)      container_of(d, struct sdio_driver, drv)
-
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\
@@ -251,12 +248,15 @@
 /*
  * Unregister a SDIO function with the driver model, and
  * (eventually) free it.
+ * This function can be called through error paths where sdio_add_func() was
+ * never executed (because a failure occurred at an earlier point).
  */
 void sdio_remove_func(struct sdio_func *func)
 {
-	if (sdio_func_present(func))
-		device_del(&func->dev);
+	if (!sdio_func_present(func))
+		return;
 
+	device_del(&func->dev);
 	put_device(&func->dev);
 }
 
diff -ruaN linux-2.6.31/drivers/mmc/core/sdio.c linux-2.6/drivers/mmc/core/sdio.c
--- linux-2.6.31/drivers/mmc/core/sdio.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/sdio.c	2011-01-04 14:03:00.000000000 -0800
@@ -165,6 +165,29 @@
 }
 
 /*
+ * If desired, disconnect the pull-up resistor on CD/DAT[3] (pin 1)
+ * of the card. This may be required on certain setups of boards,
+ * controllers and embedded sdio device which do not need the card's
+ * pull-up. As a result, card detection is disabled and power is saved.
+ */
+static int sdio_disable_cd(struct mmc_card *card)
+{
+	int ret;
+	u8 ctrl;
+
+	if (!card->cccr.disable_cd)
+		return 0;
+
+	ret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);
+	if (ret)
+		return ret;
+
+	ctrl |= SDIO_BUS_CD_DISABLE;
+
+	return mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
+}
+
+/*
  * Test if the card supports high-speed mode and, if so, switch to it.
  */
 static int sdio_enable_hs(struct mmc_card *card)
@@ -195,6 +218,135 @@
 }
 
 /*
+ * Handle the detection and initialisation of a card.
+ *
+ * In the case of a resume, "oldcard" will contain the card
+ * we're trying to reinitialise.
+ */
+static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
+			      struct mmc_card *oldcard)
+{
+	struct mmc_card *card;
+	int err;
+
+	BUG_ON(!host);
+	WARN_ON(!host->claimed);
+
+	/*
+	 * Inform the card of the voltage
+	 */
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+			goto err;
+	}
+
+	/*
+	 * Allocate card structure.
+	 */
+	card = mmc_alloc_card(host, NULL);
+	if (IS_ERR(card)) {
+		err = PTR_ERR(card);
+		goto err;
+	}
+
+	card->type = MMC_TYPE_SDIO;
+
+	/*
+	 * For native busses:  set card RCA and quit open drain mode.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto remove;
+
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+
+	/*
+	 * Select card, as all following commands rely on that.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto remove;
+	}
+
+	/*
+	 * Read the common registers.
+	 */
+	err = sdio_read_cccr(card);
+	if (err)
+		goto remove;
+
+	/*
+	 * Read the common CIS tuples.
+	 */
+	err = sdio_read_common_cis(card);
+	if (err)
+		goto remove;
+
+	if (oldcard) {
+		int same = (card->cis.vendor == oldcard->cis.vendor &&
+			    card->cis.device == oldcard->cis.device);
+		mmc_remove_card(card);
+		if (!same) {
+			err = -ENOENT;
+			goto err;
+		}
+		card = oldcard;
+		return 0;
+	}
+
+	/*
+	 * Switch to high-speed (if supported).
+	 */
+	err = sdio_enable_hs(card);
+	if (err)
+		goto remove;
+
+	/*
+	 * Change to the card's maximum speed.
+	 */
+	if (mmc_card_highspeed(card)) {
+		/*
+		 * The SDIO specification doesn't mention how
+		 * the CIS transfer speed register relates to
+		 * high-speed, but it seems that 50 MHz is
+		 * mandatory.
+		 */
+		mmc_set_clock(host, 50000000);
+	} else {
+		mmc_set_clock(host, card->cis.max_dtr);
+	}
+
+	/*
+	 * Switch to wider bus (if supported).
+	 */
+	err = sdio_enable_wide(card);
+	if (err)
+		goto remove;
+
+	if (!oldcard)
+		host->card = card;
+	return 0;
+
+remove:
+	if (!oldcard)
+		mmc_remove_card(card);
+
+err:
+	return err;
+}
+
+/*
  * Host is being removed. Free up the current card.
  */
 static void mmc_sdio_remove(struct mmc_host *host)
@@ -243,10 +395,77 @@
 	}
 }
 
+/*
+ * SDIO suspend.  We need to suspend all functions separately.
+ * Therefore all registered functions must have drivers with suspend
+ * and resume methods.  Failing that we simply remove the whole card.
+ */
+static int mmc_sdio_suspend(struct mmc_host *host)
+{
+	int i, err = 0;
+
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			if (!pmops || !pmops->suspend || !pmops->resume) {
+				/* force removal of entire card in that case */
+				err = -ENOSYS;
+			} else
+				err = pmops->suspend(&func->dev);
+			if (err)
+				break;
+		}
+	}
+	while (err && --i >= 0) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			pmops->resume(&func->dev);
+		}
+	}
+
+	return err;
+}
+
+static int mmc_sdio_resume(struct mmc_host *host)
+{
+	int i, err;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	/* Basic card reinitialization. */
+	mmc_claim_host(host);
+	err = mmc_sdio_init_card(host, host->ocr, host->card);
+	mmc_release_host(host);
+
+	/*
+	 * If the card looked to be the same as before suspending, then
+	 * we proceed to resume all card functions.  If one of them returns
+	 * an error then we simply return that error to the core and the
+	 * card will be redetected as new.  It is the responsibility of
+	 * the function driver to perform further tests with the extra
+	 * knowledge it has of the card to confirm the card is indeed the
+	 * same as before suspending (same MAC address for network cards,
+	 * etc.) and return an error otherwise.
+	 */
+	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			err = pmops->resume(&func->dev);
+		}
+	}
+
+	return err;
+}
 
 static const struct mmc_bus_ops mmc_sdio_ops = {
 	.remove = mmc_sdio_remove,
 	.detect = mmc_sdio_detect,
+	.suspend = mmc_sdio_suspend,
+	.resume = mmc_sdio_resume,
 };
 
 
@@ -275,13 +494,6 @@
 		ocr &= ~0x7F;
 	}
 
-	if (ocr & MMC_VDD_165_195) {
-		printk(KERN_WARNING "%s: SDIO card claims to support the "
-		       "incompletely defined 'low voltage range'. This "
-		       "will be ignored.\n", mmc_hostname(host));
-		ocr &= ~MMC_VDD_165_195;
-	}
-
 	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*
@@ -293,108 +505,31 @@
 	}
 
 	/*
-	 * Inform the card of the voltage
+	 * Detect and init the card.
 	 */
-	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	err = mmc_sdio_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
-
-	/*
-	 * For SPI, enable CRC as appropriate.
-	 */
-	if (mmc_host_is_spi(host)) {
-		err = mmc_spi_set_crc(host, use_spi_crc);
-		if (err)
-			goto err;
-	}
+	card = host->card;
 
 	/*
 	 * The number of functions on the card is encoded inside
 	 * the ocr.
 	 */
 	funcs = (ocr & 0x70000000) >> 28;
+	card->sdio_funcs = 0;
 
 	/*
-	 * Allocate card structure.
-	 */
-	card = mmc_alloc_card(host, NULL);
-	if (IS_ERR(card)) {
-		err = PTR_ERR(card);
-		goto err;
-	}
-
-	card->type = MMC_TYPE_SDIO;
-	card->sdio_funcs = funcs;
-
-	host->card = card;
-
-	/*
-	 * For native busses:  set card RCA and quit open drain mode.
-	 */
-	if (!mmc_host_is_spi(host)) {
-		err = mmc_send_relative_addr(host, &card->rca);
-		if (err)
-			goto remove;
-
-		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
-	}
-
-	/*
-	 * Select card, as all following commands rely on that.
+	 * If needed, disconnect card detection pull-up resistor.
 	 */
-	if (!mmc_host_is_spi(host)) {
-		err = mmc_select_card(card);
-		if (err)
-			goto remove;
-	}
-
-	/*
-	 * Read the common registers.
-	 */
-	err = sdio_read_cccr(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Read the common CIS tuples.
-	 */
-	err = sdio_read_common_cis(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Switch to high-speed (if supported).
-	 */
-	err = sdio_enable_hs(card);
-	if (err)
-		goto remove;
-
-	/*
-	 * Change to the card's maximum speed.
-	 */
-	if (mmc_card_highspeed(card)) {
-		/*
-		 * The SDIO specification doesn't mention how
-		 * the CIS transfer speed register relates to
-		 * high-speed, but it seems that 50 MHz is
-		 * mandatory.
-		 */
-		mmc_set_clock(host, 50000000);
-	} else {
-		mmc_set_clock(host, card->cis.max_dtr);
-	}
-
-	/*
-	 * Switch to wider bus (if supported).
-	 */
-	err = sdio_enable_wide(card);
+	err = sdio_disable_cd(card);
 	if (err)
 		goto remove;
 
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
-	for (i = 0;i < funcs;i++) {
+	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
 		err = sdio_init_func(host->card, i + 1);
 		if (err)
 			goto remove;
diff -ruaN linux-2.6.31/drivers/mmc/core/sdio_cis.c linux-2.6/drivers/mmc/core/sdio_cis.c
--- linux-2.6.31/drivers/mmc/core/sdio_cis.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/sdio_cis.c	2011-01-04 14:03:00.000000000 -0800
@@ -29,6 +29,8 @@
 	unsigned i, nr_strings;
 	char **buffer, *string;
 
+	/* Find all null-terminated (including zero length) strings in
+	   the TPLLV1_INFO field. Trailing garbage is ignored. */
 	buf += 2;
 	size -= 2;
 
@@ -39,11 +41,8 @@
 		if (buf[i] == 0)
 			nr_strings++;
 	}
-
-	if (buf[i-1] != '\0') {
-		printk(KERN_WARNING "SDIO: ignoring broken CISTPL_VERS_1\n");
+	if (nr_strings == 0)
 		return 0;
-	}
 
 	size = i;
 
@@ -98,10 +97,56 @@
 static const unsigned int speed_unit[8] =
 	{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };
 
-static int cistpl_funce_common(struct mmc_card *card,
+
+typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
+			   const unsigned char *, unsigned);
+
+struct cis_tpl {
+	unsigned char code;
+	unsigned char min_size;
+	tpl_parse_t *parse;
+};
+
+static int cis_tpl_parse(struct mmc_card *card, struct sdio_func *func,
+			 const char *tpl_descr,
+			 const struct cis_tpl *tpl, int tpl_count,
+			 unsigned char code,
+			 const unsigned char *buf, unsigned size)
+{
+	int i, ret;
+
+	/* look for a matching code in the table */
+	for (i = 0; i < tpl_count; i++, tpl++) {
+		if (tpl->code == code)
+			break;
+	}
+	if (i < tpl_count) {
+		if (size >= tpl->min_size) {
+			if (tpl->parse)
+				ret = tpl->parse(card, func, buf, size);
+			else
+				ret = -EILSEQ;	/* known tuple, not parsed */
+		} else {
+			/* invalid tuple */
+			ret = -EINVAL;
+		}
+		if (ret && ret != -EILSEQ && ret != -ENOENT) {
+			printk(KERN_ERR "%s: bad %s tuple 0x%02x (%u bytes)\n",
+			       mmc_hostname(card->host), tpl_descr, code, size);
+		}
+	} else {
+		/* unknown tuple */
+		ret = -ENOENT;
+	}
+
+	return ret;
+}
+
+static int cistpl_funce_common(struct mmc_card *card, struct sdio_func *func,
 			       const unsigned char *buf, unsigned size)
 {
-	if (size < 0x04 || buf[0] != 0)
+	/* Only valid for the common CIS (function 0) */
+	if (func)
 		return -EINVAL;
 
 	/* TPLFE_FN0_BLK_SIZE */
@@ -114,16 +159,24 @@
 	return 0;
 }
 
-static int cistpl_funce_func(struct sdio_func *func,
+static int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,
 			     const unsigned char *buf, unsigned size)
 {
 	unsigned vsn;
 	unsigned min_size;
 
+	/* Only valid for the individual function's CIS (1-7) */
+	if (!func)
+		return -EINVAL;
+
+	/*
+	 * This tuple has a different length depending on the SDIO spec
+	 * version.
+	 */
 	vsn = func->card->cccr.sdio_vsn;
 	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
 
-	if (size < min_size || buf[0] != 1)
+	if (size < min_size)
 		return -EINVAL;
 
 	/* TPLFE_MAX_BLK_SIZE */
@@ -138,40 +191,32 @@
 	return 0;
 }
 
+/*
+ * Known TPLFE_TYPEs table for CISTPL_FUNCE tuples.
+ *
+ * Note that, unlike PCMCIA, CISTPL_FUNCE tuples are not parsed depending
+ * on the TPLFID_FUNCTION value of the previous CISTPL_FUNCID as on SDIO
+ * TPLFID_FUNCTION is always hardcoded to 0x0C.
+ */
+static const struct cis_tpl cis_tpl_funce_list[] = {
+	{	0x00,	4,	cistpl_funce_common		},
+	{	0x01,	0,	cistpl_funce_func		},
+	{	0x04,	1+1+6,	/* CISTPL_FUNCE_LAN_NODE_ID */	},
+};
+
 static int cistpl_funce(struct mmc_card *card, struct sdio_func *func,
 			const unsigned char *buf, unsigned size)
 {
-	int ret;
-
-	/*
-	 * There should be two versions of the CISTPL_FUNCE tuple,
-	 * one for the common CIS (function 0) and a version used by
-	 * the individual function's CIS (1-7). Yet, the later has a
-	 * different length depending on the SDIO spec version.
-	 */
-	if (func)
-		ret = cistpl_funce_func(func, buf, size);
-	else
-		ret = cistpl_funce_common(card, buf, size);
-
-	if (ret) {
-		printk(KERN_ERR "%s: bad CISTPL_FUNCE size %u "
-		       "type %u\n", mmc_hostname(card->host), size, buf[0]);
-		return ret;
-	}
+	if (size < 1)
+		return -EINVAL;
 
-	return 0;
+	return cis_tpl_parse(card, func, "CISTPL_FUNCE",
+			     cis_tpl_funce_list,
+			     ARRAY_SIZE(cis_tpl_funce_list),
+			     buf[0], buf, size);
 }
 
-typedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,
-			   const unsigned char *, unsigned);
-
-struct cis_tpl {
-	unsigned char code;
-	unsigned char min_size;
-	tpl_parse_t *parse;
-};
-
+/* Known TPL_CODEs table for CIS tuples */
 static const struct cis_tpl cis_tpl_list[] = {
 	{	0x15,	3,	cistpl_vers_1		},
 	{	0x20,	4,	cistpl_manfid		},
@@ -250,31 +295,37 @@
 			break;
 		}
 
-		for (i = 0; i < ARRAY_SIZE(cis_tpl_list); i++)
-			if (cis_tpl_list[i].code == tpl_code)
-				break;
-		if (i >= ARRAY_SIZE(cis_tpl_list)) {
-			/* this tuple is unknown to the core */
+		/* Try to parse the CIS tuple */
+		ret = cis_tpl_parse(card, func, "CIS",
+				    cis_tpl_list, ARRAY_SIZE(cis_tpl_list),
+				    tpl_code, this->data, tpl_link);
+		if (ret == -EILSEQ || ret == -ENOENT) {
+			/*
+			 * The tuple is unknown or known but not parsed.
+			 * Queue the tuple for the function driver.
+			 */
 			this->next = NULL;
 			this->code = tpl_code;
 			this->size = tpl_link;
 			*prev = this;
 			prev = &this->next;
-			printk(KERN_DEBUG
-			       "%s: queuing CIS tuple 0x%02x length %u\n",
-			       mmc_hostname(card->host), tpl_code, tpl_link);
-		} else {
-			const struct cis_tpl *tpl = cis_tpl_list + i;
-			if (tpl_link < tpl->min_size) {
-				printk(KERN_ERR
-				       "%s: bad CIS tuple 0x%02x (length = %u, expected >= %u)\n",
+
+			if (ret == -ENOENT) {
+				/* warn about unknown tuples */
+				printk(KERN_WARNING "%s: queuing unknown"
+				       " CIS tuple 0x%02x (%u bytes)\n",
 				       mmc_hostname(card->host),
-				       tpl_code, tpl_link, tpl->min_size);
-				ret = -EINVAL;
-			} else if (tpl->parse) {
-				ret = tpl->parse(card, func,
-						 this->data, tpl_link);
+				       tpl_code, tpl_link);
 			}
+
+			/* keep on analyzing tuples */
+			ret = 0;
+		} else {
+			/*
+			 * We don't need the tuple anymore if it was
+			 * successfully parsed by the SDIO core or if it is
+			 * not going to be queued for a driver.
+			 */
 			kfree(this);
 		}
 
diff -ruaN linux-2.6.31/drivers/mmc/core/sdio_io.c linux-2.6/drivers/mmc/core/sdio_io.c
--- linux-2.6.31/drivers/mmc/core/sdio_io.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/core/sdio_io.c	2011-01-04 14:03:00.000000000 -0800
@@ -624,7 +624,7 @@
 
 	BUG_ON(!func);
 
-	if (addr < 0xF0 || addr > 0xFF) {
+	if ((addr < 0xF0 || addr > 0xFF) && (!mmc_card_lenient_fn0(func->card))) {
 		if (err_ret)
 			*err_ret = -EINVAL;
 		return;
diff -ruaN linux-2.6.31/drivers/mmc/host/Kconfig linux-2.6/drivers/mmc/host/Kconfig
--- linux-2.6.31/drivers/mmc/host/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/host/Kconfig	2011-01-04 15:00:45.000000000 -0800
@@ -199,6 +199,31 @@
 
 	  If unsure, say N.
 
+config MMC_MES
+	tristate "MagicEyes SDIO host controller support"
+	depends on PLAT_MES
+	help
+	   This enables support for the SD/SDIO host controller in MagicEyes
+           SoCs such as the Pollux.
+
+config MMC_MES_CHANNEL0
+	bool "Enable SDIO controller 0"
+	depends on MMC_MES
+	default Y
+	help
+	   This enables SD/SDIO host controller channel 0.  If you have a
+	   device or SD slot wired to host controller 0, say Y here.  Otherwise
+	   say N.  You must enable at least one host controller.
+
+config MMC_MES_CHANNEL1
+	bool "Enable SDIO controller 1"
+	depends on MMC_MES
+	default N
+	help
+	   This enables SD/SDIO host controller channel 1.  If you have a
+	   device or SD slot wired to host controller 1, say Y here.  Otherwise
+	   say N.  You must enable at least one host controller.
+
 config MMC_MXC
 	tristate "Freescale i.MX2/3 Multimedia Card Interface support"
 	depends on ARCH_MXC
diff -ruaN linux-2.6.31/drivers/mmc/host/Makefile linux-2.6/drivers/mmc/host/Makefile
--- linux-2.6.31/drivers/mmc/host/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mmc/host/Makefile	2011-01-04 15:00:45.000000000 -0800
@@ -33,6 +33,7 @@
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
 obj-$(CONFIG_MMC_CB710)	+= cb710-mmc.o
 obj-$(CONFIG_MMC_VIA_SDMMC)	+= via-sdmmc.o
+obj-$(CONFIG_MMC_MES)		+= mes_sdhc.o
 
 ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
diff -ruaN linux-2.6.31/drivers/mmc/host/mes_sdhc.c linux-2.6/drivers/mmc/host/mes_sdhc.c
--- linux-2.6.31/drivers/mmc/host/mes_sdhc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mmc/host/mes_sdhc.c	2012-11-16 20:56:57.000000000 -0800
@@ -0,0 +1,1099 @@
+/* SD/SDIO Host Controller Driver for MagicEyes SoCs
+ *
+ * Copyright (c) 2010 Leapfrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This host controller supports:
+ * - MMC spec 4.2
+ * - SD memory card spec 2.0
+ * - SDIO card spec 1.10
+ * - 1-bit and 4-bit data bus modes
+ * - PIO and DMA (PIO not implemented)
+ * - up to 50MHz bus clock
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio.h>
+#include <linux/io.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <asm/sizes.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/gpio.h>
+#include <mach/dma.h>
+
+#include "mes_sdhc.h"
+
+#if !defined(CONFIG_MMC_MES_CHANNEL0) && \
+    !defined(CONFIG_MMC_MES_CHANNEL1)
+#warning "No host controllers enabled.  Enable at least one."
+#endif
+
+#define RESSIZE(res) (((res)->end - (res)->start)+1)
+
+#define MAX_CHANNELS	2
+
+#define COMPLETION_TIMEOUT	(2*1000)
+#define DRIVER_NAME		"mes-sdhc"
+#define SDIO_CLK_SRC		PLL1
+#define	SDIO_CLK_DIV		3
+#define DIV_400KHZ	62	/* divider for 400KHz */
+#define SDIO_DIV		0	/* divider for full speed */
+
+#define SDIO_GPIO_PORT	GPIO_PORT_B
+#define SDIO_GPIO_FUNC	GPIO_ALT1
+
+/* TODO: these are platform resources, move them and/or integrate with the
+ * GPIO framework and request them */
+static u8 sdio_pins[MAX_CHANNELS][6] = {
+	{
+		2,  /* Data 0 */
+		3,  /* Data 1 */
+		4,  /* Data 2 */
+		5,  /* Data 3 */
+		0,  /* Clock */
+		1,  /* Command */
+	},
+	{
+		8,  /* Data 0 */
+		9,  /* Data 1 */
+		10, /* Data 2 */
+		11, /* Data 3 */
+		6,  /* Clock */
+		7,  /* Command */
+	},
+};
+
+static const enum gpio_resource power_pins[MAX_CHANNELS] = {
+	(-1),
+	SD1_POWER,
+};
+
+struct mes_sdio_host {
+	struct mmc_host		*mmc;
+	struct resource 	*mem;
+	void __iomem		*base;
+	struct platform_device	*pdev;
+
+	char			name[20];
+	u8			channel;
+	unsigned int		dma_channel;
+	int			dma_id;
+	struct dma_control	ctrl;
+	bool			dma_active;
+	enum dma_data_direction	dma_dir;
+	int			dma_nents;
+	int			irq;
+	int			div;
+	u32			clock_hz;
+	u8			bus_width;
+	unsigned char		power_mode;
+	bool			sdio_irq_en;
+
+	struct mmc_request	*mrq;
+	struct mmc_data		*data;
+
+	struct completion	dma_transfer;
+
+	/* debugging */
+	struct dentry		*debug;
+};
+
+static void mes_regs_show_reg(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct mes_sdio_host *host = s->private;
+
+	seq_printf(s, "%9s:  0x%08X\n", nm, readl(host->base + reg));
+}
+
+static int mes_regs_show(struct seq_file *s, void *v)
+{
+	struct mes_sdio_host *host = s->private;
+
+	seq_printf(s, "%9s:  %u\n", "CHANNEL", host->mmc->index);
+	seq_printf(s, "%9s:  0x%p\n", "ADDRESS", host->base);
+	seq_printf(s, "\n");
+	mes_regs_show_reg(s, "CTRL", SDI_CTRL);
+	mes_regs_show_reg(s, "CLKDIV", SDI_CLKDIV);
+	mes_regs_show_reg(s, "CLKENA", SDI_CLKENA);
+	mes_regs_show_reg(s, "TMOUT", SDI_TMOUT);
+	mes_regs_show_reg(s, "CTYPE", SDI_CTYPE);
+	mes_regs_show_reg(s, "BLKSIZ", SDI_BLKSIZ);
+	mes_regs_show_reg(s, "BYTCNT", SDI_BYTCNT);
+	mes_regs_show_reg(s, "INTMASK", SDI_INTMASK);
+	mes_regs_show_reg(s, "CMDARG", SDI_CMDARG);
+	mes_regs_show_reg(s, "CMD", SDI_CMD);
+	mes_regs_show_reg(s, "RESP0", SDI_RESP0);
+	mes_regs_show_reg(s, "RESP1", SDI_RESP1);
+	mes_regs_show_reg(s, "RESP2", SDI_RESP2);
+	mes_regs_show_reg(s, "RESP3", SDI_RESP3);
+	mes_regs_show_reg(s, "MINTSTS", SDI_MINTSTS);
+	mes_regs_show_reg(s, "RINTSTS", SDI_RINTSTS);
+	mes_regs_show_reg(s, "STATUS", SDI_STATUS);
+	mes_regs_show_reg(s, "FIFOTH", SDI_FIFOTH);
+	mes_regs_show_reg(s, "TCBCNT", SDI_TCBCNT);
+	mes_regs_show_reg(s, "TBBCNT", SDI_TBBCNT);
+	mes_regs_show_reg(s, "DAT", SDI_DAT);
+	mes_regs_show_reg(s, "SYSCLKENB", SDI_SYSCLKENB);
+	mes_regs_show_reg(s, "CLKGEN", SDI_CLKGEN);
+
+	return 0;
+}
+
+static void mes_status_show_bit(struct seq_file *s, const char *nm, u32 v)
+{
+	seq_printf(s, "%10s:\t%d\n", nm, !!v);
+}
+
+static void mes_status_show_hex(struct seq_file *s, const char *nm, u32 v)
+{
+	seq_printf(s, "%10s:\t0x%X\n", nm, v);
+}
+
+static int mes_status_show(struct seq_file *s, void *v)
+{
+	struct mes_sdio_host *host = s->private;
+	u32 status = readl(host->base + SDI_STATUS);
+
+	mes_status_show_bit(s, "DMAREQ", status & (1<<DMAREQ));
+	mes_status_show_bit(s, "DMAACK", status & (1<<DMAACK));
+	mes_status_show_hex(s, "FIFOCOUNT", (status>>FIFOCOUNT) & 0x1F);
+	mes_status_show_hex(s, "RSPINDEX", (status>>RSPINDEX) & 0x3F);
+	mes_status_show_bit(s, "FSMBUSY", status & (1<<FSMBUSY));
+	mes_status_show_bit(s, "DATBUSY", status & (1<<DATBUSY));
+	mes_status_show_bit(s, "CPRESENT", status & (1<<CPRESENT));
+	mes_status_show_hex(s, "CMDFSM", (status>>CMDFSM) & 0xF);
+	mes_status_show_bit(s, "FIFOFULL", status & (1<<FIFOFULL));
+	mes_status_show_bit(s, "FIFOEMPTY", status & (1<<FIFOEMPTY));
+	mes_status_show_bit(s, "TXWMARK", status & (1<<TXWMARK));
+	mes_status_show_bit(s, "RXWMARK", status & (1<<RXWMARK));
+
+	return 0;
+}
+
+static int mes_sdio_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mes_regs_show, inode->i_private);
+}
+
+static int mes_sdio_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mes_status_show, inode->i_private);
+}
+
+static const struct file_operations mes_sdio_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mes_sdio_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations mes_sdio_status_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mes_sdio_status_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void mes_sdio_init_debugfs(struct mes_sdio_host *host)
+{
+	struct dentry *dir;
+       
+	dir = debugfs_create_dir(host->name, NULL);
+	if (!dir || IS_ERR(dir)) {
+		host->debug = NULL;
+		return;
+	}
+
+	debugfs_create_file("registers", S_IRUSR, dir, host,
+			&mes_sdio_regs_fops);
+	debugfs_create_file("status", S_IRUSR, dir, host,
+			&mes_sdio_status_fops);
+
+	host->debug = dir;
+	
+}
+
+/*
+ * Hardware helpers.
+ */
+
+static void mes_sdio_reset_controller(struct mes_sdio_host *host)
+{
+	u32 tmp = readl(host->base + SDI_CTRL);
+
+	tmp &= ~((1<<DMARST)|(1<<FIFORST));
+	tmp |= (1<<CTRLRST);
+	writel(tmp, host->base + SDI_CTRL);
+
+	while (readl(host->base + SDI_CTRL) & (1<<CTRLRST));
+	dev_dbg(&host->pdev->dev, "Finished resetting controller\n");
+}
+
+static void mes_sdio_set_dma(struct mes_sdio_host *host, bool en)
+{
+	u32 tmp = readl(host->base + SDI_CTRL) & ~(1<<DMA_ENA);
+
+	writel(tmp | (en<<DMA_ENA), host->base + SDI_CTRL);
+}
+
+static void mes_sdio_reset_dma(struct mes_sdio_host *host)
+{
+	u32 tmp = readl(host->base + SDI_CTRL);
+
+	tmp &= ~((1<<CTRLRST)|(1<<FIFORST));
+	tmp |= (1<<DMARST);
+	writel(tmp, host->base + SDI_CTRL);
+
+	while (readl(host->base + SDI_CTRL) & (1<<DMARST));
+	dev_dbg(&host->pdev->dev, "Finished resetting dma\n");
+}
+
+static void mes_sdio_reset_fifo(struct mes_sdio_host *host)
+{
+	u32 tmp = readl(host->base + SDI_CTRL);
+
+	tmp &= ~((1<<DMARST)|(1<<CTRLRST));
+	tmp |= (1<<FIFORST);
+	writel(tmp, host->base + SDI_CTRL);
+
+	while (readl(host->base + SDI_CTRL) & (1<<FIFORST));
+	dev_dbg(&host->pdev->dev, "Finished resetting fifo\n");
+}
+
+/* Set the RX and TX FIFO thresholds.  The FIFOs are 64 bytes (16 words) long
+ * and the recommended values are a TX threshold of (length/2) or 8 and an RX
+ * threshold of ((length/2)-1) or 7. */
+static void mes_sdio_set_fifo_th(struct mes_sdio_host *host)
+{
+	u32 tmp = readl(host->base + SDI_FIFOTH) & ~((0xF<<RXTH)|(0x3<<TXTH));
+
+	tmp |= (7<<RXTH)|(8<<TXTH);
+
+	writel(tmp, host->base + SDI_FIFOTH);
+}
+
+static void mes_sdio_set_width(struct mes_sdio_host *host, u8 width)
+{
+	u32 tmp = readl(host->base + SDI_CTYPE);
+
+	if (width == MMC_BUS_WIDTH_4)
+		tmp |= (1<<WIDTH);
+	else
+		tmp &= ~(1<<WIDTH);
+
+	writel(tmp, host->base + SDI_CTYPE);
+}
+
+static inline void mes_sdio_clear_int_status(struct mes_sdio_host *host)
+{
+	writel(0xFFFFFFFF, host->base + SDI_RINTSTS);
+}
+
+static void mes_sdio_interrupt_enable(struct mes_sdio_host *host)
+{
+	u32 tmp = readl(host->base + SDI_CTRL);
+	tmp |= (1<<INT_ENA)/*|(1<<SEND_IRQ_RESP)*/;
+	writel(tmp, host->base + SDI_CTRL);
+}
+
+static int check_command_error(struct mes_sdio_host *host, u32 irqm)
+{
+	if (irqm & (1<<HLEINT)) {
+		dev_err(&host->pdev->dev, "HW locked error\n");
+		return -EIO;
+	}
+
+	if (irqm & (1<<REINT)) {
+		dev_err(&host->pdev->dev, "response error\n");
+		return -EIO;
+	}
+
+	if (irqm & (1<<RCRCINT)) {
+		dev_err(&host->pdev->dev, "bad CRC\n");
+		return -EILSEQ;
+	}
+
+	if (irqm & (1<<RTOINT)) {
+		/* This happens when the stack probes for different types of
+		 * cards and is expected.  For example, an SD card will time
+		 * out when probed as an SDIO card. */
+		dev_dbg(&host->pdev->dev, "response timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int check_data_error(struct mes_sdio_host *host, u32 irqm)
+{
+	if (irqm & (1<<FRUNINT)) {
+		dev_err(&host->pdev->dev, "FIFO error\n");
+		return -EIO;
+	}
+	
+	if (irqm & (1<<DRTOINT)) {
+		dev_err(&host->pdev->dev, "data read response timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static void mes_sdio_setup_controller(struct mes_sdio_host *host)
+{
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	/* Turn off clock output, turn off clock low power mode.  The clock
+	 * output will be enabled later by the MMC subsystem. */
+	writel(0, host->base + SDI_CLKENA);
+
+	/* use PLL1/3, 147MHz/3 = 49MHz */
+	writel((2<<CLKSRCSEL0)|((SDIO_CLK_DIV-1)<<CLKDIV0),
+			host->base + SDI_CLKGEN);
+	writel((1<<PCLKMODE)|(1<<CLKGENENB), host->base + SDI_SYSCLKENB);
+	/* set SDIO clock to "detect" rate, ~400KHz:
+	 * 49MHz/(62*2) = ~400KHz */
+	writel(62, host->base + SDI_CLKDIV);
+
+	mes_sdio_interrupt_enable(host);
+
+	mes_sdio_reset_controller(host);
+	mes_sdio_reset_dma(host);
+	mes_sdio_reset_fifo(host);
+
+//	mes_sdio_set_dma(host, 1);
+	mes_sdio_set_dma(host, 0);
+
+	mes_sdio_set_width(host, MMC_BUS_WIDTH_1);
+
+	/* Set host data and response timeouts. */
+
+#if 0	// 17mar11
+//ok	writel((0x800000<<DTMOUT)|(0x80<<RSPTMOUT), host->base + SDI_TMOUT);
+//ok	writel((0x400000<<DTMOUT)|(0x40<<RSPTMOUT), host->base + SDI_TMOUT);
+	writel((0x200000<<DTMOUT)|(0x20<<RSPTMOUT), host->base + SDI_TMOUT);
+//ok	writel((0x100000<<DTMOUT)|(0x10<<RSPTMOUT), host->base + SDI_TMOUT);
+//FAILS	writel((0x080000<<DTMOUT)|(0x08<<RSPTMOUT), host->base + SDI_TMOUT);
+#else	// original
+	writel((0xFFFFFF<<DTMOUT)|(0xFF<<RSPTMOUT), host->base + SDI_TMOUT);
+#endif	// 17mar11
+
+	/* Set a defult block size: 512B is typical for MMC/SD cards. */
+	writel(512, host->base + SDI_BLKSIZ);
+
+	mes_sdio_set_fifo_th(host);
+
+	/* Disable interrupts and clear any pending. */
+	writel(0, host->base + SDI_INTMASK);
+	mes_sdio_clear_int_status(host);
+}
+
+static void mes_sdio_clock_disable(struct mes_sdio_host *host)
+{
+	u32 reg = readl(host->base + SDI_SYSCLKENB);
+	
+	reg &= ~(1<<CLKGENENB);
+
+	writel(reg, host->base + SDI_SYSCLKENB);
+}
+
+static void mes_sdio_enable_irq(struct mmc_host *mmc, int enable)
+{
+	struct mes_sdio_host *host = mmc_priv(mmc);
+
+	host->sdio_irq_en = enable;
+}
+
+/*
+ * Command and data transfer.
+ */
+
+/* Read the command result and, if there is a data stage and we are writing,
+ * launch a DMA request.  If the command resulted in an error or if there is
+ * no data stange, we are done handling this command and we report that to the
+ * stack.  Otherwise we need to wait for the data stage to complete before we
+ * report to the stack that the request is complete. */
+static int mes_sdio_command_complete(struct mes_sdio_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+	
+	if (mrq->cmd->flags & MMC_RSP_PRESENT) {
+		if (mrq->cmd->flags & MMC_RSP_136) {
+			mrq->cmd->resp[0] = readl(host->base + SDI_RESP3);
+			mrq->cmd->resp[1] = readl(host->base + SDI_RESP2);
+			mrq->cmd->resp[2] = readl(host->base + SDI_RESP1);
+			mrq->cmd->resp[3] = readl(host->base + SDI_RESP0);
+		} else
+			mrq->cmd->resp[0] = readl(host->base + SDI_RESP0);
+	}
+
+	if (mrq->cmd->error || !mrq->data) {
+		host->mrq = NULL;
+		mmc_request_done(host->mmc, mrq);
+		
+		return 1;
+	}
+
+	if (mrq->data && (mrq->data->flags & MMC_DATA_WRITE)) {
+		dev_dbg(&host->pdev->dev, "launching DMA TX\n");
+		WARN_ON(dma_start(host->dma_channel));
+	}
+
+	return 0;
+}
+
+static void mes_sdio_dma_done(struct mes_sdio_host *host)
+{
+	host->dma_active = 0;
+	dma_unmap_sg(mmc_dev(host->mmc), host->data->sg, host->dma_nents,
+			host->dma_dir);
+	host->data = NULL;
+	complete(&host->dma_transfer);
+}
+
+static void mes_sdio_transfer_complete(struct mes_sdio_host *host)
+{
+	struct mmc_data *data = host->mrq->data;
+
+	dev_dbg(&host->pdev->dev, "data transfer complete\n");
+
+	if (!data)
+		return;
+
+	if (data->error) {
+		dev_err(&host->pdev->dev, "data error\n");
+		if (host->dma_active) {
+			dma_stop(host->dma_channel);
+			mes_sdio_set_dma(host, 0);
+			mes_sdio_dma_done(host);
+		}
+	} else {
+		data->bytes_xfered = data->blocks * data->blksz;
+	}
+
+	/* Complete the command now that the data transfer portion has
+	 * finished. */
+	host->mrq = NULL;
+	mmc_request_done(host->mmc, data->mrq);
+	return;
+}
+
+static irqreturn_t mes_sdio_dma_cb(int irq, void *dev_id)
+{
+	struct mes_sdio_host *host = (struct mes_sdio_host *)dev_id;
+
+	WARN_ON(!host->dma_active);
+
+	if (host->dma_active) {
+		dev_dbg(&host->pdev->dev, "DMA transfer completed\n");
+		dma_stop(host->dma_channel);
+		mes_sdio_set_dma(host, 0);
+		mes_sdio_dma_done(host);
+	}
+	
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mes_sdio_irq(int irq, void *dev_id)
+{
+	struct mes_sdio_host *host = (struct mes_sdio_host *)dev_id;
+	u32 irqm = readl(host->base + SDI_MINTSTS);
+
+	dev_dbg(&host->pdev->dev, "IRQ: 0x%08X\n", irqm);
+
+	if (host->mrq) {
+		host->mrq->cmd->error = check_command_error(host, irqm);
+		if (host->mrq->cmd->error) {
+			dev_dbg(&host->pdev->dev, "command error\n");
+			mes_sdio_command_complete(host);
+			goto out_req;
+		}
+
+		if (irqm & (1<<CDINT)) {
+			dev_dbg(&host->pdev->dev, "command done\n");
+			if (mes_sdio_command_complete(host))
+				goto out_req;
+		}
+
+		if (host->mrq->data && (irqm & (1<<DTOINT))) {
+			dev_dbg(&host->pdev->dev, "data transfer over\n");
+			host->mrq->data->error = check_data_error(host, irqm);
+			mes_sdio_transfer_complete(host);
+		}
+	}
+
+out_req:
+	if (irqm & (1<<SDIOINT)) {
+		dev_dbg(&host->pdev->dev, "SDIO interrupt occured\n");
+		mmc_signal_sdio_irq(host->mmc);
+	}
+
+	writel(irqm, host->base + SDI_RINTSTS);
+	return IRQ_HANDLED;
+}
+
+/* Set up and launch a transfer from the controller to memory. */
+static void mes_sdio_start_dma_rx(struct mes_sdio_host *host)
+{
+	struct dma_control *ctrl = &host->ctrl;
+	struct scatterlist *sg = host->mrq->data->sg;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	if (host->dma_active)
+		wait_for_completion(&host->dma_transfer);
+
+	init_completion(&host->dma_transfer);
+	host->dma_active = 1;
+	host->dma_nents = dma_map_sg(mmc_dev(host->mmc), host->mrq->data->sg,
+			host->mrq->data->sg_len, host->dma_dir);
+
+	ctrl->transfer = DMA_IO_TO_MEM;
+	ctrl->interrupt = DMA_INT_LAST_BLOCK;
+	ctrl->request_id = host->dma_id;
+	ctrl->src_width = ctrl->dest_width = 4;
+
+	WARN_ON(dma_transfer_init(host->dma_channel, DMA_MEM_IO));
+	WARN_ON(dma_sg_read(host->dma_channel, host->mem->start, sg,
+			host->mrq->data->sg_len, ctrl));
+
+	WARN_ON(dma_start(host->dma_channel));
+}
+
+/* Set up a transfer from memory to the controller.  The transfer will be 
+ * launched once the hardware is ready. */
+static void mes_sdio_start_dma_tx(struct mes_sdio_host *host)
+{
+	struct dma_control *ctrl = &host->ctrl;
+	struct scatterlist *sg = host->mrq->data->sg;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	if (host->dma_active)
+		wait_for_completion(&host->dma_transfer);
+
+	init_completion(&host->dma_transfer);
+	host->dma_active = 1;
+	host->dma_nents = dma_map_sg(mmc_dev(host->mmc), host->mrq->data->sg,
+			host->mrq->data->sg_len, host->dma_dir);
+
+	ctrl->transfer = DMA_MEM_TO_IO;
+	ctrl->interrupt = DMA_INT_LAST_BLOCK;
+	ctrl->request_id = host->dma_id;
+	ctrl->src_width = ctrl->dest_width = 4;
+	
+	dma_transfer_init(host->dma_channel, DMA_MEM_IO);
+	dma_sg_write(host->dma_channel, sg, host->mem->start,
+			host->mrq->data->sg_len, ctrl);
+}
+
+static void mes_sdio_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	u32 irqm = 0;
+	u32 flags = 0;
+	struct mes_sdio_host *host = mmc_priv(mmc);
+	u8 resp = mmc_resp_type(mrq->cmd);
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	WARN_ON(host->mrq != NULL);
+	host->mrq = mrq;
+	
+	flags |= (1<<STARTCMD)|(mrq->cmd->opcode & 0x3F);
+
+	dev_dbg(&host->pdev->dev, "cmd resp flags: 0x%X\n", resp);
+
+	/* Send 80 clocks before the first command for initialization */
+	if (mrq->cmd->opcode == MMC_GO_IDLE_STATE ||
+	    mrq->cmd->opcode == SD_IO_SEND_OP_COND)
+		flags |= (1<<SENDINIT);
+
+	if (mrq->cmd->opcode != MMC_SEND_STATUS)
+		flags |= (1<<WAITPRVDAT);
+
+	if (resp & MMC_RSP_PRESENT) { /* expect a response */
+		flags |= (1<<RSPEXP);
+		irqm |= (1<<MSKRTO);
+		if (resp & MMC_RSP_136) /* expect a long response */
+			flags |= (1<<RSPLEN);
+	}
+
+	if (resp & MMC_RSP_CRC) /* expect valid CRC */
+		flags |= (1<<CHKRSPCRC);
+
+	/* We always want to know about command completion, HW errors, and 
+	 * response errors. */
+	irqm |= (1<<MSKHLE)|(1<<MSKRE)|(1<<MSKCD);
+
+	/* Preserve the SDIO Interrupt setting. */
+	irqm |= (host->sdio_irq_en<<MSKSDIOINT);
+
+	if (mrq->data) {
+		int i;
+		struct scatterlist *sg;
+		u32 length = mrq->data->blocks * mrq->data->blksz;
+
+		/* TODO: handle non-aligned data w/PIO or an intermediate
+		 * buffer. */
+		for_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i) {
+			if(unlikely(mrq->data->sg->offset & 0x3)) {
+				dev_err(&host->pdev->dev, "invalid alignment for DMA\n");
+				mrq->cmd->error = -EINVAL;
+				mrq->cmd->retries = 0;
+				host->mrq = NULL;
+				mmc_request_done(mmc, mrq);
+				return;
+			}
+		}
+
+		dev_dbg(&host->pdev->dev, "transferring %d bytes\n", length);
+
+		host->data = mrq->data;
+
+		mes_sdio_set_dma(host, 1);
+
+		if (mrq->data->blocks > 1 &&
+			(mrq->cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||
+			 mrq->cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK)) {
+			dev_dbg(&host->pdev->dev, "setting autostop\n");
+			flags |= (1<<SENDAUTOSTOP);
+			irqm |= (1<<MSKACD);
+		}
+
+		writel(mrq->data->blksz, host->base + SDI_BLKSIZ);
+		writel(length, host->base + SDI_BYTCNT);
+
+		irqm |= (1<<MSKDTO)|(1<<MSKHTO)|(1<<MSKFRUN);
+		flags |= (1<<DATEXP);
+
+		if (mrq->data->flags & MMC_DATA_STREAM) {
+			dev_dbg(&host->pdev->dev, "data stream requested\n");
+			flags |= (1<<TRMODE);
+		}
+
+		if (mrq->data->flags & MMC_DATA_READ) {
+			irqm |= (1<<MSKDRTO);
+			mes_sdio_start_dma_rx(host);
+		}
+		
+		if (mrq->data->flags & MMC_DATA_WRITE) {
+			flags |= (1<<RW);
+			mes_sdio_start_dma_tx(host);
+		}
+	} else if (mrq->stop) {
+		flags |= (1<<STOPABORT);
+	}
+	
+	dev_dbg(&host->pdev->dev, "submitting cmd: 0x%04X irqm: 0x%04X\n",
+			flags, irqm);
+
+	/* Submit the command. */
+	mes_sdio_clear_int_status(host);
+	writel(0xFFFFFFFF, host->base + SDI_RINTSTS);
+	writel(irqm, host->base + SDI_INTMASK);
+	writel(0xFFFFFFFF, host->base + SDI_RINTSTS);
+	writel(mrq->cmd->arg, host->base + SDI_CMDARG);
+	writel(flags, host->base + SDI_CMD);
+}
+
+static int mes_sdio_get_ro(struct mmc_host *mmc)
+{
+	/* we don't support RO detection */
+	return -ENOSYS;
+}
+
+static void mes_sdio_set_clock_out(struct mes_sdio_host *host, bool en)
+{
+	writel((en<<CLKENA), host->base + SDI_CLKENA);
+}
+
+static int mes_sdio_update_clock(struct mes_sdio_host *host)
+{
+	u32 tout, tmp;
+
+	/* send a clock update command and wait for it to complete, repeat if
+	 * a HLEINT occurs */
+	while (1) {
+		writel((1<<STARTCMD)|(1<<UPDATECLKONLY)|(1<<WAITPRVDAT),
+				host->base + SDI_CMD);
+
+		tout = 0;
+		while (readl(host->base + SDI_CMD) & (1<<STARTCMD))
+			if (++tout > 0x1000000)
+				return 1;
+
+
+		dev_dbg(&host->pdev->dev, 
+			"mes_sdio_update_clock: tout %d\n", tout);
+		tmp = readl(host->base + SDI_RINTSTS);
+		if (!(tmp & (1<<HLEINT)))
+			break;
+
+		tmp |= (1<<HLEINT);
+		writel(tmp, host->base + SDI_RINTSTS);
+	}
+
+	return 0;
+}
+
+static int mes_sdio_set_clock_hz(struct mes_sdio_host *host, u32 hz)
+{
+	int div; 
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	if (hz == 400000)
+		div = DIV_400KHZ;
+	else if (hz == host->mmc->f_max)
+		div = SDIO_DIV;
+	else {
+		u32 clk_hz = get_pll_freq(SDIO_CLK_SRC)/SDIO_CLK_DIV;
+		div = lf1000_CalcDivider(clk_hz, hz);
+		if (div < 0)
+			return 1;
+		div >>= 1;
+	}
+	dev_dbg(&host->pdev->dev, "setting DIV=%d\n", div);
+
+	/* disable the SDIO clock and set the divider */
+	mes_sdio_set_clock_out(host, 0);
+	writel(div & 0xFF, host->base + SDI_CLKDIV);
+	host->div = div;
+
+	if (mes_sdio_update_clock(host)) {
+		dev_err(&host->pdev->dev, "can't set clock: disabled\n");
+		return 1;
+	}
+
+	mes_sdio_set_clock_out(host, 1);
+
+	if (mes_sdio_update_clock(host)) {
+		dev_err(&host->pdev->dev, "can't set clock\n");
+		return 1;
+	}
+
+	writel((1<<PCLKMODE)|(1<<CLKGENENB), host->base + SDI_SYSCLKENB);
+
+	return 0;
+}
+
+static inline bool mes_sdio_card_busy(struct mes_sdio_host *host)
+{
+	u32 reg = readl(host->base + SDI_STATUS);
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	return !!(reg & ((1<<FSMBUSY)|(1<<DATBUSY)));
+}
+
+static void mes_sdio_setup_pins(struct mes_sdio_host *host, const int on)
+{
+	int i;
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	if (host->channel >= MAX_CHANNELS) {
+		dev_err(&host->pdev->dev, "invalid SDIO channel\n");
+		return;
+	}
+
+	for (i = 0; i < 6; i++)
+	{
+		if(on)
+		{
+			gpio_configure_pin(SDIO_GPIO_PORT,
+				   sdio_pins[host->channel][i],
+				   SDIO_GPIO_FUNC, 0, 0, 1);
+		}
+		else
+		{
+			/* "card" will have power cut - drive bus low */
+			gpio_configure_pin(SDIO_GPIO_PORT,
+				   sdio_pins[host->channel][i],
+				   GPIO_GPIOFN, 1, 0, 0);
+		}
+	}
+}
+
+static void mes_sdio_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct mes_sdio_host *host = mmc_priv(mmc);
+
+	dev_dbg(&host->pdev->dev, "%s\n", __FUNCTION__);
+
+	if (host->power_mode != MMC_POWER_OFF && mes_sdio_card_busy(host)) {
+		dev_err(&host->pdev->dev, "%s.%d card (%p) channel(%d) busy\n",
+			__FUNCTION__, __LINE__, host->base, host->channel);
+	}
+	//Set DAT3 (CS in SPI mode) high if requested or allow MMC controller to drive it if not
+	if (ios->chip_select == MMC_CS_HIGH)
+		gpio_configure_pin(SDIO_GPIO_PORT, sdio_pins[host->channel][3], GPIO_GPIOFN, 1, 0, 1);
+	else
+		gpio_configure_pin(SDIO_GPIO_PORT, sdio_pins[host->channel][3], SDIO_GPIO_FUNC, 0, 0, 1);
+	
+
+	if (ios->bus_width != host->bus_width) {
+		mes_sdio_set_width(host, ios->bus_width);
+		host->bus_width = ios->bus_width;
+	}
+
+	if (ios->clock != host->clock_hz) {
+		if (ios->clock > 0) {
+			if (mes_sdio_set_clock_hz(host, ios->clock))
+				dev_err(&host->pdev->dev,
+				"%s.%d card (%p) can't set clock rate\n",
+				__FUNCTION__, __LINE__, host->base);
+			else {
+				host->clock_hz = ios->clock;
+				dev_dbg(&host->pdev->dev, 
+					"mes_sdio_set_ios: clock %d hz\n", 
+					host->clock_hz);
+			}
+		} else
+			mes_sdio_clock_disable(host);
+	}
+
+	if (ios->power_mode != host->power_mode) {
+		switch (ios->power_mode) {
+			case MMC_POWER_OFF:
+				mes_sdio_set_clock_out(host, 0);
+
+					/* drive bus low before cutting power */
+					mes_sdio_setup_pins(host, 0);
+				break;
+
+			case MMC_POWER_ON:
+				mes_sdio_set_clock_out(host, 1);
+				mes_sdio_reset_dma(host);
+				mes_sdio_reset_fifo(host);
+				mdelay(5);
+				break;
+
+			case MMC_POWER_UP:
+
+					mdelay(5);
+
+					/* restore pins */
+					mes_sdio_setup_pins(host, 1);
+
+				mdelay(5);
+				break;
+
+			default:
+				break;
+		}
+		host->power_mode = ios->power_mode;
+	}
+}
+
+static struct mmc_host_ops mes_sdio_ops = {
+	.request 		= mes_sdio_request,
+	.get_ro			= mes_sdio_get_ro,
+	.set_ios		= mes_sdio_set_ios,
+	.enable_sdio_irq	= mes_sdio_enable_irq,
+};
+
+static int mes_sdio_probe(struct platform_device *pdev)
+{
+	struct mmc_host *mmc;
+	struct mes_sdio_host *host = NULL;
+	struct resource *res;
+	int ret;
+
+	dev_dbg(&pdev->dev, "%s\n", __FUNCTION__);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	mmc = mmc_alloc_host(sizeof(struct mes_sdio_host), &pdev->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	mmc->ops = &mes_sdio_ops;
+
+	mmc->max_hw_segs = 1;
+	mmc->max_phys_segs = 128;
+	mmc->max_blk_size = 512;
+	mmc->max_blk_count = 128;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+
+	mmc->f_min = 400000;
+	mmc->f_max = get_pll_freq(SDIO_CLK_SRC)/SDIO_CLK_DIV;
+	mmc->ocr_avail = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+	       MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 | MMC_VDD_33_34 |
+	       MMC_VDD_34_35 | MMC_VDD_35_36;
+
+	mmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED |
+		MMC_CAP_SDIO_IRQ | MMC_CAP_NONREMOVABLE;
+
+	if (!request_mem_region(res->start, RESSIZE(res), res->name)) {
+		dev_err(&pdev->dev, "failed to get IO memory region\n");
+		ret = -EBUSY;
+		goto out_mem;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->mem = res;
+	host->pdev = pdev;
+	host->channel = pdev->id;
+	host->div = 0;
+	host->clock_hz = 0;
+	host->dma_id = (host->channel == 0 ) ? DMA_PERI_SD0RW : DMA_PERI_SD1RW;
+	host->dma_channel = 0;
+	host->dma_active = 0;
+	host->bus_width = MMC_BUS_WIDTH_1;
+	host->sdio_irq_en = 0;
+
+	snprintf(host->name, sizeof(host->name), "%s%u",
+		pdev->name, pdev->id);
+
+	host->base = ioremap(res->start, res->end - res->start + 1);
+	if (!host->base) {
+		dev_err(&pdev->dev, "failed to remap\n");
+		ret = -ENOMEM;
+		goto out_mem;
+	}
+
+	host->irq = platform_get_irq(pdev, 0);
+	if (host->irq < 0) {
+		dev_err(&pdev->dev, "failed to get an IRQ number\n");
+		ret = -EINVAL;
+		goto out_remap;
+	}
+
+	ret = request_irq(host->irq, mes_sdio_irq, 0, host->name, host);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get SDIO%d IRQ\n", host->channel);
+		ret = -ENOENT;
+		goto out_irq;
+	}
+
+	ret = dma_request(host->name, DMA_PRIORITY_LV0, mes_sdio_dma_cb, host,
+		&host->dma_channel);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "can't get DMA channel: %d\n",
+				ret);
+		goto out_dma;
+	}
+
+	/* prepare the hardware */
+	mes_sdio_setup_pins(host, 1);
+	mes_sdio_setup_controller(host);
+
+	platform_set_drvdata(pdev, mmc);
+
+	mes_sdio_init_debugfs(host);
+
+	mmc_add_host(mmc);
+
+	dev_dbg(&pdev->dev, "\"%s\" probe complete\n", host->name);
+
+	return 0;
+
+out_dma:
+	free_irq(host->irq, host);
+out_irq:
+	iounmap(host->base);
+out_remap:
+	release_mem_region(host->mem->start, RESSIZE(host->mem));
+out_mem:
+	mmc_free_host(mmc);
+
+	return ret;
+}
+
+static int mes_sdio_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	struct mes_sdio_host *host = NULL;
+
+	if (mmc) {
+		host = mmc_priv(mmc);
+
+		if (host->debug)
+			debugfs_remove_recursive(host->debug);
+
+		mmc_remove_host(mmc);
+		mes_sdio_clock_disable(host);
+		writel(0, host->base + SDI_INTMASK);
+		mes_sdio_clear_int_status(host);
+		free_irq(host->irq, host);
+		dma_release(host->dma_channel);
+		if (host->dma_active)
+			complete(&host->dma_transfer);
+		iounmap(host->base);
+		release_mem_region(host->mem->start, RESSIZE(host->mem));
+		release_resource(host->mem);
+	}
+	
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mes_sdio_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int mes_sdio_resume(struct platform_device *dev)
+{
+	return 0;
+}
+#else
+#define mes_sdio_suspend NULL
+#define mes_sdio_resume	NULL
+#endif
+
+static struct platform_driver mes_sdio_driver = {
+	.probe		= mes_sdio_probe,
+	.remove		= mes_sdio_remove,
+	.suspend	= mes_sdio_suspend,
+	.resume		= mes_sdio_resume,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init mes_sdio_init(void)
+{
+	return platform_driver_register(&mes_sdio_driver);
+}
+
+static void __exit mes_sdio_exit(void)
+{
+	platform_driver_unregister(&mes_sdio_driver);
+}
+
+module_init(mes_sdio_init);
+module_exit(mes_sdio_exit);
+
+MODULE_DESCRIPTION("SD/SDIO Host Controller Driver for MagicEyes SoCs");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -ruaN linux-2.6.31/drivers/mmc/host/mes_sdhc.h linux-2.6/drivers/mmc/host/mes_sdhc.h
--- linux-2.6.31/drivers/mmc/host/mes_sdhc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mmc/host/mes_sdhc.h	2011-01-04 15:00:52.000000000 -0800
@@ -0,0 +1,142 @@
+/* SD/SDIO Host Controller Driver for MagicEyes SoCs
+ *
+ * Copyright (c) 2010 Leapfrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __MES_SDHC_H__
+#define __MES_SDHC_H__
+
+/* Registers */
+#define SDI_CTRL	0x000
+#define SDI_CLKDIV	0x008
+#define SDI_CLKENA	0x010
+#define SDI_TMOUT	0x014
+#define SDI_CTYPE	0x018
+#define SDI_BLKSIZ	0x01C
+#define SDI_BYTCNT	0x020
+#define SDI_INTMASK	0x024
+#define SDI_CMDARG	0x028
+#define SDI_CMD		0x02C
+#define SDI_RESP0	0x030
+#define SDI_RESP1	0x034
+#define SDI_RESP2	0x038
+#define SDI_RESP3	0x03C
+#define SDI_MINTSTS	0x040
+#define SDI_RINTSTS	0x044
+#define SDI_STATUS	0x048
+#define SDI_FIFOTH	0x04C
+#define SDI_TCBCNT	0x05C
+#define SDI_TBBCNT	0x060
+#define SDI_DAT		0x100
+#define SDI_SYSCLKENB	0x7C0
+#define SDI_CLKGEN	0x7C4
+
+/* SDI Control Register (CTRL) */
+#define ABORT_DATA	8
+#define SEND_IRQ_RESP	7
+#define READ_WAIT	6
+#define DMA_ENA		5
+#define INT_ENA		4
+#define DMARST		2
+#define FIFORST		1
+#define CTRLRST		0
+
+/* SDI Clock Enable Register (CLKENA) */
+#define LOWPWR		16
+#define CLKENA		0
+
+/* SDI Timeout Register (TMOUT) */
+#define DTMOUT		8
+#define RSPTMOUT	0
+
+/* SDI Card Type Register (CTYPE) */
+#define WIDTH		0	/* 0: 1-bit, 1: 4-bit */
+
+/* SDI Interrupt Mask Register (INTMASK) */
+#define MSKSDIOINT	16
+#define MSKEBE		15
+#define MSKACD		14
+#define MSKSBE		13
+#define MSKHLE		12
+#define MSKFRUN		11
+#define MSKHTO		10
+#define MSKDRTO		9
+#define MSKRTO		8
+#define MSKDCRC		7
+#define MSKRCRC		6
+#define MSKRXDR		5
+#define MSKTXDR		4
+#define MSKDTO		3
+#define MSKCD		2
+#define MSKRE		1
+
+/* SDI Command Register (CMD) */
+#define STARTCMD	31	/* start command (don't set until arg ready) */
+#define UPDATECLKONLY	21	/* update CLKDIV, CLKENA, don't send command */
+#define CARDNUM		16	/* must be 0, bits 16:20 */
+#define SENDINIT	15	/* send init sequence before sending command */
+#define STOPABORT	14	/* stop or abort current transfer, if any */
+#define WAITPRVDAT	13	/* wait for previous transfer completion */
+#define SENDAUTOSTOP	12	/* send stop at end of transfer */
+#define TRMODE		11	/* data transfer mode (0: block, 1: stream) */
+#define RW		10	/* data transfer (read and write) expected */
+#define DATEXP		9	/* data transfer (at least read) expected */
+#define CHKRSPCRC	8	/* need to check CRC for response */
+#define RSPLEN		7	/* expected response (0: short, 1: long) */
+#define RSPEXP		6	/* expected response (0: no, 1: yes) */
+#define CMDINDEX	0	/* command opcode */
+
+/* SDI Masked Interrupt Status Register */
+#define SDIOINT		16	/* SDIO interrupt */
+#define EBEINT		15	/* end bit error (read) or no CRC (write) */
+#define ACDINT		14	/* auto command done */
+#define SBEINT		13	/* start bit error */
+#define HLEINT		12	/* hardware locked error */
+#define FRUNINT		11	/* FIFO underrun or overrun error */
+#define HTOINT		10	/* data starvation by host timeout */
+#define DRTOINT		9	/* data read timeout */
+#define RTOINT		8	/* response timeout */
+#define DCRCINT		7	/* data CRC error */
+#define RCRCINT		6	/* response CRC error */
+#define RXDRINT		5	/* RX FIFO data request */
+#define TXDRINT		4	/* TX FIFO data request */
+#define DTOINT		3	/* data transfer over */
+#define CDINT		2	/* command done */
+#define REINT		1	/* response error */
+
+/* SDI Status Register (STATUS) */
+#define DMAREQ		31
+#define DMAACK		30
+#define FIFOCOUNT	17
+#define RSPINDEX	11
+#define FSMBUSY		10
+#define DATBUSY		9
+#define CPRESENT	8
+#define CMDFSM		4
+#define FIFOFULL	3
+#define FIFOEMPTY	2
+#define TXWMARK		1
+#define RXWMARK		0
+
+/* SDI FIFO Threshold Watermark Register (FIFOTH) */
+#define RXTH		16
+#define TXTH		0
+
+/* SDI Card Interface Control Register (CICTRL) */
+#define CDETECT		2
+#define WRTPRT		0
+
+/* SDI System Clock Enable Register (SYSCLKENB) */
+#define PCLKMODE	3
+#define CLKGENENB	2
+
+/* SDI Clock Generator Register (CLKGEN) */
+#define CLKDIV0		4	/* bits 6:4 */
+#define CLKSRCSEL0	1	/* bits 3:1, 0:PCLK, 1:PLL0, 2:PLL1 */
+
+#endif /* __MES_SDHC_H__ */
diff -ruaN linux-2.6.31/drivers/mtd/chips/cfi_cmdset_0002.c linux-2.6/drivers/mtd/chips/cfi_cmdset_0002.c
--- linux-2.6.31/drivers/mtd/chips/cfi_cmdset_0002.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/chips/cfi_cmdset_0002.c	2012-11-13 21:41:36.000000000 -0800
@@ -52,6 +52,8 @@
 #define SST49LF008A		0x005a
 #define AT49BV6416		0x00d6
 
+#define WAIT_TIDA		150	// wait 150ns after reset
+
 static int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);
 static int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
@@ -81,8 +83,7 @@
 	.module		= THIS_MODULE
 };
 
-
-/* #define DEBUG_CFI_FEATURES */
+#define DEBUG_CFI_FEATURES
 
 
 #ifdef DEBUG_CFI_FEATURES
@@ -979,7 +980,7 @@
 	spin_lock(chip->mutex);
 
 	if (chip->state != FL_READY){
-#if 0
+#if 1
 		printk(KERN_DEBUG "Waiting for chip to read, status = %d\n", chip->state);
 #endif
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1114,6 +1115,7 @@
 	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);
 	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);
 	map_write(map, datum, adr);
+	cfi_udelay(1);
 	chip->state = FL_WRITING;
 
 	INVALIDATE_CACHE_UDELAY(map, chip,
@@ -1154,7 +1156,7 @@
 	if (!chip_good(map, adr, datum)) {
 		/* reset on all failures. */
 		map_write( map, CMD(0xF0), chip->start );
-		/* FIXME - should have reset delay before continuing */
+		ndelay(WAIT_TIDA);	// delay after reset
 
 		if (++retry_cnt <= MAX_WORD_RETRIES)
 			goto retry;
@@ -1200,7 +1202,7 @@
 		spin_lock(cfi->chips[chipnum].mutex);
 
 		if (cfi->chips[chipnum].state != FL_READY) {
-#if 0
+#if 1
 			printk(KERN_DEBUG "Waiting for chip to write, status = %d\n", cfi->chips[chipnum].state);
 #endif
 			set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1278,7 +1280,7 @@
 		spin_lock(cfi->chips[chipnum].mutex);
 
 		if (cfi->chips[chipnum].state != FL_READY) {
-#if 0
+#if 1
 			printk(KERN_DEBUG "Waiting for chip to write, status = %d\n", cfi->chips[chipnum].state);
 #endif
 			set_current_state(TASK_UNINTERRUPTIBLE);
@@ -1413,7 +1415,7 @@
 	/* reset on all failures. */
 	map_write( map, CMD(0xF0), chip->start );
 	xip_enable(map, chip, adr);
-	/* FIXME - should have reset delay before continuing */
+	ndelay(WAIT_TIDA);	// delay after reset
 
 	printk(KERN_WARNING "MTD %s(): software timeout\n",
 	       __func__ );
@@ -1587,7 +1589,7 @@
 	if (!chip_good(map, adr, map_word_ff(map))) {
 		/* reset on all failures. */
 		map_write( map, CMD(0xF0), chip->start );
-		/* FIXME - should have reset delay before continuing */
+		ndelay(WAIT_TIDA);	// delay after reset
 
 		ret = -EIO;
 	}
diff -ruaN linux-2.6.31/drivers/mtd/chips/jedec_probe.c linux-2.6/drivers/mtd/chips/jedec_probe.c
--- linux-2.6.31/drivers/mtd/chips/jedec_probe.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/chips/jedec_probe.c	2011-01-18 15:23:11.000000000 -0800
@@ -128,6 +128,7 @@
 #define UPD29F064115	0x221C
 
 /* PMC */
+#define	PM39LV040	0x003E
 #define PM49FL002	0x006D
 #define PM49FL004	0x006E
 #define PM49FL008	0x006A
@@ -186,6 +187,7 @@
 /* Winbond */
 #define W49V002A	0x00b0
 
+#define	FLASH_TIDA	150	// generic flash command delay time in ns
 
 /*
  * Unlock address sets for AMD command sets.
@@ -1252,6 +1254,18 @@
 		}
 	}, {
 		.mfr_id		= MANUFACTURER_PMC,
+		.dev_id		= PM39LV040,
+		.name		= "PMC Pm39LV040",
+		.devtypes	= CFI_DEVICETYPE_X8,
+		.uaddr		= MTD_UADDR_0x5555_0x2AAA,
+		.dev_size	= SIZE_512KiB,
+		.cmd_set	= P_ID_AMD_STD,
+		.nr_regions	= 1,
+		.regions	= {
+			ERASEINFO( 0x01000, 128 )
+		}
+	}, {
+		.mfr_id		= MANUFACTURER_PMC,
 		.dev_id		= PM49FL002,
 		.name		= "PMC Pm49FL002",
 		.devtypes	= CFI_DEVICETYPE_X8,
@@ -1876,13 +1890,16 @@
 	}
 
 	cfi_send_gen_cmd(0xF0, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
+	ndelay(FLASH_TIDA);	// delay before continuing
 	/* Some misdesigned Intel chips do not respond for 0xF0 for a reset,
 	 * so ensure we're in read mode.  Send both the Intel and the AMD command
 	 * for this.  Intel uses 0xff for this, AMD uses 0xff for NOP, so
 	 * this should be safe.
 	 */
+#if 0
 	cfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);
-	/* FIXME - should have reset delay before continuing */
+	ndelay(FLASH_TIDA);	// delay before continuing
+#endif
 }
 
 
@@ -2060,7 +2077,7 @@
 		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);
 	}
 	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
-	/* FIXME - should have a delay before continuing */
+	ndelay(FLASH_TIDA);	// delay before continuing
 
  match_done:
 	return rc;
@@ -2109,7 +2126,7 @@
 		cfi_send_gen_cmd(0x55, cfi->addr_unlock2, base, map, cfi, cfi->device_type, NULL);
 	}
 	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, base, map, cfi, cfi->device_type, NULL);
-	/* FIXME - should have a delay before continuing */
+	ndelay(FLASH_TIDA);	// delay before continuing
 
 	if (!cfi->numchips) {
 		/* This is the first time we're called. Set up the CFI
@@ -2193,8 +2210,8 @@
 	jedec_reset(base, map, cfi);
 
 	printk(KERN_INFO "%s: Found %d x%d devices at 0x%x in %d-bit bank\n",
-	       map->name, cfi_interleave(cfi), cfi->device_type*8, base,
-	       map->bankwidth*8);
+	       map->name, cfi_interleave(cfi), cfi->device_type*8,
+	       map->phys + base, map->bankwidth*8);
 
 	return 1;
 }
diff -ruaN linux-2.6.31/drivers/mtd/Makefile linux-2.6/drivers/mtd/Makefile
--- linux-2.6.31/drivers/mtd/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -29,6 +29,7 @@
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
+# Move nand/ before maps/ so that lf1000 NOR chip shows up later
+obj-y		+= chips/ lpddr/ devices/ nand/ maps/ onenand/ tests/
 
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff -ruaN linux-2.6.31/drivers/mtd/maps/Kconfig linux-2.6/drivers/mtd/maps/Kconfig
--- linux-2.6.31/drivers/mtd/maps/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/maps/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -160,6 +160,13 @@
 	  More info at
 	  <http://www.arcomcontrols.com/products/icp/pc104/processors/SBC_GX1.htm>.
 
+config MTD_LF1000
+	tristate "CFI Flash device mapped on LeapFrog LF1000 based boards"
+	depends on ARCH_LF1000 && ( MTD_CFI || MTD_JEDECPROBE || MTD_ROM )
+	select MTD_PARTITIONS
+	help
+	  This provides a driver for the NOR flash attached to the LF1000 chip.
+
 config MTD_PXA2XX
 	tristate "CFI Flash device mapped on Intel XScale PXA2xx based boards"
 	depends on (PXA25x || PXA27x) && MTD_CFI_INTELEXT
diff -ruaN linux-2.6.31/drivers/mtd/maps/lf1000-flash.c linux-2.6/drivers/mtd/maps/lf1000-flash.c
--- linux-2.6.31/drivers/mtd/maps/lf1000-flash.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/maps/lf1000-flash.c	2012-11-13 20:29:32.000000000 -0800
@@ -0,0 +1,251 @@
+/*
+ * Map driver for LeapFrog LF1000 platform.
+ * Based on pxa2xx-flash.c driver
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/cacheflush.h>
+
+#include <asm/mach/flash.h>
+
+static void lf1000_map_inval_cache(struct map_info *map, unsigned long from,
+				      ssize_t len)
+{
+	flush_ioremap_region(map->phys, map->cached, from, len);
+}
+
+struct lf1000_flash_info {
+	struct mtd_partition	*parts;
+	struct mtd_info		*mtd;
+	unsigned int		nr_parts;
+	struct map_info		map;
+};
+
+
+static const char *probes[] = { "cmdlinepart", NULL };
+
+int lf1000_mtd_probe_flash(struct lf1000_flash_info* info,
+			   struct flash_platform_data* flash)
+{
+        info->map.virt = ioremap(info->map.phys, info->map.size);
+        if (!info->map.virt) {
+                printk(KERN_WARNING "Failed to ioremap %s\n",
+                       info->map.name);
+                return -ENOMEM;
+        }
+        info->map.cached =
+                ioremap_cached(info->map.phys, info->map.size);
+        if (!info->map.cached)
+                printk(KERN_WARNING "Failed to ioremap cached %s\n",
+                       info->map.name);
+        info->map.inval_cache = lf1000_map_inval_cache;
+        simple_map_init(&info->map);
+
+        printk(KERN_NOTICE
+               "Probing %s at physical address 0x%08x"
+               " (%d-bit bankwidth)\n",
+               info->map.name, info->map.phys,
+               info->map.bankwidth * 8);
+
+        info->mtd = do_map_probe(flash->map_name, &info->map);
+	return(0);
+}
+
+
+static int __init lf1000_flash_probe(struct platform_device *pdev)
+{
+	struct flash_platform_data *flash = pdev->dev.platform_data;
+	struct lf1000_flash_info *info;
+	struct mtd_partition *parts;
+	struct resource *res;
+	int ret = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	info = kmalloc(sizeof(struct lf1000_flash_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	memset(info, 0, sizeof(struct lf1000_flash_info));
+	info->map.name = (char *) flash->name;
+	info->map.bankwidth = flash->width;
+	info->map.phys = res->start;
+	info->map.size = res->end - res->start + 1;
+	info->parts = flash->parts;
+	info->nr_parts = flash->nr_parts;
+
+	ret = lf1000_mtd_probe_flash(info, flash);
+	printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+	if (ret < 0) {	// error mapping flash
+		return(ret);
+	}
+
+	/*
+ 	 * If NOR not found, maybe try a second HIGH address.
+ 	 * We can't tell if system booted from internal NAND
+ 	 * or external ATAP cartridge.
+ 	 */
+	if (!info->mtd) {
+		printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+		if (info->map.virt)
+			iounmap((void *)info->map.virt);
+		if (info->map.cached) {
+			printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+			iounmap(info->map.cached);
+		}
+		/* NOR not found, maybe try a second HIGH address */
+		if (info->map.phys != LF1000_NOR_FLASH_BASE_HIGH0)
+			return -ENXIO;
+
+		printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+		/* Look for NOR at second address */
+		res->start = LF1000_NOR_FLASH_BASE_HIGH1;
+		res->end   = res->start + LF1000_NOR_FLASH_SIZE - 1;
+		info->map.phys = res->start;
+		ret = lf1000_mtd_probe_flash(info, flash);
+
+		if (ret < 0) {	// error mapping flash
+			printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+			return(ret);
+		}
+
+		if (!info->mtd) {  /* NOR not found at second address */
+			printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+			if (info->map.virt)
+				iounmap((void *)info->map.virt);
+			if(info->map.cached)
+				iounmap(info->map.cached);
+				release_resource(res);
+			printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+			return -ENXIO;
+		}
+		printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+	}
+	info->mtd->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = parse_mtd_partitions(info->mtd, probes, &parts, 0);
+
+	printk(KERN_INFO "%s().%d\n", __FUNCTION__, __LINE__);
+
+	if (ret > 0) {
+		info->nr_parts = ret;
+		info->parts = parts;
+	}
+#endif
+
+	if (info->nr_parts) {
+		add_mtd_partitions(info->mtd, info->parts,
+				   info->nr_parts);
+	} else {
+		printk("Registering %s as whole device\n",
+		       info->map.name);
+		add_mtd_device(info->mtd);
+	}
+
+	platform_set_drvdata(pdev, info);
+	return 0;
+}
+
+static int __exit lf1000_flash_remove(struct platform_device *pdev)
+{
+	struct lf1000_flash_info *info = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		del_mtd_partitions(info->mtd);
+	else
+#endif
+		del_mtd_device(info->mtd);
+
+	map_destroy(info->mtd);
+	iounmap(info->map.virt);
+	if (info->map.cached)
+		iounmap(info->map.cached);
+	kfree(info->parts);
+	kfree(info);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_flash_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct lf1000_flash_info *info = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (info)
+		ret = info->mtd->suspend(info->mtd);
+
+	return ret;
+}
+
+static int lf1000_flash_resume(struct platform_device *pdev)
+{
+	struct lf1000_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info->mtd && info->mtd->resume)
+		info->mtd->resume(info->mtd);
+	return 0;
+}
+static void lf1000_flash_shutdown(struct platform_device *pdev)
+{
+	struct lf1000_flash_info *info = platform_get_drvdata(pdev);
+
+	if (info && info->mtd->suspend(info->mtd) == 0)
+		info->mtd->resume(info->mtd);
+}
+#else
+#define lf1000_flash_suspend NULL
+#define lf1000_flash_resume NULL
+#define lf1000_flash_shutdown NULL
+#endif
+
+static struct platform_driver lf1000_flash_driver = {
+	.probe		= lf1000_flash_probe,
+	.remove		= __exit_p(lf1000_flash_remove),
+	.suspend	= lf1000_flash_suspend,
+	.resume		= lf1000_flash_resume,
+	.shutdown	= lf1000_flash_shutdown,
+	
+	.driver 	= {
+		.name	= "lf1000-flash",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init init_lf1000_flash(void)
+{
+	return platform_driver_register(&lf1000_flash_driver);
+}
+
+static void __exit cleanup_lf1000_flash(void)
+{
+	platform_driver_unregister(&lf1000_flash_driver);
+}
+
+module_init(init_lf1000_flash);
+module_exit(cleanup_lf1000_flash);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("MTD map driver for LeapFrog LF1000");
diff -ruaN linux-2.6.31/drivers/mtd/maps/Makefile linux-2.6/drivers/mtd/maps/Makefile
--- linux-2.6.31/drivers/mtd/maps/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/maps/Makefile	2012-11-13 20:52:46.000000000 -0800
@@ -18,6 +18,7 @@
 obj-$(CONFIG_MTD_ICHXROM)	+= ichxrom.o
 obj-$(CONFIG_MTD_CK804XROM)	+= ck804xrom.o
 obj-$(CONFIG_MTD_TSUNAMI)	+= tsunami_flash.o
+obj-$(CONFIG_MTD_LF1000)	+= lf1000-flash.o
 obj-$(CONFIG_MTD_PXA2XX)	+= pxa2xx-flash.o
 obj-$(CONFIG_MTD_MBX860)	+= mbx860.o
 obj-$(CONFIG_MTD_CEIVA)		+= ceiva.o
diff -ruaN linux-2.6.31/drivers/mtd/mtdchar.c linux-2.6/drivers/mtd/mtdchar.c
--- linux-2.6.31/drivers/mtd/mtdchar.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/mtdchar.c	2011-01-04 13:50:21.000000000 -0800
@@ -21,7 +21,11 @@
 
 #include <asm/uaccess.h>
 
-
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM
+#include <linux/io.h>
+#include <linux/mtd/nand.h>
+#include <linux/delay.h>
+#endif
 /*
  * Data structure to hold the pointer to the mtd device as well
  * as mode information ofr various use cases.
@@ -29,6 +33,9 @@
 struct mtd_file_info {
 	struct mtd_info *mtd;
 	enum mtd_file_modes mode;
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM
+	int  otp_flag;
+#endif	
 };
 
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
@@ -105,6 +112,9 @@
 		goto out;
 	}
 	mfi->mtd = mtd;
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM		
+	mfi->otp_flag = 0;
+#endif	
 	file->private_data = mfi;
 
 out:
@@ -121,6 +131,10 @@
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM		
+	mfi->otp_flag = 0;
+#endif	
+
 	/* Only sync if opened RW */
 	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
 		mtd->sync(mtd);
@@ -230,6 +244,109 @@
 	return total_retlen;
 } /* mtd_read */
 
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM
+
+#define OTP_SANDISK_PAGESIZE   512
+#define OTP_SANDISK_PAGESIZE_SHIFT   9
+
+/* return value negative: something wrong, positive, number of bytes written */
+static ssize_t mtd_write_sandisk_otp(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
+{
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
+	char *kbuf;
+
+	uint8_t b1;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t addr;
+	int i;
+		
+	if(count != OTP_SANDISK_PAGESIZE) {
+		printk(KERN_ERR "Only support write to OTP %dbyte per write !\n", OTP_SANDISK_PAGESIZE);
+		return -EINVAL;
+	}
+
+	kbuf=kmalloc(count, GFP_KERNEL);
+	if (!kbuf)
+		return -ENOMEM;
+	
+	if (copy_from_user(kbuf, buf, count)) {
+		kfree(kbuf);
+		return -EFAULT;
+	}
+	// printk(KERN_INFO "Program offset at %lld \n", *ppos);
+	
+	chip->select_chip(mtd, 0);
+	udelay(2);
+	chip->cmd_ctrl(mtd, NAND_CMD_SEQIN, NAND_CLE);
+	
+	addr = *ppos;
+	
+	if((addr & 0x01FF) != 0) {
+		printk(KERN_ERR "Error, address is not page aligned, addr = 0x%x\n", addr);
+	}
+	
+#if 0	
+	chip->cmd_ctrl(mtd, addr, NAND_ALE);
+	chip->cmd_ctrl(mtd, (addr>> 8), NAND_ALE);
+	chip->cmd_ctrl(mtd, (addr>> 16), NAND_ALE);
+	chip->cmd_ctrl(mtd, (addr>> 24), NAND_ALE);
+#else
+	addr = addr >> OTP_SANDISK_PAGESIZE_SHIFT;
+	chip->cmd_ctrl(mtd, 0, NAND_ALE);
+	chip->cmd_ctrl(mtd, (addr>>0), NAND_ALE);	
+	chip->cmd_ctrl(mtd, (addr>>8), NAND_ALE);
+	chip->cmd_ctrl(mtd, (addr>>16), NAND_ALE);
+#endif	
+	
+	for( i=0; i<OTP_SANDISK_PAGESIZE; i++ )	
+		writeb(kbuf[i], chip->IO_ADDR_W);
+	
+	chip->cmd_ctrl(mtd, NAND_CMD_PAGEPROG, NAND_CLE);
+
+	#if 1
+	chip->cmd_ctrl(mtd, NAND_CMD_STATUS, NAND_CLE);
+	for(i=0; i<80; i++) {
+		b1 = readb(chip->IO_ADDR_R);
+		
+		/* page successfully written */
+		if(b1 & 0x40) {
+			*ppos += OTP_SANDISK_PAGESIZE;				
+			kfree(kbuf);
+			
+			/* is it the end of the chip*/
+			if(*ppos == mtd->size) {
+				mfi->otp_flag = 0;
+				printk(KERN_INFO "Driver: Program OTP at the end i=%d !! \n", i);				
+			}
+			return OTP_SANDISK_PAGESIZE;
+		}
+		udelay(100);
+	}
+	#else
+	for(i=0; i<80; i++) {
+		if(chip->dev_ready(mtd)) {
+			*ppos += OTP_SANDISK_PAGESIZE;				
+			kfree(kbuf);
+
+			/* is it the end of the chip*/
+			if(*ppos == mtd->size) {
+				mfi->otp_flag = 0;
+			}
+			return OTP_SANDISK_PAGESIZE;
+		}
+		udelay(100);
+	}
+	#endif
+
+	printk(KERN_INFO "Program offset at %lld time out !! \n", *ppos);
+	
+	mfi->otp_flag = 0;
+	kfree(kbuf);
+	return -EFAULT;
+}
+#endif
+
 static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
 {
 	struct mtd_file_info *mfi = file->private_data;
@@ -242,6 +359,12 @@
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
 
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM
+	if((strcmp(mtd->name, "Cartridge") == 0)  && (mfi->otp_flag == 1)){
+		return mtd_write_sandisk_otp(file, buf, count, ppos);
+	}
+#endif
+	
 	if (*ppos == mtd->size)
 		return -ENOSPC;
 
@@ -772,6 +895,57 @@
 	}
 #endif
 
+#ifdef CONFIG_MTD_OTP_SANDISK_PROGRAM
+	case SDOTPPREP:
+	{
+		uint8_t b1, b2;
+		struct nand_chip *chip;
+	
+		chip = mtd->priv;
+		if(!chip) {
+			printk(KERN_ERR "SDOTPPREP, mtd->priv null !!\n");
+			return -EOPNOTSUPP;
+		}
+		
+		// printk(KERN_INFO "page_shift=0x%x, pagemask = 0x%x, \n", chip->page_shift, chip->pagemask);
+
+		
+		chip->select_chip(mtd, 0);         /* 0: select chip, -1: deselect chip */
+
+		/* first verify that the mtd is the right device type */
+		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+		udelay(10);
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+		b1 = chip->read_byte(mtd);
+		b2 = chip->read_byte(mtd);
+		if ((0x45 != b1) ||  (0x76 != b2)) {
+			printk(KERN_ERR "Not SanDisk OTP chip, b1 = 0x%u b2=0x%u\n", b1, b2);
+			return -EOPNOTSUPP;
+		}
+		
+		/* Reset */
+		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+		// wait for 10 microseconds		
+		udelay(10);
+
+		/* Read ID 3x */
+		#if 0
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+		#else
+		chip->cmd_ctrl(mtd, NAND_CMD_READID, NAND_CLE);
+		chip->cmd_ctrl(mtd, NAND_CMD_READID, NAND_CLE);
+		chip->cmd_ctrl(mtd, NAND_CMD_READID, NAND_CLE);		
+		#endif
+		
+		mfi->otp_flag = 1;
+		
+		break;
+	}
+#endif
+	
 	case ECCGETLAYOUT:
 	{
 		if (!mtd->ecclayout)
@@ -814,6 +988,50 @@
 		file->f_pos = 0;
 		break;
 	}
+	
+	case BBTERASE:
+	{
+		void bbt_erase (struct mtd_info *mtd);
+		/*** This code lifted from mtdpart.c ***/
+		/* Our partition node structure */
+		struct mtd_part {
+			struct mtd_info mtd;
+			struct mtd_info *master;
+			u_int32_t offset;
+			int index;
+			struct list_head list;
+			int registered;
+		};
+
+#define PART(x)  ((struct mtd_part *)(x))
+		struct mtd_part *part = PART(mtd);
+		struct mtd_info *master = part->master;
+		/*** End of lifting from mtdpart.c ***/
+		bbt_erase (master);
+		break;
+	}
+
+	case BBTSCAN:
+	{
+		void bbt_scan (struct mtd_info *mtd);
+		/*** This code lifted from mtdpart.c ***/
+		/* Our partition node structure */
+		struct mtd_part {
+			struct mtd_info mtd;
+			struct mtd_info *master;
+			u_int32_t offset;
+			int index;
+			struct list_head list;
+			int registered;
+		};
+
+		struct mtd_part *part = PART(mtd);
+		struct mtd_info *master = part->master;
+		/*** End of lifting from mtdpart.c ***/
+		bbt_scan (master);
+		break;
+	}
+
 
 	default:
 		ret = -ENOTTY;
diff -ruaN linux-2.6.31/drivers/mtd/mtdpart.c linux-2.6/drivers/mtd/mtdpart.c
--- linux-2.6.31/drivers/mtd/mtdpart.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/mtdpart.c	2011-01-04 13:50:21.000000000 -0800
@@ -343,6 +343,8 @@
 	}
 	list_add(&slave->list, &mtd_partitions);
 
+	slave->mtd.priv = master->priv;
+	
 	/* set up the MTD object for this partition */
 	slave->mtd.type = master->type;
 	slave->mtd.flags = master->flags & ~part->mask_flags;
diff -ruaN linux-2.6.31/drivers/mtd/nand/Kconfig linux-2.6/drivers/mtd/nand/Kconfig
--- linux-2.6.31/drivers/mtd/nand/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/nand/Kconfig	2012-11-11 20:22:20.000000000 -0800
@@ -74,6 +74,160 @@
 	help
 	  Support for NAND flash on Amstrad E3 (Delta).
 
+config MTD_NAND_LF1000
+	tristate "NAND Flash device on Leapfrog LF1000"
+	depends on ARCH_LF1000 && MTD_PARTITIONS && LF1000_GPIO
+	help
+	  Support for NAND flash on Leap Frog LF1000.
+
+config MTD_NAND_LF1000_HOTSWAP
+	bool "Cartridge hot swap support for Leapfrog LF1000"
+	default y
+	depends on MTD_NAND_LF1000
+	help
+		Support for cartridge hot swap.  
+		Say 'Y' when cartridge hot swap is desired.
+
+config MTD_OTP_SANDISK_PROGRAM
+	bool "Support programming to SanDisk OTP chip"
+	default y
+	depends on MTD_NAND_LF1000
+	help
+		Support for programming SanDisk OTP chip. 
+		Say 'Y' when you need to program Sandisk OTP chip.
+
+config MTD_NAND_LF1000_HWECC
+	bool "Hardware ECC support for Leapfrog LF1000"
+	default y
+	depends on MTD_NAND_LF1000
+	help
+		Support for hardware ECC on the LF1000 processor.  
+		Say 'Y' when MLC NAND flash is supported.
+
+config MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD
+	int "MLC block scrubbing threshold"
+	default 2
+	range 1 4
+	depends on MTD_NAND_LF1000
+	help
+	  When the MLC NAND driver detects this many bit-flip errors (or more) 
+	  while reading a page, it returns a value that indicates bit-flip 
+	  errors were detected and that it is time to copy the page's erase 
+	  eraseblock contents to another eraseblock.  (UBI calls this process 
+	  "scrubbing".)  Lower values increase wear but reduce the amount of 
+	  time that's spent correcting bit-flip errors.  Higher values reduce 
+	  wear but increase the amount of time that's spent correcting bit-flip 
+	  errors (roughly 1.5 msec per error).  Leave the default value if unsure.
+
+config MTD_NAND_LF1000_PROF
+	bool "Profiling support for Leapfrog LF1000"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Support for profiling NAND access on the LF1000 processor.
+
+config MTD_NAND_LF1000_READ_DELAY
+	bool "Support slowing read access to NAND to simulate slower parts"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Support slowing down read access to both internal and
+		cartridge NAND by X microseconds, settable from
+		/sys/device/platform/lf1000-nand/read_delay.
+
+config MTD_NAND_LF1000_DEBUG
+	bool "Additional debugging for LF1000 NAND Controller"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Additional debugging hooks for LF1000 NAND controller.  If
+		unsure, say N.
+
+config MTD_NAND_LF1000_STRESS_TEST
+	bool "Enable stress testing of NAND subsystem"
+	default n
+	select UBIFS_FS_DEBUG
+	depends on LF1000_STRESS_TEST && MTD_NAND_LF1000
+	help
+		Creates sysfs entry in
+		/sys/device/platform/lf1000-nand/stress
+		to activate various NAND stress tests.
+
+		You do not want this, say N. 
+
+config MTD_NAND_LF1000_TRACK_MLC_ERRORS
+	bool "Collects and reports info about MLC NAND read errors"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Collects and reports info about MLC NAND read errors.  If
+		unsure, say N.
+
+config MTD_NAND_LF1000_TRACK_SLC_ERRORS
+	bool "Collects and reports info about SLC NAND read errors"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Collects and reports info about SLC NAND read errors.  If
+		unsure, say N.
+
+config MTD_NAND_LF1000_TIMING_TESTS
+	bool "Collects and reports timing data for NAND operations"
+	default n
+	depends on MTD_NAND_LF1000
+	help
+		Collects and reports timing data for NAND operations.
+		When this is 'Y', tracking of MLC and SLC errors is suppressed.
+		If unsure, say N.
+
+config NAND_LF1000_P0_SIZE
+	hex "Size of Emerald_Boot partition in NAND flash."
+	depends on MTD_NAND_LF1000
+	default 0x00100000
+	help
+		Size of zeroeth partition of LF1000 NAND flash.  Must be aligned to
+		erase block size.  This is where the LF1000 bootloader
+		lives.  You probably don't want to mess with this setting.
+
+config NAND_LF1000_P1_SIZE
+	hex "Size of Kernel partition of LF1000 NAND flash."
+	depends on MTD_NAND_LF1000
+	default 0x00500000
+	help
+		Size of Kernel partition of LF1000 NAND flash.
+		Must be aligned to erase block size.  
+		Only mess with this setting if you know what you're doing.
+		The default setting is appropriate for an MLC NAND flash.
+
+config NAND_LF1000_P2_SIZE
+	hex "Size of RFS partition of LF1000 NAND flash."
+	depends on MTD_NAND_LF1000
+	default 0x02800000
+	help
+		Size of Linux Root File System partition of LF1000 NAND flash.  Must
+		be aligned to erase block size.  Only mess with this setting if you
+		know what you're doing.
+
+config NAND_LF1000_P3_SIZE
+	hex "Size of Linux Bulk partition of LF1000 NAND flash."
+	depends on MTD_NAND_LF1000
+	default 0x00000000
+	help
+		Size of Bulk partition of LF1000 NAND flash.  Must
+		be aligned to erase block size.  Only mess with this setting if you
+		know what you're doing.
+		The magic size "0" means grow to end of master MTD device.
+
+config NAND_LF1000_CART_SIZE
+	hex "Size of the LF1000 NAND Flash cartridge."
+	depends on MTD_NAND_LF1000
+	default 0x10000000
+	help
+		Size of the single partition on the LF1000 NAND Flash 
+		cartridge.  Must be aligned to block size and there may be
+		multiple partitions in the future.  Only mess with this setting
+		if you know what you're doing.
+
 config MTD_NAND_OMAP2
 	tristate "NAND Flash device on OMAP2 and OMAP3"
 	depends on ARM && MTD_NAND && (ARCH_OMAP2 || ARCH_OMAP3)
diff -ruaN linux-2.6.31/drivers/mtd/nand/lf1000.c linux-2.6/drivers/mtd/nand/lf1000.c
--- linux-2.6.31/drivers/mtd/nand/lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/lf1000.c	2012-11-16 01:34:18.000000000 -0800
@@ -0,0 +1,2740 @@
+/*
+ *  drivers/mtd/nand/lf1000.c
+ *
+ * Copyright 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ * Robert T. Dowling <rdowling@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/leds.h>
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/nand.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include "../ubi/ubi-media.h"
+#include <linux/mtd/nand_ecc.h>
+
+/*
+ * For devices which display every fart in the system on a separate LED. Is
+ * compiled away when LED support is disabled.
+ */
+DEFINE_LED_TRIGGER(nand_led_trigger);
+
+
+#ifdef CPU_LF1000
+
+    /* another type of ECC, needed for the Micron MT29F4G08ABADA */
+#define NAND_ECC_INTERNAL   ((int)NAND_ECC_HW_SYNDROME + 1)
+
+#define MAX_NUM_ERASE_BLOCKS    4096
+static u32 block_erase_counts[MAX_NUM_ERASE_BLOCKS];
+static u32 block_read_counts[MAX_NUM_ERASE_BLOCKS];
+static u32 block_write_counts[MAX_NUM_ERASE_BLOCKS];
+static u32 total_erases;
+static u32 total_reads;
+static u32 total_writes;
+static u32 total_bitflips;
+
+#define MAX_ECC_BYTES_PER_PAGE	(56)		
+	/* this is for 4KB page with 4-bit ECC / 512 bytes */
+
+static int  lf1000_cart_remove(void);
+static int  lf1000_init_cart(u32 nand_base);
+static void lf1000_init_for_MLC_nand(struct mtd_info *mtd, 
+                                     struct nand_chip *chip);
+static void lf1000_init_for_SLC_nand(struct mtd_info *mtd, 
+                                     struct nand_chip *chip);
+static void lf1000_init_mtd_info(struct mtd_info **ppmtd_info, u32 nand_base);
+static void lf1000_prepare_for_4BitEcc( struct nand_chip * pchip);
+static int  lf1000_nand_switch_ecc_mode(struct mtd_info *mtd, int ecc_mode);
+static int lf1000_nand_scan(struct mtd_info * mtd, 
+			    int		      maxchips, 
+			    u32		    * p_nand_props, 
+			    int		      cart_nand);
+static int  lf1000_nand_scan_tail(struct mtd_info *mtd);
+static int lf1000_verify_SLC_page(struct mtd_info *mtd, 
+				  const uint8_t *buf, int len);
+
+static int DisableInternalECC(struct mtd_info *mtd, 
+		 	      struct nand_chip *chip,
+			      u32 * p_nand_props,
+			      int cart_nand);
+static int EnableInternalECC(struct mtd_info *mtd, 
+		 	     struct nand_chip *chip,
+			     u32 * p_nand_props,
+			     int cart_nand);
+
+/* Here are prototypes of MTD Interface functions defined in nand_base.c */
+int  nand_block_isbad(struct mtd_info *mtd, loff_t offs);
+int  nand_block_markbad(struct mtd_info *mtd, loff_t ofs);
+int  nand_do_read_oob(struct mtd_info *mtd, loff_t from,
+                      struct mtd_oob_ops *ops);
+uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
+         				   struct mtd_oob_ops *ops, size_t len);
+void nand_resume(struct mtd_info *mtd);
+int  nand_suspend(struct mtd_info *mtd);
+void nand_sync(struct mtd_info *mtd);
+int  nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			    size_t *retlen, const uint8_t *buf);
+int  nand_write_oob(struct mtd_info *mtd, loff_t to,
+    			    struct mtd_oob_ops *ops);
+int  nand_read_subpage(struct mtd_info  *mtd, 
+                       struct nand_chip *chip, 
+                       uint32_t          data_offs, 
+                       uint32_t          readlen, 
+                       uint8_t          *bufpoi);
+
+
+int  nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
+			   		 int new_state);
+void nand_release_device(struct mtd_info *mtd);
+int  nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+			     		struct mtd_oob_ops *ops);
+int  nand_check_wp(struct mtd_info *mtd);
+int  nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
+			             int allowbbt);
+int  nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
+			           int page, int sndcmd);
+int  nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page);
+void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+        				 const uint8_t *buf);
+int  nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+    			        uint8_t *buf);
+
+/* nand_oob_8/16/64/128 are defined in nand_base.c */
+extern struct nand_ecclayout nand_oob_8;
+extern struct nand_ecclayout nand_oob_16;
+extern struct nand_ecclayout nand_oob_64;
+extern struct nand_ecclayout nand_oob_128;
+
+
+/* Enable the following #define if you want to collect nand access timing data*/
+//#define NAND_ACCESS_TIMING 1
+
+#ifdef NAND_ACCESS_TIMING
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/timer.h>
+
+
+/* If you want to collect timing data for reads from nand, enable the
+ * following #define, which enables timing in lf1000_nand_do_read_ops()
+ */
+#define TIME_NAND_READ_ENTIRE  1 
+
+/* If you want to collect timing data for writes to nand, enable one of the
+ * next two #defines.
+ *
+ * If TIME_NAND_WRITE_PARTS is defined, timing is collected separately for
+ * calculation of ECC and for actual write to nand.
+ * If TIME_NAND_WRITE_ENTIRE is defined, timing is collected for the entire
+ * calculate/write process.
+ * If both symbols are defined, the reported number of writes will increase by 2
+ * and the reported total times will not be correct.
+ */
+//#define TIME_NAND_WRITE_PARTS   1
+#define TIME_NAND_WRITE_ENTIRE  1
+
+
+#define TIMER32(r)	REG32(IO_ADDRESS(TIMER_BASE+r))
+
+/* 
+ * settings 
+ */
+#define TIMER_BASE	LF1000_TIMER3_BASE
+
+#define TIMER_CLK_SRC	1
+#define TIMER_PRES	17			/* divide by 18 */
+#define TIMER_CLK	2			/* divide by 8 */
+
+/*
+ * Timer Clock Rate:
+ *
+ * TIMER_SRC_RATE/(TIMER_PRES+1)/(TIMER_CLK+1) =
+ *
+ * 147461538/18/8 = 1024038 Hz, ~ 1.024MHz, ~1us tick
+ */
+
+/* start the stopwatch */
+void timer_start(void)
+{
+	/* make sure the timer is stopped */
+	BIT_CLR(TIMER32(TMRCONTROL), RUN);
+
+	/* zero out the timer */
+	TIMER32(TMRCOUNT) = 0;
+
+	/* run the timer */
+	BIT_SET(TIMER32(TMRCONTROL), RUN);
+}
+
+/* stop the stopwatch, and return the time */
+u32 timer_stop(void)
+{
+	BIT_CLR(TIMER32(TMRCONTROL), RUN);	/* stop the timer */
+	BIT_SET(TIMER32(TMRCONTROL), LDCNT);	/* get access to counter */
+	return TIMER32(TMRCOUNT);		/* and return it */
+}
+
+u32 nand_num_reads;
+u32 nand_read_time;
+u32 nand_read_calc_time;
+u32 nand_read_check_time;
+u32 nand_num_writes;
+u32 nand_write_time;
+u32 nand_write_calc_time;
+
+#endif  /* NAND_ACCESS_TIMING */
+
+
+
+/* control registers */
+#define MCU_Y_BASE	IO_ADDRESS(LF1000_MCU_Y_BASE)
+#define NAND_BASE	IO_ADDRESS(LF1000_MCU_S_BASE)
+
+/*
+ * Private device structure
+ *
+ *  mtd_onboard points to info about the base NAND flash
+ *  mtd_cart    points to info about the cartridge NAND flash
+ *  controller is the control structure for the LF1000's NAND hardware controller
+ */
+
+struct lf1000_nand_device {
+	void __iomem	       * mem;
+	struct mtd_info        * mtd_onboard;
+	struct mtd_info        * mtd_cart;
+	struct platform_device * pdev;
+
+	struct nand_hw_control   controller;
+	int                      cart_ready;
+	int                      cart_ubi;
+	struct semaphore         sem_hotswap;
+
+	u32			 base_nand_props;	
+	u32			 cart_nand_props;	
+#define NAND_SUPPORTS_INTERNAL_ECC	1
+#define NAND_INTERNAL_ECC_ENABLED	2
+#define NAND_SUPPORTS_ONFI		4
+
+#define NAND_INTERNAL_ECC_ENABLED_SHIFT	1
+#define NAND_SUPPORTS_ONFI_SHIFT	2
+};
+
+static struct lf1000_nand_device nand = {
+	.mem         = NULL,
+	.mtd_onboard = NULL,
+	.mtd_cart    = NULL,
+	.cart_ready  = 0,
+	.cart_ubi    = 0,
+	.base_nand_props = 0,
+	.cart_nand_props = 0
+};
+
+/*
+ * Define partitions for flash devices
+ */
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char * part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+/* We might use a config parameter for this
+ *#define LF_ERASE_BLK CONFIG_NAND_LF1000_MAX_ERASEBLK_SIZE
+ *
+ * for now, just make it 512KB, big enough for the MLC NAND chip we're using
+ * (the symbol is used only for validating the partition sizes a few lines
+ *  below)
+ */
+#define LF_ERASE_BLK 0x80000
+
+/* Just shortening the names for clearer code */
+#define LF_P0 (CONFIG_NAND_LF1000_P0_SIZE)
+#define LF_P1 (CONFIG_NAND_LF1000_P1_SIZE)
+#define LF_P2 (CONFIG_NAND_LF1000_P2_SIZE)
+#define LF_P3 (CONFIG_NAND_LF1000_P3_SIZE)
+
+#if ((LF_P0 % LF_ERASE_BLK) || (LF_P1 % LF_ERASE_BLK) || \
+     (LF_P2 % LF_ERASE_BLK) || (LF_P3 % LF_ERASE_BLK))
+#error "NAND partitions must be multiple of erase block."
+#endif
+
+
+static struct mtd_partition partition_info[] = {
+  	{ .name		= "Emerald_Boot",
+  	  .offset	= 0,
+ 	  .size		= LF_P0},
+  	{ .name		= "Kernel",
+ 	  .offset	= LF_P0,
+ 	  .size		= LF_P1},
+  	{ .name		= "RFS",
+ 	  .offset	= LF_P0 + LF_P1,
+ 	  .size		= LF_P2 },
+  	{ .name		= "Data",
+ 	  .offset	= LF_P0 + LF_P1 + LF_P2,
+ 	  .size		= MTDPART_SIZ_FULL },
+};
+
+static struct mtd_partition partition_info_recovery[] = {
+  	{ .name		= "Base",
+  	  .offset	= 0,
+ 	  .size		= MTDPART_SIZ_FULL },
+};
+
+static struct mtd_partition partition_info_cart[] = {
+	{ .name		= "Cartridge",
+	  .offset	= 0,
+ 	  .size		= MTDPART_SIZ_FULL },
+};
+
+#undef LF_P0
+#undef LF_P1
+#undef LF_P2
+#undef LF_P3
+#undef LF_ERASE_BLK
+
+/*******************
+ * sysfs Interface *
+ *******************/
+
+/* Create a new MTD device as a subset, a slice of another device */
+static ssize_t set_new_mtd( struct device           *dev, 
+                            struct device_attribute *attr, 
+                            const char              *buf, 
+                            size_t                   count)
+{
+	int old_mtd_num;
+	u32 offset, size;
+	char tag[64];
+
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	
+	static struct mtd_partition new_part[1] = { { NULL } };
+	
+	if (sscanf(buf, "%d %x %x %63s", &old_mtd_num, &offset, &size, tag) != 4)
+		return -EINVAL;
+
+	/* Nice if we could convert old_mtd_num to "1=cart, 0=base" type number */
+	mtd = old_mtd_num ? nand.mtd_cart : nand.mtd_onboard;
+	chip = mtd->priv;
+
+	new_part[0].offset = offset;
+	new_part[0].size = size;
+	tag[63] = 0;
+	new_part[0].name = kmalloc(1+strlen(tag), GFP_KERNEL);
+	strcpy (new_part[0].name, tag);
+	if (chip) {
+		spin_lock(&chip->controller->lock);
+		add_mtd_partitions(mtd, new_part, 1);
+		spin_unlock(&chip->controller->lock);
+		dev_alert(dev, "New mtd device '%s' offset=0x%x size=0x%x "
+	                       "created on %s.\n", 
+				tag, offset, size, 
+				old_mtd_num ? "cart" : "onboard");
+	}
+	else {
+		dev_alert(dev, "No MTD device found\n");
+	}
+	return count;
+}
+
+static DEVICE_ATTR(new_mtd, S_IWUSR|S_IWGRP|S_IWOTH, NULL, set_new_mtd);
+
+typedef const volatile void __iomem * tpIO;
+
+static ssize_t show_ramsize(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	uint size;
+
+	size = (readw((tpIO)(MCU_Y_BASE + MEMCFG)) >> SDRCAP) & 3;
+	switch(size) {
+		case SDRCAP_64MBIT:	return(sprintf(buf, "%s\n",  "8MB"));
+		case SDRCAP_128MBIT:	return(sprintf(buf, "%s\n", "16MB"));
+		case SDRCAP_256MBIT:	return(sprintf(buf, "%s\n", "32MB"));
+		case SDRCAP_512MBIT:	return(sprintf(buf, "%s\n", "64MB"));
+		default:		return sprintf(buf, "unknown\n");
+	}
+}
+static DEVICE_ATTR(ramsize, S_IRUSR|S_IRGRP|S_IROTH, show_ramsize, NULL);
+
+#if defined CONFIG_MTD_NAND_LF1000_DEBUG
+static ssize_t show_nand_timing(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	u32 tmp;
+
+	tmp = readl((tpIO)(NAND_BASE+MEMTIMEACS));
+	len += sprintf(buf+len, "0: ACS = %d\n", ((tmp>>22) & 0x3));
+	tmp = readl((tpIO)(NAND_BASE+MEMTIMECOS));
+	len += sprintf(buf+len, "1: COS = %d\n", ((tmp>>22) & 0x3));
+	tmp = readl((tpIO)(NAND_BASE+MEMTIMEACCH));
+	len += sprintf(buf+len, "2: ACC = %d\n", ((tmp>>12) & 0xF));
+	tmp = readl((tpIO)(NAND_BASE+MEMTIMECOH));
+	len += sprintf(buf+len, "3: COH = %d\n", ((tmp>>22) & 0x3));	
+	tmp = readl((tpIO)(NAND_BASE+MEMTIMECAH));
+	len += sprintf(buf+len, "4: CAH = %d\n", ((tmp>>22) & 0x3));	
+
+	return len;
+}
+
+static ssize_t set_nand_timing(	struct device *dev,
+				struct device_attribute *attr, 
+				const char *buf, size_t count)
+{
+	unsigned int index, value;
+	u32 tmp;
+
+	if(sscanf(buf, "%u,%u", &index, &value) != 2)
+		return -EINVAL;
+	
+	switch(index) {
+		case 0: /* ACS */
+		tmp = readl((tpIO)(NAND_BASE+MEMTIMEACS)) & ~(0x3<<22);
+		tmp |= ((0x3 & value)<<22);
+		writel(tmp, (tpIO)(NAND_BASE+MEMTIMEACS));
+		break;
+		case 1: /* COS */
+		tmp =  readl((tpIO)(NAND_BASE+MEMTIMECOS)) & ~(0x3<<22);
+		tmp |= ((0x3 & value)<<22);
+		writel(tmp, (tpIO)(NAND_BASE+MEMTIMECOS));
+		break;
+		case 2: /* ACC */
+		tmp = readl((tpIO)(NAND_BASE+MEMTIMEACCH)) & ~(0xF<<12);
+		tmp |= ((0xF & value)<<12);
+		writel(tmp, (tpIO)(NAND_BASE+MEMTIMEACCH));
+		break;
+		case 3: /* COH */   // TODO: repo shifts by 21
+		tmp = readl((tpIO)(NAND_BASE+MEMTIMECOH)) & ~(0x3<<22);
+		tmp |= ((0x3 & value)<<22);
+		writel(tmp, (tpIO)(NAND_BASE+MEMTIMECOH));
+		break;
+		case 4: /* CAH */
+		tmp = readl((tpIO)(NAND_BASE+MEMTIMECAH)) & ~(0x3<<22);
+		tmp |= ((0x3 & value)<<22);
+		writel(tmp, (tpIO)(NAND_BASE+MEMTIMECAH));
+		break;
+		default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(timing, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH, 
+		show_nand_timing, set_nand_timing);
+#endif
+
+
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+#include "prof.h"
+static unsigned long ws_n[NS_MAX], ws_sum[NS_MAX], ws_min[NS_MAX], ws_max[NS_MAX];
+static long ws_start[NS_MAX];
+static int ws_any = 0;
+
+/* From the timer module; 15 minutes worth of ticks at 4.593MHz fits in 32 bits */
+extern int read_current_timer(unsigned long *timer_value);
+
+void nand_stats_erase (void)
+{
+	int i;
+	for (i=0; i<NS_MAX; i++)
+		ws_n[i] = ws_sum[i] = 0;
+}
+
+/* Accumulate a start (in=1) or stop (in=0) time for a given type of access */
+void nand_stats_accum (enum prof_type type, int in)
+{
+	long stop, delta;
+	if (type >= NS_MAX) {
+		dev_alert(&nand.pdev->dev,
+				"nand_stats_accum: type=%d > NS_MAX", type);
+		return;
+	}
+	if (!ws_any) {
+		/* First time through, erase stats  */
+		nand_stats_erase ();
+		ws_any = 1;
+	}
+	read_current_timer ((unsigned long *)&stop);
+	if (in) {
+		ws_start[type] = stop;
+	} else {
+		delta = stop - ws_start[type];
+		ws_sum[type] += delta;
+		if (!ws_n[type]) {
+			/* First data point, set min and max */
+			ws_min[type] = ws_max[type] = delta;
+		} else {
+			if (ws_min[type] > delta)
+				ws_min[type] = delta;
+			if (ws_max[type] < delta)
+				ws_max[type] = delta;
+		}
+		ws_n[type]++;
+	}
+}
+
+static ssize_t show_write_stats(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	int x=0, i;
+	static char *title[] = {"Read ", "Write", "Erase", "Lock "};
+	for (i=0; i<NS_MAX; i++) {
+		if (ws_n[i]) {
+			x += sprintf (buf+x, "%s N=%ld %ld/%ld/%ld\n", 
+				      title[i], ws_n[i], ws_min[i], 
+					ws_sum[i]/ws_n[i], ws_max[i]);
+		} else {
+			x += sprintf (buf+x, "%s N=%ld %ld/%ld/%ld\n", 
+					title[i], 0L,0L,0L,0L);
+		}
+	}
+	return x;
+}
+
+static ssize_t clear_write_stats(struct device *dev, 
+				 struct device_attribute *attr, 
+				 const char *buf, 
+				 size_t count)
+{
+	nand_stats_erase ();
+	return count;
+}
+
+/* Write to this sysfs device:	clear stats.  
+ * Read:			dump out stats.  
+ * See profnand.c 
+ */
+static DEVICE_ATTR(write, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH, 
+		   show_write_stats, clear_write_stats);
+
+#endif
+/* End #ifdef CONFIG_MTD_NAND_LF1000_PROF */
+
+
+static ssize_t show_nand_accesses(struct device *dev, 
+				  struct device_attribute *attr, char *buf)
+{
+	int x;
+
+	x = sprintf (buf, "NAND accesses: page reads %d, "
+			  "page writes %d, block erasures %d, bitflips %d\n", 
+		     total_reads, total_writes, total_erases, total_bitflips);
+	return x;
+}
+
+
+static ssize_t clear_nand_accesses(struct device *dev, 
+				   struct device_attribute *attr, 
+				   const char *buf, size_t count)
+{
+    total_erases   = 0;
+    total_reads    = 0;
+    total_writes   = 0;
+    total_bitflips = 0;
+	return count;
+}
+
+static DEVICE_ATTR(nand_accesses, 
+		   S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH, 	
+		   show_nand_accesses, clear_nand_accesses);
+
+#ifdef CONFIG_MTD_NAND_LF1000_READ_DELAY
+static volatile int read_delay = 0;
+
+static ssize_t show_read_delay(	struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf (buf, "%d\n", read_delay);
+}
+
+static ssize_t set_read_delay(struct device *dev, 
+			      struct device_attribute *attr, 
+			      const char *buf, size_t count)
+{
+	if(sscanf(buf, "%d", &read_delay) != 1)
+		return -EINVAL;
+	return count;
+}
+
+static DEVICE_ATTR(read_delay, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		   show_read_delay, set_read_delay);
+#endif /* ifdef CONFIG_MTD_NAND_LF1000_READ_DELAY */
+
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+volatile int nand_stress = 0;
+
+static ssize_t show_nand_stress(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf (buf, "%d\n", nand_stress);
+}
+
+static ssize_t set_nand_stress(	struct device *dev, 
+				struct device_attribute *attr, 
+				const char *buf, size_t count)
+{
+	int ret, value;
+
+	ret = get_option(&buf, &value);
+
+	if(ret != 1)
+		return -EINVAL;
+
+	nand_stress = value;
+
+	/*
+	 * Restore any severed connections
+	 */
+	if(IS_CLR(nand_stress, CART_READ)) {
+		stress_cut_cart(0);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(stress, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		   show_nand_stress, set_nand_stress);
+
+#endif /* ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST */
+
+static ssize_t show_cart_ecc_mode(struct device *dev, 
+				  struct device_attribute *attr, char *buf)
+{
+	int cart_ecc_mode = -1;
+	
+	if (nand.mtd_cart) {
+		struct nand_chip *cart;
+		cart = (struct nand_chip *) (&nand.mtd_cart[1]);
+		if (cart) {
+			switch (cart->ecc.mode)
+			{
+			case NAND_ECC_NONE: 
+			case NAND_ECC_SOFT: 
+			case NAND_ECC_HW_SYNDROME:
+			case NAND_ECC_INTERNAL:	
+				cart_ecc_mode = cart->ecc.mode;
+				break;
+			default: cart_ecc_mode = -1; break;
+			}
+		} else {
+			dev_alert(dev, "Funky cartridge device\n");
+		}
+	} else {
+		dev_alert(dev, "No cartridge device\n");
+	}
+	return sprintf (buf, "%d\n", cart_ecc_mode);
+}
+
+static ssize_t set_cart_ecc_mode(struct device           *dev, 
+                                 struct device_attribute *attr, 
+                                 const char              *buf, 
+                                 size_t                   count)
+{
+	int cart_ecc_mode;
+	int ecc_mode = -1;
+	if(sscanf(buf, "%d", &cart_ecc_mode) != 1)
+		return -EINVAL;
+	if (nand.mtd_cart) {
+		struct mtd_info *mtd = nand.mtd_cart;
+		struct nand_chip *cart;
+		cart = (struct nand_chip *) (&nand.mtd_cart[1]);
+		if (cart) {
+			switch (cart_ecc_mode) {
+			case 0: ecc_mode = NAND_ECC_NONE; break;
+			case 1: ecc_mode = NAND_ECC_SOFT; break;
+			case 3: ecc_mode = NAND_ECC_HW_SYNDROME; break;
+			case 4: 
+				if (nand.cart_nand_props 
+					& NAND_SUPPORTS_INTERNAL_ECC) {
+					ecc_mode = NAND_ECC_INTERNAL; 
+				}
+				else {
+					dev_alert(dev, "nand doesn't support "
+							"internal ecc\n"); 
+				}
+				break;
+			default: 
+				dev_alert(dev, "Bad ecc_mode %d\n", cart_ecc_mode); 
+				break;
+			}
+			if (ecc_mode != -1) {
+				/* Delete cart parts and reinstate them */
+				struct nand_chip *chip = mtd->priv;
+				int cart_parts_nb = 0;
+				struct mtd_partition *cart_parts = NULL;
+				int switch_ecc = 0;
+
+				if (ecc_mode == chip->ecc.mode) {
+					dev_alert(dev, 
+						"Cart already in ecc_mode %d\n",
+						 cart_ecc_mode); 
+				}
+				else if (ecc_mode == NAND_ECC_INTERNAL) {
+					if (!(nand.cart_nand_props 
+						& NAND_SUPPORTS_INTERNAL_ECC)) {
+						dev_alert(dev,"Cart nand cannot"
+							"support internal ecc\n"); 
+					}
+					else if (EnableInternalECC( mtd, chip,
+							&nand.cart_nand_props, 1))
+					{
+						switch_ecc = 1;
+					}
+					else {
+						dev_alert(dev,"Failed to enable"
+							     " internal ecc\n"); 
+					}
+				}
+				else {
+					if (nand.cart_nand_props 
+						& NAND_INTERNAL_ECC_ENABLED) {
+						if (DisableInternalECC( mtd, chip,
+							&nand.cart_nand_props,1))
+						{
+							switch_ecc = 1;
+						}
+						else {
+							dev_alert(dev,
+							     "Failed to disable"
+							     " internal ecc\n"); 
+						}
+					}
+					else {
+						switch_ecc = 1;
+					}
+				}
+				if (switch_ecc) {
+					cart_parts = partition_info_cart;
+					cart_parts_nb = 
+						ARRAY_SIZE(partition_info_cart);
+					spin_lock(&chip->controller->lock);
+					del_mtd_partitions(mtd);
+					lf1000_nand_switch_ecc_mode(mtd, 
+								    ecc_mode);
+					chip->scan_bbt(mtd);
+					add_mtd_partitions(nand.mtd_cart, 
+						     cart_parts, cart_parts_nb);
+					spin_unlock(&chip->controller->lock);
+				}
+			}
+		} else {
+			dev_alert(dev, "Funky cartridge device\n");
+		}
+	}
+	else {
+		dev_alert(dev, "No cartridge device\n");
+	}
+	return count;
+}
+
+static DEVICE_ATTR(cart_ecc_mode, 
+		   S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		   show_cart_ecc_mode, set_cart_ecc_mode);
+
+
+#ifdef CONFIG_MTD_NAND_LF1000_HOTSWAP
+static ssize_t get_cart_hotswap_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ready = 0;
+
+	/* first make sure mtd_cart is allocated */
+	if(nand.mtd_cart != NULL) {
+		ready = nand.cart_ready;
+	}
+	return sprintf (buf, "%d\t%d\n", ready, nand.cart_ubi);
+}
+
+static ssize_t set_cart_hotswap_state(struct device *dev, 
+				      struct device_attribute *attr, 
+				      const char *buf, size_t count)
+{
+	struct resource *res;
+	int cart_parts_nb = 0;
+	int hotswap_state;
+	struct platform_device *pdev__ ;	
+	struct mtd_partition *cart_parts = NULL;
+	size_t nread;
+	uint32_t magic;
+	ssize_t ret = count;
+
+	if(sscanf(buf, "%d", &hotswap_state) != 1)
+		return -EINVAL;
+
+	pdev__= to_platform_device(dev);
+	res = platform_get_resource(pdev__, IORESOURCE_MEM, 0);
+	if(!res) {
+		dev_err(dev, "nand: failed to get resource!\n");
+		return -ENXIO;
+	}
+
+	if (down_interruptible(&nand.sem_hotswap))
+		return -ERESTARTSYS;
+	
+	/* cart is inserted */
+	if(hotswap_state) {
+		
+		/* check if a cartridge is inserted */
+		gpio_configure_pin(NAND_CART_DETECT_PORT, NAND_CART_DETECT_PIN,
+                		   GPIO_GPIOFN, 0, 1, 0);
+		if (gpio_get_val(NAND_CART_DETECT_PORT, NAND_CART_DETECT_PIN) 
+		    != NAND_CART_DETECT_LEVEL) {
+			dev_err(dev, "cartridge insertion "
+				     "can't be confirmed by driver\n");
+			ret = -EAGAIN;
+			goto out;
+		} else {
+			int i = 0;
+			int scan;
+
+			dev_info(dev, "cartridge inserted\n");
+			
+			if(nand.cart_ready == 1){
+				dev_err(dev, "cartridge driver was ready\n");
+				goto out;
+			}
+			
+			if(lf1000_init_cart(res->start)) {
+				nand.cart_ready = -1;
+				if(nand.mtd_cart)
+					kfree(nand.mtd_cart);
+				ret = -EPERM;
+				goto out;
+			}
+			
+			do {
+				scan = lf1000_nand_scan(nand.mtd_cart, 1,
+							&nand.cart_nand_props,1);
+			} while (scan && ++i < 4);
+
+			if (i > 1)
+				dev_info(dev, 
+					"tried to scan cartridge %d times\n",i);
+			
+			if (scan) {
+				nand.cart_ready = -1;
+				dev_err(dev, "cartridge inserted, "
+					     "but NAND not detected !\n");
+				nand_release(nand.mtd_cart);
+				kfree(nand.mtd_cart);
+				nand.mtd_cart = NULL;
+				ret = -EPERM;
+				goto out;
+			}
+			
+#ifdef CONFIG_MTD_PARTITIONS
+			nand.mtd_cart->name = "lf1000-cart";
+			cart_parts_nb = parse_mtd_partitions(nand.mtd_cart,
+							     part_probes,
+							     &cart_parts, 0);
+#endif
+			if (cart_parts_nb == 0) {
+				cart_parts = partition_info_cart;
+				cart_parts_nb = ARRAY_SIZE(partition_info_cart);
+			}
+
+			/* Register the cartridge partitions, if it exists */
+			add_mtd_partitions(nand.mtd_cart, cart_parts, cart_parts_nb);
+
+			nand.mtd_cart->read(nand.mtd_cart, 0, sizeof(uint32_t),
+					   &nread, (void *)&magic);
+			magic = be32_to_cpu(magic);
+			if (magic == UBI_EC_HDR_MAGIC) {
+				nand.cart_ubi=1;
+				dev_info(dev, 
+					"cartridge has UBI layer, nread=%d\n",
+					 nread);
+			} else {
+				nand.cart_ubi=0;
+				dev_info(dev,"cartridge has no UBI, nread=%d\n",
+					 nread);
+			}
+			
+			/* Error checking */
+			if (   (gpio_get_val(NAND_CART_TYPE_PORT,
+					     NAND_CART_TYPE_EMERALD) == 0) 
+			    && (nand.cart_ubi==1))
+			{
+				dev_err(dev, "cart has UBI layer, "
+					     "but is using Emerald Cart ID\n");
+			} else if ((gpio_get_val(NAND_CART_TYPE_PORT,
+						 NAND_CART_TYPE_EMERALD) == 1)
+				   && (nand.cart_ubi==0)){
+				dev_err(dev, "cart ID is Didj, but "
+					     "no UBI layer found !!\n");
+			}
+			nand.cart_ready = 1;
+			dev_info(dev, "cart driver ready !\n");
+		}
+	} else {  /* cart is removed */
+		nand.cart_ready = 0;
+		
+		lf1000_cart_remove();
+		
+		dev_info(dev, "cartridge removed !\n");		
+	}
+out:	
+	up(&nand.sem_hotswap);	
+	
+	return ret;
+}
+static DEVICE_ATTR(cart_hotswap, 
+		   S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		   get_cart_hotswap_state, set_cart_hotswap_state);
+#endif
+
+static ssize_t get_base_nand_internal_ecc_support(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = nand.base_nand_props & NAND_SUPPORTS_INTERNAL_ECC;
+	return sprintf(buf, "%d\n", tmp);
+}
+
+static DEVICE_ATTR(base_nand_internal_ecc_support, 
+		   S_IRUSR|S_IRGRP|S_IROTH,
+		   get_base_nand_internal_ecc_support, NULL);
+
+
+static ssize_t get_base_nand_internal_ecc_enabled(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	u32 tmp;
+
+	tmp = (nand.base_nand_props & NAND_INTERNAL_ECC_ENABLED)
+		>> NAND_INTERNAL_ECC_ENABLED_SHIFT;
+	return sprintf(buf, "%d\n", tmp);
+}
+
+static DEVICE_ATTR(base_nand_internal_ecc_enabled, 
+		   S_IRUSR|S_IRGRP|S_IROTH,
+		   get_base_nand_internal_ecc_enabled, NULL);
+
+
+static ssize_t get_base_nand_ecc_mode(struct device *dev, 
+				struct device_attribute *attr, char *buf)
+{
+	struct nand_chip *chip;
+	u32    base_ecc_mode;
+
+	chip = (struct nand_chip *)nand.mtd_onboard->priv;
+	switch (chip->ecc.mode)
+	{
+	case NAND_ECC_NONE: 
+	case NAND_ECC_SOFT: 
+	case NAND_ECC_HW_SYNDROME:
+	case NAND_ECC_INTERNAL:	
+		base_ecc_mode = chip->ecc.mode;
+		break;
+	default: 
+		base_ecc_mode = -1;
+		break;
+	}
+	return sprintf (buf, "%d\n", base_ecc_mode);
+}
+
+static DEVICE_ATTR(base_nand_ecc_mode, 
+		   S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+		   get_base_nand_ecc_mode, NULL);
+
+/******************************************************************************/
+
+static struct attribute *nand_attributes[] = {
+	&dev_attr_new_mtd.attr,
+	&dev_attr_ramsize.attr,
+#if defined CONFIG_MTD_NAND_LF1000_DEBUG
+	&dev_attr_timing.attr,
+#endif
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+	&dev_attr_write.attr,
+#endif
+#ifdef CONFIG_MTD_NAND_LF1000_READ_DELAY
+	&dev_attr_read_delay.attr,
+#endif
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	&dev_attr_stress.attr,
+#endif
+
+#ifdef CONFIG_MTD_NAND_LF1000_HOTSWAP
+	&dev_attr_cart_hotswap.attr,
+#endif	
+	&dev_attr_nand_accesses.attr,
+	&dev_attr_base_nand_internal_ecc_support.attr,
+	&dev_attr_base_nand_internal_ecc_enabled.attr,
+	&dev_attr_base_nand_ecc_mode.attr,
+	NULL
+};
+
+static struct attribute_group nand_attr_group = {
+	.attrs = nand_attributes
+};
+
+/*
+ * There are 3 ways to test ready/busy bit:
+ * 1) test the RnB bit in NFCONTROL (used here)
+ * 2) test the IRQPEND bit in NFCONTROL and then set it to clear the interrupt
+ * 3) send a NAND_CMD_STATUS to then NAND chip, test the response against
+ *    the mask 0x40
+ */
+static int lf1000_nand_ready(struct mtd_info *mtd)
+{
+	u32 ctl = readl((tpIO)(NAND_BASE+NFCONTROL));
+
+	if(IS_SET(ctl,RnB))
+		return 1;	/* ready */
+	return 0;		/* busy */
+}
+
+/*
+ * hardware-specific access to control and address lines:
+ * The LF1000's NAND controller handles the CLE and ALE signals automatically,
+ * data must simply be written to the appropriate register: NFCMD or NFADDR
+ * respectively.
+ */
+static void lf1000_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if(cmd == NAND_CMD_NONE)
+		return;
+
+	if(ctrl & NAND_CLE) /* command */ {
+		writeb(cmd, chip->IO_ADDR_W + NFCMD);
+	}
+	else if(ctrl & NAND_ALE) /* address */ {
+		writeb(cmd, chip->IO_ADDR_W + NFADDR);
+	}
+}
+
+static void lf1000_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	struct nand_chip *chip = mtd->priv;
+	u32 tmp;
+
+	switch(chipnr) {
+	case -1:	/* TODO: FIXME: no need to call chip->cmd_ctrl(): 
+			 * it does nothing */
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
+		break;
+	case 0:
+		tmp = readl((tpIO)(NAND_BASE+NFCONTROL));
+		BIT_CLR(tmp, NFBANK);
+		writel(tmp, (tpIO)(NAND_BASE+NFCONTROL));
+		break;
+	default:
+		BUG();
+	}
+}
+
+static void lf1000_select_cart(struct mtd_info *mtd, int chipnr)
+{
+	struct nand_chip *chip = mtd->priv;
+	u32 tmp;
+
+	switch(chipnr) {
+	case -1:
+		chip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);
+		break;
+	case 0:
+		tmp = readl((tpIO)(NAND_BASE+NFCONTROL));
+		BIT_SET(tmp, NFBANK);
+		writel(tmp, (tpIO)(NAND_BASE+NFCONTROL));
+		break;
+	default:
+		BUG();
+	}
+}
+
+static int lf1000_init_cart(u32 nand_base)
+{
+	struct nand_chip *cart;
+	const char *s;
+
+	lf1000_init_mtd_info(&nand.mtd_cart, nand_base);
+	if(!nand.mtd_cart) {
+		dev_err(&nand.pdev->dev, "Unable to allocate cart device\n");
+		return -ENOMEM;
+	}
+	cart              = (struct nand_chip *)nand.mtd_cart->priv;
+	cart->select_chip = lf1000_select_cart;
+
+	if (! gpio_have_gpio_madrid() )
+	{
+		gpio_configure_pin( NAND_CART_TYPE_PORT, NAND_CART_TYPE_EMERALD,
+					    GPIO_GPIOFN, 0, 1, 0);
+		gpio_configure_pin( NAND_CART_TYPE_PORT, NAND_CART_TYPE_HIGH,
+					    GPIO_GPIOFN, 0, 1, 0);
+		if(gpio_get_val(NAND_CART_TYPE_PORT, NAND_CART_TYPE_HIGH) == 0) {
+			dev_info(&nand.pdev->dev, "cartridge type: OTP\n");
+			cart->ecc.mode = NAND_ECC_NONE;
+		} else {
+			dev_info(&nand.pdev->dev, "cartridge type: NAND\n");	
+			cart->ecc.mode = NAND_ECC_SOFT;
+		}
+	}
+	else
+	{
+		/* HACK: On Madrid, we can't check Cart Type pins, assume OTP for the time being */
+		cart->ecc.mode = NAND_ECC_NONE;
+	}
+
+	/* report the ECC mode that we wound up with for the cartridge */
+	switch(cart->ecc.mode) {
+	case NAND_ECC_NONE:		s="none"; break;
+	case NAND_ECC_SOFT:		s="software"; break;
+	case NAND_ECC_HW_SYNDROME:	s="hardware syndrome"; break;
+	default:			s="unknown"; break;
+	}
+	dev_info(&nand.pdev->dev, "cartridge ECC mode: %s\n", s);
+
+	return 0;
+}
+
+static int lf1000_cart_remove(void)
+{
+	/* Release resources, unregister device */
+	if(nand.mtd_cart)
+		nand_release(nand.mtd_cart);
+	
+	if(nand.mtd_cart)
+		kfree(nand.mtd_cart);
+	
+	nand.mtd_cart = NULL;
+	
+	return 0;
+}
+
+    /* returns 1 if all 'len' bytes at buf are 0xff;
+     *         0 if at least one of the first 'len' bytes at buf is not 0xff
+     */
+static int all_bytes_ff( const uint8_t * buf, int len)
+{
+	int rem   = (3 & (unsigned int)buf);
+	int allFF = 1;
+
+	if (rem) {
+		while ( (len > 0) && (rem < 4)) {
+			if (*buf++ != 0xFF) {
+				allFF = 0;
+				break;
+			}
+			++rem;
+			--len;
+		}
+	}
+	if (allFF) {
+		if (0 == (3 & (unsigned int)buf)) {
+			u32 * p = (u32 *)buf;
+
+			for ( ; len > 3; len -= 4) {
+				if (*p++ != 0xFFFFFFFF) {
+					allFF = 0;
+					break;
+				}
+			}
+			if (allFF) {
+				for (buf = (uint8_t *)p; len > 0; --len) {
+					if (*buf++ != 0xFF) {
+						allFF = 0;
+						break;
+					}
+				}
+			}
+		} else {
+			dev_info(&nand.pdev->dev, "!@#$ all_bytes_ff()\n");
+			for ( ; len > 0; --len) {
+				if (*buf++ != 0xFF) {
+					allFF = 0;
+					break;
+				}
+			}
+		}
+	}
+	return allFF;
+}
+
+/**
+ * lf1000_nand_erase - [MTD Interface] erase block(s)
+ * @mtd:	MTD device structure
+ * @instr:	erase instruction
+ *
+ * Erase one or more blocks
+ *
+ * NOTE:    This routine is a merger of nand_base.c's nand_erase() and
+ *          nand_erase_nand().  nand_erase() calls nand_erase_nand() with
+ *  a 3rd argument (allowbbt) that's 0.  This merged code assumes that
+ *  allowbbt is 0.
+ *	    This routine exists only to remove the Leapfrog-specific code
+ *  from nand_base.c.
+ *
+ * NOTE: nand_erase_nand() is also called from nand_bbt.c's write_bbt().
+ *       Its erasures will not be added to the profile data.
+ */
+#define BBT_PAGE_MASK	0xffffff3f
+static int lf1000_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	int page, status, pages_per_block, ret, chipnr;
+	struct nand_chip *chip = mtd->priv;
+	loff_t rewrite_bbt[NAND_MAX_CHIPS]={0};
+	unsigned int bbt_masked_page = 0xffffffff;
+	loff_t len;
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	int power = 0;
+#endif
+
+	DEBUG(MTD_DEBUG_LEVEL3, "nand_erase: start = 0x%012llx, len = %llu\n",
+	      (unsigned long long)instr->addr, (unsigned long long)instr->len);
+
+	/* Start address must align on block boundary */
+	if (instr->addr & ((1 << chip->phys_erase_shift) - 1)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: Unaligned address\n");
+		return -EINVAL;
+	}
+
+	/* Length must align on block boundary */
+	if (instr->len & ((1 << chip->phys_erase_shift) - 1)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: "
+		      "Length not block aligned\n");
+		return -EINVAL;
+	}
+
+	/* Do not allow erase past end of device */
+	if ((instr->len + instr->addr) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: "
+		      "Erase past end of device\n");
+		return -EINVAL;
+	}
+
+	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+
+	/* Grab the lock and see if the device is available */
+	nand_get_device(chip, mtd, FL_ERASING);
+
+	/* Shift to get first page */
+	page = (int)(instr->addr >> chip->page_shift);
+	chipnr = (int)(instr->addr >> chip->chip_shift);
+
+	/* Calculate pages in each block */
+	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
+
+	/* Select the NAND device */
+	chip->select_chip(mtd, chipnr);
+
+	/* Check, if it is write protected */
+	if (nand_check_wp(mtd)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: "
+		      "Device is write protected!!!\n");
+		instr->state = MTD_ERASE_FAILED;
+		goto erase_exit;
+	}
+
+	/*
+	 * If BBT requires refresh, set the BBT page mask to see if the BBT
+	 * should be rewritten. Otherwise the mask is set to 0xffffffff which
+	 * can not be matched. This is also done when the bbt is actually
+	 * erased to avoid recusrsive updates
+	 */
+	/* next line has the original nand_erase_nand() line from nand_base.c: 
+	 * if (chip->options & BBT_AUTO_REFRESH && !allowbbt)
+	 */
+	if (chip->options & BBT_AUTO_REFRESH)
+		bbt_masked_page = chip->bbt_td->pages[chipnr] & BBT_PAGE_MASK;
+
+	/* Loop through the pages */
+	len = instr->len;
+
+	instr->state = MTD_ERASING;
+
+	while (len) {
+		u32 eb_index;
+		/*
+		 * heck if we have a bad block, we do not erase bad blocks !
+		 */
+		/* here's the original nand_erase_nand() code from nand_base.c 
+		 * if (nand_block_checkbad(mtd, ((loff_t) page) <<
+		 *			chip->page_shift, 0, allowbbt)) 
+		 */
+		if (nand_block_checkbad(mtd, ((loff_t)page) << chip->page_shift, 
+					0, 0)) 
+	        {
+			dev_warn(&nand.pdev->dev, "nand_erase: attempt to erase"
+			       " a bad block at page 0x%08x\n", page);
+			instr->state = MTD_ERASE_FAILED;
+			goto erase_exit;
+		}
+		/*
+		 * Invalidate the page cache, if we erase the block which
+		 * contains the current cached page
+		 */
+		if (page <= chip->pagebuf 
+		    && chip->pagebuf < (page + pages_per_block))
+			chip->pagebuf = -1;
+
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+		nand_stats_accum (NS_ERASE, 1);
+#endif
+
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+		power = IS_SET(nand_stress, POWER_ERASE);
+		if(power) {
+			dev_emerg(&nand.pdev->dev, "nand_erase: cutting power"
+			      " while erasing block %d (page 0x%08x)\n",
+			      (page & chip->pagemask) / pages_per_block,
+			      page & chip->pagemask );
+
+			stress_config_power();
+		}
+#endif
+		chip->erase_cmd(mtd, page & chip->pagemask);
+		eb_index = (page & chip->pagemask) / pages_per_block;
+		if (eb_index < MAX_NUM_ERASE_BLOCKS) {
+			block_erase_counts[ eb_index ] += 1;
+			total_erases++;
+		}
+
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+		if(power) {
+			stress_cut_power();
+		}
+#endif
+		status = chip->waitfunc(mtd, chip);
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+		nand_stats_accum (NS_ERASE, 0);
+#endif
+		/*
+		 * See if operation failed and additional status checks are
+		 * available
+		 */
+		if ((status & NAND_STATUS_FAIL) && (chip->errstat))
+			status = chip->errstat(mtd, chip, FL_ERASING,
+					       status, page);
+
+		/* See if block erase succeeded */
+		if (status & NAND_STATUS_FAIL) {
+			DEBUG(MTD_DEBUG_LEVEL0, "nand_erase: "
+			      "Failed erase, page 0x%08x\n", page);
+			instr->state = MTD_ERASE_FAILED;
+			instr->fail_addr =
+				((loff_t)page << chip->page_shift);
+			goto erase_exit;
+		}
+
+		/*
+		 * If BBT requires refresh, set the BBT rewrite flag to the
+		 * page being erased
+		 */
+		if (bbt_masked_page != 0xffffffff 
+		    && (page & BBT_PAGE_MASK) == bbt_masked_page)
+			rewrite_bbt[chipnr] =
+					((loff_t)page << chip->page_shift);
+
+		/* Increment page address and decrement length */
+		len -= (1 << chip->phys_erase_shift);
+		page += pages_per_block;
+
+		/* Check, if we cross a chip boundary */
+		if (len && !(page & chip->pagemask)) {
+			chipnr++;
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
+			/*
+			 * If BBT requires refresh and BBT-PERCHIP, set the BBT
+			 * page mask to see if this BBT should be rewritten
+			 */
+			if (bbt_masked_page != 0xffffffff 
+			    && (chip->bbt_td->options & NAND_BBT_PERCHIP))
+				bbt_masked_page = chip->bbt_td->pages[chipnr] 
+						  & BBT_PAGE_MASK;
+		}
+	}
+	instr->state = MTD_ERASE_DONE;
+
+erase_exit:
+	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
+
+	/* Deselect and wake up anyone waiting on the device */
+	nand_release_device(mtd);
+
+	/* Do call back function */
+	if (!ret)
+		mtd_erase_callback(instr);
+	/*
+	 * If BBT requires refresh and erase was successful, rewrite any
+	 * selected bad block tables
+	 */
+	if (bbt_masked_page == 0xffffffff || ret)
+		return ret;
+
+	for (chipnr = 0; chipnr < chip->numchips; chipnr++) {
+		if (!rewrite_bbt[chipnr])
+			continue;
+		/* update the BBT for chip */
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_erase_nand: nand_update_bbt "
+		      "(%d:0x%0llx 0x%0x)\n", chipnr, rewrite_bbt[chipnr],
+		      chip->bbt_td->pages[chipnr]);
+		nand_update_bbt(mtd, rewrite_bbt[chipnr]);
+	}
+
+	/* Return more or less happy */
+	return ret;
+}
+
+static inline int num_zero_bits_u8(uint8_t val) {
+	int count;
+    
+	if (val == 0) {
+		count = 8;
+	} else {
+		for (val = ~val, count = 0; val; val >>= 1) {
+			if (val & 1) {
+				++count;
+			}
+		}        
+	}
+	return count;
+}
+
+static inline int num_zero_bits_u32(uint32_t val) {
+	int count;
+    
+	if (val == 0) {
+		count = 32;
+	} else {
+		for (val = ~val, count = 0; val; val >>= 1) {
+			if (val & 1) {
+				++count;
+			}
+		}        
+	}
+	return count;
+}
+
+
+/* 
+ * NAND_SUBPAGE_READ(x) is defined this way
+ * #define NAND_SUBPAGE_READ(chip) ((chip->ecc.mode == NAND_ECC_SOFT) \
+ *                                       && (chip->page_shift > 9))
+ * in linux-2.6/include/linux/mtd/nand.h.
+ *
+ * Because of this definition, NAND_SUBPAGE_READ(chip) is always false
+ * when 'chip' refers to an MLC NAND flash.
+ *
+ * Since we store 7 BCH ECC bytes for each 512-byte subpage of an MLC
+ * NAND flash, we can read subpages (in chunks that are multiples of
+ * 512 bytes).
+ *
+ * Here we change the definition of NAND_SUBPAGE_READ(x) so it's
+ * true for an MLC NAND flash. 
+ * When the ecc mode is HW_SYNDROME (i.e., when the NAND is MLC) we also 
+ * initialize ecc.read_subpage to point to lf1000_nand_read_subpage_BCH().
+ * We also change the definition so NAND_SUBPAGE_READ(x) is true for
+ * a Micron chip with internal ECC enabled.  
+ */
+#ifdef NAND_SUBPAGE_READ
+#undef NAND_SUBPAGE_READ
+#define NAND_SUBPAGE_READ(chip) \
+                     (   (   (chip->ecc.mode == NAND_ECC_SOFT) \
+                          && (chip->page_shift > 9)) \
+                      || (   (chip->ecc.mode == NAND_ECC_HW_SYNDROME) \
+                          && (chip->cellinfo & NAND_CI_CELLTYPE_MSK  )) \
+		      ||     (chip->ecc.mode == NAND_ECC_INTERNAL))
+#endif
+
+#include "lf1000_MLC_BCH.c"
+#include "lf1000_internal_ECC.c"
+
+/**
+ * lf1000_nand_do_read_ops - Leapfrog replacement for nand_do_read_ops()
+ *
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @ops:	oob ops structure
+ *
+ * Internal function. Called with chip held.
+ *
+ * Differences from nand_do_read_ops():
+ *   code for profiling
+ *   code for counting and timing read operations
+ *   use of CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD
+ *   calls to dev_info() in order to report errors.
+ */
+static int lf1000_nand_do_read_ops(struct mtd_info *mtd, loff_t from,
+			           struct mtd_oob_ops *ops)
+{
+	int chipnr, page, realpage, col, bytes, aligned;
+	struct nand_chip *chip = mtd->priv;
+	struct mtd_ecc_stats stats;
+	int blkcheck = (1 << (chip->phys_erase_shift - chip->page_shift)) - 1;
+	int sndcmd = 1;
+	int ret = 0;
+	uint32_t readlen = ops->len;
+	uint32_t oobreadlen = ops->ooblen;
+	uint8_t *bufpoi, *oob, *buf;
+	uint32_t numCorrected;
+
+	stats	     = mtd->ecc_stats;
+	numCorrected = stats.corrected;
+
+	chipnr = (int)(from >> chip->chip_shift);
+	chip->select_chip(mtd, chipnr);
+
+	realpage = (int)(from >> chip->page_shift);
+	page	 = realpage & chip->pagemask;
+
+	col = (int)(from & (mtd->writesize - 1));
+
+	buf = ops->datbuf;
+	oob = ops->oobbuf;
+
+	while(1) {
+		u32 eb_index;
+
+		bytes   = min(mtd->writesize - col, readlen);
+		aligned = (bytes == mtd->writesize);
+
+		/* Is the current page in the buffer ? */
+		if (realpage != chip->pagebuf || oob) {
+			bufpoi = aligned ? buf : chip->buffers->databuf;
+
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+			nand_stats_accum (NS_READ, 1);
+#endif
+			if (likely(sndcmd)) {
+				/* if the nand has internal ECC and if we
+				 * don't want to start reading at the beginning
+				 * of a page, specify the starting offset.
+				 * Specifying the offset here makes it 
+				 * unnecessary for the read_subpage function
+				 * to specify the offset.
+				 */
+				if (   (col > 0)
+			 	    && (chip->ecc.mode == NAND_ECC_INTERNAL))
+					chip->cmdfunc(mtd, NAND_CMD_READ0, 
+						      col, page);
+				else /* start at beginning of page */
+					chip->cmdfunc(mtd, NAND_CMD_READ0, 
+						      0x00, page);
+				sndcmd = 0;
+			}
+			/* Now read the page into the buffer */
+			if (unlikely(ops->mode == MTD_OOB_RAW))
+				ret = chip->ecc.read_page_raw(mtd, chip, bufpoi);
+			else if (!aligned && NAND_SUBPAGE_READ(chip) && !oob) {
+				/*
+				 * if the nand has internal ECC, read directly
+				 * into the destination buffer.
+				 */
+				if (chip->ecc.mode == NAND_ECC_INTERNAL)
+					bufpoi = buf;
+
+				ret = chip->ecc.read_subpage(mtd, chip, col, 
+							     bytes, bufpoi);
+			} else {
+#ifdef TIME_NAND_READ_ENTIRE
+				++nand_num_reads;
+				timer_start();
+#endif
+				ret = chip->ecc.read_page(mtd, chip, bufpoi);
+#ifdef TIME_NAND_READ_ENTIRE
+		                nand_read_time += timer_stop();
+				/* enable this 'if' to reduce output
+		                 * if (0 == (nand_num_reads % 100))
+				 */
+				dev_info(&nand.pdev->dev, "NandRead: %d, %d\n", 
+				        nand_num_reads, nand_read_time);
+#endif
+			}
+			eb_index = realpage / (blkcheck + 1);
+			if (eb_index < MAX_NUM_ERASE_BLOCKS) {
+				block_read_counts[ eb_index ] += 1;
+				total_reads++;
+			}
+			if (ret < 0) {
+                		dev_info(&nand.pdev->dev, 
+					"Error reading %d bytes from page %d\n", 
+		                        bytes, realpage);
+				break;
+			}
+			else if ( mtd->ecc_stats.corrected != numCorrected ) {
+			        numCorrected = mtd->ecc_stats.corrected;
+			        dev_info(&nand.pdev->dev, 
+					"Corrected error while reading %d bytes "
+		                        "at offset %d from page %d\n",
+		               		bytes, col, realpage);
+		    	}
+
+			/* Transfer not aligned data */
+			if (!aligned) {
+				if (!NAND_SUBPAGE_READ(chip) && !oob)
+					chip->pagebuf = realpage;
+				/* if the nand doesn't have internal ECC
+				 * (so we didn't read directly into the
+				 *  destination buffer), copy the requested
+				 *  bytes to the destination buffer.
+				 */
+				if (chip->ecc.mode != NAND_ECC_INTERNAL)
+					memcpy(buf, chip->buffers->databuf + col,
+					       bytes);
+			}
+			buf += bytes;
+
+			if (unlikely(oob)) {
+				/* Raw mode does data:oob:data:oob */
+				if (ops->mode != MTD_OOB_RAW) {
+					int toread = min(oobreadlen,
+						    chip->ecc.layout->oobavail);
+					if (toread) {
+						oob = nand_transfer_oob(chip,
+							oob, ops, toread);
+						oobreadlen -= toread;
+					}
+				} else
+					buf = nand_transfer_oob(chip,
+						buf, ops, mtd->oobsize);
+			}
+
+			if (!(chip->options & NAND_NO_READRDY)) {
+				/* Apply delay or wait for ready/busy pin. Do
+				 * this before the AUTOINCR check, so no
+				 * problems arise if a chip which does auto
+				 * increment is marked as NOAUTOINCR by the
+				 * board driver.
+				 */
+				if (!chip->dev_ready)
+					udelay(chip->chip_delay);
+				else
+					nand_wait_ready(mtd);
+			}
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+			nand_stats_accum (NS_READ, 0);
+#endif
+		} else {
+			memcpy(buf, chip->buffers->databuf + col, bytes);
+			buf += bytes;
+		}
+		readlen -= bytes;
+		if (!readlen)
+			break;
+
+		/* For subsequent reads align to page boundary. */
+		col = 0;
+		realpage++;
+
+		page = realpage & chip->pagemask;
+		/* Check if we cross a chip boundary */
+		if (!page) {
+			chipnr++;
+			chip->select_chip(mtd, -1);
+			chip->select_chip(mtd, chipnr);
+		}
+
+		/* Check if the chip supports auto page increment
+		 * or if we have hit a block boundary.
+		 */
+		if (!NAND_CANAUTOINCR(chip) || !(page & blkcheck))
+			sndcmd = 1;
+	}
+
+	ops->retlen = ops->len - (size_t) readlen;
+	if (oob)
+		ops->oobretlen = ops->ooblen - oobreadlen;
+
+	if (ret)
+		return ret;
+
+	if (mtd->ecc_stats.failed - stats.failed) {
+        	dev_info(&nand.pdev->dev, "nand_do_read_ops: ECC error: "
+                         "from %08x %08x; realpage %x; page %x; readlen %d\n",	
+                	(uint32_t)(from >> 32), (uint32_t)from, 
+                	realpage, page, ops->len);
+		return -EBADMSG;
+    	}
+#ifndef CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD
+	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
+#else
+            /* if this device is an MLC NAND, check for at least
+             * CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD bit-flip errors
+             * on the current page; if found, return -EUCLEAN.
+             * (When UBI sees that value returned, it schedules the page's
+             * erase block for scrubbing (copying to another block and then
+             * erasing)
+             */
+	if (chip->cellinfo & NAND_CI_CELLTYPE_MSK) {
+        	return  (mtd->ecc_stats.corrected - stats.corrected
+                                >= CONFIG_MTD_NAND_LF1000_MLC_SCRUB_THRESHOLD)
+                	? -EUCLEAN
+                	: 0;
+    	}
+	else {
+        	return  mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN 
+								   : 0;
+    	}
+#endif
+}
+
+/**
+ * lf1000_nand_read - Leapfrog's replacement for nand_read()
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @len:	number of bytes to read
+ * @retlen:	pointer to variable to store the number of read bytes
+ * @buf:	the databuffer to put data
+ *
+ * Get hold of the chip and call nand_do_read
+ *
+ * Leapfrog has a special version of this function in order to call
+ * lf1000_nand_do_read_ops() instead of the standard nand_do_read_ops().
+ * Except for that call, this function is identical to nand_do_read_ops().
+ */
+static int lf1000_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		                    size_t *retlen, uint8_t *buf)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size)
+		return -EINVAL;
+	if (!len)
+		return 0;
+
+	nand_get_device(chip, mtd, FL_READING);
+
+	chip->ops.len = len;
+	chip->ops.datbuf = buf;
+	chip->ops.oobbuf = NULL;
+
+	ret = lf1000_nand_do_read_ops(mtd, from, &chip->ops);
+
+	*retlen = chip->ops.retlen;
+
+	nand_release_device(mtd);
+
+	return ret;
+}
+
+/**
+ * lf1000_nand_read_oob - Leapfrog replacement for nand_read_oob().
+ * @mtd:	MTD device structure
+ * @from:	offset to read from
+ * @ops:	oob operation description structure
+ *
+ * NAND read data and/or out-of-band data
+ *
+ * This function differs from nand_read_oob() only by calling 
+ * lf1000_nand_do_read_ops() instead of nand_do_read_ops().
+ */
+static int lf1000_nand_read_oob(struct mtd_info *mtd, loff_t from,
+		            	 struct mtd_oob_ops *ops)
+{
+	struct nand_chip *chip = mtd->priv;
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if (ops->datbuf && (from + ops->len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "nand_read_oob: "
+		      "Attempt read beyond end of device\n");
+		return -EINVAL;
+	}
+	nand_get_device(chip, mtd, FL_READING);
+
+	switch(ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+	default:
+		goto out;
+	}
+	if (!ops->datbuf)
+		ret = nand_do_read_oob(mtd, from, ops);
+	else
+		ret = lf1000_nand_do_read_ops(mtd, from, ops);
+out:
+	nand_release_device(mtd);
+	return ret;
+}
+
+
+/**
+ * lf1000_nand_write_page - write one page; replaces nand_write_page()
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip descriptor
+ * @buf:	the data to write
+ * @page:	page number to write
+ * @cached:	cached programming
+ * @raw:	use _raw version of write_page
+ *
+ * We use a special version that checks for all FF before trying to write
+ * to the NAND.  This is necessary when using UBIFS on MLC NAND.
+ */
+static int lf1000_nand_write_page(struct mtd_info  *mtd, 
+                                  struct nand_chip *chip,
+	                          const uint8_t    *buf, 
+                                  int page, 
+                                  int cached, 
+                                  int raw)
+{
+	u32 eb_index;
+	int status;
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	int power = 0;
+#endif
+
+	/* First check if the page is all FF; if it is, don't bother writing
+	 * to the NAND.  Just verify that the nand page is all FF
+	 */
+	if ( !all_bytes_ff( buf, mtd->writesize) ) {
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+	    	nand_stats_accum (NS_WRITE, 1);
+#endif
+#ifdef TIME_NAND_WRITE_ENTIRE
+		++nand_num_writes;
+		timer_start();
+#endif
+		eb_index = (page & chip->pagemask) / 
+			                    (1 << (chip->phys_erase_shift 
+						   - chip->page_shift));
+		if (eb_index < MAX_NUM_ERASE_BLOCKS) {
+			block_write_counts[ eb_index ] += 1;
+		        total_writes++;
+		}
+	    	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+    		if (unlikely(raw))
+    			chip->ecc.write_page_raw(mtd, chip, buf);
+    		else
+    			chip->ecc.write_page(mtd, chip, buf);
+
+		/*
+		 * Cached progamming disabled for now, Not sure if its worth the
+		 * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
+		 */
+	    	cached = 0;
+
+	    	if (!cached || !(chip->options & NAND_CACHEPRG)) {
+
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	    		power = IS_SET(nand_stress, POWER_WRITE);
+	    		if(power) {
+	    			int pages_per_block = 
+						1 << (chip->phys_erase_shift - 
+							chip->page_shift);
+	    			dev_emerg(&nand.pdev->dev, 
+					 "nand_write: cutting power while"
+	    			         " writing page 0x%08x (block %d)\n",
+	    				  page & chip->pagemask,
+	    				 (page & chip->pagemask) 
+						/ pages_per_block );
+	    			stress_config_power();
+	    		}
+#endif
+	    		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	    		if(power) 
+	    			stress_cut_power();
+#endif
+			status = chip->waitfunc(mtd, chip);
+#ifdef TIME_NAND_WRITE_ENTIRE
+			nand_write_time += timer_stop();
+#endif
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+    			nand_stats_accum (NS_WRITE, 0);
+#endif
+			/* See if operation failed and additional status checks 
+			 * are available
+			 */
+			if ((status & NAND_STATUS_FAIL) && (chip->errstat))
+				status = chip->errstat(mtd, chip, FL_WRITING,
+							status, page);
+			if (status & NAND_STATUS_FAIL)
+				return -EIO;
+    		} 
+        	else { /* cached */
+			chip->cmdfunc(mtd, NAND_CMD_CACHEDPROG, -1, -1);
+    			status = chip->waitfunc(mtd, chip);
+#ifdef TIME_NAND_WRITE_ENTIRE
+            		nand_write_time += timer_stop();
+
+#endif
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+    			nand_stats_accum (NS_WRITE, 0);
+#endif
+	    	}
+	}   /* !all_bytes_ff */
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+        eb_index = (page & chip->pagemask) / 
+                        (1 << (chip->phys_erase_shift - chip->page_shift));
+        if (eb_index < MAX_NUM_ERASE_BLOCKS) {
+            block_read_counts[ eb_index ] += 1;
+            total_reads++;
+        }
+	if (chip->verify_buf(mtd, buf, mtd->writesize))
+		return -EIO;
+#endif
+	return 0;
+}
+
+
+
+/**
+ * lf1000_nand_write_page_swecc - [REPLACABLE] software ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ *
+ * NOTE: This routine is identical to nand_write_page_swecc() EXCEPT for the
+ *       code that's been added to count and time write operations.
+ */
+static void lf1000_nand_write_page_swecc(struct mtd_info  *mtd, 
+                                         struct nand_chip *chip,
+				         const uint8_t    *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+#ifdef TIME_NAND_WRITE_PARTS
+	++nand_num_writes;
+	timer_start();
+#endif
+	/* Software ecc calculation */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+#ifdef TIME_NAND_WRITE_PARTS
+	nand_write_calc_time += timer_stop();
+#endif
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+#ifdef TIME_NAND_WRITE_PARTS
+	timer_start();
+#endif
+
+	chip->ecc.write_page_raw(mtd, chip, buf);
+#ifdef TIME_NAND_WRITE_PARTS
+	nand_write_time += timer_stop();
+
+	/* enable this 'if' to reduce the amount of output
+	 * if (0 == (nand_num_writes % 100))
+	 */
+	dev_info(&nand.pdev->dev, "NandWrite: %d, %d, %d\n", 
+	         nand_num_writes, nand_write_time, nand_write_calc_time);
+#endif
+}
+
+/**
+ * lf1000_nand_read_page_swecc - replaces nand_read_page_swecc() when
+ *                               timing of nand reads is enabled.
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ *
+ * NOTE: This routine is identical to nand_read_page_swecc() EXCEPT for the
+ *       code that's been added to count and time read operations.
+ */
+static int lf1000_nand_read_page_swecc( struct mtd_info *mtd, 
+                                        struct nand_chip *chip,
+                        				uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint8_t *ecc_code = chip->buffers->ecccode;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+#ifdef TIME_NAND_READ
+	++nand_num_reads;
+	timer_start();
+#endif
+	chip->ecc.read_page_raw(mtd, chip, buf);
+#ifdef TIME_NAND_READ
+	nand_read_time += timer_stop();
+	timer_start();
+#endif
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+#ifdef TIME_NAND_READ
+	nand_read_calc_time += timer_stop();
+	timer_start();
+#endif
+	for (i = 0; i < chip->ecc.total; i++)
+		ecc_code[i] = chip->oob_poi[eccpos[i]];
+
+	eccsteps = chip->ecc.steps;
+	p	 = buf;
+
+	for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		int stat;
+
+		stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
+	}
+#ifdef TIME_NAND_READ
+	nand_read_check_time += timer_stop();
+
+	/* enable this 'if' to reduce the amount of output
+	 * if (0 == (nand_num_reads % 100))
+	 */
+	dev_info(&nand.pdev->dev, "NandRead: %d, %d, %d, %d\n", 
+	          nand_num_reads, nand_read_time, 
+        	  nand_read_calc_time, nand_read_check_time);
+#endif
+	return 0;
+}
+
+
+/**
+ * lf1000_nand_read_buf - read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ * Differs from nand_read_buf() by using 32-bit access to the LF1000's
+ * NAND Flash Data register when possible.
+ */
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+extern void lf1000_select_cart(struct mtd_info *mtd, int chipnr);
+#endif
+
+static void lf1000_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	uint8_t *b   = buf;
+	int      rem = (3 & (unsigned int)b);
+	struct nand_chip    *chip = mtd->priv;
+	tpIO A = chip->IO_ADDR_R;
+
+#ifdef CONFIG_MTD_NAND_LF1000_STRESS_TEST
+	if( IS_SET(nand_stress, CART_READ) &&
+	    (chip->select_chip == lf1000_select_cart) )	{
+		stress_cut_cart(1);
+	}
+#endif
+	if (rem) {
+	        while ( (len > 0) && (rem < 4)) {
+			*b++ = readb(A);
+            		++rem;
+            		--len;
+        	}
+	}
+	if (0 == (3 & (unsigned int)b)) {
+	        u32 * p = (u32 *)b;
+		for (i = 0; i < len - 3; i += 4) {
+			*p++ = readl(A);
+        	}
+        	b = (uint8_t *)p;
+	    	while (i++ < len) {
+			*b++ = readb(A);
+        	}
+	}
+	else {
+	        dev_info(&nand.pdev->dev, 
+			 "!@#$ Unexpected path through nand_read_buf()\n");
+		for (i = 0; i < len; i++)
+			*b++ = readb(A);
+	}
+}
+
+
+
+/**
+ * lf1000_nand_write_buf - write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ * Differs from nand_write_buf() by using 32-bit access to the LF1000's
+ * NAND Flash Data register when possible.
+ */
+static void lf1000_nand_write_buf(struct mtd_info * mtd, 
+                                  const uint8_t   * buf, 
+                                  int               len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+	int rem = (3 & (unsigned int)buf);
+
+	/* NOTE:   This function is called many times  
+	 *          (Currently 8 times per page: 4 for 512-byte subpages and
+	 *           4 for 7-byte ECC codes.
+	 */
+	if ((rem == 0) && (0 == (3 & len))) {
+		/* we'll use 32-bit access if buffer is on a 4-byte boundary
+		 * and len is a multiple of 4
+		 */
+		u32 * p = (u32 *)buf;
+		for (i = 0; i < len; i += 4) {
+			writel(*p++, chip->IO_ADDR_W);
+        	}
+	}
+	else {
+	        for (i = 0; i < len; i++)
+		        writeb(buf[i], chip->IO_ADDR_W);
+	}
+}
+
+
+/**
+ * lf1000_nand_wait - [DEFAULT]  wait until the command is done
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip structure
+ *
+ * Wait for command done. This applies to erase and program only
+ * Erase can take up to 400ms and program up to 20ms according to
+ * general NAND and SmartMedia specs.
+ *
+ * This function differs from nand_wait() by calling ndelay(2000) instead of
+ * ndelay(100).  The additional delay seemed to make 32-bit writes to the
+ * LF1000's NAND Flash Data register work ok.
+ */
+static int lf1000_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+
+	unsigned long timeo = jiffies;
+	int status, state = chip->state;
+
+	if (state == FL_ERASING)
+		timeo += (HZ * 400) / 1000;
+	else
+		timeo += (HZ * 20) / 1000;
+
+	led_trigger_event(nand_led_trigger, LED_FULL);
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+	ndelay(2000);
+
+	if ((state == FL_ERASING) && (chip->options & NAND_IS_AND))
+		chip->cmdfunc(mtd, NAND_CMD_STATUS_MULTI, -1, -1);
+	else
+		chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+
+	while (time_before(jiffies, timeo)) {
+		if (chip->dev_ready) {
+			if (chip->dev_ready(mtd))
+				break;
+		} else {
+			if (chip->read_byte(mtd) & NAND_STATUS_READY)
+				break;
+		}
+		cond_resched();
+	}
+	led_trigger_event(nand_led_trigger, LED_OFF);
+
+	status = (int)chip->read_byte(mtd);
+	return status;
+}
+
+
+
+/* If this routine fails to allocate mtd_info and nand_chip structures, 
+ * on return from the routine *ppmtd_info will be NULL.
+ */
+static void lf1000_init_mtd_info(struct mtd_info **ppmtd_info, u32 nand_base)
+{
+	struct nand_chip *pchip;
+
+	*ppmtd_info = kmalloc(sizeof(struct mtd_info) +
+			                sizeof(struct nand_chip), GFP_KERNEL);
+	if(!*ppmtd_info)
+		return;
+
+	memset(*ppmtd_info, 0, sizeof(struct mtd_info)+ sizeof(struct nand_chip));
+
+	(*ppmtd_info)->owner = THIS_MODULE;
+
+	/* Get pointer to private data */
+	pchip = (struct nand_chip *) (&((*ppmtd_info)[1]));
+
+	/* Link the private data with the MTD structure */
+	(*ppmtd_info)->priv = pchip;
+
+	pchip->controller = &nand.controller;
+
+	/* Set address of NAND IO lines */
+	pchip->IO_ADDR_R   = (void __iomem *)(IO_ADDRESS(nand_base+NFDATA));
+	pchip->IO_ADDR_W   = (void __iomem *)(IO_ADDRESS(nand_base+NFDATA));
+
+	pchip->dev_ready   = lf1000_nand_ready;
+	pchip->options     = 0; /* 8 bit bus width */
+	pchip->cmd_ctrl    = lf1000_hwcontrol; /* hardware access for cmd, addr */
+	pchip->write_page  = lf1000_nand_write_page;
+	pchip->read_buf    = lf1000_nand_read_buf;
+	pchip->write_buf   = lf1000_nand_write_buf;
+	pchip->waitfunc    = lf1000_nand_wait;
+
+	/* 25 us command delay time */
+	pchip->chip_delay  = 25;
+}
+
+
+
+static int lf1000_verify_SLC_page(struct mtd_info *mtd, 
+                                  const uint8_t *buf, 
+                                  int len)
+{
+	/* When using MLC, we must verify writes.  
+	 * When using SLC, we don't need to, but the kernel configuration 
+	 * parameter causes us to do so.  
+	 * Because SLC allows subpage writes, and because the default
+	 * nand_verify_buf() doesn't work correctly in that case, we
+	 * just skip the verification and say it was ok.
+	 */
+	return 0;
+}
+
+
+static void lf1000_set_soft_ecc(struct nand_chip *chip)
+{
+	chip->ecc.calculate      = nand_calculate_ecc;
+	chip->ecc.correct        = nand_correct_data;
+	chip->ecc.read_page      = lf1000_nand_read_page_swecc;
+	chip->ecc.read_subpage   = nand_read_subpage;
+	chip->ecc.write_page     = lf1000_nand_write_page_swecc;
+	chip->ecc.read_page_raw  = nand_read_page_raw;
+	chip->ecc.write_page_raw = nand_write_page_raw;
+	chip->ecc.read_oob       = nand_read_oob_std;
+	chip->ecc.write_oob      = nand_write_oob_std;
+	chip->ecc.size           = 256;
+	chip->ecc.bytes          = 3;
+}
+
+static void lf1000_set_no_ecc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	dev_warn(&nand.pdev->dev, "NAND_ECC_NONE selected by board driver. "
+	        	        "This is not recommended !!\n");
+	chip->ecc.read_page      = nand_read_page_raw;
+	chip->ecc.read_page_raw  = nand_read_page_raw;
+	chip->ecc.write_page     = nand_write_page_raw;
+	chip->ecc.write_page_raw = nand_write_page_raw;
+	chip->ecc.read_oob       = nand_read_oob_std;
+	chip->ecc.write_oob      = nand_write_oob_std;
+	chip->ecc.size           = mtd->writesize;
+	chip->ecc.bytes          = 0;
+}
+
+/**
+ * lf1000_nand_switch_ecc_mode - [NAND Interface] Scan for the NAND device
+ * @mtd:	    MTD device structure
+ * @maxchips:	    Number of chips to scan for
+ *
+ * Change ECC mode on master MTD device
+ */
+static int lf1000_nand_switch_ecc_mode(struct mtd_info *mtd, int ecc_mode)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	chip->ecc.mode = ecc_mode;
+	switch (chip->ecc.mode) {
+
+	case NAND_ECC_HW_SYNDROME:
+        	lf1000_set_hw_syndrome_ecc(chip);
+		if (mtd->writesize >= chip->ecc.size)
+			break;
+		dev_warn(&nand.pdev->dev, "%d byte HW ECC not possible on "
+		       "%d byte page size, fallback to SW ECC\n",
+		       chip->ecc.size, mtd->writesize);
+		chip->ecc.mode = NAND_ECC_SOFT;
+		/* drop through here */
+	case NAND_ECC_SOFT:
+        	lf1000_set_soft_ecc(chip);
+		break;
+
+	case NAND_ECC_NONE:
+        	lf1000_set_no_ecc(mtd, chip);
+		break;
+
+	case NAND_ECC_INTERNAL:
+	        lf1000_prepare_for_InternalEcc(chip);
+	        break;
+
+	default:
+		dev_warn(&nand.pdev->dev, "Invalid NAND_ECC_MODE %d\n",
+		       chip->ecc.mode);
+		BUG();
+	}
+	/* The number of bytes available for a client to place data into
+	 * the out of band area
+	 */
+	chip->ecc.layout->oobavail = 0;
+	for (i = 0; chip->ecc.layout->oobfree[i].length; i++)
+		chip->ecc.layout->oobavail += 
+					chip->ecc.layout->oobfree[i].length;
+	mtd->oobavail = chip->ecc.layout->oobavail;
+
+	/* Set the number of read / write steps for one page depending on ECC
+	 * mode
+	 */
+	chip->ecc.steps = mtd->writesize / chip->ecc.size;
+	if(chip->ecc.steps * chip->ecc.size != mtd->writesize) {
+		dev_warn(&nand.pdev->dev, "Invalid ecc parameters\n");
+		BUG();
+	}
+	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
+
+	/* Allow subpage writes up to ecc.steps. Not possible for MLC
+	 * FLASH.
+	 */
+	if (   !(chip->options & NAND_NO_SUBPAGE_WRITE) 
+	    && !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
+		switch(chip->ecc.steps) {
+		case 1: mtd->subpage_sft = 0;
+			break;
+		case 2: mtd->subpage_sft = 1;
+			break;
+		case 4:
+		case 8: mtd->subpage_sft = 2;
+			break;
+		}
+	}
+	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
+
+	/* Invalidate the pagebuffer reference */
+	chip->pagebuf = -1;
+
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = chip->ecc.layout;
+
+	return 0;
+}
+
+
+/**
+ * lf1000_nand_scan_tail - [NAND Interface] Scan for the NAND device
+ * @mtd:	    MTD device structure
+ *
+ * Leapfrog's version of nand_scan_tail().
+ * We have our own version in order to use code in common with 
+ * lf1000_nand_switch_ecc_mode().
+ */
+static int lf1000_nand_scan_tail(struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	if (!(chip->options & NAND_OWN_BUFFERS))
+		chip->buffers = kmalloc(sizeof(*chip->buffers), GFP_KERNEL);
+	if (!chip->buffers)
+		return -ENOMEM;
+
+	/* Set the internal oob buffer location, just after the page data */
+	chip->oob_poi = chip->buffers->databuf + mtd->writesize;
+
+	/*
+	 * If no default placement scheme is given, select an appropriate one
+	 */
+	if (!chip->ecc.layout) {
+		switch (mtd->oobsize) {
+		case 8: chip->ecc.layout = &nand_oob_8;
+			break;
+		case 16: chip->ecc.layout = &nand_oob_16;
+			break;
+		case 64: chip->ecc.layout = &nand_oob_64;
+			break;
+		case 128: chip->ecc.layout = &nand_oob_128;
+			break;
+		default: dev_warn(&nand.pdev->dev, "No oob scheme defined for "
+			       "oobsize %d\n", mtd->oobsize);
+			BUG();
+		}
+	}
+
+	if (!chip->write_page)
+		chip->write_page = lf1000_nand_write_page;
+
+	/* check ECC mode, default to software if 3byte/512byte hardware ECC is
+	 * selected and we have 256 byte pagesize fallback to software ECC
+	 */
+	switch (chip->ecc.mode) {
+
+	case NAND_ECC_HW_SYNDROME:
+	        lf1000_set_hw_syndrome_ecc(chip);
+		if (mtd->writesize >= chip->ecc.size)
+			break;
+		dev_warn(&nand.pdev->dev, "%d byte HW ECC not possible on "
+		       "%d byte page size, fallback to SW ECC\n",
+		       chip->ecc.size, mtd->writesize);
+		chip->ecc.mode = NAND_ECC_SOFT;
+		/* drop through here */
+	case NAND_ECC_SOFT:
+	        lf1000_set_soft_ecc(chip);
+		break;
+
+	case NAND_ECC_NONE:
+	        lf1000_set_no_ecc(mtd, chip);
+		break;
+
+	case NAND_ECC_INTERNAL:
+	        lf1000_prepare_for_InternalEcc(chip);
+	        break;
+
+	default:
+		dev_warn(&nand.pdev->dev, "Invalid NAND_ECC_MODE %d\n",
+		       chip->ecc.mode);
+		BUG();
+	}
+
+	/* The number of bytes available for a client to place data into
+	 * the out of band area
+	 */
+	chip->ecc.layout->oobavail = 0;
+	for (i = 0; chip->ecc.layout->oobfree[i].length
+		    && i < ARRAY_SIZE(chip->ecc.layout->oobfree); i++)
+		chip->ecc.layout->oobavail +=
+					chip->ecc.layout->oobfree[i].length;
+	mtd->oobavail = chip->ecc.layout->oobavail;
+
+	/* Set the number of read / write steps for one page depending on ECC
+	 * mode
+	 */
+	chip->ecc.steps = mtd->writesize / chip->ecc.size;
+	if(chip->ecc.steps * chip->ecc.size != mtd->writesize) {
+		dev_warn(&nand.pdev->dev, "Invalid ecc parameters\n");
+		BUG();
+	}
+	chip->ecc.total = chip->ecc.steps * chip->ecc.bytes;
+
+	/* Allow subpage writes up to ecc.steps. Not possible for MLC
+	 * FLASH.
+	 */
+	if (   !(chip->options & NAND_NO_SUBPAGE_WRITE) 
+	    && !(chip->cellinfo & NAND_CI_CELLTYPE_MSK)) {
+		switch(chip->ecc.steps) {
+		case 1: mtd->subpage_sft = 0;
+			break;
+		case 2: mtd->subpage_sft = 1;
+			break;
+		case 4:
+		case 8:
+		case 16: mtd->subpage_sft = 2;
+			break;
+		}
+	}
+	dev_err(&nand.pdev->dev, "I: chip->options & NAND_NO_SUBPAGE_WRITE = %d\n", 
+            chip->options & NAND_NO_SUBPAGE_WRITE);
+	dev_err(&nand.pdev->dev, "I: chip->options & NAND_CI_CELLTYPE_MSK = %d\n", 
+            chip->options & NAND_CI_CELLTYPE_MSK);
+	dev_err(&nand.pdev->dev, "I: ecc.steps = %d\n", chip->ecc.steps);
+	dev_err(&nand.pdev->dev, "I: mtd=%p mtd->subpage_sft = %x\n", 
+            mtd, mtd->subpage_sft);
+	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
+
+	chip->state = FL_READY;
+
+	chip->select_chip(mtd, -1); /* De-select the device */
+	chip->pagebuf = -1;	    /* Invalidate the pagebuffer reference */
+
+	/* Fill in remaining MTD driver data */
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->erase = lf1000_nand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = lf1000_nand_read;
+	mtd->write = nand_write;
+	mtd->read_oob = lf1000_nand_read_oob;
+	mtd->write_oob = nand_write_oob;
+	mtd->sync = nand_sync;
+	mtd->lock = NULL;
+	mtd->unlock = NULL;
+	mtd->suspend = nand_suspend;
+	mtd->resume = nand_resume;
+	mtd->block_isbad = nand_block_isbad;
+	mtd->block_markbad = nand_block_markbad;
+
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = chip->ecc.layout;
+
+	/* Check, if we should skip the bad block table scan */
+	if (chip->options & NAND_SKIP_BBTSCAN)
+		return 0;
+
+	/* Build bad block table */
+	return chip->scan_bbt(mtd);
+}
+
+
+
+
+static void lf1000_init_for_SLC_nand(struct mtd_info *mtd, 
+                                     struct nand_chip *chip)
+{
+    chip->ecc.mode    = NAND_ECC_SOFT;
+    chip->verify_buf  = lf1000_verify_SLC_page;
+    dev_info(&nand.pdev->dev, "Using 1-bit ECC\n");
+}
+
+
+
+/* Leapfrog-specific version of standard nand_scan() function.
+ * This function calls the standard nand_scan_ident() and nand_scan_tail(),
+ * but between those calls it performs initialization that's appropriate for
+ * the types of NAND flash parts that are found in Leapfrog products that use
+ * this software.
+ *
+ * cart_nand: 0 == base nand, nonzero == cart nand
+ */
+static int lf1000_nand_scan(struct mtd_info * mtd, 
+			    int		      maxchips, 
+			    u32		    * p_nand_props, 
+			    int		      cart_nand)
+{
+	int ret;
+
+	ret = nand_scan_ident(mtd, maxchips);
+
+	if (!ret) {
+		struct nand_chip *chip = mtd->priv;
+
+			/* if cartridge has OTP, use standard code */
+		if (cart_nand && (chip->ecc.mode == NAND_ECC_NONE)) {
+			ret = nand_scan_tail(mtd);
+		}
+		else {
+			if (chip_is_MT29F4G08ABADA(mtd, chip, p_nand_props, 
+							cart_nand))
+			{
+				lf1000_init_for_MT29F4G08ABADA( mtd, chip, 
+								p_nand_props);
+			} else if (chip->cellinfo & NAND_CI_CELLTYPE_MSK) {
+				lf1000_init_for_MLC_nand( mtd, chip );
+			} else {
+				lf1000_init_for_SLC_nand( mtd, chip );
+			}
+			dev_info(&nand.pdev->dev, " subpage_sft %d, "
+						  "subpagesize %d\n",
+			       mtd->subpage_sft, chip->subpagesize);
+
+			dev_info(&nand.pdev->dev, 
+				 "  IDB3 0x%02x, page_shift %d, pagemask x%x\n"
+				 "  bbt_erase_shift %d, chip_shift %d,"
+				 " badblkpos %d\n",
+				 chip->cellinfo, chip->page_shift, chip->pagemask, 
+				 chip->bbt_erase_shift, chip->chip_shift, 
+				 chip->badblockpos);
+			ret = lf1000_nand_scan_tail(mtd);
+		}
+	}
+	return ret;
+}
+
+
+static int lf1000_nand_probe(struct platform_device *pdev)
+{
+	int                   ret;
+	struct resource      *res;
+	struct nand_chip     *this;
+	const char           *part_type     = NULL;
+	int                   base_parts_nb = 0;
+	int                   cart_parts_nb = 0;
+	struct mtd_partition *base_parts    = NULL;
+	struct mtd_partition *cart_parts    = NULL;
+
+	nand.pdev = pdev;
+
+	/* check if a cartridge is inserted */
+	gpio_configure_pin(NAND_CART_DETECT_PORT, NAND_CART_DETECT_PIN,
+			   GPIO_GPIOFN, 0, 1, 0);
+        
+	/* initialization of a cartridge nand is initiated by
+         * set_cart_hotswap_state().
+         */
+	init_MUTEX(&nand.sem_hotswap);
+	
+	/* Reserve resources for driver */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		dev_err(&pdev->dev, "failed to get resource!\n");
+		return -ENXIO;
+	}
+	if(!request_mem_region(res->start, (res->end - res->start)+1,
+				"lf1000-nand")) {
+		dev_err(&pdev->dev, "failed to map memory region.");
+		return -EBUSY;
+	}
+	nand.mem = ioremap(res->start, (res->end - res->start)+1);
+	if(nand.mem == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+	
+	/* initialize the controller */
+	spin_lock_init(&nand.controller.lock);
+	init_waitqueue_head(&nand.controller.wq);
+	
+	printk(KERN_INFO "MTD: Controller Initialized\n");
+
+	/* Allocate memory for onboard NAND MTD device structure and private data */
+	lf1000_init_mtd_info(&nand.mtd_onboard, res->start);
+	if(!nand.mtd_onboard) {
+		dev_err(&pdev->dev, "Unable to allocate MTD device\n");
+		ret = -ENOMEM;
+		goto fail_mem_onboard;
+	}
+	this              = (struct nand_chip *)nand.mtd_onboard->priv;
+	this->select_chip = lf1000_select_chip;
+	
+	/* Use our version of nand_scan(), with special processing for SLC/MLC*/
+	/* find the onboard NAND Flash*/
+	if (lf1000_nand_scan(nand.mtd_onboard, 1, &nand.base_nand_props, 0)) {
+		dev_err(&pdev->dev, "Failed to find on board NAND\n");
+		kfree(nand.mtd_onboard);
+		nand.mtd_onboard = NULL;
+	}
+	
+	/* Add the base partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	if(nand.mtd_onboard != NULL)
+	{
+		nand.mtd_onboard->name = "lf1000-base";
+		base_parts_nb = parse_mtd_partitions(nand.mtd_onboard,
+						     part_probes, &base_parts, 0);
+		if (base_parts_nb > 0)
+			part_type = "command line";
+		else
+			base_parts_nb = 0;
+	}
+
+	if(nand.mtd_cart != NULL) {
+		nand.mtd_cart->name = "lf1000-cart";
+		cart_parts_nb = parse_mtd_partitions(nand.mtd_cart,
+						     part_probes,
+						     &cart_parts, 0);
+		if (cart_parts_nb > 0)
+			part_type = "command line";
+		else
+			cart_parts_nb = 0;
+	}
+#endif
+	if (base_parts_nb == 0) {
+		if (gpio_get_boot_source_config() == SCRATCH_BOOT_SOURCE_USB) {
+			base_parts = partition_info_recovery;
+			base_parts_nb = ARRAY_SIZE(partition_info_recovery);
+		} else {
+			base_parts = partition_info;
+			base_parts_nb = ARRAY_SIZE(partition_info);
+		}
+		part_type = "static";
+	}
+
+	if (cart_parts_nb == 0) {
+		cart_parts = partition_info_cart;
+		cart_parts_nb = ARRAY_SIZE(partition_info_cart);
+		part_type = "static";
+	}
+
+	/* if madrid (LeapPad), defer to CartManager, otherwise register partitions */
+	
+	/* Register the onboard partitions */
+	if ( nand.mtd_onboard != NULL)
+		add_mtd_partitions(nand.mtd_onboard, base_parts, base_parts_nb);
+
+	/* if madrid (LeapPad), let CartManager request partitions */
+	/* Register the cartridge partitions, if it exists */
+	if ( !gpio_have_gpio_madrid() && nand.mtd_cart != NULL) {
+		nand.cart_ready = 1;		
+		add_mtd_partitions(nand.mtd_cart, cart_parts, cart_parts_nb);
+	}
+
+	/* enable NAND_WP pin as an output, enable write & erase */
+	gpio_configure_pin(NAND_WP_PORT, NAND_WP_PIN, GPIO_GPIOFN, 1, 0, 1);
+
+	sysfs_create_group(&pdev->dev.kobj, &nand_attr_group);
+	return 0;
+
+fail_mem_onboard:
+	iounmap(nand.mem);
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	return ret;
+}
+
+static int lf1000_nand_remove(struct platform_device *pdev)
+{
+	struct resource *res  = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	sysfs_remove_group(&pdev->dev.kobj, &nand_attr_group);
+
+	/* Release resources, unregister device */
+	nand_release(nand.mtd_onboard);
+	if(nand.mtd_cart)
+		nand_release(nand.mtd_cart);
+
+	/* Free the MTD device structure */
+	kfree(nand.mtd_onboard);
+	if(nand.mtd_cart)
+		kfree(nand.mtd_cart);
+
+	if(nand.mem != NULL)
+		iounmap(nand.mem);
+
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	return 0;
+}
+
+static struct platform_driver lf1000_nand_driver = {
+	.probe		= lf1000_nand_probe,
+	.remove		= lf1000_nand_remove,
+	.driver		= {
+		.name	= "lf1000-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lf1000_init(void)
+{
+	return platform_driver_register(&lf1000_nand_driver);
+}
+module_init(lf1000_init);
+
+static void __exit lf1000_cleanup(void)
+{
+	platform_driver_unregister(&lf1000_nand_driver);
+}
+module_exit(lf1000_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("leapfrog.com");
+MODULE_DESCRIPTION("NAND Flash Controller for the LF1000");
+
+#endif  /* CPU_LF1000 */
+
diff -ruaN linux-2.6.31/drivers/mtd/nand/lf1000_ecc.c linux-2.6/drivers/mtd/nand/lf1000_ecc.c
--- linux-2.6.31/drivers/mtd/nand/lf1000_ecc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/lf1000_ecc.c	2011-01-04 14:58:51.000000000 -0800
@@ -0,0 +1,272 @@
+/*
+ *  drivers/mtd/nand/lf1000_ecc.c
+ *
+ *  Andrey Yurovsky <andrey@cozybit.com>
+ *  Robert Dowling <rdowling@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/nand.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+
+#if defined CPU_LF1000 && defined CONFIG_MTD_NAND_LF1000_HWECC
+
+/* control registers */
+#define NAND_BASE	IO_ADDRESS(LF1000_MCU_S_BASE)
+
+/******************************************************************************
+ * Lifted from Magic Eyes ./vtk/test/NAND_Flash/mes_nand.c
+ *
+//  Copyright (C) 2007 MagicEyes Digital Co., All Rights Reserved
+//  MagicEyes Digital Co. Proprietary & Confidential
+//
+//	MAGICEYES INFORMS THAT THIS CODE AND INFORMATION IS PROVIDED "AS IS" BASE
+//  AND WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING
+//  BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
+//  FOR A PARTICULAR PURPOSE.
+ *
+ * MES_NAND_GetErrorLocation( int *pLocation )
+ ******************************************************************************/
+
+extern const short BCH_AlphaToTable[8192];
+extern const short BCH_IndexOfTable[8192];
+extern const unsigned int BCH_TGRTable[52][2];
+
+
+//------------------------------------------------------------------------------
+// Derived from Magic Eyes's
+// int MES_NAND_GetErrorLocation( int *pLocation )
+//
+int lf1000_GetErrorLocation (int *pLocation, u16 s1, u16 s3, u16 s5, u16 s7)
+{
+	register int i, j, elp_sum ;
+	int count;
+	int r;			// Iteration steps
+	int Delta; 		// Discrepancy value
+	int elp[8+1][8+2]; 	// Error locator polynomial (ELP)
+	int L[8+1];		// Degree of ELP
+	int B[8+1][8+2];	// Scratch polynomial
+	//	int root[8+1];	// Roots of ELP
+	int reg[8+1];		// Register state
+	int	s[8];
+
+	s[0] = s1;
+	s[2] = s3;
+	s[4] = s5;
+	s[6] = s7;
+
+	// Even syndrome = (Odd syndrome) ** 2
+	for( i=1,j=0 ; i<8 ; i+=2, j++ )
+	{
+		if( s[j] == 0 )		s[i] = 0;
+		else				s[i] = BCH_AlphaToTable[(2 * BCH_IndexOfTable[s[j]]) % 8191];
+	}
+
+	// Initialization of elp, B and register
+	for( i=0 ; i<=8 ; i++ )
+	{
+		L[i] = 0 ;
+		for( j=0 ; j<=8 ; j++ )
+		{
+			elp[i][j] = 0 ;
+			B[i][j] = 0 ;
+		}
+	}
+
+	for( i=0 ; i<=4 ; i++ )
+	{
+		//		root[i] = 0 ;
+		reg[i] = 0 ;
+	}
+
+	elp[1][0] = 1 ;
+	elp[1][1] = s[0] ;
+
+	L[1] = 1 ;
+	if( s[0] != 0 )
+		B[1][0] = BCH_AlphaToTable[(8191 - BCH_IndexOfTable[s[0]]) % 8191];
+	else
+		B[1][0] = 0;
+
+	for( r=3 ; r<=8-1 ; r=r+2 )
+	{
+		// Compute discrepancy
+		Delta = s[r-1] ;
+		for( i=1 ; i<=L[r-2] ; i++ )
+		{
+			if( (s[r-i-1] != 0) && (elp[r-2][i] != 0) )
+				Delta ^= BCH_AlphaToTable[(BCH_IndexOfTable[s[r-i-1]] + BCH_IndexOfTable[elp[r-2][i]]) % 8191];
+		}
+
+		if( Delta == 0 )
+		{
+			L[r] = L[r-2] ;
+			for( i=0 ; i<=L[r-2] ; i++ )
+			{
+				elp[r][i] = elp[r-2][i];
+				B[r][i+2] = B[r-2][i] ;
+			}
+		}
+		else
+		{
+			// Form new error locator polynomial
+			for( i=0 ; i<=L[r-2] ; i++ )
+			{
+				elp[r][i] = elp[r-2][i] ;
+			}
+
+			for( i=0 ; i<=L[r-2] ; i++ )
+			{
+				if( B[r-2][i] != 0 )
+					elp[r][i+2] ^= BCH_AlphaToTable[(BCH_IndexOfTable[Delta] + BCH_IndexOfTable[B[r-2][i]]) % 8191];
+			}
+
+			// Form new scratch polynomial and register length
+			if( 2 * L[r-2] >= r )
+			{
+				L[r] = L[r-2] ;
+				for( i=0 ; i<=L[r-2] ; i++ )
+				{
+					B[r][i+2] = B[r-2][i];
+				}
+			}
+			else
+			{
+				L[r] = r - L[r-2];
+				for( i=0 ; i<=L[r-2] ; i++ )
+				{
+					if( elp[r-2][i] != 0 )
+						B[r][i] = BCH_AlphaToTable[(BCH_IndexOfTable[elp[r-2][i]] + 8191 - BCH_IndexOfTable[Delta]) % 8191];
+					else
+						B[r][i] = 0;
+				}
+			}
+		}
+	}
+
+	if( L[8-1] > 4 )
+	{
+		//return L[8-1];
+		return -1;
+	}
+	else
+	{
+		// Chien's search to find roots of the error location polynomial
+		// Ref: L&C pp.216, Fig.6.1
+		for( i=1 ; i<=L[8-1] ; i++ )
+			reg[i] = elp[8-1][i];
+
+		count = 0;
+		for( i=1 ; i<=8191 ; i++ )
+		{
+			elp_sum = 1;
+			for( j=1 ; j<=L[8-1] ; j++ )
+			{
+				if( reg[j] != 0 )
+				{
+					reg[j] = BCH_AlphaToTable[(BCH_IndexOfTable[reg[j]] + j) % 8191] ;
+					elp_sum ^= reg[j] ;
+				}
+			}
+
+			if( !elp_sum )		// store root and error location number indices
+			{
+				//				root[count] = i;
+
+				// Convert error location from systematic form to storage form
+				pLocation[count] = 8191 - i;
+
+				if (pLocation[count] >= 52)
+				{
+					// Data Bit Error
+					pLocation[count] = pLocation[count] - 52;
+					pLocation[count] = 4095 - pLocation[count];
+				}
+				else
+				{
+					// ECC Error
+					pLocation[count] = pLocation[count] + 4096;
+				}
+
+				if( pLocation[count] < 0 )	return -1;
+				/*
+				  if( i <= 8191 - 52 )	pLocation[count] = 4095 - (8191 - 52 - i);
+				  else					pLocation[count] = 4095 - (8191 + 4096 - i);
+				*/
+
+				printk (KERN_DEBUG "lf1000_GetErrorLocation: count=%d, location=%d, count++\n", count, pLocation[count]);
+				count++;
+			}
+		}
+
+		if( count == L[8-1] )	// Number of roots = degree of elp hence <= 4 errors
+		{
+			return L[8-1];
+		}
+		else	// Number of roots != degree of ELP => >4 errors and cannot solve
+		{
+			return -1;
+		}
+	}
+}
+
+    /* returns 0 if no errors
+     *      N >0 if N errors were corrected
+     *        <0 if uncorrectable errors
+     */
+int TryToCorrectBCH_Errors( u8 * pData ) 
+{
+    u32 x, s7, s5, s3, s1;
+    int errorLocations[4];
+    int numErrors;
+    int eccsize  = 512;
+
+        /* Pull out the 4 syndrome words */
+    x  = readl(NAND_BASE+NFSYNDRONE75);
+    s7 = (x >> SYNDROM7) & 0x1fff;
+    s5 = (x >> SYNDROM5) & 0x1fff;
+
+    x  = readl(NAND_BASE+NFSYNDRONE31);
+    s3 = (x >> SYNDROM3) & 0x1fff;
+    s1 = (x >> SYNDROM1) & 0x1fff;
+
+    numErrors = lf1000_GetErrorLocation( &errorLocations[0], s1, s3, s5, s7);
+	    /* If there is one or more correctable errors 		 
+         * ('numErrors' is the number of correctable errors)
+	     */
+    if (numErrors > 0)
+    {
+        int errorOffset;
+        int errorMask;
+        int j;
+
+        printk( KERN_INFO "Found %d correctable ECC errors\n", numErrors);
+        for (j = 0; j < numErrors; ++j)
+        {
+            errorOffset = errorLocations[j] >> 3;
+            errorMask   = 1 << (errorLocations[j] & 7);
+		        /* We see errorOffset >= 512 when an ECC bit is in error
+		    	 * Don't bother correcting ECC bit errors, because the
+				 * bit positions might be beyond the end of the buffer.
+				 */
+			if (errorOffset < eccsize)
+			{
+                printk(KERN_INFO "Flip bit %d; offset %d; mask %02x\n",
+                        errorLocations[j], errorOffset, errorMask);
+               	*(pData + errorOffset) ^= errorMask;
+			}
+        }
+    }
+    return numErrors;
+}
+
+#endif /* CPU_LF1000 && CONFIG_MTD_NAND_LF1000_HWECC */
diff -ruaN linux-2.6.31/drivers/mtd/nand/lf1000_ecc_tables.c linux-2.6/drivers/mtd/nand/lf1000_ecc_tables.c
--- linux-2.6.31/drivers/mtd/nand/lf1000_ecc_tables.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/lf1000_ecc_tables.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,1061 @@
+/*
+ *  drivers/mtd/nand/lf1000_ecc_tables.c
+ *
+ *  Robert Dowling <rdowling@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Tables lifted from Magic Eyes ./vtk/test/NAND_Flash/mes_bch_table.c
+ *  (No copyright found in file)
+ */
+
+const short BCH_AlphaToTable[8192] =
+{
+	   1,    2,    4,    8,   16,   32,   64,  128,  256,  512, 1024, 2048, 4096, 1455, 2910, 5820, 	//    0 ~   15
+	2263, 4526, 1779, 3558, 7116, 4663,  449,  898, 1796, 3592, 7184, 7567, 7857, 6349, 5173, 3525, 	//   16 ~   31
+	7050, 4795,  217,  434,  868, 1736, 3472, 6944, 5103,  625, 1250, 2500, 5000,  703, 1406, 2812, 	//   32 ~   47
+	5624, 3679, 7358, 7379, 7177, 7613, 7893, 6149, 5541, 3813, 7626, 7739, 6617, 5661, 2453, 4906, 	//   48 ~   63
+	1019, 2038, 4076, 8152, 6687, 4497, 1677, 3354, 6708, 4551, 1569, 3138, 6276, 5287, 3297, 6594, 	//   64 ~   79
+	5675, 2553, 5106,  587, 1174, 2348, 4696,  287,  574, 1148, 2296, 4592, 1615, 3230, 6460, 6103, 	//   80 ~   95
+	2561, 5122, 3499, 6998, 4867,  937, 1874, 3748, 7496, 7999, 7121, 4621,  437,  874, 1748, 3496, 	//   96 ~  111
+	6992, 4879,  945, 1890, 3780, 7560, 7871, 6353, 5133, 3509, 7018, 4987,  857, 1714, 3428, 6856, 	//  112 ~  127
+	4159, 1489, 2978, 5956, 2855, 5710, 2355, 4710,  355,  710, 1420, 2840, 5680, 2511, 5022,  659, 	//  128 ~  143
+	1318, 2636, 5272, 3231, 6462, 6099, 2569, 5138, 3467, 6934, 4995,  681, 1362, 2724, 5448, 3903, 	//  144 ~  159
+	7806, 6483, 5897, 3005, 6010, 2907, 5814, 2243, 4486, 1699, 3398, 6796, 4279, 1217, 2434, 4868, 	//  160 ~  175
+	 935, 1870, 3740, 7480, 8159, 6673, 4493, 1717, 3434, 6868, 4103, 1441, 2882, 5764, 2215, 4430, 	//  176 ~  191
+	1843, 3686, 7372, 7223, 7617, 7725, 6645, 5701, 2341, 4682,  315,  630, 1260, 2520, 5040,  719, 	//  192 ~  207
+	1438, 2876, 5752, 2399, 4798,  211,  422,  844, 1688, 3376, 6752, 4463, 1905, 3810, 7620, 7719, 	//  208 ~  223
+	6625, 5741, 2421, 4842,  123,  246,  492,  984, 1968, 3936, 7872, 6191, 5617, 3661, 7322, 7323, 	//  224 ~  239
+	7321, 7325, 7317, 7301, 7333, 7397, 7269, 7525, 8037, 7013, 4965,  869, 1738, 3476, 6952, 5119, 	//  240 ~  255
+	 593, 1186, 2372, 4744,  191,  382,  764, 1528, 3056, 6112, 2671, 5342, 3091, 6182, 5603, 3689, 	//  256 ~  271
+	7378, 7179, 7609, 7901, 6165, 5509, 3749, 7498, 7995, 7129, 4637,  405,  810, 1620, 3240, 6480, 	//  272 ~  287
+	5903, 2993, 5986, 2923, 5846, 2051, 4102, 1443, 2886, 5772, 2231, 4462, 1907, 3814, 7628, 7735, 	//  288 ~  303
+	6593, 5677, 2549, 5098,  635, 1270, 2540, 5080,  543, 1086, 2172, 4344, 1119, 2238, 4476, 1879, 	//  304 ~  319
+	3758, 7516, 7959, 7041, 4781,  245,  490,  980, 1960, 3920, 7840, 6383, 5233, 3405, 6810, 4251, 	//  320 ~  335
+	1177, 2354, 4708,  359,  718, 1436, 2872, 5744, 2383, 4766,  147,  294,  588, 1176, 2352, 4704, 	//  336 ~  351
+	 367,  734, 1468, 2936, 5872, 2127, 4254, 1171, 2342, 4684,  311,  622, 1244, 2488, 4976,  847, 	//  352 ~  367
+	1694, 3388, 6776, 4447, 1809, 3618, 7236, 7463, 8161, 6765, 4469, 1861, 3722, 7444, 8071, 6817, 	//  368 ~  383
+	4333, 1141, 2282, 4564, 1543, 3086, 6172, 5527, 3713, 7426, 8107, 6905, 4189, 1301, 2602, 5204, 	//  384 ~  399
+	3335, 6670, 4531, 1737, 3474, 6948, 5095,  609, 1218, 2436, 4872,  959, 1918, 3836, 7672, 7775, 	//  400 ~  415
+	6417, 6029, 2741, 5482, 3963, 7926, 6211, 5417, 4093, 8186, 6747, 4377, 1949, 3898, 7796, 6471, 	//  416 ~  431
+	5921, 3053, 6106, 2587, 5174, 3523, 7046, 4771,  233,  466,  932, 1864, 3728, 7456, 8175, 6769, 	//  432 ~  447
+	4429, 1845, 3690, 7380, 7175, 7585, 7917, 6261, 5445, 3877, 7754, 6459, 6105, 2589, 5178, 3547, 	//  448 ~  463
+	7094, 4803,   41,   82,  164,  328,  656, 1312, 2624, 5248, 3247, 6494, 5907, 2953, 5906, 2955, 	//  464 ~  479
+	5910, 2947, 5894, 2979, 5958, 2851, 5702, 2339, 4678,  291,  582, 1164, 2328, 4656,  463,  926, 	//  480 ~  495
+	1852, 3704, 7408, 7247, 7473, 8141, 6709, 4549, 1573, 3146, 6292, 5255, 3233, 6466, 5931, 3065, 	//  496 ~  511
+	6130, 2635, 5270, 3203, 6406, 6051, 2793, 5586, 3595, 7190, 7555, 7849, 6397, 5205, 3333, 6666, 	//  512 ~  527
+	4539, 1753, 3506, 7012, 4967,  865, 1730, 3460, 6920, 5055,  721, 1442, 2884, 5768, 2239, 4478, 	//  528 ~  543
+	1875, 3750, 7500, 7991, 7105, 4653,  501, 1002, 2004, 4008, 8016, 6927, 5041,  717, 1434, 2868, 	//  544 ~  559
+	5736, 2431, 4862,   83,  166,  332,  664, 1328, 2656, 5312, 3119, 6238, 5395, 3977, 7954, 7051, 	//  560 ~  575
+	4793,  221,  442,  884, 1768, 3536, 7072, 4847,  113,  226,  452,  904, 1808, 3616, 7232, 7471, 	//  576 ~  591
+	8177, 6733, 4405, 1989, 3978, 7956, 7047, 4769,  237,  474,  948, 1896, 3792, 7584, 7919, 6257, 	//  592 ~  607
+	5453, 3893, 7786, 6523, 5977, 2845, 5690, 2523, 5046,  707, 1414, 2828, 5656, 2463, 4926,  979, 	//  608 ~  623
+	1958, 3916, 7832, 6303, 5265, 3213, 6426, 6043, 2713, 5426, 4043, 8086, 6787, 4265, 1277, 2554, 	//  624 ~  639
+	5108,  583, 1166, 2332, 4664,  479,  958, 1916, 3832, 7664, 7759, 6449, 6093, 2613, 5226, 3451, 	//  640 ~  655
+	6902, 4163, 1321, 2642, 5284, 3303, 6606, 5683, 2505, 5010,  651, 1302, 2604, 5208, 3359, 6718, 	//  656 ~  671
+	4563, 1545, 3090, 6180, 5607, 3681, 7362, 7211, 7673, 7773, 6421, 6021, 2725, 5450, 3899, 7798, 	//  672 ~  687
+	6467, 5929, 3069, 6138, 2651, 5302, 3267, 6534, 5795, 2281, 4562, 1547, 3094, 6188, 5623, 3649, 	//  688 ~  703
+	7298, 7339, 7417, 7261, 7445, 8069, 6821, 4325, 1125, 2250, 4500, 1671, 3342, 6684, 4503, 1665, 	//  704 ~  719
+	3330, 6660, 4519, 1761, 3522, 7044, 4775,  225,  450,  900, 1800, 3600, 7200, 7663, 7793, 6477, 	//  720 ~  735
+	5941, 3013, 6026, 2747, 5494, 3907, 7814, 6307, 5353, 3197, 6394, 5211, 3353, 6706, 4555, 1593, 	//  736 ~  751
+	3186, 6372, 5223, 3425, 6850, 4139, 1529, 3058, 6116, 2663, 5326, 3123, 6246, 5475, 3945, 7890, 	//  752 ~  767
+	6155, 5561, 3805, 7610, 7899, 6169, 5533, 3733, 7466, 8187, 6745, 4381, 1941, 3882, 7764, 6407, 	//  768 ~  783
+	6049, 2797, 5594, 3611, 7222, 7619, 7721, 6653, 5717, 2309, 4618,  443,  886, 1772, 3544, 7088, 	//  784 ~  799
+	4815,   49,   98,  196,  392,  784, 1568, 3136, 6272, 5295, 3313, 6626, 5739, 2425, 4850,   75, 	//  800 ~  815
+	 150,  300,  600, 1200, 2400, 4800,   47,   94,  188,  376,  752, 1504, 3008, 6016, 2735, 5470, 	//  816 ~  831
+	3859, 7718, 6627, 5737, 2429, 4858,   91,  182,  364,  728, 1456, 2912, 5824, 2095, 4190, 1299, 	//  832 ~  847
+	2598, 5196, 3383, 6766, 4467, 1865, 3730, 7460, 8167, 6753, 4461, 1909, 3818, 7636, 7687, 6561, 	//  848 ~  863
+	5869, 2165, 4330, 1147, 2294, 4588, 1655, 3310, 6620, 5655, 2433, 4866,  939, 1878, 3756, 7512, 	//  864 ~  879
+	7967, 7057, 4749,  181,  362,  724, 1448, 2896, 5792, 2287, 4574, 1555, 3110, 6220, 5431, 4033, 	//  880 ~  895
+	8066, 6827, 4345, 1117, 2234, 4468, 1863, 3726, 7452, 8087, 6785, 4269, 1269, 2538, 5076,  519, 	//  896 ~  911
+	1038, 2076, 4152, 1503, 3006, 6012, 2903, 5806, 2291, 4582, 1635, 3270, 6540, 5815, 2241, 4482, 	//  912 ~  927
+	1707, 3414, 6828, 4343, 1089, 2178, 4356, 1959, 3918, 7836, 6295, 5249, 3245, 6490, 5915, 2969, 	//  928 ~  943
+	5938, 3019, 6038, 2691, 5382, 4003, 8006, 6947, 5097,  637, 1274, 2548, 5096,  639, 1278, 2556, 	//  944 ~  959
+	5112,  607, 1214, 2428, 4856,   95,  190,  380,  760, 1520, 3040, 6080, 2607, 5214, 3347, 6694, 	//  960 ~  975
+	4579, 1641, 3282, 6564, 5863, 2145, 4290, 1067, 2134, 4268, 1271, 2542, 5084,  535, 1070, 2140, 	//  976 ~  991
+	4280, 1247, 2494, 4988,  855, 1710, 3420, 6840, 4319, 1041, 2082, 4164, 1319, 2638, 5276, 3223, 	//  992 ~ 1007
+	6446, 6131, 2633, 5266, 3211, 6422, 6019, 2729, 5458, 3851, 7702, 6531, 5801, 2301, 4602, 1627, 	// 1008 ~ 1023
+	3254, 6508, 6007, 2881, 5762, 2219, 4438, 1795, 3590, 7180, 7607, 7873, 6189, 5621, 3653, 7306, 	// 1024 ~ 1039
+	7355, 7385, 7197, 7573, 7813, 6309, 5349, 3173, 6346, 5179, 3545, 7090, 4811,   57,  114,  228, 	// 1040 ~ 1055
+	 456,  912, 1824, 3648, 7296, 7343, 7409, 7245, 7477, 8133, 6693, 4581, 1637, 3274, 6548, 5767, 	// 1056 ~ 1071
+	2209, 4418, 1835, 3670, 7340, 7415, 7233, 7469, 8181, 6725, 4389, 2021, 4042, 8084, 6791, 4257, 	// 1072 ~ 1087
+	1261, 2522, 5044,  711, 1422, 2844, 5688, 2527, 5054,  723, 1446, 2892, 5784, 2207, 4414, 2003, 	// 1088 ~ 1103
+	4006, 8012, 6967, 5057,  557, 1114, 2228, 4456, 1919, 3838, 7676, 7767, 6401, 6061, 2805, 5610, 	// 1104 ~ 1119
+	3707, 7414, 7235, 7465, 8189, 6741, 4357, 1957, 3914, 7828, 6279, 5281, 3309, 6618, 5659, 2457, 	// 1120 ~ 1135
+	4914,  971, 1942, 3884, 7768, 6431, 6033, 2701, 5402, 3995, 7990, 7107, 4649,  509, 1018, 2036, 	// 1136 ~ 1151
+	4072, 8144, 6671, 4529, 1741, 3482, 6964, 5063,  545, 1090, 2180, 4360, 1983, 3966, 7932, 6231, 	// 1152 ~ 1167
+	5377, 4013, 8026, 6939, 5017,  669, 1338, 2676, 5352, 3199, 6398, 5203, 3337, 6674, 4491, 1721, 	// 1168 ~ 1183
+	3442, 6884, 4199, 1377, 2754, 5508, 3751, 7502, 7987, 7113, 4669,  469,  938, 1876, 3752, 7504, 	// 1184 ~ 1199
+	7951, 7089, 4813,   53,  106,  212,  424,  848, 1696, 3392, 6784, 4271, 1265, 2530, 5060,  551, 	// 1200 ~ 1215
+	1102, 2204, 4408, 2015, 4030, 8060, 6999, 4865,  941, 1882, 3764, 7528, 8063, 6993, 4877,  949, 	// 1216 ~ 1231
+	1898, 3796, 7592, 7935, 6225, 5389, 4021, 8042, 7035, 4953,  797, 1594, 3188, 6376, 5247, 3409, 	// 1232 ~ 1247
+	6818, 4331, 1145, 2290, 4580, 1639, 3278, 6556, 5783, 2177, 4354, 1963, 3926, 7852, 6391, 5185, 	// 1248 ~ 1263
+	3373, 6746, 4379, 1945, 3890, 7780, 6503, 5985, 2925, 5850, 2075, 4150, 1475, 2950, 5900, 2999, 	// 1264 ~ 1279
+	5998, 2931, 5862, 2147, 4294, 1059, 2118, 4236, 1207, 2414, 4828,   23,   46,   92,  184,  368, 	// 1280 ~ 1295
+	 736, 1472, 2944, 5888, 2991, 5982, 2835, 5670, 2531, 5062,  547, 1094, 2188, 4376, 1951, 3902, 	// 1296 ~ 1311
+	7804, 6487, 5889, 2989, 5978, 2843, 5686, 2499, 4998,  675, 1350, 2700, 5400, 3999, 7998, 7123, 	// 1312 ~ 1327
+	4617,  445,  890, 1780, 3560, 7120, 4623,  433,  866, 1732, 3464, 6928, 5007,  689, 1378, 2756, 	// 1328 ~ 1343
+	5512, 3775, 7550, 8019, 6921, 5053,  725, 1450, 2900, 5800, 2303, 4606, 1619, 3238, 6476, 5943, 	// 1344 ~ 1359
+	3009, 6018, 2731, 5462, 3843, 7686, 6563, 5865, 2173, 4346, 1115, 2230, 4460, 1911, 3822, 7644, 	// 1360 ~ 1375
+	7703, 6529, 5805, 2293, 4586, 1659, 3318, 6636, 5751, 2369, 4738,  171,  342,  684, 1368, 2736, 	// 1376 ~ 1391
+	5472, 3951, 7902, 6163, 5513, 3773, 7546, 8027, 6937, 5021,  661, 1322, 2644, 5288, 3327, 6654, 	// 1392 ~ 1407
+	5715, 2313, 4626,  395,  790, 1580, 3160, 6320, 5327, 3121, 6242, 5483, 3961, 7922, 6219, 5433, 	// 1408 ~ 1423
+	4061, 8122, 6875, 4121, 1437, 2874, 5748, 2375, 4750,  179,  358,  716, 1432, 2864, 5728, 2415, 	// 1424 ~ 1439
+	4830,   19,   38,   76,  152,  304,  608, 1216, 2432, 4864,  943, 1886, 3772, 7544, 8031, 6929, 	// 1440 ~ 1455
+	5005,  693, 1386, 2772, 5544, 3839, 7678, 7763, 6409, 6077, 2773, 5546, 3835, 7670, 7747, 6441, 	// 1456 ~ 1471
+	6141, 2645, 5290, 3323, 6646, 5699, 2345, 4690,  267,  534, 1068, 2136, 4272, 1231, 2462, 4924, 	// 1472 ~ 1487
+	 983, 1966, 3932, 7864, 6367, 5137, 3469, 6938, 5019,  665, 1330, 2660, 5320, 3135, 6270, 5459, 	// 1488 ~ 1503
+	3849, 7698, 6539, 5817, 2269, 4538, 1755, 3510, 7020, 4983,  833, 1666, 3332, 6664, 4543, 1745, 	// 1504 ~ 1519
+	3490, 6980, 4903,  993, 1986, 3972, 7944, 7103, 4817,   13,   26,   52,  104,  208,  416,  832, 	// 1520 ~ 1535
+	1664, 3328, 6656, 4527, 1777, 3554, 7108, 4647,  481,  962, 1924, 3848, 7696, 6543, 5809, 2253, 	// 1536 ~ 1551
+	4506, 1691, 3382, 6764, 4471, 1857, 3714, 7428, 8103, 6881, 4205, 1397, 2794, 5588, 3591, 7182, 	// 1552 ~ 1567
+	7603, 7881, 6205, 5589, 3589, 7178, 7611, 7897, 6173, 5525, 3717, 7434, 8123, 6873, 4125, 1429, 	// 1568 ~ 1583
+	2858, 5716, 2311, 4622,  435,  870, 1740, 3480, 6960, 5071,  561, 1122, 2244, 4488, 1727, 3454, 	// 1584 ~ 1599
+	6908, 4183, 1281, 2562, 5124, 3495, 6990, 4915,  969, 1938, 3876, 7752, 6463, 6097, 2573, 5146, 	// 1600 ~ 1615
+	3483, 6966, 5059,  553, 1106, 2212, 4424, 1855, 3710, 7420, 7255, 7425, 8109, 6901, 4165, 1317, 	// 1616 ~ 1631
+	2634, 5268, 3207, 6414, 6067, 2761, 5522, 3723, 7446, 8067, 6825, 4349, 1109, 2218, 4436, 1799, 	// 1632 ~ 1647
+	3598, 7196, 7575, 7809, 6317, 5365, 3141, 6282, 5307, 3289, 6578, 5835, 2105, 4210, 1355, 2710, 	// 1648 ~ 1663
+	5420, 4087, 8174, 6771, 4425, 1853, 3706, 7412, 7239, 7457, 8173, 6773, 4421, 1829, 3658, 7316, 	// 1664 ~ 1679
+	7303, 7329, 7405, 7285, 7493, 7973, 7141, 4709,  357,  714, 1428, 2856, 5712, 2319, 4638,  403, 	// 1680 ~ 1695
+	 806, 1612, 3224, 6448, 6095, 2609, 5218, 3435, 6870, 4099, 1449, 2898, 5796, 2279, 4558, 1587, 	// 1696 ~ 1711
+	3174, 6348, 5175, 3521, 7042, 4779,  249,  498,  996, 1992, 3984, 7968, 7151, 4721,  333,  666, 	// 1712 ~ 1727
+	1332, 2664, 5328, 3087, 6174, 5523, 3721, 7442, 8075, 6841, 4317, 1045, 2090, 4180, 1287, 2574, 	// 1728 ~ 1743
+	5148, 3479, 6958, 5107,  585, 1170, 2340, 4680,  319,  638, 1276, 2552, 5104,  591, 1182, 2364, 	// 1744 ~ 1759
+	4728,  351,  702, 1404, 2808, 5616, 3663, 7326, 7315, 7305, 7357, 7381, 7173, 7589, 7909, 6245, 	// 1760 ~ 1775
+	5477, 3941, 7882, 6203, 5593, 3613, 7226, 7643, 7705, 6557, 5781, 2181, 4362, 1979, 3958, 7916, 	// 1776 ~ 1791
+	6263, 5441, 3885, 7770, 6427, 6041, 2717, 5434, 4059, 8118, 6851, 4137, 1533, 3066, 6132, 2631, 	// 1792 ~ 1807
+	5262, 3251, 6502, 5987, 2921, 5842, 2059, 4118, 1411, 2822, 5644, 2487, 4974,  883, 1766, 3532, 	// 1808 ~ 1823
+	7064, 4767,  145,  290,  580, 1160, 2320, 4640,  495,  990, 1980, 3960, 7920, 6223, 5425, 4045, 	// 1824 ~ 1839
+	8090, 6811, 4249, 1181, 2362, 4724,  327,  654, 1308, 2616, 5232, 3407, 6814, 4243, 1161, 2322, 	// 1840 ~ 1855
+	4644,  487,  974, 1948, 3896, 7792, 6479, 5937, 3021, 6042, 2715, 5430, 4035, 8070, 6819, 4329, 	// 1856 ~ 1871
+	1149, 2298, 4596, 1607, 3214, 6428, 6039, 2689, 5378, 4011, 8022, 6915, 5033,  765, 1530, 3060, 	// 1872 ~ 1887
+	6120, 2687, 5374, 3155, 6310, 5347, 3177, 6354, 5131, 3513, 7026, 4939,  825, 1650, 3300, 6600, 	// 1888 ~ 1903
+	5695, 2513, 5026,  747, 1494, 2988, 5976, 2847, 5694, 2515, 5030,  739, 1478, 2956, 5912, 2975, 	// 1904 ~ 1919
+	5950, 3027, 6054, 2787, 5574, 3619, 7238, 7459, 8169, 6781, 4437, 1797, 3594, 7188, 7559, 7841, 	// 1920 ~ 1935
+	6381, 5237, 3397, 6794, 4283, 1241, 2482, 4964,  871, 1742, 3484, 6968, 5087,  529, 1058, 2116, 	// 1936 ~ 1951
+	4232, 1215, 2430, 4860,   87,  174,  348,  696, 1392, 2784, 5568, 3631, 7262, 7443, 8073, 6845, 	// 1952 ~ 1967
+	4309, 1029, 2058, 4116, 1415, 2830, 5660, 2455, 4910, 1011, 2022, 4044, 8088, 6815, 4241, 1165, 	// 1968 ~ 1983
+	2330, 4660,  455,  910, 1820, 3640, 7280, 7503, 7985, 7117, 4661,  453,  906, 1812, 3624, 7248, 	// 1984 ~ 1999
+	7439, 8113, 6861, 4149, 1477, 2954, 5908, 2951, 5902, 2995, 5990, 2915, 5830, 2083, 4166, 1315, 	// 2000 ~ 2015
+	2630, 5260, 3255, 6510, 6003, 2889, 5778, 2187, 4374, 1923, 3846, 7692, 6583, 5825, 2093, 4186, 	// 2016 ~ 2031
+	1307, 2614, 5228, 3447, 6894, 4211, 1353, 2706, 5412, 4071, 8142, 6707, 4553, 1597, 3194, 6388, 	// 2032 ~ 2047
+	5191, 3361, 6722, 4395, 2041, 4082, 8164, 6759, 4449, 1901, 3802, 7604, 7879, 6177, 5613, 3701, 	// 2048 ~ 2063
+	7402, 7291, 7513, 7965, 7061, 4741,  165,  330,  660, 1320, 2640, 5280, 3311, 6622, 5651, 2441, 	// 2064 ~ 2079
+	4882,  907, 1814, 3628, 7256, 7455, 8081, 6797, 4277, 1221, 2442, 4884,  903, 1806, 3612, 7224, 	// 2080 ~ 2095
+	7647, 7697, 6541, 5813, 2245, 4490, 1723, 3446, 6892, 4215, 1345, 2690, 5380, 4007, 8014, 6963, 	// 2096 ~ 2111
+	5065,  573, 1146, 2292, 4584, 1663, 3326, 6652, 5719, 2305, 4610,  427,  854, 1708, 3416, 6832, 	// 2112 ~ 2127
+	4303, 1073, 2146, 4292, 1063, 2126, 4252, 1175, 2350, 4700,  279,  558, 1116, 2232, 4464, 1871, 	// 2128 ~ 2143
+	3742, 7484, 8151, 6657, 4525, 1781, 3562, 7124, 4615,  417,  834, 1668, 3336, 6672, 4495, 1713, 	// 2144 ~ 2159
+	3426, 6852, 4135, 1505, 3010, 6020, 2727, 5454, 3891, 7782, 6499, 5993, 2941, 5882, 2139, 4278, 	// 2160 ~ 2175
+	1219, 2438, 4876,  951, 1902, 3804, 7608, 7903, 6161, 5517, 3765, 7530, 8059, 7001, 4893,  917, 	// 2176 ~ 2191
+	1834, 3668, 7336, 7423, 7249, 7437, 8117, 6853, 4133, 1509, 3018, 6036, 2695, 5390, 4019, 8038, 	// 2192 ~ 2207
+	7011, 4969,  893, 1786, 3572, 7144, 4735,  337,  674, 1348, 2696, 5392, 3983, 7966, 7059, 4745, 	// 2208 ~ 2223
+	 189,  378,  756, 1512, 3024, 6048, 2799, 5598, 3603, 7206, 7651, 7785, 6525, 5973, 2821, 5642, 	// 2224 ~ 2239
+	2491, 4982,  835, 1670, 3340, 6680, 4511, 1681, 3362, 6724, 4391, 2017, 4034, 8068, 6823, 4321, 	// 2240 ~ 2255
+	1133, 2266, 4532, 1735, 3470, 6940, 5015,  641, 1282, 2564, 5128, 3519, 7038, 4947,  777, 1554, 	// 2256 ~ 2271
+	3108, 6216, 5439, 4049, 8098, 6891, 4217, 1373, 2746, 5492, 3911, 7822, 6323, 5321, 3133, 6266, 	// 2272 ~ 2287
+	5467, 3865, 7730, 6603, 5689, 2525, 5050,  731, 1462, 2924, 5848, 2079, 4158, 1491, 2982, 5964, 	// 2288 ~ 2303
+	2871, 5742, 2419, 4838,   99,  198,  396,  792, 1584, 3168, 6336, 5167, 3569, 7138, 4715,  377, 	// 2304 ~ 2319
+	 754, 1508, 3016, 6032, 2703, 5406, 3987, 7974, 7139, 4713,  381,  762, 1524, 3048, 6096, 2575, 	// 2320 ~ 2335
+	5150, 3475, 6950, 5091,  617, 1234, 2468, 4936,  831, 1662, 3324, 6648, 5727, 2321, 4642,  491, 	// 2336 ~ 2351
+	 982, 1964, 3928, 7856, 6351, 5169, 3533, 7066, 4763,  153,  306,  612, 1224, 2448, 4896, 1007, 	// 2352 ~ 2367
+	2014, 4028, 8056, 7007, 4881,  909, 1818, 3636, 7272, 7551, 8017, 6925, 5045,  709, 1418, 2836, 	// 2368 ~ 2383
+	5672, 2559, 5118,  595, 1190, 2380, 4760,  159,  318,  636, 1272, 2544, 5088,  623, 1246, 2492, 	// 2384 ~ 2399
+	4984,  863, 1726, 3452, 6904, 4191, 1297, 2594, 5188, 3367, 6734, 4403, 1993, 3986, 7972, 7143, 	// 2400 ~ 2415
+	4705,  365,  730, 1460, 2920, 5840, 2063, 4126, 1427, 2854, 5708, 2359, 4718,  371,  742, 1484, 	// 2416 ~ 2431
+	2968, 5936, 3023, 6046, 2707, 5414, 4067, 8134, 6691, 4585, 1661, 3322, 6644, 5703, 2337, 4674, 	// 2432 ~ 2447
+	 299,  598, 1196, 2392, 4784,  207,  414,  828, 1656, 3312, 6624, 5743, 2417, 4834,  107,  214, 	// 2448 ~ 2463
+	 428,  856, 1712, 3424, 6848, 4143, 1521, 3042, 6084, 2599, 5198, 3379, 6758, 4451, 1897, 3794, 	// 2464 ~ 2479
+	7588, 7911, 6241, 5485, 3957, 7914, 6267, 5465, 3869, 7738, 6619, 5657, 2461, 4922,  987, 1974, 	// 2480 ~ 2495
+	3948, 7896, 6175, 5521, 3725, 7450, 8091, 6809, 4253, 1173, 2346, 4692,  263,  526, 1052, 2104, 	// 2496 ~ 2511
+	4208, 1359, 2718, 5436, 4055, 8110, 6899, 4169, 1341, 2682, 5364, 3143, 6286, 5299, 3273, 6546, 	// 2512 ~ 2527
+	5771, 2233, 4466, 1867, 3734, 7468, 8183, 6721, 4397, 2037, 4074, 8148, 6663, 4513, 1773, 3546, 	// 2528 ~ 2543
+	7092, 4807,   33,   66,  132,  264,  528, 1056, 2112, 4224, 1199, 2398, 4796,  215,  430,  860, 	// 2544 ~ 2559
+	1720, 3440, 6880, 4207, 1393, 2786, 5572, 3623, 7246, 7475, 8137, 6717, 4565, 1541, 3082, 6164, 	// 2560 ~ 2575
+	5511, 3745, 7490, 7979, 7161, 4701,  277,  554, 1108, 2216, 4432, 1807, 3614, 7228, 7639, 7681, 	// 2576 ~ 2591
+	6573, 5877, 2117, 4234, 1211, 2422, 4844,  119,  238,  476,  952, 1904, 3808, 7616, 7727, 6641, 	// 2592 ~ 2607
+	5709, 2357, 4714,  379,  758, 1516, 3032, 6064, 2767, 5534, 3731, 7462, 8163, 6761, 4477, 1877, 	// 2608 ~ 2623
+	3754, 7508, 7943, 7073, 4845,  117,  234,  468,  936, 1872, 3744, 7488, 7983, 7153, 4685,  309, 	// 2624 ~ 2639
+	 618, 1236, 2472, 4944,  783, 1566, 3132, 6264, 5471, 3857, 7714, 6635, 5753, 2397, 4794,  219, 	// 2640 ~ 2655
+	 438,  876, 1752, 3504, 7008, 4975,  881, 1762, 3524, 7048, 4799,  209,  418,  836, 1672, 3344, 	// 2656 ~ 2671
+	6688, 4591, 1649, 3298, 6596, 5671, 2529, 5058,  555, 1110, 2220, 4440, 1823, 3646, 7292, 7511, 	// 2672 ~ 2687
+	7937, 7085, 4853,   69,  138,  276,  552, 1104, 2208, 4416, 1839, 3678, 7356, 7383, 7169, 7597, 	// 2688 ~ 2703
+	7925, 6213, 5413, 4069, 8138, 6715, 4569, 1565, 3130, 6260, 5447, 3873, 7746, 6443, 6137, 2653, 	// 2704 ~ 2719
+	5306, 3291, 6582, 5827, 2089, 4178, 1291, 2582, 5164, 3575, 7150, 4723,  329,  658, 1316, 2632, 	// 2720 ~ 2735
+	5264, 3215, 6430, 6035, 2697, 5394, 3979, 7958, 7043, 4777,  253,  506, 1012, 2024, 4048, 8096, 	// 2736 ~ 2751
+	6895, 4209, 1357, 2714, 5428, 4039, 8078, 6835, 4297, 1085, 2170, 4340, 1095, 2190, 4380, 1943, 	// 2752 ~ 2767
+	3886, 7772, 6423, 6017, 2733, 5466, 3867, 7734, 6595, 5673, 2557, 5114,  603, 1206, 2412, 4824, 	// 2768 ~ 2783
+	  31,   62,  124,  248,  496,  992, 1984, 3968, 7936, 7087, 4849,   77,  154,  308,  616, 1232, 	// 2784 ~ 2799
+	2464, 4928,  815, 1630, 3260, 6520, 5983, 2833, 5666, 2539, 5078,  515, 1030, 2060, 4120, 1439, 	// 2800 ~ 2815
+	2878, 5756, 2391, 4782,  243,  486,  972, 1944, 3888, 7776, 6511, 6001, 2893, 5786, 2203, 4406, 	// 2816 ~ 2831
+	1987, 3974, 7948, 7095, 4801,   45,   90,  180,  360,  720, 1440, 2880, 5760, 2223, 4446, 1811, 	// 2832 ~ 2847
+	3622, 7244, 7479, 8129, 6701, 4597, 1605, 3210, 6420, 6023, 2721, 5442, 3883, 7766, 6403, 6057, 	// 2848 ~ 2863
+	2813, 5626, 3675, 7350, 7363, 7209, 7677, 7765, 6405, 6053, 2789, 5578, 3643, 7286, 7491, 7977, 	// 2864 ~ 2879
+	7165, 4693,  261,  522, 1044, 2088, 4176, 1295, 2590, 5180, 3543, 7086, 4851,   73,  146,  292, 	// 2880 ~ 2895
+	 584, 1168, 2336, 4672,  303,  606, 1212, 2424, 4848,   79,  158,  316,  632, 1264, 2528, 5056, 	// 2896 ~ 2911
+	 559, 1118, 2236, 4472, 1887, 3774, 7548, 8023, 6913, 5037,  757, 1514, 3028, 6056, 2815, 5630, 	// 2912 ~ 2927
+	3667, 7334, 7395, 7273, 7549, 8021, 6917, 5029,  741, 1482, 2964, 5928, 3071, 6142, 2643, 5286, 	// 2928 ~ 2943
+	3299, 6598, 5667, 2537, 5074,  523, 1046, 2092, 4184, 1311, 2622, 5244, 3415, 6830, 4339, 1097, 	// 2944 ~ 2959
+	2194, 4388, 2023, 4046, 8092, 6807, 4225, 1197, 2394, 4788,  199,  398,  796, 1592, 3184, 6368, 	// 2960 ~ 2975
+	5231, 3441, 6882, 4203, 1401, 2802, 5604, 3687, 7374, 7219, 7625, 7741, 6613, 5637, 2469, 4938, 	// 2976 ~ 2991
+	 827, 1654, 3308, 6616, 5663, 2449, 4898, 1003, 2006, 4012, 8024, 6943, 5009,  653, 1306, 2612, 	// 2992 ~ 3007
+	5224, 3455, 6910, 4179, 1289, 2578, 5156, 3559, 7118, 4659,  457,  914, 1828, 3656, 7312, 7311, 	// 3008 ~ 3023
+	7345, 7373, 7221, 7621, 7717, 6629, 5733, 2405, 4810,   59,  118,  236,  472,  944, 1888, 3776, 	// 3024 ~ 3039
+	7552, 7855, 6385, 5197, 3381, 6762, 4475, 1881, 3762, 7524, 8039, 7009, 4973,  885, 1770, 3540, 	// 3040 ~ 3055
+	7080, 4863,   81,  162,  324,  648, 1296, 2592, 5184, 3375, 6750, 4371, 1929, 3858, 7716, 6631, 	// 3056 ~ 3071
+	5729, 2413, 4826,   27,   54,  108,  216,  432,  864, 1728, 3456, 6912, 5039,  753, 1506, 3012, 	// 3072 ~ 3087
+	6024, 2751, 5502, 3923, 7846, 6371, 5225, 3453, 6906, 4187, 1305, 2610, 5220, 3431, 6862, 4147, 	// 3088 ~ 3103
+	1481, 2962, 5924, 3047, 6094, 2611, 5222, 3427, 6854, 4131, 1513, 3026, 6052, 2791, 5582, 3635, 	// 3104 ~ 3119
+	7270, 7523, 8041, 7037, 4949,  773, 1546, 3092, 6184, 5631, 3665, 7330, 7403, 7289, 7517, 7957, 	// 3120 ~ 3135
+	7045, 4773,  229,  458,  916, 1832, 3664, 7328, 7407, 7281, 7501, 7989, 7109, 4645,  485,  970, 	// 3136 ~ 3151
+	1940, 3880, 7760, 6415, 6065, 2765, 5530, 3739, 7478, 8131, 6697, 4605, 1621, 3242, 6484, 5895, 	// 3152 ~ 3167
+	2977, 5954, 2859, 5718, 2307, 4614,  419,  838, 1676, 3352, 6704, 4559, 1585, 3170, 6340, 5159, 	// 3168 ~ 3183
+	3553, 7106, 4651,  505, 1010, 2020, 4040, 8080, 6799, 4273, 1229, 2458, 4916,  967, 1934, 3868, 	// 3184 ~ 3199
+	7736, 6623, 5649, 2445, 4890,  923, 1846, 3692, 7384, 7199, 7569, 7821, 6325, 5317, 3109, 6218, 	// 3200 ~ 3215
+	5435, 4057, 8114, 6859, 4153, 1501, 3002, 6004, 2887, 5774, 2227, 4454, 1891, 3782, 7564, 7863, 	// 3216 ~ 3231
+	6337, 5165, 3573, 7146, 4731,  345,  690, 1380, 2760, 5520, 3727, 7454, 8083, 6793, 4285, 1237, 	// 3232 ~ 3247
+	2474, 4948,  775, 1550, 3100, 6200, 5599, 3601, 7202, 7659, 7801, 6493, 5909, 2949, 5898, 3003, 	// 3248 ~ 3263
+	6006, 2883, 5766, 2211, 4422, 1827, 3654, 7308, 7351, 7361, 7213, 7669, 7749, 6437, 6117, 2661, 	// 3264 ~ 3279
+	5322, 3131, 6262, 5443, 3881, 7762, 6411, 6073, 2781, 5562, 3803, 7606, 7875, 6185, 5629, 3669, 	// 3280 ~ 3295
+	7338, 7419, 7257, 7453, 8085, 6789, 4261, 1253, 2506, 5012,  647, 1294, 2588, 5176, 3551, 7102, 	// 3296 ~ 3311
+	4819,    9,   18,   36,   72,  144,  288,  576, 1152, 2304, 4608,  431,  862, 1724, 3448, 6896, 	// 3312 ~ 3327
+	4175, 1329, 2658, 5316, 3111, 6222, 5427, 4041, 8082, 6795, 4281, 1245, 2490, 4980,  839, 1678, 	// 3328 ~ 3343
+	3356, 6712, 4575, 1553, 3106, 6212, 5415, 4065, 8130, 6699, 4601, 1629, 3258, 6516, 5959, 2849, 	// 3344 ~ 3359
+	5698, 2347, 4694,  259,  518, 1036, 2072, 4144, 1487, 2974, 5948, 3031, 6062, 2803, 5606, 3683, 	// 3360 ~ 3375
+	7366, 7203, 7657, 7805, 6485, 5893, 2981, 5962, 2875, 5750, 2371, 4742,  163,  326,  652, 1304, 	// 3376 ~ 3391
+	2608, 5216, 3439, 6878, 4115, 1417, 2834, 5668, 2535, 5070,  563, 1126, 2252, 4504, 1695, 3390, 	// 3392 ~ 3407
+	6780, 4439, 1793, 3586, 7172, 7591, 7905, 6253, 5493, 3909, 7818, 6331, 5337, 3101, 6202, 5595, 	// 3408 ~ 3423
+	3609, 7218, 7627, 7737, 6621, 5653, 2437, 4874,  955, 1910, 3820, 7640, 7711, 6545, 5773, 2229, 	// 3424 ~ 3439
+	4458, 1915, 3830, 7660, 7799, 6465, 5933, 3061, 6122, 2683, 5366, 3139, 6278, 5283, 3305, 6610, 	// 3440 ~ 3455
+	5643, 2489, 4978,  843, 1686, 3372, 6744, 4383, 1937, 3874, 7748, 6439, 6113, 2669, 5338, 3099, 	// 3456 ~ 3471
+	6198, 5571, 3625, 7250, 7435, 8121, 6877, 4117, 1413, 2826, 5652, 2439, 4878,  947, 1894, 3788, 	// 3472 ~ 3487
+	7576, 7839, 6289, 5261, 3253, 6506, 6011, 2905, 5810, 2251, 4502, 1667, 3334, 6668, 4535, 1729, 	// 3488 ~ 3503
+	3458, 6916, 5031,  737, 1474, 2948, 5896, 3007, 6014, 2899, 5798, 2275, 4550, 1571, 3142, 6284, 	// 3504 ~ 3519
+	5303, 3265, 6530, 5803, 2297, 4594, 1611, 3222, 6444, 6135, 2625, 5250, 3243, 6486, 5891, 2985, 	// 3520 ~ 3535
+	5970, 2827, 5654, 2435, 4870,  931, 1862, 3724, 7448, 8095, 6801, 4237, 1205, 2410, 4820,    7, 	// 3536 ~ 3551
+	  14,   28,   56,  112,  224,  448,  896, 1792, 3584, 7168, 7599, 7921, 6221, 5429, 4037, 8074, 	// 3552 ~ 3567
+	6843, 4313, 1053, 2106, 4212, 1351, 2702, 5404, 3991, 7982, 7155, 4681,  317,  634, 1268, 2536, 	// 3568 ~ 3583
+	5072,  527, 1054, 2108, 4216, 1375, 2750, 5500, 3927, 7854, 6387, 5193, 3389, 6778, 4443, 1817, 	// 3584 ~ 3599
+	3634, 7268, 7527, 8033, 7021, 4981,  837, 1674, 3348, 6696, 4607, 1617, 3234, 6468, 5927, 3041, 	// 3600 ~ 3615
+	6082, 2603, 5206, 3331, 6662, 4515, 1769, 3538, 7076, 4839,   97,  194,  388,  776, 1552, 3104, 	// 3616 ~ 3631
+	6208, 5423, 4081, 8162, 6763, 4473, 1885, 3770, 7540, 8007, 6945, 5101,  629, 1258, 2516, 5032, 	// 3632 ~ 3647
+	 767, 1534, 3068, 6136, 2655, 5310, 3283, 6566, 5859, 2153, 4306, 1035, 2070, 4140, 1527, 3054, 	// 3648 ~ 3663
+	6108, 2583, 5166, 3571, 7142, 4707,  361,  722, 1444, 2888, 5776, 2191, 4382, 1939, 3878, 7756, 	// 3664 ~ 3679
+	6455, 6081, 2605, 5210, 3355, 6710, 4547, 1577, 3154, 6308, 5351, 3169, 6338, 5163, 3577, 7154, 	// 3680 ~ 3695
+	4683,  313,  626, 1252, 2504, 5008,  655, 1310, 2620, 5240, 3423, 6846, 4307, 1033, 2066, 4132, 	// 3696 ~ 3711
+	1511, 3022, 6044, 2711, 5422, 4083, 8166, 6755, 4457, 1917, 3834, 7668, 7751, 6433, 6125, 2677, 	// 3712 ~ 3727
+	5354, 3195, 6390, 5187, 3369, 6738, 4363, 1977, 3954, 7908, 6247, 5473, 3949, 7898, 6171, 5529, 	// 3728 ~ 3743
+	3741, 7482, 8155, 6681, 4509, 1685, 3370, 6740, 4359, 1953, 3906, 7812, 6311, 5345, 3181, 6362, 	// 3744 ~ 3759
+	5147, 3481, 6962, 5067,  569, 1138, 2276, 4552, 1599, 3198, 6396, 5207, 3329, 6658, 4523, 1785, 	// 3760 ~ 3775
+	3570, 7140, 4711,  353,  706, 1412, 2824, 5648, 2447, 4894,  915, 1830, 3660, 7320, 7327, 7313, 	// 3776 ~ 3791
+	7309, 7349, 7365, 7205, 7653, 7781, 6501, 5989, 2917, 5834, 2107, 4214, 1347, 2694, 5388, 4023, 	// 3792 ~ 3807
+	8046, 7027, 4937,  829, 1658, 3316, 6632, 5759, 2385, 4770,  235,  470,  940, 1880, 3760, 7520, 	// 3808 ~ 3823
+	8047, 7025, 4941,  821, 1642, 3284, 6568, 5887, 2129, 4258, 1259, 2518, 5036,  759, 1518, 3036, 	// 3824 ~ 3839
+	6072, 2783, 5566, 3795, 7590, 7907, 6249, 5501, 3925, 7850, 6395, 5209, 3357, 6714, 4571, 1561, 	// 3840 ~ 3855
+	3122, 6244, 5479, 3937, 7874, 6187, 5625, 3677, 7354, 7387, 7193, 7581, 7829, 6277, 5285, 3301, 	// 3856 ~ 3871
+	6602, 5691, 2521, 5042,  715, 1430, 2860, 5720, 2335, 4670,  467,  934, 1868, 3736, 7472, 8143, 	// 3872 ~ 3887
+	6705, 4557, 1589, 3178, 6356, 5127, 3489, 6978, 4907, 1017, 2034, 4068, 8136, 6719, 4561, 1549, 	// 3888 ~ 3903
+	3098, 6196, 5575, 3617, 7234, 7467, 8185, 6749, 4373, 1925, 3850, 7700, 6535, 5793, 2285, 4570, 	// 3904 ~ 3919
+	1563, 3126, 6252, 5495, 3905, 7810, 6315, 5369, 3165, 6330, 5339, 3097, 6194, 5579, 3641, 7282, 	// 3920 ~ 3935
+	7499, 7993, 7133, 4629,  389,  778, 1556, 3112, 6224, 5391, 4017, 8034, 7019, 4985,  861, 1722, 	// 3936 ~ 3951
+	3444, 6888, 4223, 1361, 2722, 5444, 3879, 7758, 6451, 6089, 2621, 5242, 3419, 6838, 4291, 1065, 	// 3952 ~ 3967
+	2130, 4260, 1255, 2510, 5020,  663, 1326, 2652, 5304, 3295, 6590, 5843, 2057, 4114, 1419, 2838, 	// 3968 ~ 3983
+	5676, 2551, 5102,  627, 1254, 2508, 5016,  671, 1342, 2684, 5368, 3167, 6334, 5331, 3081, 6162, 	// 3984 ~ 3999
+	5515, 3769, 7538, 8011, 6969, 5085,  533, 1066, 2132, 4264, 1279, 2558, 5116,  599, 1198, 2396, 	// 4000 ~ 4015
+	4792,  223,  446,  892, 1784, 3568, 7136, 4719,  369,  738, 1476, 2952, 5904, 2959, 5918, 2963, 	// 4016 ~ 4031
+	5926, 3043, 6086, 2595, 5190, 3363, 6726, 4387, 2025, 4050, 8100, 6887, 4193, 1389, 2778, 5556, 	// 4032 ~ 4047
+	3783, 7566, 7859, 6345, 5181, 3541, 7082, 4859,   89,  178,  356,  712, 1424, 2848, 5696, 2351, 	// 4048 ~ 4063
+	4702,  275,  550, 1100, 2200, 4400, 1999, 3998, 7996, 7127, 4609,  429,  858, 1716, 3432, 6864, 	// 4064 ~ 4079
+	4111, 1457, 2914, 5828, 2087, 4174, 1331, 2662, 5324, 3127, 6254, 5491, 3913, 7826, 6283, 5305, 	// 4080 ~ 4095
+	3293, 6586, 5851, 2073, 4146, 1483, 2966, 5932, 3063, 6126, 2675, 5350, 3171, 6342, 5155, 3561, 	// 4096 ~ 4111
+	7122, 4619,  441,  882, 1764, 3528, 7056, 4751,  177,  354,  708, 1416, 2832, 5664, 2543, 5086, 	// 4112 ~ 4127
+	 531, 1062, 2124, 4248, 1183, 2366, 4732,  343,  686, 1372, 2744, 5488, 3919, 7838, 6291, 5257, 	// 4128 ~ 4143
+	3261, 6522, 5979, 2841, 5682, 2507, 5014,  643, 1286, 2572, 5144, 3487, 6974, 5075,  521, 1042, 	// 4144 ~ 4159
+	2084, 4168, 1343, 2686, 5372, 3159, 6318, 5363, 3145, 6290, 5259, 3257, 6514, 5963, 2873, 5746, 	// 4160 ~ 4175
+	2379, 4758,  131,  262,  524, 1048, 2096, 4192, 1391, 2782, 5564, 3799, 7598, 7923, 6217, 5437, 	// 4176 ~ 4191
+	4053, 8106, 6907, 4185, 1309, 2618, 5236, 3399, 6798, 4275, 1225, 2450, 4900,  999, 1998, 3996, 	// 4192 ~ 4207
+	7992, 7135, 4625,  397,  794, 1588, 3176, 6352, 5135, 3505, 7010, 4971,  889, 1778, 3556, 7112, 	// 4208 ~ 4223
+	4671,  465,  930, 1860, 3720, 7440, 8079, 6833, 4301, 1077, 2154, 4308, 1031, 2062, 4124, 1431, 	// 4224 ~ 4239
+	2862, 5724, 2327, 4654,  499,  998, 1996, 3992, 7984, 7119, 4657,  461,  922, 1844, 3688, 7376, 	// 4240 ~ 4255
+	7183, 7601, 7885, 6197, 5573, 3621, 7242, 7483, 8153, 6685, 4501, 1669, 3338, 6676, 4487, 1697, 	// 4256 ~ 4271
+	3394, 6788, 4263, 1249, 2498, 4996,  679, 1358, 2716, 5432, 4063, 8126, 6867, 4105, 1469, 2938, 	// 4272 ~ 4287
+	5876, 2119, 4238, 1203, 2406, 4812,   55,  110,  220,  440,  880, 1760, 3520, 7040, 4783,  241, 	// 4288 ~ 4303
+	 482,  964, 1928, 3856, 7712, 6639, 5745, 2381, 4762,  155,  310,  620, 1240, 2480, 4960,  879, 	// 4304 ~ 4319
+	1758, 3516, 7032, 4959,  785, 1570, 3140, 6280, 5311, 3281, 6562, 5867, 2169, 4338, 1099, 2198, 	// 4320 ~ 4335
+	4396, 2039, 4078, 8156, 6679, 4481, 1709, 3418, 6836, 4295, 1057, 2114, 4228, 1191, 2382, 4764, 	// 4336 ~ 4351
+	 151,  302,  604, 1208, 2416, 4832,  111,  222,  444,  888, 1776, 3552, 7104, 4655,  497,  994, 	// 4352 ~ 4367
+	1988, 3976, 7952, 7055, 4785,  205,  410,  820, 1640, 3280, 6560, 5871, 2161, 4322, 1131, 2262, 	// 4368 ~ 4383
+	4524, 1783, 3566, 7132, 4631,  385,  770, 1540, 3080, 6160, 5519, 3761, 7522, 8043, 7033, 4957, 	// 4384 ~ 4399
+	 789, 1578, 3156, 6312, 5375, 3153, 6306, 5355, 3193, 6386, 5195, 3385, 6770, 4427, 1849, 3698, 	// 4400 ~ 4415
+	7396, 7271, 7521, 8045, 7029, 4933,  805, 1610, 3220, 6440, 6143, 2641, 5282, 3307, 6614, 5635, 	// 4416 ~ 4431
+	2473, 4946,  779, 1558, 3116, 6232, 5407, 3985, 7970, 7147, 4729,  349,  698, 1396, 2792, 5584, 	// 4432 ~ 4447
+	3599, 7198, 7571, 7817, 6333, 5333, 3077, 6154, 5563, 3801, 7602, 7883, 6201, 5597, 3605, 7210, 	// 4448 ~ 4463
+	7675, 7769, 6429, 6037, 2693, 5386, 4027, 8054, 6979, 4905, 1021, 2042, 4084, 8168, 6783, 4433, 	// 4464 ~ 4479
+	1805, 3610, 7220, 7623, 7713, 6637, 5749, 2373, 4746,  187,  374,  748, 1496, 2992, 5984, 2927, 	// 4480 ~ 4495
+	5854, 2067, 4134, 1507, 3014, 6028, 2743, 5486, 3955, 7910, 6243, 5481, 3965, 7930, 6235, 5401, 	// 4496 ~ 4511
+	3997, 7994, 7131, 4633,  413,  826, 1652, 3304, 6608, 5647, 2481, 4962,  875, 1750, 3500, 7000, 	// 4512 ~ 4527
+	4895,  913, 1826, 3652, 7304, 7359, 7377, 7181, 7605, 7877, 6181, 5605, 3685, 7370, 7227, 7641, 	// 4528 ~ 4543
+	7709, 6549, 5765, 2213, 4426, 1851, 3702, 7404, 7287, 7489, 7981, 7157, 4677,  293,  586, 1172, 	// 4544 ~ 4559
+	2344, 4688,  271,  542, 1084, 2168, 4336, 1103, 2206, 4412, 2007, 4014, 8028, 6935, 4993,  685, 	// 4560 ~ 4575
+	1370, 2740, 5480, 3967, 7934, 6227, 5385, 4029, 8058, 7003, 4889,  925, 1850, 3700, 7400, 7295, 	// 4576 ~ 4591
+	7505, 7949, 7093, 4805,   37,   74,  148,  296,  592, 1184, 2368, 4736,  175,  350,  700, 1400, 	// 4592 ~ 4607
+	2800, 5600, 3695, 7390, 7187, 7561, 7869, 6357, 5125, 3493, 6986, 4923,  985, 1970, 3940, 7880, 	// 4608 ~ 4623
+	6207, 5585, 3597, 7194, 7579, 7833, 6301, 5269, 3205, 6410, 6075, 2777, 5554, 3787, 7574, 7811, 	// 4624 ~ 4639
+	6313, 5373, 3157, 6314, 5371, 3161, 6322, 5323, 3129, 6258, 5451, 3897, 7794, 6475, 5945, 3037, 	// 4640 ~ 4655
+	6074, 2779, 5558, 3779, 7558, 7843, 6377, 5245, 3413, 6826, 4347, 1113, 2226, 4452, 1895, 3790, 	// 4656 ~ 4671
+	7580, 7831, 6273, 5293, 3317, 6634, 5755, 2393, 4786,  203,  406,  812, 1624, 3248, 6496, 5999, 	// 4672 ~ 4687
+	2929, 5858, 2155, 4310, 1027, 2054, 4108, 1463, 2926, 5852, 2071, 4142, 1523, 3046, 6092, 2615, 	// 4688 ~ 4703
+	5230, 3443, 6886, 4195, 1385, 2770, 5540, 3815, 7630, 7731, 6601, 5693, 2517, 5034,  763, 1526, 	// 4704 ~ 4719
+	3052, 6104, 2591, 5182, 3539, 7078, 4835,  105,  210,  420,  840, 1680, 3360, 6720, 4399, 2033, 	// 4720 ~ 4735
+	4066, 8132, 6695, 4577, 1645, 3290, 6580, 5831, 2081, 4162, 1323, 2646, 5292, 3319, 6638, 5747, 	// 4736 ~ 4751
+	2377, 4754,  139,  278,  556, 1112, 2224, 4448, 1903, 3806, 7612, 7895, 6145, 5549, 3829, 7658, 	// 4752 ~ 4767
+	7803, 6489, 5917, 2965, 5930, 3067, 6134, 2627, 5254, 3235, 6470, 5923, 3049, 6098, 2571, 5142, 	// 4768 ~ 4783
+	3459, 6918, 5027,  745, 1490, 2980, 5960, 2879, 5758, 2387, 4774,  227,  454,  908, 1816, 3632, 	// 4784 ~ 4799
+	7264, 7535, 8049, 6989, 4917,  965, 1930, 3860, 7720, 6655, 5713, 2317, 4634,  411,  822, 1644, 	// 4800 ~ 4815
+	3288, 6576, 5839, 2097, 4194, 1387, 2774, 5548, 3831, 7662, 7795, 6473, 5949, 3029, 6058, 2811, 	// 4816 ~ 4831
+	5622, 3651, 7302, 7331, 7401, 7293, 7509, 7941, 7077, 4837,  101,  202,  404,  808, 1616, 3232, 	// 4832 ~ 4847
+	6464, 5935, 3057, 6114, 2667, 5334, 3075, 6150, 5539, 3817, 7634, 7691, 6585, 5853, 2069, 4138, 	// 4848 ~ 4863
+	1531, 3062, 6124, 2679, 5358, 3187, 6374, 5219, 3433, 6866, 4107, 1465, 2930, 5860, 2151, 4302, 	// 4864 ~ 4879
+	1075, 2150, 4300, 1079, 2158, 4316, 1047, 2094, 4188, 1303, 2606, 5212, 3351, 6702, 4595, 1609, 	// 4880 ~ 4895
+	3218, 6436, 6119, 2657, 5314, 3115, 6230, 5379, 4009, 8018, 6923, 5049,  733, 1466, 2932, 5864, 	// 4896 ~ 4911
+	2175, 4350, 1107, 2214, 4428, 1847, 3694, 7388, 7191, 7553, 7853, 6389, 5189, 3365, 6730, 4411, 	// 4912 ~ 4927
+	2009, 4018, 8036, 7015, 4961,  877, 1754, 3508, 7016, 4991,  849, 1698, 3396, 6792, 4287, 1233, 	// 4928 ~ 4943
+	2466, 4932,  807, 1614, 3228, 6456, 6111, 2577, 5154, 3563, 7126, 4611,  425,  850, 1700, 3400, 	// 4944 ~ 4959
+	6800, 4239, 1201, 2402, 4804,   39,   78,  156,  312,  624, 1248, 2496, 4992,  687, 1374, 2748, 	// 4960 ~ 4975
+	5496, 3935, 7870, 6355, 5129, 3517, 7034, 4955,  793, 1586, 3172, 6344, 5183, 3537, 7074, 4843, 	// 4976 ~ 4991
+	 121,  242,  484,  968, 1936, 3872, 7744, 6447, 6129, 2637, 5274, 3227, 6454, 6083, 2601, 5202, 	// 4992 ~ 5007
+	3339, 6678, 4483, 1705, 3410, 6820, 4327, 1121, 2242, 4484, 1703, 3406, 6812, 4247, 1153, 2306, 	// 5008 ~ 5023
+	4612,  423,  846, 1692, 3384, 6768, 4431, 1841, 3682, 7364, 7207, 7649, 7789, 6517, 5957, 2853, 	// 5024 ~ 5039
+	5706, 2363, 4726,  323,  646, 1292, 2584, 5168, 3535, 7070, 4755,  137,  274,  548, 1096, 2192, 	// 5040 ~ 5055
+	4384, 2031, 4062, 8124, 6871, 4097, 1453, 2906, 5812, 2247, 4494, 1715, 3430, 6860, 4151, 1473, 	// 5056 ~ 5071
+	2946, 5892, 2983, 5966, 2867, 5734, 2403, 4806,   35,   70,  140,  280,  560, 1120, 2240, 4480, 	// 5072 ~ 5087
+	1711, 3422, 6844, 4311, 1025, 2050, 4100, 1447, 2894, 5788, 2199, 4398, 2035, 4070, 8140, 6711, 	// 5088 ~ 5103
+	4545, 1581, 3162, 6324, 5319, 3105, 6210, 5419, 4089, 8178, 6731, 4409, 2013, 4026, 8052, 6983, 	// 5104 ~ 5119
+	4897, 1005, 2010, 4020, 8040, 7039, 4945,  781, 1562, 3124, 6248, 5503, 3921, 7842, 6379, 5241, 	// 5120 ~ 5135
+	3421, 6842, 4315, 1049, 2098, 4196, 1383, 2766, 5532, 3735, 7470, 8179, 6729, 4413, 2005, 4010, 	// 5136 ~ 5151
+	8020, 6919, 5025,  749, 1498, 2996, 5992, 2943, 5886, 2131, 4262, 1251, 2502, 5004,  695, 1390, 	// 5152 ~ 5167
+	2780, 5560, 3807, 7614, 7891, 6153, 5565, 3797, 7594, 7931, 6233, 5405, 3989, 7978, 7163, 4697, 	// 5168 ~ 5183
+	 285,  570, 1140, 2280, 4560, 1551, 3102, 6204, 5591, 3585, 7170, 7595, 7929, 6237, 5397, 3973, 	// 5184 ~ 5199
+	7946, 7099, 4825,   29,   58,  116,  232,  464,  928, 1856, 3712, 7424, 8111, 6897, 4173, 1333, 	// 5200 ~ 5215
+	2666, 5332, 3079, 6158, 5555, 3785, 7570, 7819, 6329, 5341, 3093, 6186, 5627, 3673, 7346, 7371, 	// 5216 ~ 5231
+	7225, 7645, 7701, 6533, 5797, 2277, 4554, 1595, 3190, 6380, 5239, 3393, 6786, 4267, 1273, 2546, 	// 5232 ~ 5247
+	5092,  615, 1230, 2460, 4920,  991, 1982, 3964, 7928, 6239, 5393, 3981, 7962, 7067, 4761,  157, 	// 5248 ~ 5263
+	 314,  628, 1256, 2512, 5024,  751, 1502, 3004, 6008, 2911, 5822, 2259, 4518, 1763, 3526, 7052, 	// 5264 ~ 5279
+	4791,  193,  386,  772, 1544, 3088, 6176, 5615, 3697, 7394, 7275, 7545, 8029, 6933, 4997,  677, 	// 5280 ~ 5295
+	1354, 2708, 5416, 4095, 8190, 6739, 4361, 1981, 3962, 7924, 6215, 5409, 4077, 8154, 6683, 4505, 	// 5296 ~ 5311
+	1693, 3386, 6772, 4423, 1825, 3650, 7300, 7335, 7393, 7277, 7541, 8005, 6949, 5093,  613, 1226, 	// 5312 ~ 5327
+	2452, 4904, 1023, 2046, 4092, 8184, 6751, 4369, 1933, 3866, 7732, 6599, 5665, 2541, 5082,  539, 	// 5328 ~ 5343
+	1078, 2156, 4312, 1055, 2110, 4220, 1367, 2734, 5468, 3863, 7726, 6643, 5705, 2365, 4730,  347, 	// 5344 ~ 5359
+	 694, 1388, 2776, 5552, 3791, 7582, 7827, 6281, 5309, 3285, 6570, 5883, 2137, 4274, 1227, 2454, 	// 5360 ~ 5375
+	4908, 1015, 2030, 4060, 8120, 6879, 4113, 1421, 2842, 5684, 2503, 5006,  691, 1382, 2764, 5528, 	// 5376 ~ 5391
+	3743, 7486, 8147, 6665, 4541, 1749, 3498, 6996, 4871,  929, 1858, 3716, 7432, 8127, 6865, 4109, 	// 5392 ~ 5407
+	1461, 2922, 5844, 2055, 4110, 1459, 2918, 5836, 2103, 4206, 1395, 2790, 5580, 3639, 7278, 7539, 	// 5408 ~ 5423
+	8009, 6973, 5077,  517, 1034, 2068, 4136, 1535, 3070, 6140, 2647, 5294, 3315, 6630, 5731, 2409, 	// 5424 ~ 5439
+	4818,   11,   22,   44,   88,  176,  352,  704, 1408, 2816, 5632, 2479, 4958,  787, 1574, 3148, 	// 5440 ~ 5455
+	6296, 5279, 3217, 6434, 6123, 2681, 5362, 3147, 6294, 5251, 3241, 6482, 5899, 3001, 6002, 2891, 	// 5456 ~ 5471
+	5782, 2179, 4358, 1955, 3910, 7820, 6327, 5313, 3117, 6234, 5403, 3993, 7986, 7115, 4665,  477, 	// 5472 ~ 5487
+	 954, 1908, 3816, 7632, 7695, 6577, 5837, 2101, 4202, 1403, 2806, 5612, 3703, 7406, 7283, 7497, 	// 5488 ~ 5503
+	7997, 7125, 4613,  421,  842, 1684, 3368, 6736, 4367, 1969, 3938, 7876, 6183, 5601, 3693, 7386, 	// 5504 ~ 5519
+	7195, 7577, 7837, 6293, 5253, 3237, 6474, 5947, 3033, 6066, 2763, 5526, 3715, 7430, 8099, 6889, 	// 5520 ~ 5535
+	4221, 1365, 2730, 5460, 3847, 7694, 6579, 5833, 2109, 4218, 1371, 2742, 5484, 3959, 7918, 6259, 	// 5536 ~ 5551
+	5449, 3901, 7802, 6491, 5913, 2973, 5946, 3035, 6070, 2755, 5510, 3747, 7494, 7971, 7145, 4733, 	// 5552 ~ 5567
+	 341,  682, 1364, 2728, 5456, 3855, 7710, 6547, 5769, 2237, 4474, 1883, 3766, 7532, 8055, 6977, 	// 5568 ~ 5583
+	4909, 1013, 2026, 4052, 8104, 6911, 4177, 1293, 2586, 5172, 3527, 7054, 4787,  201,  402,  804, 	// 5584 ~ 5599
+	1608, 3216, 6432, 6127, 2673, 5346, 3179, 6358, 5123, 3497, 6994, 4875,  953, 1906, 3812, 7624, 	// 5600 ~ 5615
+	7743, 6609, 5645, 2485, 4970,  891, 1782, 3564, 7128, 4639,  401,  802, 1604, 3208, 6416, 6031, 	// 5616 ~ 5631
+	2737, 5474, 3947, 7894, 6147, 5545, 3837, 7674, 7771, 6425, 6045, 2709, 5418, 4091, 8182, 6723, 	// 5632 ~ 5647
+	4393, 2045, 4090, 8180, 6727, 4385, 2029, 4058, 8116, 6855, 4129, 1517, 3034, 6068, 2759, 5518, 	// 5648 ~ 5663
+	3763, 7526, 8035, 7017, 4989,  853, 1706, 3412, 6824, 4351, 1105, 2210, 4420, 1831, 3662, 7324, 	// 5664 ~ 5679
+	7319, 7297, 7341, 7413, 7237, 7461, 8165, 6757, 4453, 1893, 3786, 7572, 7815, 6305, 5357, 3189, 	// 5680 ~ 5695
+	6378, 5243, 3417, 6834, 4299, 1081, 2162, 4324, 1127, 2254, 4508, 1687, 3374, 6748, 4375, 1921, 	// 5696 ~ 5711
+	3842, 7684, 6567, 5857, 2157, 4314, 1051, 2102, 4204, 1399, 2798, 5596, 3607, 7214, 7667, 7753, 	// 5712 ~ 5727
+	6461, 6101, 2565, 5130, 3515, 7030, 4931,  809, 1618, 3236, 6472, 5951, 3025, 6050, 2795, 5590, 	// 5728 ~ 5743
+	3587, 7174, 7587, 7913, 6269, 5461, 3845, 7690, 6587, 5849, 2077, 4154, 1499, 2998, 5996, 2935, 	// 5744 ~ 5759
+	5870, 2163, 4326, 1123, 2246, 4492, 1719, 3438, 6876, 4119, 1409, 2818, 5636, 2471, 4942,  819, 	// 5760 ~ 5775
+	1638, 3276, 6552, 5791, 2193, 4386, 2027, 4054, 8108, 6903, 4161, 1325, 2650, 5300, 3271, 6542, 	// 5776 ~ 5791
+	5811, 2249, 4498, 1675, 3350, 6700, 4599, 1601, 3202, 6404, 6055, 2785, 5570, 3627, 7254, 7427, 	// 5792 ~ 5807
+	8105, 6909, 4181, 1285, 2570, 5140, 3463, 6926, 5043,  713, 1426, 2852, 5704, 2367, 4734,  339, 	// 5808 ~ 5823
+	 678, 1356, 2712, 5424, 4047, 8094, 6803, 4233, 1213, 2426, 4852,   71,  142,  284,  568, 1136, 	// 5824 ~ 5839
+	2272, 4544, 1583, 3166, 6332, 5335, 3073, 6146, 5547, 3833, 7666, 7755, 6457, 6109, 2581, 5162, 	// 5840 ~ 5855
+	3579, 7158, 4675,  297,  594, 1188, 2376, 4752,  143,  286,  572, 1144, 2288, 4576, 1647, 3294, 	// 5856 ~ 5871
+	6588, 5847, 2049, 4098, 1451, 2902, 5804, 2295, 4590, 1651, 3302, 6604, 5687, 2497, 4994,  683, 	// 5872 ~ 5887
+	1366, 2732, 5464, 3871, 7742, 6611, 5641, 2493, 4986,  859, 1718, 3436, 6872, 4127, 1425, 2850, 	// 5888 ~ 5903
+	5700, 2343, 4686,  307,  614, 1228, 2456, 4912,  975, 1950, 3900, 7800, 6495, 5905, 2957, 5914, 	// 5904 ~ 5919
+	2971, 5942, 3011, 6022, 2723, 5446, 3875, 7750, 6435, 6121, 2685, 5370, 3163, 6326, 5315, 3113, 	// 5920 ~ 5935
+	6226, 5387, 4025, 8050, 6987, 4921,  989, 1978, 3956, 7912, 6271, 5457, 3853, 7706, 6555, 5785, 	// 5936 ~ 5951
+	2205, 4410, 2011, 4022, 8044, 7031, 4929,  813, 1626, 3252, 6504, 6015, 2897, 5794, 2283, 4566, 	// 5952 ~ 5967
+	1539, 3078, 6156, 5559, 3777, 7554, 7851, 6393, 5213, 3349, 6698, 4603, 1625, 3250, 6500, 5991, 	// 5968 ~ 5983
+	2913, 5826, 2091, 4182, 1283, 2566, 5132, 3511, 7022, 4979,  841, 1682, 3364, 6728, 4415, 2001, 	// 5984 ~ 5999
+	4002, 8004, 6951, 5089,  621, 1242, 2484, 4968,  895, 1790, 3580, 7160, 4703,  273,  546, 1092, 	// 6000 ~ 6015
+	2184, 4368, 1935, 3870, 7740, 6615, 5633, 2477, 4954,  795, 1590, 3180, 6360, 5151, 3473, 6946, 	// 6016 ~ 6031
+	5099,  633, 1266, 2532, 5064,  575, 1150, 2300, 4600, 1631, 3262, 6524, 5975, 2817, 5634, 2475, 	// 6032 ~ 6047
+	4950,  771, 1542, 3084, 6168, 5535, 3729, 7458, 8171, 6777, 4445, 1813, 3626, 7252, 7431, 8097, 	// 6048 ~ 6063
+	6893, 4213, 1349, 2698, 5396, 3975, 7950, 7091, 4809,   61,  122,  244,  488,  976, 1952, 3904, 	// 6064 ~ 6079
+	7808, 6319, 5361, 3149, 6298, 5275, 3225, 6450, 6091, 2617, 5234, 3403, 6806, 4227, 1193, 2386, 	// 6080 ~ 6095
+	4772,  231,  462,  924, 1848, 3696, 7392, 7279, 7537, 8013, 6965, 5061,  549, 1098, 2196, 4392, 	// 6096 ~ 6111
+	2047, 4094, 8188, 6743, 4353, 1965, 3930, 7860, 6343, 5153, 3565, 7130, 4635,  409,  818, 1636, 	// 6112 ~ 6127
+	3272, 6544, 5775, 2225, 4450, 1899, 3798, 7596, 7927, 6209, 5421, 4085, 8170, 6779, 4441, 1821, 	// 6128 ~ 6143
+	3642, 7284, 7495, 7969, 7149, 4725,  325,  650, 1300, 2600, 5200, 3343, 6686, 4499, 1673, 3346, 	// 6144 ~ 6159
+	6692, 4583, 1633, 3266, 6532, 5799, 2273, 4546, 1579, 3158, 6316, 5367, 3137, 6274, 5291, 3321, 	// 6160 ~ 6175
+	6642, 5707, 2361, 4722,  331,  662, 1324, 2648, 5296, 3279, 6558, 5779, 2185, 4370, 1931, 3862, 	// 6176 ~ 6191
+	7724, 6647, 5697, 2349, 4698,  283,  566, 1132, 2264, 4528, 1743, 3486, 6972, 5079,  513, 1026, 	// 6192 ~ 6207
+	2052, 4104, 1471, 2942, 5884, 2135, 4270, 1267, 2534, 5068,  567, 1134, 2268, 4536, 1759, 3518, 	// 6208 ~ 6223
+	7036, 4951,  769, 1538, 3076, 6152, 5567, 3793, 7586, 7915, 6265, 5469, 3861, 7722, 6651, 5721, 	// 6224 ~ 6239
+	2333, 4666,  475,  950, 1900, 3800, 7600, 7887, 6193, 5581, 3637, 7274, 7547, 8025, 6941, 5013, 	// 6240 ~ 6255
+	 645, 1290, 2580, 5160, 3583, 7166, 4691,  265,  530, 1060, 2120, 4240, 1167, 2334, 4668,  471, 	// 6256 ~ 6271
+	 942, 1884, 3768, 7536, 8015, 6961, 5069,  565, 1130, 2260, 4520, 1791, 3582, 7164, 4695,  257, 	// 6272 ~ 6287
+	 514, 1028, 2056, 4112, 1423, 2846, 5692, 2519, 5038,  755, 1510, 3020, 6040, 2719, 5438, 4051, 	// 6288 ~ 6303
+	8102, 6883, 4201, 1405, 2810, 5620, 3655, 7310, 7347, 7369, 7229, 7637, 7685, 6565, 5861, 2149, 	// 6304 ~ 6319
+	4298, 1083, 2166, 4332, 1143, 2286, 4572, 1559, 3118, 6236, 5399, 3969, 7938, 7083, 4857,   93, 	// 6320 ~ 6335
+	 186,  372,  744, 1488, 2976, 5952, 2863, 5726, 2323, 4646,  483,  966, 1932, 3864, 7728, 6607, 	// 6336 ~ 6351
+	5681, 2509, 5018,  667, 1334, 2668, 5336, 3103, 6206, 5587, 3593, 7186, 7563, 7865, 6365, 5141, 	// 6352 ~ 6367
+	3461, 6922, 5051,  729, 1458, 2916, 5832, 2111, 4222, 1363, 2726, 5452, 3895, 7790, 6515, 5961, 	// 6368 ~ 6383
+	2877, 5754, 2395, 4790,  195,  390,  780, 1560, 3120, 6240, 5487, 3953, 7906, 6251, 5497, 3933, 	// 6384 ~ 6399
+	7866, 6363, 5145, 3485, 6970, 5083,  537, 1074, 2148, 4296, 1087, 2174, 4348, 1111, 2222, 4444, 	// 6400 ~ 6415
+	1815, 3630, 7260, 7447, 8065, 6829, 4341, 1093, 2186, 4372, 1927, 3854, 7708, 6551, 5761, 2221, 	// 6416 ~ 6431
+	4442, 1819, 3638, 7276, 7543, 8001, 6957, 5109,  581, 1162, 2324, 4648,  511, 1022, 2044, 4088, 	// 6432 ~ 6447
+	8176, 6735, 4401, 1997, 3994, 7988, 7111, 4641,  493,  986, 1972, 3944, 7888, 6159, 5553, 3789, 	// 6448 ~ 6463
+	7578, 7835, 6297, 5277, 3221, 6442, 6139, 2649, 5298, 3275, 6550, 5763, 2217, 4434, 1803, 3606, 	// 6464 ~ 6479
+	7212, 7671, 7745, 6445, 6133, 2629, 5258, 3259, 6518, 5955, 2857, 5714, 2315, 4630,  387,  774, 	// 6480 ~ 6495
+	1548, 3096, 6192, 5583, 3633, 7266, 7531, 8057, 7005, 4885,  901, 1802, 3604, 7208, 7679, 7761, 	// 6496 ~ 6511
+	6413, 6069, 2757, 5514, 3771, 7542, 8003, 6953, 5117,  597, 1194, 2388, 4776,  255,  510, 1020, 	// 6512 ~ 6527
+	2040, 4080, 8160, 6767, 4465, 1869, 3738, 7476, 8135, 6689, 4589, 1653, 3306, 6612, 5639, 2465, 	// 6528 ~ 6543
+	4930,  811, 1622, 3244, 6488, 5919, 2961, 5922, 3051, 6102, 2563, 5126, 3491, 6982, 4899, 1001, 	// 6544 ~ 6559
+	2002, 4004, 8008, 6975, 5073,  525, 1050, 2100, 4200, 1407, 2814, 5628, 3671, 7342, 7411, 7241, 	// 6560 ~ 6575
+	7485, 8149, 6661, 4517, 1765, 3530, 7060, 4743,  161,  322,  644, 1288, 2576, 5152, 3567, 7134, 	// 6576 ~ 6591
+	4627,  393,  786, 1572, 3144, 6288, 5263, 3249, 6498, 5995, 2937, 5874, 2123, 4246, 1155, 2310, 	// 6592 ~ 6607
+	4620,  439,  878, 1756, 3512, 7024, 4943,  817, 1634, 3268, 6536, 5823, 2257, 4514, 1771, 3542, 	// 6608 ~ 6623
+	7084, 4855,   65,  130,  260,  520, 1040, 2080, 4160, 1327, 2654, 5308, 3287, 6574, 5875, 2121, 	// 6624 ~ 6639
+	4242, 1163, 2326, 4652,  503, 1006, 2012, 4024, 8048, 6991, 4913,  973, 1946, 3892, 7784, 6527, 	// 6640 ~ 6655
+	5969, 2829, 5658, 2459, 4918,  963, 1926, 3852, 7704, 6559, 5777, 2189, 4378, 1947, 3894, 7788, 	// 6656 ~ 6671
+	6519, 5953, 2861, 5722, 2331, 4662,  451,  902, 1804, 3608, 7216, 7631, 7729, 6605, 5685, 2501, 	// 6672 ~ 6687
+	5002,  699, 1398, 2796, 5592, 3615, 7230, 7635, 7689, 6589, 5845, 2053, 4106, 1467, 2934, 5868, 	// 6688 ~ 6703
+	2167, 4334, 1139, 2278, 4556, 1591, 3182, 6364, 5143, 3457, 6914, 5035,  761, 1522, 3044, 6088, 	// 6704 ~ 6719
+	2623, 5246, 3411, 6822, 4323, 1129, 2258, 4516, 1767, 3534, 7068, 4759,  129,  258,  516, 1032, 	// 6720 ~ 6735
+	2064, 4128, 1519, 3038, 6076, 2775, 5550, 3827, 7654, 7779, 6505, 6013, 2901, 5802, 2299, 4598, 	// 6736 ~ 6751
+	1603, 3206, 6412, 6071, 2753, 5506, 3755, 7510, 7939, 7081, 4861,   85,  170,  340,  680, 1360, 	// 6752 ~ 6767
+	2720, 5440, 3887, 7774, 6419, 6025, 2749, 5498, 3931, 7862, 6339, 5161, 3581, 7162, 4699,  281, 	// 6768 ~ 6783
+	 562, 1124, 2248, 4496, 1679, 3358, 6716, 4567, 1537, 3074, 6148, 5543, 3809, 7618, 7723, 6649, 	// 6784 ~ 6799
+	5725, 2325, 4650,  507, 1014, 2028, 4056, 8112, 6863, 4145, 1485, 2970, 5940, 3015, 6030, 2739, 	// 6800 ~ 6815
+	5478, 3939, 7878, 6179, 5609, 3709, 7418, 7259, 7449, 8093, 6805, 4229, 1189, 2378, 4756,  135, 	// 6816 ~ 6831
+	 270,  540, 1080, 2160, 4320, 1135, 2270, 4540, 1751, 3502, 7004, 4887,  897, 1794, 3588, 7176, 	// 6832 ~ 6847
+	7615, 7889, 6157, 5557, 3781, 7562, 7867, 6361, 5149, 3477, 6954, 5115,  601, 1202, 2404, 4808, 	// 6848 ~ 6863
+	  63,  126,  252,  504, 1008, 2016, 4032, 8064, 6831, 4337, 1101, 2202, 4404, 1991, 3982, 7964, 	// 6864 ~ 6879
+	7063, 4737,  173,  346,  692, 1384, 2768, 5536, 3823, 7646, 7699, 6537, 5821, 2261, 4522, 1787, 	// 6880 ~ 6895
+	3574, 7148, 4727,  321,  642, 1284, 2568, 5136, 3471, 6942, 5011,  649, 1298, 2596, 5192, 3391, 	// 6896 ~ 6911
+	6782, 4435, 1801, 3602, 7204, 7655, 7777, 6509, 6005, 2885, 5770, 2235, 4470, 1859, 3718, 7436, 	// 6912 ~ 6927
+	8119, 6849, 4141, 1525, 3050, 6100, 2567, 5134, 3507, 7014, 4963,  873, 1746, 3492, 6984, 4927, 	// 6928 ~ 6943
+	 977, 1954, 3908, 7816, 6335, 5329, 3085, 6170, 5531, 3737, 7474, 8139, 6713, 4573, 1557, 3114, 	// 6944 ~ 6959
+	6228, 5383, 4001, 8002, 6955, 5113,  605, 1210, 2420, 4840,  127,  254,  508, 1016, 2032, 4064, 	// 6960 ~ 6975
+	8128, 6703, 4593, 1613, 3226, 6452, 6087, 2593, 5186, 3371, 6742, 4355, 1961, 3922, 7844, 6375, 	// 6976 ~ 6991
+	5217, 3437, 6874, 4123, 1433, 2866, 5732, 2407, 4814,   51,  102,  204,  408,  816, 1632, 3264, 	// 6992 ~ 7007
+	6528, 5807, 2289, 4578, 1643, 3286, 6572, 5879, 2113, 4226, 1195, 2390, 4780,  247,  494,  988, 	// 7008 ~ 7023
+	1976, 3952, 7904, 6255, 5489, 3917, 7834, 6299, 5273, 3229, 6458, 6107, 2585, 5170, 3531, 7062, 	// 7024 ~ 7039
+	4739,  169,  338,  676, 1352, 2704, 5408, 4079, 8158, 6675, 4489, 1725, 3450, 6900, 4167, 1313, 	// 7040 ~ 7055
+	2626, 5252, 3239, 6478, 5939, 3017, 6034, 2699, 5398, 3971, 7942, 7075, 4841,  125,  250,  500, 	// 7056 ~ 7071
+	1000, 2000, 4000, 8000, 6959, 5105,  589, 1178, 2356, 4712,  383,  766, 1532, 3064, 6128, 2639, 	// 7072 ~ 7087
+	5278, 3219, 6438, 6115, 2665, 5330, 3083, 6166, 5507, 3753, 7506, 7947, 7097, 4829,   21,   42, 	// 7088 ~ 7103
+	  84,  168,  336,  672, 1344, 2688, 5376, 4015, 8030, 6931, 5001,  701, 1402, 2804, 5608, 3711, 	// 7104 ~ 7119
+	7422, 7251, 7433, 8125, 6869, 4101, 1445, 2890, 5780, 2183, 4366, 1971, 3942, 7884, 6199, 5569, 	// 7120 ~ 7135
+	3629, 7258, 7451, 8089, 6813, 4245, 1157, 2314, 4628,  391,  782, 1564, 3128, 6256, 5455, 3889, 	// 7136 ~ 7151
+	7778, 6507, 6009, 2909, 5818, 2267, 4534, 1731, 3462, 6924, 5047,  705, 1410, 2820, 5640, 2495, 	// 7152 ~ 7167
+	4990,  851, 1702, 3404, 6808, 4255, 1169, 2338, 4676,  295,  590, 1180, 2360, 4720,  335,  670, 	// 7168 ~ 7183
+	1340, 2680, 5360, 3151, 6302, 5267, 3209, 6418, 6027, 2745, 5490, 3915, 7830, 6275, 5289, 3325, 	// 7184 ~ 7199
+	6650, 5723, 2329, 4658,  459,  918, 1836, 3672, 7344, 7375, 7217, 7629, 7733, 6597, 5669, 2533, 	// 7200 ~ 7215
+	5066,  571, 1142, 2284, 4568, 1567, 3134, 6268, 5463, 3841, 7682, 6571, 5881, 2141, 4282, 1243, 	// 7216 ~ 7231
+	2486, 4972,  887, 1774, 3548, 7096, 4831,   17,   34,   68,  136,  272,  544, 1088, 2176, 4352, 	// 7232 ~ 7247
+	1967, 3934, 7868, 6359, 5121, 3501, 7002, 4891,  921, 1842, 3684, 7368, 7231, 7633, 7693, 6581, 	// 7248 ~ 7263
+	5829, 2085, 4170, 1339, 2678, 5356, 3191, 6382, 5235, 3401, 6802, 4235, 1209, 2418, 4836,  103, 	// 7264 ~ 7279
+	 206,  412,  824, 1648, 3296, 6592, 5679, 2545, 5090,  619, 1238, 2476, 4952,  799, 1598, 3196, 	// 7280 ~ 7295
+	6392, 5215, 3345, 6690, 4587, 1657, 3314, 6628, 5735, 2401, 4802,   43,   86,  172,  344,  688, 	// 7296 ~ 7311
+	1376, 2752, 5504, 3759, 7518, 7955, 7049, 4797,  213,  426,  852, 1704, 3408, 6816, 4335, 1137, 	// 7312 ~ 7327
+	2274, 4548, 1575, 3150, 6300, 5271, 3201, 6402, 6059, 2809, 5618, 3659, 7318, 7299, 7337, 7421, 	// 7328 ~ 7343
+	7253, 7429, 8101, 6885, 4197, 1381, 2762, 5524, 3719, 7438, 8115, 6857, 4157, 1493, 2986, 5972, 	// 7344 ~ 7359
+	2823, 5646, 2483, 4966,  867, 1734, 3468, 6936, 5023,  657, 1314, 2628, 5256, 3263, 6526, 5971, 	// 7360 ~ 7375
+	2825, 5650, 2443, 4886,  899, 1798, 3596, 7192, 7583, 7825, 6285, 5301, 3269, 6538, 5819, 2265, 	// 7376 ~ 7391
+	4530, 1739, 3478, 6956, 5111,  577, 1154, 2308, 4616,  447,  894, 1788, 3576, 7152, 4687,  305, 	// 7392 ~ 7407
+	 610, 1220, 2440, 4880,  911, 1822, 3644, 7288, 7519, 7953, 7053, 4789,  197,  394,  788, 1576, 	// 7408 ~ 7423
+	3152, 6304, 5359, 3185, 6370, 5227, 3449, 6898, 4171, 1337, 2674, 5348, 3175, 6350, 5171, 3529, 	// 7424 ~ 7439
+	7058, 4747,  185,  370,  740, 1480, 2960, 5920, 3055, 6110, 2579, 5158, 3555, 7110, 4643,  489, 	// 7440 ~ 7455
+	 978, 1956, 3912, 7824, 6287, 5297, 3277, 6554, 5787, 2201, 4402, 1995, 3990, 7980, 7159, 4673, 	// 7456 ~ 7471
+	 301,  602, 1204, 2408, 4816,   15,   30,   60,  120,  240,  480,  960, 1920, 3840, 7680, 6575, 	// 7472 ~ 7487
+	5873, 2125, 4250, 1179, 2358, 4716,  375,  750, 1500, 3000, 6000, 2895, 5790, 2195, 4390, 2019, 	// 7488 ~ 7503
+	4038, 8076, 6839, 4289, 1069, 2138, 4276, 1223, 2446, 4892,  919, 1838, 3676, 7352, 7391, 7185, 	// 7504 ~ 7519
+	7565, 7861, 6341, 5157, 3557, 7114, 4667,  473,  946, 1892, 3784, 7568, 7823, 6321, 5325, 3125, 	// 7520 ~ 7535
+	6250, 5499, 3929, 7858, 6347, 5177, 3549, 7098, 4827,   25,   50,  100,  200,  400,  800, 1600, 	// 7536 ~ 7551
+	3200, 6400, 6063, 2801, 5602, 3691, 7382, 7171, 7593, 7933, 6229, 5381, 4005, 8010, 6971, 5081, 	// 7552 ~ 7567
+	 541, 1082, 2164, 4328, 1151, 2302, 4604, 1623, 3246, 6492, 5911, 2945, 5890, 2987, 5974, 2819, 	// 7568 ~ 7583
+	5638, 2467, 4934,  803, 1606, 3212, 6424, 6047, 2705, 5410, 4075, 8150, 6659, 4521, 1789, 3578, 	// 7584 ~ 7599
+	7156, 4679,  289,  578, 1156, 2312, 4624,  399,  798, 1596, 3192, 6384, 5199, 3377, 6754, 4459, 	// 7600 ~ 7615
+	1913, 3826, 7652, 7783, 6497, 5997, 2933, 5866, 2171, 4342, 1091, 2182, 4364, 1975, 3950, 7900, 	// 7616 ~ 7631
+	6167, 5505, 3757, 7514, 7963, 7065, 4765,  149,  298,  596, 1192, 2384, 4768,  239,  478,  956, 	// 7632 ~ 7647
+	1912, 3824, 7648, 7791, 6513, 5965, 2869, 5738, 2427, 4854,   67,  134,  268,  536, 1072, 2144, 	// 7648 ~ 7663
+	4288, 1071, 2142, 4284, 1239, 2478, 4956,  791, 1582, 3164, 6328, 5343, 3089, 6178, 5611, 3705, 	// 7664 ~ 7679
+	7410, 7243, 7481, 8157, 6677, 4485, 1701, 3402, 6804, 4231, 1185, 2370, 4740,  167,  334,  668, 	// 7680 ~ 7695
+	1336, 2672, 5344, 3183, 6366, 5139, 3465, 6930, 5003,  697, 1394, 2788, 5576, 3647, 7294, 7507, 	// 7696 ~ 7711
+	7945, 7101, 4821,    5,   10,   20,   40,   80,  160,  320,  640, 1280, 2560, 5120, 3503, 7006, 	// 7712 ~ 7727
+	4883,  905, 1810, 3620, 7240, 7487, 8145, 6669, 4533, 1733, 3466, 6932, 4999,  673, 1346, 2692, 	// 7728 ~ 7743
+	5384, 4031, 8062, 6995, 4873,  957, 1914, 3828, 7656, 7807, 6481, 5901, 2997, 5994, 2939, 5878, 	// 7744 ~ 7759
+	2115, 4230, 1187, 2374, 4748,  183,  366,  732, 1464, 2928, 5856, 2159, 4318, 1043, 2086, 4172, 	// 7760 ~ 7775
+	1335, 2670, 5340, 3095, 6190, 5619, 3657, 7314, 7307, 7353, 7389, 7189, 7557, 7845, 6373, 5221, 	// 7776 ~ 7791
+	3429, 6858, 4155, 1497, 2994, 5988, 2919, 5838, 2099, 4198, 1379, 2758, 5516, 3767, 7534, 8051, 	// 7792 ~ 7807
+	6985, 4925,  981, 1962, 3924, 7848, 6399, 5201, 3341, 6682, 4507, 1689, 3378, 6756, 4455, 1889, 	// 7808 ~ 7823
+	3778, 7556, 7847, 6369, 5229, 3445, 6890, 4219, 1369, 2738, 5476, 3943, 7886, 6195, 5577, 3645, 	// 7824 ~ 7839
+	7290, 7515, 7961, 7069, 4757,  133,  266,  532, 1064, 2128, 4256, 1263, 2526, 5052,  727, 1454, 	// 7840 ~ 7855
+	2908, 5816, 2271, 4542, 1747, 3494, 6988, 4919,  961, 1922, 3844, 7688, 6591, 5841, 2061, 4122, 	// 7856 ~ 7871
+	1435, 2870, 5740, 2423, 4846,  115,  230,  460,  920, 1840, 3680, 7360, 7215, 7665, 7757, 6453, 	// 7872 ~ 7887
+	6085, 2597, 5194, 3387, 6774, 4419, 1833, 3666, 7332, 7399, 7265, 7533, 8053, 6981, 4901,  997, 	// 7888 ~ 7903
+	1994, 3988, 7976, 7167, 4689,  269,  538, 1076, 2152, 4304, 1039, 2078, 4156, 1495, 2990, 5980, 	// 7904 ~ 7919
+	2839, 5678, 2547, 5094,  611, 1222, 2444, 4888,  927, 1854, 3708, 7416, 7263, 7441, 8077, 6837, 	// 7920 ~ 7935
+	4293, 1061, 2122, 4244, 1159, 2318, 4636,  407,  814, 1628, 3256, 6512, 5967, 2865, 5730, 2411, 	// 7936 ~ 7951
+	4822,    3,    6,   12,   24,   48,   96,  192,  384,  768, 1536, 3072, 6144, 5551, 3825, 7650, 	// 7952 ~ 7967
+	7787, 6521, 5981, 2837, 5674, 2555, 5110,  579, 1158, 2316, 4632,  415,  830, 1660, 3320, 6640, 	// 7968 ~ 7983
+	5711, 2353, 4706,  363,  726, 1452, 2904, 5808, 2255, 4510, 1683, 3366, 6732, 4407, 1985, 3970, 	// 7984 ~ 7999
+	7940, 7079, 4833,  109,  218,  436,  872, 1744, 3488, 6976, 4911, 1009, 2018, 4036, 8072, 6847, 	// 8000 ~ 8015
+	4305, 1037, 2074, 4148, 1479, 2958, 5916, 2967, 5934, 3059, 6118, 2659, 5318, 3107, 6214, 5411, 	// 8016 ~ 8031
+	4073, 8146, 6667, 4537, 1757, 3514, 7028, 4935,  801, 1602, 3204, 6408, 6079, 2769, 5538, 3819, 	// 8032 ~ 8047
+	7638, 7683, 6569, 5885, 2133, 4266, 1275, 2550, 5100,  631, 1262, 2524, 5048,  735, 1470, 2940, 	// 8048 ~ 8063
+	5880, 2143, 4286, 1235, 2470, 4940,  823, 1646, 3292, 6584, 5855, 2065, 4130, 1515, 3030, 6060, 	// 8064 ~ 8079
+	2807, 5614, 3699, 7398, 7267, 7529, 8061, 6997, 4869,  933, 1866, 3732, 7464, 8191, 6737, 4365, 	// 8080 ~ 8095
+	1973, 3946, 7892, 6151, 5537, 3821, 7642, 7707, 6553, 5789, 2197, 4394, 2043, 4086, 8172, 6775, 	// 8096 ~ 8111
+	4417, 1837, 3674, 7348, 7367, 7201, 7661, 7797, 6469, 5925, 3045, 6090, 2619, 5238, 3395, 6790, 	// 8112 ~ 8127
+	4259, 1257, 2514, 5028,  743, 1486, 2972, 5944, 3039, 6078, 2771, 5542, 3811, 7622, 7715, 6633, 	// 8128 ~ 8143
+	5757, 2389, 4778,  251,  502, 1004, 2008, 4016, 8032, 7023, 4977,  845, 1690, 3380, 6760, 4479, 	// 8144 ~ 8159
+	1873, 3746, 7492, 7975, 7137, 4717,  373,  746, 1492, 2984, 5968, 2831, 5662, 2451, 4902,  995, 	// 8160 ~ 8175
+	1990, 3980, 7960, 7071, 4753,  141,  282,  564, 1128, 2256, 4512, 1775, 3550, 7100, 4823,    0  	// 8176 ~ 8191
+};
+
+const short BCH_IndexOfTable[8192] =
+{
+	  -1,    0,    1, 7953,    2, 7715, 7954, 3551,    3, 3313, 7716, 5441, 7955, 1529, 3552, 7477, 	//    0 ~   15
+	   4, 7239, 3314, 1441, 7717, 7102, 5442, 1291, 7956, 7545, 1530, 3075, 3553, 5203, 7478, 2784, 	//   16 ~   31
+	   5, 2546, 7240, 5080, 3315, 4596, 1442, 4965, 7718,  466, 7103, 7307, 5443, 2837, 1292,  822, 	//   32 ~   47
+	7957,  801, 7546, 7001, 1531, 1203, 3076, 4294, 3554, 1053, 5204, 3033, 7479, 6073, 2785, 6864, 	//   48 ~   63
+	   6, 6626, 2547, 7658, 7241, 2691, 5081, 5835, 3316, 2893, 4597,  815, 1443, 2795, 4966, 2905, 	//   64 ~   79
+	7719, 3058,  467,  563, 7104, 6763, 7308, 1956, 5444, 4056, 2838,  838, 1293, 6335,  823,  965, 	//   80 ~   95
+	7958, 3626,  802, 2308, 7547, 4842, 7002, 7279, 1532, 4727, 1204, 2462, 3077, 8003, 4295, 4358, 	//   96 ~  111
+	3555,  584, 1054, 7877, 5205, 2629, 3034, 2599, 7480, 4992, 6074,  228, 2786, 7069, 6865, 6970, 	//  112 ~  127
+	   7, 6732, 6627, 4178, 2548, 7845, 7659, 6831, 7242, 5051, 2692, 4754, 5082, 8181, 5836, 5864, 	//  128 ~  143
+	3317, 1826, 2894,  346, 4598, 7639,  816, 4352, 1444, 2361, 2796, 4313, 4967, 5263, 2906, 2391, 	//  144 ~  159
+	7720, 6584, 3059, 3388,  468, 2070,  564, 7693, 7105, 7041, 6764, 1387, 7309, 6882, 1957, 4604, 	//  160 ~  175
+	5445, 4120, 4057, 1433, 2839,  883,  839, 7765, 1294, 7442, 6336, 4489,  824, 2224,  966,  260, 	//  176 ~  191
+	7959, 5281, 3627, 6388,  803, 7420, 2309, 2970, 7548, 5597, 4843, 4681, 7003, 4373, 7280, 2453, 	//  192 ~  207
+	1533, 2667, 4728,  213, 1205, 7320, 2463, 2557, 3078,   34, 8004, 2655, 4296,  577, 4359, 4017, 	//  208 ~  223
+	3556,  727,  585, 4795, 1055, 3138, 7878, 6097, 5206,  440, 2630, 3818, 3035,  600, 2600, 7645, 	//  224 ~  239
+	7481, 4303, 4993, 2820, 6075,  325,  229, 7021, 2787, 1718, 7070, 8147, 6866, 2746, 6971, 6525, 	//  240 ~  255
+	   8, 6287, 6733, 3363, 6628, 2882, 4179, 2508, 2549, 6263, 7846, 1480, 7660, 7909, 6832, 4562, 	//  256 ~  271
+	7243, 6013, 5052, 4065, 2693, 2582, 4755, 2138, 5083, 6783, 8182, 6197, 5837, 5184, 5865,   87, 	//  272 ~  287
+	3318, 7602, 1827,  489, 2895, 4557,  347, 7177, 4599, 5859, 7640, 2448,  817, 7472, 4353, 2900, 	//  288 ~  303
+	1445, 7407, 2362, 5907, 2797, 2639, 4314,  362, 4968, 3697, 5264,  202, 2907, 3580, 2392, 1752, 	//  304 ~  319
+	7721, 6899, 6585, 5043, 3060, 6150, 3389, 1846,  469, 2732, 2071, 6180,  565, 1726, 7694, 7182, 	//  320 ~  335
+	7106, 2215, 7042, 5823, 6765, 5568, 1388, 4135, 7310, 3237, 6883, 5359, 1958, 4443, 4605, 1761, 	//  336 ~  351
+	5446, 3779, 4121,  136, 4058, 1688, 1434,  339, 2840, 3670,  884, 7987,  840, 2417, 7766,  352, 	//  352 ~  367
+	1295, 4024, 7443, 2429, 6337, 8166, 4490, 7494,  825, 2319, 2225, 2611,  967, 2330,  261, 7082, 	//  368 ~  383
+	7960, 4389, 5282, 6494, 3628, 3940, 6389, 7145,  804, 6593, 7421, 1411, 2310, 4211, 2971, 7607, 	//  384 ~  399
+	7549, 5626, 5598, 1695, 4844,  283, 4682, 7943, 7004, 6125, 4374, 4813, 7281, 4516, 2454, 7979, 	//  400 ~  415
+	1534, 2153, 2668, 3174, 4729, 5507,  214, 5025, 1206, 4956, 7321, 2123, 2464, 4075, 2558, 3323, 	//  416 ~  431
+	3079, 1335,   35, 1588, 8005,  108, 2656, 6609, 4297, 4114,  578,  795, 4360, 1329, 4018, 7401, 	//  432 ~  447
+	3557,   22,  728, 6678,  586, 1995, 4796, 1986, 1056, 3018, 3139, 7204, 7879, 4251, 6098,  494, 	//  448 ~  463
+	5207, 4225,  441, 3882, 2631, 1195, 3819, 6271, 3036, 7527,  601, 6242, 2601, 5487, 7646,  645, 	//  464 ~  479
+	7482, 1544, 4304, 6346, 4994, 3150, 2821, 1857, 6076, 7455,  326, 2351,  230, 6456, 7022, 1832, 	//  480 ~  495
+	2788, 4366, 1719, 4244, 7071,  550, 8148, 6644, 6867, 3187, 2747, 6803, 6972, 1149, 6526, 6444, 	//  496 ~  511
+	   9, 6206, 6288, 2811, 6734, 5427, 3364,  911, 6629, 4158, 2883, 2949, 4180, 6565, 2509, 3585, 	//  512 ~  527
+	2550, 1949, 6264, 4128, 7847, 4006, 1481,  989, 7661, 6406, 7910, 5343, 6833, 7568, 4563,  312, 	//  528 ~  543
+	7244, 1160, 6014, 1306, 5053, 6108, 4066, 1215, 2694, 1619, 2583, 2680, 4756, 1108, 2139, 2912, 	//  544 ~  559
+	5084, 1594, 6784, 3402, 8183, 6279, 6198, 6218, 5838, 3764, 5185, 7217, 5866, 2113,   88, 6037, 	//  560 ~  575
+	3319, 7397, 7603, 7975, 1828, 6440,  490,  641, 2896, 1748, 4558,   83,  348, 7078, 7178, 1757, 	//  576 ~  591
+	4600,  256, 5860, 2387, 7641, 6521, 2449, 4013,  818, 6860, 7473, 2780, 4354, 6966, 2901,  961, 	//  592 ~  607
+	1446,  407, 7408, 7924, 2363, 5326, 5908, 5249, 2798, 2340, 2640, 7289, 4315, 6004,  363, 2397, 	//  608 ~  623
+	4969,   41, 3698, 3987, 5265, 3644,  203, 8057, 2908, 6033, 3581,  308, 2393,  953, 1753,  957, 	//  624 ~  639
+	7722, 2263, 6900, 4151, 6586, 6256, 5044, 3306, 3061, 6907, 6151,  666, 3390, 3005, 1847, 3702, 	//  640 ~  655
+	 470, 7369, 2733,  143, 2072, 1402, 6181, 3973,  566, 1497, 1727, 6355, 7695, 1173, 7183, 3991, 	//  656 ~  671
+	7107, 7741, 2216, 1321, 7043, 5295, 5824, 4278, 6766,  155, 5569, 5887, 1389, 4575, 4136, 4973, 	//  672 ~  687
+	7311, 1341, 3238, 5388, 6884, 1457, 5360, 5166, 1959, 7705, 4444, 6689, 4606, 7115, 1762,   45, 	//  688 ~  703
+	5447, 7163, 3780,  617, 4122, 2381,  137, 1091, 4059, 5817, 1689, 3876, 1435,  557,  340,  207, 	//  704 ~  719
+	2841,  538, 3671, 1097,  885, 1350, 7988, 7854,  841, 6371, 2418, 2295, 7767, 4908,  353, 8061, 	//  720 ~  735
+	1296, 3507, 4025, 1915, 7444, 2936, 2430, 8132, 6338, 4787, 8167, 1907, 4491, 5155, 7495, 5269, 	//  736 ~  751
+	 826, 3085, 2320, 6297, 2226, 2922, 2612, 3837,  968, 6716, 2331, 4718,  262, 1885, 7083, 3648, 	//  752 ~  767
+	7961, 6226, 4390, 6049, 5283, 3125, 6495, 3250, 3629, 2270, 3941, 4434, 6390, 5127, 7146, 2644, 	//  768 ~  783
+	 805, 4324, 6594, 5453, 7422, 4400, 1412, 7671, 2311, 4984, 4212, 6025, 2972, 1242, 7608, 7293, 	//  784 ~  799
+	7550, 8040, 5627, 7587, 5599, 4422, 1696, 4946, 4845, 5735,  284, 6545, 4683, 5959, 7944, 2802, 	//  800 ~  815
+	7005, 6615, 6126, 5775, 4375, 3827, 4814, 8070, 7282, 1900, 4517, 2992, 2455, 3811, 7980, 2344, 	//  816 ~  831
+	1535, 1514, 2154, 2242, 2669, 3606, 3175, 3342, 4730, 5994, 5508, 3459,  215, 8155, 5026,  367, 	//  832 ~  847
+	1207, 4938, 4957, 7169, 7322, 5669, 2124,  996, 2465,  124, 4076, 5897, 2559, 3950, 3324, 2401, 	//  848 ~  863
+	3080,  533, 1336, 7364,   36,  251, 1589, 1944, 8006, 6939,  109, 4524, 2657, 4933, 6610, 4319, 	//  864 ~  879
+	4298, 2662, 4115, 1821,  579, 3053,  796, 7234, 4361, 4220, 1330, 5621, 4019, 2210, 7402, 6008, 	//  880 ~  895
+	3558, 6844,   23, 7380,  729, 6506, 6679, 2092,  587, 7729, 1996, 2081, 4797, 2373, 1987, 7412, 	//  896 ~  911
+	1057, 4529, 3019, 3786, 3140, 2191, 7205, 7514, 7880, 7256, 4252, 3205, 6099, 4587,  495, 7928, 	//  912 ~  927
+	5208, 5401, 4226, 3541,  442, 8089, 3883,  176, 2632,  101, 1196,  876, 3820, 1224, 6272, 1450, 	//  928 ~  943
+	3037,  114, 7528, 3485,  602, 1231, 6243, 2179, 2602, 5612, 5488, 3432, 7647, 7749,  646,  411, 	//  944 ~  959
+	7483, 7864, 1545, 6661, 4305, 4805, 6347, 3197, 4995, 1608, 3151, 1137, 2822, 6651, 1858, 5912, 	//  960 ~  975
+	6077, 6944, 7456,  623,  327, 7810, 2352, 1488,  231, 4620, 6457, 2494, 7023, 5942, 1833, 5253, 	//  976 ~  991
+	2789, 1523, 4367, 8175, 1720, 7903, 4245, 4205, 7072, 6559,  551, 2999, 8149, 5121, 6645, 2367, 	//  992 ~ 1007
+	6868, 8011, 3188, 1977, 2748, 5585, 6804, 5377, 6973, 3897, 1150,   64, 6527, 4474, 6445, 5330, 	// 1008 ~ 1023
+	  10, 5092, 6207, 4692, 6289, 1969, 2812, 4236, 6735, 3709, 5428, 3659, 3365, 8017,  912, 7914, 	// 1024 ~ 1039
+	6630, 1001, 4159, 7773, 2884, 1739, 2950, 4886, 4181, 5139, 6566, 5718, 2510, 3570, 3586, 5347, 	// 1040 ~ 1055
+	2551, 4346, 1950, 1285, 6265, 7937, 4129, 2132, 7848, 3967, 4007,  983, 1482, 7508,  990, 7665, 	// 1056 ~ 1071
+	7662, 2129, 6407, 4880, 7911, 4233, 5344, 4883, 6834, 5701, 7569, 6321, 4564, 2761,  313, 6410, 	// 1072 ~ 1087
+	7245,  932, 1161, 7626, 6015, 6423, 1307, 2764, 5054, 2959, 6109, 4334, 4067, 6874, 1216, 4567, 	// 1088 ~ 1103
+	2695, 5674, 1620, 4914, 2584, 1644, 2681, 6413, 4757, 4667, 1109, 1370, 2140,  899, 2913,  316, 	// 1104 ~ 1119
+	5085, 5015, 1595, 5763, 6785,  712, 3403, 5704, 8184, 6725, 6280, 4382, 6199, 2256, 6219, 6837, 	// 1120 ~ 1135
+	5839, 7327, 3765, 6706, 5186,  385, 7218, 6324, 5867, 1250, 2114,  867,   89, 1872, 6038, 7572, 	// 1136 ~ 1151
+	3320, 5022, 7398, 6606, 7604, 7142, 7976, 7940, 1829, 1854, 6441, 6641,  491, 1983,  642, 6268, 	// 1152 ~ 1167
+	2897, 7174, 1749,  359, 4559, 2505,   84, 2135,  349,  336, 7079, 7491, 7179, 1843, 1758, 4132, 	// 1168 ~ 1183
+	4601, 7690,  257, 7762, 5861, 6828, 2388, 4349, 7642, 6094, 6522, 7018, 2450, 2967, 4014, 2554, 	// 1184 ~ 1199
+	 819, 4962, 6861, 4291, 7474, 3548, 2781, 1288, 4355, 7276, 6967, 2596, 2902, 5832,  962, 1953, 	// 1200 ~ 1215
+	1447,  173,  408, 2176, 7409, 2089, 7925, 7511, 2364, 4202, 5327, 5374, 5909, 3194, 5250, 1485, 	// 1216 ~ 1231
+	2799, 4943, 2341, 8067, 2641, 3247, 7290, 7668, 4316, 1941, 6005, 7231,  364, 3339, 2398,  993, 	// 1232 ~ 1247
+	4970, 4275,   42, 5163, 3699, 3303, 3988, 3970, 5266, 8129, 3645, 3834,  204, 1088, 8058, 7851, 	// 1248 ~ 1263
+	2909, 1212, 6034, 6215, 3582,  908,  309,  986, 2394, 5246,  954, 8054, 1754,  638,  958, 4010, 	// 1264 ~ 1279
+	7723, 1602, 2264, 5988, 6901, 5811, 4152, 1742, 6587, 3012, 6257, 2726, 5045, 5591, 3307, 2887, 	// 1280 ~ 1295
+	3062, 2406, 6908,  847, 6152,  397,  667, 4889, 3391, 3098, 3006, 2032, 1848, 4196, 3703, 2953, 	// 1296 ~ 1311
+	 471, 7055, 7370, 2015, 2734, 1631,  144, 1004, 2073,  658, 1403, 4746, 6182, 5787, 3974, 6633, 	// 1312 ~ 1327
+	 567, 3329, 1498, 4086, 1728, 5215, 6356, 7776, 7696, 7433, 1174, 7267, 7184, 2520, 3992, 4162, 	// 1328 ~ 1343
+	7108, 2106, 7742, 3804, 2217, 6066, 1322, 3573, 7044, 2038, 5296, 1662, 5825, 2754, 4279, 2513, 	// 1344 ~ 1359
+	6767, 3955,  156, 6377, 5570, 5537, 5888, 5350, 1390, 7832, 4576, 5546, 4137, 2279, 4974, 3589, 	// 1360 ~ 1375
+	7312, 1187, 1342, 7802, 3239, 7349, 5389, 5142, 6885, 4708, 1458, 4821, 5361, 4045, 5167, 4184, 	// 1376 ~ 1391
+	1960, 2564, 7706, 5418, 4445, 1563, 6690, 5721, 4607, 2980, 7116, 5497, 1763, 6307,   46, 6569, 	// 1392 ~ 1407
+	5448, 5770, 7164, 1816, 3781, 3480,  618, 1972, 4123, 3397, 2382, 3982,  138, 5383, 1092, 6292, 	// 1408 ~ 1423
+	4060, 5902, 5818, 2424, 1690, 1583, 3877, 4239, 1436, 6996,  558, 7872,  341, 1428,  208, 2815, 	// 1424 ~ 1439
+	2842,  187,  539,  295, 3672, 7126, 1098, 5095,  886, 1706, 1351, 5876, 7989, 5062, 7855,   13, 	// 1440 ~ 1455
+	 842, 4081, 6372, 5413, 2419, 5408, 2296, 4695, 7768, 4875, 4909, 6701,  354, 4286, 8062, 6210, 	// 1456 ~ 1471
+	1297, 5071, 3508, 1276, 4026, 2004, 1916, 8020, 7445, 3104, 2937, 4101, 2431, 6810, 8133, 3368, 	// 1472 ~ 1487
+	6339,  129, 4788, 2301, 8168, 7357, 1908, 7917, 4492, 7795, 5156, 5756, 7496, 3221, 5270,  915, 	// 1488 ~ 1503
+	 827, 2163, 3086, 4499, 2321, 2201, 6298, 3712, 2227, 3114, 2923, 8077, 2613, 5659, 3838, 6738, 	// 1504 ~ 1519
+	 969, 2470, 6717, 4700, 2332, 6931, 4719, 3662,  263,  758, 1886, 4864, 7084, 1804, 3649, 5431, 	// 1520 ~ 1535
+	7962, 6792, 6227, 5968, 4391, 2573, 6050,  388, 5284,  673, 3126,  699, 6496, 3903, 3251, 5189, 	// 1536 ~ 1551
+	3630, 3347, 2271,  891, 3942, 6958, 4435, 6327, 6391, 3855, 5128, 3920, 7147, 2711, 2645, 7221, 	// 1552 ~ 1567
+	 806,   74, 4325, 3517, 6595,  504, 5454, 7330, 7423, 3687, 4401, 6168, 1413, 5105, 7672, 5842, 	// 1568 ~ 1583
+	2312, 3180, 4985, 1711, 4213, 3890, 6026, 6709, 2973,  751, 1243, 5239, 7609, 2045, 7294, 3768, 	// 1584 ~ 1599
+	7551, 5799, 8041, 6752, 5628, 2854, 7588, 1875, 5600, 4895, 4423, 3526, 1697, 6979, 4947,   92, 	// 1600 ~ 1615
+	4846, 3611, 5736, 1356,  285, 3164, 6546, 7575, 4684, 5980, 5960, 1023, 7945, 3355, 2803, 6041, 	// 1616 ~ 1631
+	7006, 6162, 6616,  922, 6127, 1068, 5776, 1253, 4376,  977, 3828, 7012, 4815, 4740, 8071, 5870, 	// 1632 ~ 1647
+	7283, 2674, 1901, 5881, 4518, 6539, 2993,  870, 2456, 7301, 3812, 1381, 7981, 2442, 2345, 2117, 	// 1648 ~ 1663
+	1536,  719, 1515, 3499, 2155, 4267, 2243,  715, 2670, 6158, 3607, 5795, 3176,   70, 3343, 6788, 	// 1664 ~ 1679
+	4731, 2247, 5995, 7994, 5509, 3749, 3460, 5707,  216, 7819, 8156, 1553, 5027, 5312,  368, 3406, 	// 1680 ~ 1695
+	1208, 4271, 4939,  169, 4958, 7686, 7170, 5018, 7323, 5011, 5670,  928, 2125, 4342,  997, 5088, 	// 1696 ~ 1711
+	2466, 2159,  125, 5067, 4077,  183, 5898, 5766, 2560, 1183, 3951, 2102, 3325, 7051, 2402, 1598, 	// 1712 ~ 1727
+	3081, 3503,  534, 7159, 1337, 7737, 7365, 2259,   37,  403,  252, 7393, 1590, 1156, 1945, 6202, 	// 1728 ~ 1743
+	8007, 1519, 6940, 7860,  110, 5397, 4525, 6840, 2658,  529, 4934, 1510, 6611, 8036, 4320, 6222, 	// 1744 ~ 1759
+	4299,  723, 2663, 5277, 4116, 6580, 1822, 6728,  580, 3622, 3054, 6622,  797, 2542, 7235, 8187, 	// 1760 ~ 1775
+	4362, 1540, 4221,   18, 1331, 2149, 5622, 4385, 4020, 3775, 2211, 6895, 7403, 7598, 6009, 6283, 	// 1776 ~ 1791
+	3559, 3410, 6845, 1031,   24, 1931, 7381, 1647,  730, 6914, 6507, 6478, 6680, 4480, 2093, 2587, 	// 1792 ~ 1807
+	 588,  372, 7730, 2847, 1997, 6059, 2082, 6416, 4798, 3599, 2374, 6433, 1988, 6143, 7413, 2684, 	// 1808 ~ 1823
+	1058, 5316, 4530, 3269, 3020, 1677, 3787, 5677, 3141, 7894, 2192, 1074, 7206, 8113, 7515, 2698, 	// 1824 ~ 1839
+	7881, 5031, 7257,  192, 4253,  449, 3206, 4917, 6100, 4414, 4588, 4549,  496, 1669, 7929, 1623, 	// 1840 ~ 1855
+	5209, 1557, 5402, 6925, 4227,  379, 3542,  902,  443,  853, 8090, 2531, 3884, 6533,  177, 2143, 	// 1856 ~ 1871
+	2633, 8160,  102,  544, 1197, 2623,  877,  319, 3821, 3047, 1225, 5579, 6273, 3638, 1451, 2916, 	// 1872 ~ 1887
+	3038, 7823,  115, 3228, 7529, 5689, 3486, 4670,  603, 2478, 1232, 6133, 6244, 2057, 2180, 4760, 	// 1888 ~ 1903
+	2603,  220, 5613,  300, 5489,  859, 3433, 1373, 7648, 7616, 7750, 3441,  647, 3721,  412, 1112, 	// 1904 ~ 1919
+	7484, 5711, 7865, 2025, 1546, 3913, 6662, 6426, 4306, 3068, 4806, 6190, 6348, 5336, 3198, 6018, 	// 1920 ~ 1935
+	4996, 3464, 1609, 3677, 3152,  780, 1138, 2767, 2823, 1267, 6652, 6669, 1859,  428, 5913, 1310, 	// 1936 ~ 1951
+	6078, 3753, 6945, 5475, 7457, 1127,  624,  935,  328, 6988, 7811, 1259, 2353, 6117, 1489, 7248, 	// 1952 ~ 1967
+	 232, 5513, 4621, 7131, 6458, 8096, 2495, 7629, 7024, 3735, 5943, 1789, 1834, 5303, 5254, 1164, 	// 1968 ~ 1983
+	2790, 7998, 1524, 2832, 4368,  595, 8176, 6877, 1721, 2412, 7904, 7467, 4246, 6451, 4206, 4070, 	// 1984 ~ 1999
+	7073, 5999, 6560, 1103,  552, 5150, 3000, 4570, 8150, 4928, 5122, 5954, 6646, 5116, 2368, 1219, 	// 2000 ~ 2015
+	6869, 2251, 8012, 7503, 3189, 1083, 1978, 2962, 2749, 4040, 5586, 5782, 6805, 5654, 5378, 5057, 	// 2016 ~ 2031
+	6974, 4735, 3898, 5100, 1151, 2537,   65, 4337, 6528, 2052, 4475, 8108, 6446, 5649, 5331, 6112, 	// 2032 ~ 2047
+	  11, 5874, 5093,  293, 6208, 6699, 4693, 5411, 6290, 3980, 1970, 1814, 2813, 7870, 4237, 2422, 	// 2048 ~ 2063
+	6736, 8075, 3710, 4497, 5429, 4862, 3660, 4698, 3366, 4099, 8018, 1274,  913, 5754, 7915, 2299, 	// 2064 ~ 2079
+	6631, 4744, 1002, 2013, 4160, 7265, 7774, 4084, 2885, 2724, 1740, 5986, 2951, 2030, 4887,  845, 	// 2080 ~ 2095
+	4182, 4819, 5140, 7800, 6567, 5495, 5719, 5416, 2511, 1660, 3571, 3802, 3587, 5544, 5348, 6375, 	// 2096 ~ 2111
+	2552, 7016, 4347, 7760, 1951, 2594, 1286, 4289, 6266, 6639, 7938, 6604, 4130, 7489, 2133,  357, 	// 2112 ~ 2127
+	7849, 3832, 3968, 5161, 4008, 8052,  984, 6213, 1483, 5372, 7509, 2174,  991, 7229, 7666, 8065, 	// 2128 ~ 2143
+	7663,  981, 2130, 1283, 6408, 6319, 4881, 4878, 7912, 3657, 4234, 4690, 5345, 5716, 4884, 7771, 	// 2144 ~ 2159
+	6835, 4380, 5702, 5761, 7570,  865, 6322, 6704, 4565, 4332, 2762, 7624,  314, 1368, 6411, 4912, 	// 2160 ~ 2175
+	7246, 1257,  933, 5473, 1162, 1787, 7627, 7129, 6016, 6188, 6424, 2023, 1308, 6667, 2765, 3675, 	// 2176 ~ 2191
+	5055, 5780, 2960, 7501, 6110, 8106, 4335, 5098, 4068, 7465, 6875, 2830, 1217, 5952, 4568, 1101, 	// 2192 ~ 2207
+	2696, 1072, 5675, 3267, 1621, 4547, 4915,  190, 2585, 6476, 1645, 1029, 2682, 6431, 6414, 2845, 	// 2208 ~ 2223
+	4758, 6131, 4668, 3226, 1110, 3439, 1371,  298, 2141, 2529,  900, 6923, 2914, 5577,  317,  542, 	// 2224 ~ 2239
+	5086,  926, 5016,  167, 1596, 2100, 5764, 5065, 6786, 5793,  713, 3497, 3404, 1551, 5705, 7992, 	// 2240 ~ 2255
+	8185, 6620, 6726, 5275, 6281, 6893, 4383,   16, 6200, 7391, 2257, 7157, 6220, 1508, 6838, 7858, 	// 2256 ~ 2271
+	5840, 6166, 7328, 3515, 3766, 5237, 6707, 1709, 5187,  697,  386, 5966, 7219, 3918, 6325,  889, 	// 2272 ~ 2287
+	5868, 7010, 1251,  920, 2115, 1379,  868, 5879,   90, 3524, 1873, 6750, 6039, 1021, 7573, 1354, 	// 2288 ~ 2303
+	3321, 2121, 5023, 3172, 7399,  793, 6607, 1586, 7605, 1409, 7143, 6492, 7977, 4811, 7941, 1693, 	// 2304 ~ 2319
+	1830, 2349, 1855, 6344, 6442, 6801, 6642, 4242,  492, 7202, 1984, 6676,  643, 6240, 6269, 3880, 	// 2320 ~ 2335
+	2898, 2446, 7175,  487, 1750,  200,  360, 5905, 4560, 1478, 2506, 3361,   85, 6195, 2136, 4063, 	// 2336 ~ 2351
+	 350, 7985,  337,  134, 7080, 2609, 7492, 2427, 7180, 6178, 1844, 5041, 1759, 5357, 4133, 5821, 	// 2352 ~ 2367
+	4602, 1385, 7691, 3386,  258, 4487, 7763, 1431, 5862, 4752, 6829, 4176, 2389, 4311, 4350,  344, 	// 2368 ~ 2383
+	7643, 3816, 6095, 4793, 6523, 8145, 7019, 2818, 2451, 4679, 2968, 6386, 4015, 2653, 2555,  211, 	// 2384 ~ 2399
+	 820, 7305, 4963, 5078, 6862, 3031, 4292, 6999, 7475, 5439, 3549, 7951, 2782, 3073, 1289, 1439, 	// 2400 ~ 2415
+	4356, 2460, 7277, 2306, 6968,  226, 2597, 7875, 2903,  813, 5833, 7656,  963,  836, 1954,  561, 	// 2416 ~ 2431
+	1448,  874,  174, 3539,  409, 3430, 2177, 3483, 7410, 2079, 2090, 7378, 7926, 3203, 7512, 3784, 	// 2432 ~ 2447
+	2365, 2997, 4203, 8173, 5328,   62, 5375, 1975, 5910, 1135, 3195, 6659, 5251, 2492, 1486,  621, 	// 2448 ~ 2463
+	2800, 6543, 4944, 7585, 2342, 2990, 8068, 5773, 2642, 4432, 3248, 6047, 7291, 6023, 7669, 5451, 	// 2464 ~ 2479
+	4317, 4522, 1942, 7362, 6006, 5619, 7232, 1819,  365, 3457, 3340, 2240, 2399, 5895,  994, 7167, 	// 2480 ~ 2495
+	4971, 5885, 4276, 1319,   43, 6687, 5164, 5386, 3700,  664, 3304, 4149, 3989, 6353, 3971,  141, 	// 2496 ~ 2511
+	5267, 1905, 8130, 1913, 3646, 4716, 3835, 6295,  205, 3874, 1089,  615, 8059, 2293, 7852, 1095, 	// 2512 ~ 2527
+	2910, 2678, 1213, 1304, 6035, 7215, 6216, 3400, 3583, 2947,  909, 2809,  310, 5341,  987, 4126, 	// 2528 ~ 2543
+	2395, 7287, 5247, 7922,  955,  306, 8055, 3985, 1755,   81,  639, 7973,  959, 2778, 4011, 2385, 	// 2544 ~ 2559
+	7724,   96, 1603, 6554, 2265, 5730, 5989, 6934, 6902,  150, 5812, 4782, 4153, 1614, 1743, 2335, 	// 2560 ~ 2575
+	6588, 4951, 3013, 7450, 6258, 5854, 2727, 3665, 5046, 7036, 5592,  435, 3308,  461, 2888, 4722, 	// 2576 ~ 2591
+	3063, 6983, 2407, 4035, 6909, 7889,  848, 2473, 6153, 5006,  398, 3617,  668, 3682, 4890,  972, 	// 2592 ~ 2607
+	3392, 1701, 3099, 3109, 3007,  653, 2033, 4703, 1849, 6089, 4197, 8124, 3704, 3962, 2954, 6720, 	// 2608 ~ 2623
+	 472, 3530, 7056, 4775, 7371, 6485, 2016, 1807, 2735, 1010, 1632,  513,  145, 5001, 1005, 7087, 	// 2624 ~ 2639
+	2074, 4427,  659, 2942, 1404, 1473, 4747, 5434, 6183, 6471, 5788,  692, 3975, 2719, 6634, 3652, 	// 2640 ~ 2655
+	 568, 4899, 3330, 8027, 1499, 3279, 4087,  761, 1729, 7092, 5216, 4852, 6357, 3469, 7777,  266, 	// 2656 ~ 2671
+	7697, 5604, 7434, 4106, 1175, 3727, 7268, 4867, 7185, 5461, 2521, 3449, 3993, 5930, 4163, 1889, 	// 2672 ~ 2687
+	7109, 1879, 2107,  947, 7743, 4468, 3805, 2204, 2218, 2740, 6067, 7063, 1323, 1143, 3574, 2324, 	// 2688 ~ 2703
+	7045, 7592, 2039, 2436, 5297, 5643, 1663, 3715, 5826,  632, 2755, 1866, 4280, 1798, 2514, 6301, 	// 2704 ~ 2719
+	6768, 2858, 3956, 5924,  157,  684, 6378, 2166, 5571, 1015, 5538, 1362, 5889, 2772, 5351,  830, 	// 2720 ~ 2735
+	1391, 5632, 7833, 6815, 4577,  418, 5547, 4502, 4138, 7193, 2280,  739, 4975, 6774, 3590, 3089, 	// 2736 ~ 2751
+	7313, 6756, 1188, 5561, 1343, 6514, 7803, 5662, 3240, 1637, 7350, 5530, 5390, 3157, 5143, 2616, 	// 2752 ~ 2767
+	6886, 8045, 4709, 8138, 1459, 1466, 4822, 6741, 5362, 4635, 4046, 4657, 5168, 3288, 4185, 3841, 	// 2768 ~ 2783
+	1961, 5803, 2565, 1923, 7707, 2874, 5419, 3117, 4446,  518, 1564, 5742, 6691,  785, 5722, 2230, 	// 2784 ~ 2799
+	4608, 7555, 2981, 3373, 7117, 1118, 5498, 8080, 1764, 7337, 6308, 4831,   47, 2864, 6570, 2926, 	// 2800 ~ 2815
+	5449, 6045, 5771, 7583, 7165, 2238, 1817, 7360, 3782, 7376, 3481, 3537,  619, 6657, 1973, 8171, 	// 2816 ~ 2831
+	4124, 2807, 3398, 1302, 2383, 7971, 3983, 7920,  139, 4147, 5384, 1317, 1093,  613, 6293, 1911, 	// 2832 ~ 2847
+	4061, 3359, 5903,  485, 5819, 5039, 2425,  132, 1691, 6490, 1584, 3170, 3878, 6674, 4240, 6342, 	// 2848 ~ 2863
+	1437, 7949, 6997, 5076,  559, 7654, 7873, 2304,  342, 4174, 1429, 3384,  209, 6384, 2816, 4791, 	// 2864 ~ 2879
+	2843, 1027,  188, 3265,  540, 6921,  296, 3224, 3673, 2021, 7127, 5471, 1099, 2828, 5096, 7499, 	// 2880 ~ 2895
+	 887, 5964, 1707, 3513, 1352, 6748, 5877,  918, 7990, 3495, 5063,  165, 7856, 7155,   14, 5273, 	// 2896 ~ 2911
+	 843, 5984, 4082, 2011, 6373, 3800, 5414, 7798, 2420, 1812, 5409,  291, 2297, 1272, 4696, 4495, 	// 2912 ~ 2927
+	7769, 4688, 4876, 1281, 4910, 7622, 6702, 5759,  355, 6602, 4287, 7758, 8063, 2172, 6211, 5159, 	// 2928 ~ 2943
+	1298, 7579, 5072,  481, 3509, 3261, 1277, 2007, 4027,  477, 2005,  479, 1917, 5918, 8021, 4029, 	// 2944 ~ 2959
+	7446, 6550, 3105, 4031, 2938, 4771, 4102, 8023, 2432,  943, 6811, 5920, 8134, 5557, 3369, 1919, 	// 2960 ~ 2975
+	6340, 3168,  130,  483, 4789, 3382, 2302, 5074, 8169, 3535, 7358, 7581, 1909, 1315, 7918, 1300, 	// 2976 ~ 2991
+	4493,  289, 7796, 2009, 5157, 7756, 5757, 1279, 7497, 5469, 3222, 3263, 5271,  163,  916, 3511, 	// 2992 ~ 3007
+	 828, 1360, 2164, 5922, 3087,  737, 4500, 6813, 2322, 7061, 2202,  945, 6299, 1864, 3713, 2434, 	// 3008 ~ 3023
+	2228, 5740, 3115, 1921, 2924, 4829, 8078, 3371, 2614, 5528, 5660, 5559, 3839, 4655, 6739, 8136, 	// 3024 ~ 3039
+	 970, 3615, 2471, 4033, 6718, 8122, 4701, 3107, 2333, 4780, 6932, 6552, 4720,  433, 3663, 7448, 	// 3040 ~ 3055
+	 264, 4850,  759, 8025, 1887, 3447, 4865, 4104, 7085,  511, 1805, 4773, 3650,  690, 5432, 2940, 	// 3056 ~ 3071
+	7963, 5846, 6793, 4854, 6228, 4454, 5969, 5218, 4392, 3998, 2574, 7094, 6051, 6950,  389, 1731, 	// 3072 ~ 3087
+	5285, 7676,  674,  268, 3127, 5226,  700, 7779, 6497, 3931, 3904, 3471, 3252, 3421, 5190, 6359, 	// 3088 ~ 3103
+	3631, 5109, 3348, 8029, 2272, 3214,  892, 3332, 3943, 5935, 6959, 4901, 4436, 5480, 6328,  570, 	// 3104 ~ 3119
+	6392, 1417, 3856,  763, 5129, 7535, 3921, 4089, 7148, 4648, 2712, 3281, 2646, 2286, 7222, 1501, 	// 3120 ~ 3135
+	 807, 6172,   75, 3451, 4326, 1654, 3518, 2523, 6596, 4168,  505, 5463, 5455, 6083, 7331, 7187, 	// 3136 ~ 3151
+	7424, 4405, 3688, 1891, 4402, 4642, 6169, 4165, 1414, 4645, 5106, 5932, 7673, 3928, 5843, 3995, 	// 3152 ~ 3167
+	2313, 3691, 3181, 4108, 4986, 1047, 1712, 7436, 4214, 1894, 3891, 5606, 6027, 3758, 6710, 7699, 	// 3168 ~ 3183
+	2974, 7427,  752, 4869, 1244, 5695, 5240, 7270, 7610, 4408, 2046, 3729, 7295,  745, 3769, 1177, 	// 3184 ~ 3199
+	7552, 7334, 5800,  515, 8042, 4632, 6753, 1634, 5629, 7190, 2855, 1012, 7589,  629, 1876, 2737, 	// 3200 ~ 3215
+	5601, 5458, 4896, 7089, 4424, 6468, 3527, 1007, 1698, 6086, 6980, 5003, 4948, 7033,   93,  147, 	// 3216 ~ 3231
+	4847,  508, 3612, 4777, 5737, 5525, 1357, 7058,  286, 5466, 3165, 3532, 6547,  940, 7576,  474, 	// 3232 ~ 3247
+	4685, 6599, 5981, 1809, 5961, 3492, 1024, 2018, 7946, 4171, 3356, 6487, 2804, 4144, 6042, 7373, 	// 3248 ~ 3263
+	7007, 3521, 6163,  694, 6617, 7388,  923, 5790, 6128, 2526, 1069, 6473, 5777, 7462, 1254, 6185, 	// 3264 ~ 3279
+	4377, 4329,  978, 3654, 3829, 5369, 7013, 6636, 4816, 1657, 4741, 2721, 8072, 4096, 5871, 3977, 	// 3280 ~ 3295
+	7284,   78, 2675, 2944, 1902, 3871, 5882,  661, 4519, 3454, 6540, 4429, 2994, 1132,  871, 2076, 	// 3296 ~ 3311
+	2457,  810, 7302, 5436, 3813, 4676, 1382, 4749, 7982, 6175, 2443, 1475, 2346, 7199, 2118, 1406, 	// 3312 ~ 3327
+	1537, 3772,  720, 3619, 1516,  526, 3500,  400, 2156, 1180, 4268, 5008, 2244, 7816,  716, 6155, 	// 3328 ~ 3343
+	2671, 7298, 6159,  974, 3608, 5977, 5796, 4892, 3177,  748,   71, 3684, 3344, 3852, 6789,  670, 	// 3344 ~ 3359
+	4732, 2049, 2248, 4037, 5996, 4925, 7995, 2409, 5510, 3732, 3750, 6985, 3461, 1264, 5708, 3065, 	// 3360 ~ 3375
+	 217, 7613, 7820, 2475, 8157, 3044, 1554,  850, 5028, 4411, 5313, 7891,  369, 3596, 3407, 6911, 	// 3376 ~ 3391
+	1209, 5243, 4272, 8126, 4940, 1938,  170, 4199, 4959, 7273, 7687, 6091, 7171,  333, 5019, 1851, 	// 3392 ~ 3407
+	7324, 1247, 5012, 6722, 5671, 4664,  929, 2956, 2126, 5698, 4343, 3964,  998, 5136, 5089, 3706, 	// 3408 ~ 3423
+	2467,  755, 2160, 3111,  126, 7792, 5068, 3101, 4078, 4872,  184, 1703, 5899, 6993, 5767, 3394, 	// 3424 ~ 3439
+	2561, 2977, 1184, 4705, 3952, 7829, 2103, 2035, 3326, 7430, 7052,  655, 2403, 3095, 1599, 3009, 	// 3440 ~ 3455
+	3082, 6713, 3504, 4784,  535, 6368, 7160, 5814, 1338, 7702, 7738,  152, 7366, 1494, 2260, 6904, 	// 3456 ~ 3471
+	  38, 6030,  404, 2337,  253, 6857, 7394, 1745, 1591, 3761, 1157, 1616, 1946, 6403, 6203, 4155, 	// 3472 ~ 3487
+	8008, 3894, 1520, 6556, 6941, 4617, 7861, 1605,  111, 5609, 5398,   98, 4526, 7253, 6841, 7726, 	// 3488 ~ 3503
+	2659, 4217,  530, 6936, 4935,  121, 1511, 5991, 6612, 1897, 8037, 5732, 4321, 4981, 6223, 2267, 	// 3504 ~ 3519
+	4300, 1715,  724,  437, 2664,   31, 5278, 5594, 4117, 7439, 6581, 7038, 1823, 2358, 6729, 5048, 	// 3520 ~ 3535
+	 581, 4989, 3623, 4724, 3055, 4053, 6623, 2890,  798, 1050, 2543,  463, 7236, 7542, 8188, 3310, 	// 3536 ~ 3551
+	4363, 3184, 1541, 7452, 4222, 7524,   19, 3015, 1332, 4111, 2150, 4953, 5623, 6122, 4386, 6590, 	// 3552 ~ 3567
+	4021, 2316, 3776, 3667, 2212, 3234, 6896, 2729, 7404, 3694, 7599, 5856, 6010, 6780, 6284, 6260, 	// 3568 ~ 3583
+	3560, 5193, 3411, 5744, 6846, 1572, 1032, 1566,   25, 6362, 1932,  520, 7382, 4626, 1648, 4448, 	// 3584 ~ 3599
+	 731, 3255, 6915, 2232, 6508, 4462, 6479, 5724, 6681, 3424, 4481,  787, 2094, 1781, 2588, 6693, 	// 3600 ~ 3615
+	 589, 3907,  373, 1925, 7731, 4261, 2848, 2567, 1998, 3474, 6060, 5805, 2083, 7136, 6417, 1963, 	// 3616 ~ 3631
+	4799, 6500, 3600, 3119, 2375, 6250, 6434, 5421, 1989, 3934, 6144, 2876, 7414, 7839, 2685, 7709, 	// 3632 ~ 3647
+	1059,  703, 5317, 4833, 4531, 1038, 3270, 6310, 3021, 7782, 1678, 7339, 3788,  237, 5678, 1766, 	// 3648 ~ 3663
+	3142, 3130, 7895, 2928, 2193, 3295, 1075, 6572, 7207, 5229, 8114, 2866, 7516, 3863, 2699,   49, 	// 3664 ~ 3679
+	7882,  677, 5032, 3375, 7258, 4540,  193, 2983, 4254,  271,  450, 7557, 3207, 5518, 4918, 4610, 	// 3680 ~ 3695
+	6101, 5288, 4415, 8082, 4589, 2063, 4550, 5500,  497, 7679, 1670, 1120, 7930, 6821, 1624, 7119, 	// 3696 ~ 3711
+	5210,  392, 1558, 5532, 5403, 1578, 6926, 7352, 4228, 1734,  380, 1639, 3543, 2500,  903, 3242, 	// 3712 ~ 3727
+	 444, 6054,  854, 2618, 8091,  775, 2532, 5145, 3885, 6953, 6534, 3159,  178, 3744, 2144, 5392, 	// 3728 ~ 3743
+	2634, 2577, 8161, 5563,  103,  278,  545, 1190, 1198, 7097, 2624, 6758,  878, 7634,  320, 7315, 	// 3744 ~ 3759
+	3822, 4395, 3048, 5664, 1226, 2186, 5580, 7805, 6274, 4001, 3639, 6516, 1452, 1397, 2917, 1345, 	// 3760 ~ 3775
+	3039, 5972, 7824, 4659,  116, 6852, 3229, 4048, 7530, 5221, 5690, 4637, 3487, 6463, 4671, 5364, 	// 3776 ~ 3791
+	 604, 6231, 2479, 3843, 1233, 5175, 6134, 4187, 6245, 4457, 2058, 3290, 2181,  770, 4761, 5170, 	// 3792 ~ 3807
+	2604, 6796,  221, 8140, 5614,   57,  301, 4711, 5490, 4857,  860, 8047, 3434, 8101, 1374, 6888, 	// 3808 ~ 3823
+	7649, 7966, 7617, 6743, 7751, 4766, 3442, 4824,  648, 5849, 3722, 1468,  413, 5638, 1113, 1461, 	// 3824 ~ 3839
+	7485, 7225, 5712, 1364, 7866, 5750, 2026, 5540, 1547, 1504, 3914, 1017, 6663, 5948, 6427, 5573, 	// 3840 ~ 3855
+	4307, 2649, 3069,  832, 4807, 6236, 6191, 5353, 6349, 2289, 5337, 2774, 3199, 2488, 6019, 5891, 	// 3856 ~ 3871
+	4997, 2715, 3465, 5926, 1610,  457, 3678, 3958, 3153, 3284,  781, 2860, 1139, 1794, 2768, 6770, 	// 3872 ~ 3887
+	2824, 7151, 1268, 2168, 6653,  609, 6670, 6380, 1860, 4651,  429,  686, 5914, 5553, 1311,  159, 	// 3888 ~ 3903
+	6079, 3924, 3754,  741, 6946, 3417, 5476, 2282, 7458, 4092, 1128, 7195,  625, 7029,  936, 4140, 	// 3904 ~ 3919
+	 329, 5132, 6989, 3091, 7812, 3848, 1260, 3592, 2354, 7538, 6118, 6776, 1490, 6399, 7249, 4977, 	// 3920 ~ 3935
+	 233, 3859, 5514, 6817, 4622, 1777, 7132, 7835, 6459,  766, 8097, 5634, 2496, 3740, 7630, 1393, 	// 3936 ~ 3951
+	7025, 6395, 3736, 4504, 5944, 2484, 1790, 5549, 1835, 1420, 5304,  420, 5255, 4508, 1165, 4579, 	// 3952 ~ 3967
+	2791, 6331, 7999, 7065, 1525, 5199, 2833, 6069, 4369,  573,  596, 2742, 8177, 5259, 6878, 2220, 	// 3968 ~ 3983
+	1722, 4439, 2413, 2326, 7905, 5180, 7468, 3576, 4247, 5483, 6452, 1145, 4207, 4512, 4071, 1325, 	// 3984 ~ 3999
+	7074, 6962, 6000,  949, 6561, 7564, 1104, 2109,  553, 4904, 5151, 1881, 3001, 1169, 4571, 7111, 	// 4000 ~ 4015
+	8151, 3946, 4929, 2206, 5123, 1238, 5955, 3807, 6647, 5938, 5117, 4470, 2369, 4583, 1220, 7745, 	// 4016 ~ 4031
+	6870,  895, 2252, 1868, 8013, 3566, 7504, 2757, 3190, 3335, 1084,  634, 1979, 1839, 2963, 5828, 	// 4032 ~ 4047
+	2750, 2275, 4041, 6303, 5587, 4192, 5783, 2516, 6806, 3217, 5655, 1800, 5379, 1424, 5058, 4282, 	// 4048 ~ 4063
+	6975, 3351, 4736, 2438, 3899, 2707, 5101, 2041, 1152, 8032, 2538, 7594,   66, 5308, 4338, 7047, 	// 4064 ~ 4079
+	6529, 3634, 2053, 3717, 4476, 6139, 8109, 1665, 6447, 5112, 5650, 5645, 5332,  424, 6113, 5299, 	// 4080 ~ 4095
+	  12, 5061, 5875, 1705, 5094, 7125,  294,  186, 6209, 4285, 6700, 4874, 4694, 5407, 5412, 4080, 	// 4096 ~ 4111
+	6291, 5382, 3981, 3396, 1971, 3479, 1815, 5769, 2814, 1427, 7871, 6995, 4238, 1582, 2423, 5901, 	// 4112 ~ 4127
+	6737, 5658, 8076, 3113, 3711, 2200, 4498, 2162, 5430, 1803, 4863,  757, 3661, 6930, 4699, 2469, 	// 4128 ~ 4143
+	3367, 6809, 4100, 3103, 8019, 2003, 1275, 5070,  914, 3220, 5755, 7794, 7916, 7356, 2300,  128, 	// 4144 ~ 4159
+	6632, 5786, 4745,  657, 1003, 1630, 2014, 7054, 4161, 2519, 7266, 7432, 7775, 5214, 4085, 3328, 	// 4160 ~ 4175
+	2886, 5590, 2725, 3011, 1741, 5810, 5987, 1601, 2952, 4195, 2031, 3097, 4888,  396,  846, 2405, 	// 4176 ~ 4191
+	4183, 4044, 4820, 4707, 5141, 7348, 7801, 1186, 6568, 6306, 5496, 2979, 5720, 1562, 5417, 2563, 	// 4192 ~ 4207
+	2512, 2753, 1661, 2037, 3572, 6065, 3803, 2105, 3588, 2278, 5545, 7831, 5349, 5536, 6376, 3954, 	// 4208 ~ 4223
+	2553, 2966, 7017, 6093, 4348, 6827, 7761, 7689, 1952, 5831, 2595, 7275, 1287, 3547, 4290, 4961, 	// 4224 ~ 4239
+	6267, 1982, 6640, 1853, 7939, 7141, 6605, 5021, 4131, 1842, 7490,  335, 2134, 2504,  358, 7173, 	// 4240 ~ 4255
+	7850, 1087, 3833, 8128, 3969, 3302, 5162, 4274, 4009,  637, 8053, 5245,  985,  907, 6214, 1211, 	// 4256 ~ 4271
+	1484, 3193, 5373, 4201, 7510, 2088, 2175,  172,  992, 3338, 7230, 1940, 7667, 3246, 8066, 4942, 	// 4272 ~ 4287
+	7664, 7507,  982, 3966, 2131, 7936, 1284, 4345, 6409, 2760, 6320, 5700, 4882, 4232, 4879, 2128, 	// 4288 ~ 4303
+	7913, 8016, 3658, 3708, 4235, 1968, 4691, 5091, 5346, 3569, 5717, 5138, 4885, 1738, 7772, 1000, 	// 4304 ~ 4319
+	6836, 2255, 4381, 6724, 5703,  711, 5762, 5014, 7571, 1871,  866, 1249, 6323,  384, 6705, 7326, 	// 4320 ~ 4335
+	4566, 6873, 4333, 2958, 2763, 6422, 7625,  931,  315,  898, 1369, 4666, 6412, 1643, 4913, 5673, 	// 4336 ~ 4351
+	7247, 6116, 1258, 6987,  934, 1126, 5474, 3752, 1163, 5302, 1788, 3734, 7628, 8095, 7130, 5512, 	// 4352 ~ 4367
+	6017, 5335, 6189, 3067, 6425, 3912, 2024, 5710, 1309,  427, 6668, 1266, 2766,  779, 3676, 3463, 	// 4368 ~ 4383
+	5056, 5653, 5781, 4039, 2961, 1082, 7502, 2250, 6111, 5648, 8107, 2051, 4336, 2536, 5099, 4734, 	// 4384 ~ 4399
+	4069, 6450, 7466, 2411, 6876,  594, 2831, 7997, 1218, 5115, 5953, 4927, 4569, 5149, 1102, 5998, 	// 4400 ~ 4415
+	2697, 8112, 1073, 7893, 5676, 1676, 3268, 5315, 1622, 1668, 4548, 4413, 4916,  448,  191, 5030, 	// 4416 ~ 4431
+	2586, 4479, 6477, 6913, 1646, 1930, 1030, 3409, 2683, 6142, 6432, 3598, 6415, 6058, 2846,  371, 	// 4432 ~ 4447
+	4759, 2056, 6132, 2477, 4669, 5688, 3227, 7822, 1111, 3720, 3440, 7615, 1372,  858,  299,  219, 	// 4448 ~ 4463
+	2142, 6532, 2530,  852,  901,  378, 6924, 1556, 2915, 3637, 5578, 3046,  318, 2622,  543, 8159, 	// 4464 ~ 4479
+	5087, 4341,  927, 5010, 5017, 7685,  168, 4270, 1597, 7050, 2101, 1182, 5765,  182, 5066, 2158, 	// 4480 ~ 4495
+	6787,   69, 5794, 6157,  714, 4266, 3498,  718, 3405, 5311, 1552, 7818, 5706, 3748, 7993, 2246, 	// 4496 ~ 4511
+	8186, 2541, 6621, 3621, 6727, 6579, 5276,  722, 6282, 7597, 6894, 3774, 4384, 2148,   17, 1539, 	// 4512 ~ 4527
+	6201, 1155, 7392,  402, 2258, 7736, 7158, 3502, 6221, 8035, 1509,  528, 6839, 5396, 7859, 1518, 	// 4528 ~ 4543
+	5841, 5104, 6167, 3686, 7329,  503, 3516,   73, 3767, 2044, 5238,  750, 6708, 3889, 1710, 3179, 	// 4544 ~ 4559
+	5188, 3902,  698,  672,  387, 2572, 5967, 6791, 7220, 2710, 3919, 3854, 6326, 6957,  890, 3346, 	// 4560 ~ 4575
+	5869, 4739, 7011,  976, 1252, 1067,  921, 6161, 2116, 2441, 1380, 7300,  869, 6538, 5880, 2673, 	// 4576 ~ 4591
+	  91, 6978, 3525, 4894, 1874, 2853, 6751, 5798, 6040, 3354, 1022, 5979, 7574, 3163, 1355, 3610, 	// 4592 ~ 4607
+	3322, 4074, 2122, 4955, 5024, 5506, 3173, 2152, 7400, 1328,  794, 4113, 6608,  107, 1587, 1334, 	// 4608 ~ 4623
+	7606, 4210, 1410, 6592, 7144, 3939, 6493, 4388, 7978, 4515, 4812, 6124, 7942,  282, 1694, 5625, 	// 4624 ~ 4639
+	1831, 6455, 2350, 7454, 1856, 3149, 6345, 1543, 6443, 1148, 6802, 3186, 6643,  549, 4243, 4365, 	// 4640 ~ 4655
+	 493, 4250, 7203, 3017, 1985, 1994, 6677,   21,  644, 5486, 6241, 7526, 6270, 1194, 3881, 4224, 	// 4656 ~ 4671
+	2899, 7471, 2447, 5858, 7176, 4556,  488, 7601, 1751, 3579,  201, 3696,  361, 2638, 5906, 7406, 	// 4672 ~ 4687
+	4561, 7908, 1479, 6262, 2507, 2881, 3362, 6286,   86, 5183, 6196, 6782, 2137, 2581, 4064, 6012, 	// 4688 ~ 4703
+	 351, 2416, 7986, 3669,  338, 1687,  135, 3778, 7081, 2329, 2610, 2318, 7493, 8165, 2428, 4023, 	// 4704 ~ 4719
+	7181, 1725, 6179, 2731, 1845, 6149, 5042, 6898, 1760, 4442, 5358, 3236, 4134, 5567, 5822, 2214, 	// 4720 ~ 4735
+	4603, 6881, 1386, 7040, 7692, 2069, 3387, 6583,  259, 2223, 4488, 7441, 7764,  882, 1432, 4119, 	// 4736 ~ 4751
+	5863, 8180, 4753, 5050, 6830, 7844, 4177, 6731, 2390, 5262, 4312, 2360, 4351, 7638,  345, 1825, 	// 4752 ~ 4767
+	7644,  599, 3817,  439, 6096, 3137, 4794,  726, 6524, 2745, 8146, 1717, 7020,  324, 2819, 4302, 	// 4768 ~ 4783
+	2452, 4372, 4680, 5596, 2969, 7419, 6387, 5280, 4016,  576, 2654,   33, 2556, 7319,  212, 2666, 	// 4784 ~ 4799
+	 821, 2836, 7306,  465, 4964, 4595, 5079, 2545, 6863, 6072, 3032, 1052, 4293, 1202, 7000,  800, 	// 4800 ~ 4815
+	7476, 1528, 5440, 3312, 3550, 7714, 7952, 8190, 2783, 5202, 3074, 7544, 1290, 7101, 1440, 7238, 	// 4816 ~ 4831
+	4357, 8002, 2461, 4726, 7278, 4841, 2307, 3625, 6969, 7068,  227, 4991, 2598, 2628, 7876,  583, 	// 4832 ~ 4847
+	2904, 2794,  814, 2892, 5834, 2690, 7657, 6625,  964, 6334,  837, 4055, 1955, 6762,  562, 3057, 	// 4848 ~ 4863
+	1449, 1223,  875,  100,  175, 8088, 3540, 5400,  410, 7748, 3431, 5611, 2178, 1230, 3484,  113, 	// 4864 ~ 4879
+	7411, 2372, 2080, 7728, 2091, 6505, 7379, 6843, 7927, 4586, 3204, 7255, 7513, 2190, 3785, 4528, 	// 4880 ~ 4895
+	2366, 5120, 2998, 6558, 4204, 7902, 8174, 1522, 5329, 4473,   63, 3896, 5376, 5584, 1976, 8010, 	// 4896 ~ 4911
+	5911, 6650, 1136, 1607, 3196, 4804, 6660, 7863, 5252, 5941, 2493, 4619, 1487, 7809,  622, 6943, 	// 4912 ~ 4927
+	2801, 5958, 6544, 5734, 4945, 4421, 7586, 8039, 2343, 3810, 2991, 1899, 8069, 3826, 5774, 6614, 	// 4928 ~ 4943
+	2643, 5126, 4433, 2269, 3249, 3124, 6048, 6225, 7292, 1241, 6024, 4983, 7670, 4399, 5452, 4323, 	// 4944 ~ 4959
+	4318, 4932, 4523, 6938, 1943,  250, 7363,  532, 6007, 2209, 5620, 4219, 7233, 3052, 1820, 2661, 	// 4960 ~ 4975
+	 366, 8154, 3458, 5993, 3341, 3605, 2241, 1513, 2400, 3949, 5896,  123,  995, 5668, 7168, 4937, 	// 4976 ~ 4991
+	4972, 4574, 5886,  154, 4277, 5294, 1320, 7740,   44, 7114, 6688, 7704, 5165, 1456, 5387, 1340, 	// 4992 ~ 5007
+	3701, 3004,  665, 6906, 3305, 6255, 4150, 2262, 3990, 1172, 6354, 1496, 3972, 1401,  142, 7368, 	// 5008 ~ 5023
+	5268, 5154, 1906, 4786, 8131, 2935, 1914, 3506, 3647, 1884, 4717, 6715, 3836, 2921, 6296, 3084, 	// 5024 ~ 5039
+	 206,  556, 3875, 5816, 1090, 2380,  616, 7162, 8060, 4907, 2294, 6370, 7853, 1349, 1096,  537, 	// 5040 ~ 5055
+	2911, 1107, 2679, 1618, 1214, 6107, 1305, 1159, 6036, 2112, 7216, 3763, 6217, 6278, 3401, 1593, 	// 5056 ~ 5071
+	3584, 6564, 2948, 4157,  910, 5426, 2810, 6205,  311, 7567, 5342, 6405,  988, 4005, 4127, 1948, 	// 5072 ~ 5087
+	2396, 6003, 7288, 2339, 5248, 5325, 7923,  406,  956,  952,  307, 6032, 8056, 3643, 3986,   40, 	// 5088 ~ 5103
+	1756, 7077,   82, 1747,  640, 6439, 7974, 7396,  960, 6965, 2779, 6859, 4012, 6520, 2386,  255, 	// 5104 ~ 5119
+	7725, 7252,   97, 5608, 1604, 4616, 6555, 3893, 2266, 4980, 5731, 1896, 5990,  120, 6935, 4216, 	// 5120 ~ 5135
+	6903, 1493,  151, 7701, 5813, 6367, 4783, 6712, 4154, 6402, 1615, 3760, 1744, 6856, 2336, 6029, 	// 5136 ~ 5151
+	6589, 6121, 4952, 4110, 3014, 7523, 7451, 3183, 6259, 6779, 5855, 3693, 2728, 3233, 3666, 2315, 	// 5152 ~ 5167
+	5047, 2357, 7037, 7438, 5593,   30,  436, 1714, 3309, 7541,  462, 1049, 2889, 4052, 4723, 4988, 	// 5168 ~ 5183
+	3064, 1263, 6984, 3731, 2408, 4924, 4036, 2048, 6910, 3595, 7890, 4410,  849, 3043, 2474, 7612, 	// 5184 ~ 5199
+	6154, 7815, 5007, 1179,  399,  525, 3618, 3771,  669, 3851, 3683,  747, 4891, 5976,  973, 7297, 	// 5200 ~ 5215
+	3393, 6992, 1702, 4871, 3100, 7791, 3110,  754, 3008, 3094,  654, 7429, 2034, 7828, 4704, 2976, 	// 5216 ~ 5231
+	1850,  332, 6090, 7272, 4198, 1937, 8125, 5242, 3705, 5135, 3963, 5697, 2955, 4663, 6721, 1246, 	// 5232 ~ 5247
+	 473,  939, 3531, 5465, 7057, 5524, 4776,  507, 7372, 4143, 6486, 4170, 2017, 3491, 1808, 6598, 	// 5248 ~ 5263
+	2736,  628, 1011, 7189, 1633, 4631,  514, 7333,  146, 7032, 5002, 6085, 1006, 6467, 7088, 5457, 	// 5264 ~ 5279
+	2075, 1131, 4428, 3453,  660, 3870, 2943,   77, 1405, 7198, 1474, 6174, 4748, 4675, 5435,  809, 	// 5280 ~ 5295
+	6184, 7461, 6472, 2525, 5789, 7387,  693, 3520, 3976, 4095, 2720, 1656, 6635, 5368, 3653, 4328, 	// 5296 ~ 5311
+	 569, 5479, 4900, 5934, 3331, 3213, 8028, 5108, 1500, 2285, 3280, 4647, 4088, 7534,  762, 1416, 	// 5312 ~ 5327
+	1730, 6949, 7093, 3997, 5217, 4453, 4853, 5845, 6358, 3420, 3470, 3930, 7778, 5225,  267, 7675, 	// 5328 ~ 5343
+	7698, 3757, 5605, 1893, 7435, 1046, 4107, 3690, 1176,  744, 3728, 4407, 7269, 5694, 4868, 7426, 	// 5344 ~ 5359
+	7186, 6082, 5462, 4167, 2522, 1653, 3450, 6171, 3994, 3927, 5931, 4644, 4164, 4641, 1890, 4404, 	// 5360 ~ 5375
+	7110, 1168, 1880, 4903, 2108, 7563,  948, 6961, 7744, 4582, 4469, 5937, 3806, 1237, 2205, 3945, 	// 5376 ~ 5391
+	2219, 5258, 2741,  572, 6068, 5198, 7064, 6330, 1324, 4511, 1144, 5482, 3575, 5179, 2325, 4438, 	// 5392 ~ 5407
+	7046, 5307, 7593, 8031, 2040, 2706, 2437, 3350, 5298,  423, 5644, 5111, 1664, 6138, 3716, 3633, 	// 5408 ~ 5423
+	5827, 1838,  633, 3334, 2756, 3565, 1867,  894, 4281, 1423, 1799, 3216, 2515, 4191, 6302, 2274, 	// 5424 ~ 5439
+	6769, 1793, 2859, 3283, 3957,  456, 5925, 2714,  158, 5552,  685, 4650, 6379,  608, 2167, 7150, 	// 5440 ~ 5455
+	5572, 5947, 1016, 1503, 5539, 5749, 1363, 7224, 5890, 2487, 2773, 2288, 5352, 6235,  831, 2648, 	// 5456 ~ 5471
+	1392, 3739, 5633,  765, 7834, 1776, 6816, 3858, 4578, 4507,  419, 1419, 5548, 2483, 4503, 6394, 	// 5472 ~ 5487
+	4139, 7028, 7194, 4091, 2281, 3416,  740, 3923, 4976, 6398, 6775, 7537, 3591, 3847, 3090, 5131, 	// 5488 ~ 5503
+	7314, 7633, 6757, 7096, 1189,  277, 5562, 2576, 1344, 1396, 6515, 4000, 7804, 2185, 5663, 4394, 	// 5504 ~ 5519
+	3241, 2499, 1638, 1733, 7351, 1577, 5531,  391, 5391, 3743, 3158, 6952, 5144,  774, 2617, 6053, 	// 5520 ~ 5535
+	6887, 8100, 8046, 4856, 4710,   56, 8139, 6795, 1460, 5637, 1467, 5848, 4823, 4765, 6742, 7965, 	// 5536 ~ 5551
+	5363, 6462, 4636, 5220, 4047, 6851, 4658, 5971, 5169,  769, 3289, 4456, 4186, 5174, 3842, 6230, 	// 5552 ~ 5567
+	1962, 7135, 5804, 3473, 2566, 4260, 1924, 3906, 7708, 7838, 2875, 3933, 5420, 6249, 3118, 6499, 	// 5568 ~ 5583
+	4447, 4625,  519, 6361, 1565, 1571, 5743, 5192, 6692, 1780,  786, 3423, 5723, 4461, 2231, 3254, 	// 5584 ~ 5599
+	4609, 5517, 7556,  270, 2982, 4539, 3374,  676, 7118, 6820, 1119, 7678, 5499, 2062, 8081, 5287, 	// 5600 ~ 5615
+	1765,  236, 7338, 7781, 6309, 1037, 4832,  702,   48, 3862, 2865, 5228, 6571, 3294, 2927, 3129, 	// 5616 ~ 5631
+	5450, 6022, 6046, 4431, 5772, 2989, 7584, 6542, 7166, 5894, 2239, 3456, 1818, 5618, 7361, 4521, 	// 5632 ~ 5647
+	3783, 3202, 7377, 2078, 3482, 3429, 3538,  873,  620, 2491, 6658, 1134, 1974,   61, 8172, 2996, 	// 5648 ~ 5663
+	4125, 5340, 2808, 2946, 3399, 7214, 1303, 2677, 2384, 2777, 7972,   80, 3984,  305, 7921, 7286, 	// 5664 ~ 5679
+	 140, 6352, 4148,  663, 5385, 6686, 1318, 5884, 1094, 2292,  614, 3873, 6294, 4715, 1912, 1904, 	// 5680 ~ 5695
+	4062, 6194, 3360, 1477, 5904,  199,  486, 2445, 5820, 5356, 5040, 6177, 2426, 2608,  133, 7984, 	// 5696 ~ 5711
+	1692, 4810, 6491, 1408, 1585,  792, 3171, 2120, 3879, 6239, 6675, 7201, 4241, 6800, 6343, 2348, 	// 5712 ~ 5727
+	1438, 3072, 7950, 5438, 6998, 3030, 5077, 7304,  560,  835, 7655,  812, 7874,  225, 2305, 2459, 	// 5728 ~ 5743
+	 343, 4310, 4175, 4751, 1430, 4486, 3385, 1384,  210, 2652, 6385, 4678, 2817, 8144, 4792, 3815, 	// 5744 ~ 5759
+	2844, 6430, 1028, 6475,  189, 4546, 3266, 1071,  541, 5576, 6922, 2528,  297, 3438, 3225, 6130, 	// 5760 ~ 5775
+	3674, 6666, 2022, 6187, 7128, 1786, 5472, 1256, 1100, 5951, 2829, 7464, 5097, 8105, 7500, 5779, 	// 5776 ~ 5791
+	 888, 3917, 5965,  696, 1708, 5236, 3514, 6165, 1353, 1020, 6749, 3523, 5878, 1378,  919, 7009, 	// 5792 ~ 5807
+	7991, 1550, 3496, 5792, 5064, 2099,  166,  925, 7857, 1507, 7156, 7390,   15, 6892, 5274, 6619, 	// 5808 ~ 5823
+	 844, 2029, 5985, 2723, 4083, 7264, 2012, 4743, 6374, 5543, 3801, 1659, 5415, 5494, 7799, 4818, 	// 5824 ~ 5839
+	2421, 7869, 1813, 3979, 5410, 6698,  292, 5873, 2298, 5753, 1273, 4098, 4697, 4861, 4496, 8074, 	// 5840 ~ 5855
+	7770, 5715, 4689, 3656, 4877, 6318, 1282,  980, 4911, 1367, 7623, 4331, 6703,  864, 5760, 4379, 	// 5856 ~ 5871
+	 356, 7488, 6603, 6638, 4288, 2593, 7759, 7015, 8064, 7228, 2173, 5371, 6212, 8051, 5160, 3831, 	// 5872 ~ 5887
+	1299, 1314, 7580, 3534, 5073, 3381,  482, 3167, 3510,  162, 3262, 5468, 1278, 7755, 2008,  288, 	// 5888 ~ 5903
+	4028, 5917,  478,  476, 2006, 3260,  480, 7578, 1918, 5556, 5919,  942, 8022, 4770, 4030, 6549, 	// 5904 ~ 5919
+	7447,  432, 6551, 4779, 3106, 8121, 4032, 3614, 2939,  689, 4772,  510, 4103, 3446, 8024, 4849, 	// 5920 ~ 5935
+	2433, 1863,  944, 7060, 6812,  736, 5921, 1359, 8135, 4654, 5558, 5527, 3370, 4828, 1920, 5739, 	// 5936 ~ 5951
+	6341, 6673, 3169, 6489,  131, 5038,  484, 3358, 4790, 6383, 3383, 4173, 2303, 7653, 5075, 7948, 	// 5952 ~ 5967
+	8170, 6656, 3536, 7375, 7359, 2237, 7582, 6044, 1910,  612, 1316, 4146, 7919, 7970, 1301, 2806, 	// 5968 ~ 5983
+	4494, 1271,  290, 1811, 7797, 3799, 2010, 5983, 5158, 2171, 7757, 6601, 5758, 7621, 1280, 4687, 	// 5984 ~ 5999
+	7498, 2827, 5470, 2020, 3223, 6920, 3264, 1026, 5272, 7154,  164, 3494,  917, 6747, 3512, 5963, 	// 6000 ~ 6015
+	 829, 2771, 1361, 1014, 2165,  683, 5923, 2857, 3088, 6773,  738, 7192, 4501,  417, 6814, 5631, 	// 6016 ~ 6031
+	2323, 1142, 7062, 2739, 2203, 4467,  946, 1878, 6300, 1797, 1865,  631, 3714, 5642, 2435, 7591, 	// 6032 ~ 6047
+	2229,  784, 5741,  517, 3116, 2873, 1922, 5802, 2925, 2863, 4830, 7336, 8079, 1117, 3372, 7554, 	// 6048 ~ 6063
+	2615, 3156, 5529, 1636, 5661, 6513, 5560, 6755, 3840, 3287, 4656, 4634, 6740, 1465, 8137, 8044, 	// 6064 ~ 6079
+	 971, 3681, 3616, 5005, 2472, 7888, 4034, 6982, 6719, 3961, 8123, 6088, 4702,  652, 3108, 1700, 	// 6080 ~ 6095
+	2334, 1613, 4781,  149, 6933, 5729, 6553,   95, 4721,  460,  434, 7035, 3664, 5853, 7449, 4950, 	// 6096 ~ 6111
+	 265, 3468, 4851, 7091,  760, 3278, 8026, 4898, 1888, 5929, 3448, 5460, 4866, 3726, 4105, 5603, 	// 6112 ~ 6127
+	7086, 5000,  512, 1009, 1806, 6484, 4774, 3529, 3651, 2718,  691, 6470, 5433, 1472, 2941, 4426, 	// 6128 ~ 6143
+	7964, 4764, 5847, 5636, 6794,   55, 4855, 8099, 6229, 5173, 4455,  768, 5970, 6850, 5219, 6461, 	// 6144 ~ 6159
+	4393, 2184, 3999, 1395, 2575,  276, 7095, 7632, 6052,  773, 6951, 3742,  390, 1576, 1732, 2498, 	// 6160 ~ 6175
+	5286, 2061, 7677, 6819,  675, 4538,  269, 5516, 3128, 3293, 5227, 3861,  701, 1036, 7780,  235, 	// 6176 ~ 6191
+	6498, 6248, 3932, 7837, 3905, 4259, 3472, 7134, 3253, 4460, 3422, 1779, 5191, 1570, 6360, 4624, 	// 6192 ~ 6207
+	3632, 6137, 5110,  422, 3349, 2705, 8030, 5306, 2273, 4190, 3215, 1422,  893, 3564, 3333, 1837, 	// 6208 ~ 6223
+	3944, 1236, 5936, 4581, 6960, 7562, 4902, 1167, 4437, 5178, 5481, 4510, 6329, 5197,  571, 5257, 	// 6224 ~ 6239
+	6393, 2482, 1418, 4506, 3857, 1775,  764, 3738, 5130, 3846, 7536, 6397, 3922, 3415, 4090, 7027, 	// 6240 ~ 6255
+	7149,  607, 4649, 5551, 2713,  455, 3282, 1792, 2647, 6234, 2287, 2486, 7223, 5748, 1502, 5946, 	// 6256 ~ 6271
+	 808, 4674, 6173, 7197,   76, 3869, 3452, 1130, 4327, 5367, 1655, 4094, 3519, 7386, 2524, 7460, 	// 6272 ~ 6287
+	6597, 3490, 4169, 4142,  506, 5523, 5464,  938, 5456, 6466, 6084, 7031, 7332, 4630, 7188,  627, 	// 6288 ~ 6303
+	7425, 5693, 4406,  743, 3689, 1045, 1892, 3756, 4403, 4640, 4643, 3926, 6170, 1652, 4166, 6081, 	// 6304 ~ 6319
+	1415, 7533, 4646, 2284, 5107, 3212, 5933, 5478, 7674, 5224, 3929, 3419, 5844, 4452, 3996, 6948, 	// 6320 ~ 6335
+	2314, 3232, 3692, 6778, 3182, 7522, 4109, 6120, 4987, 4051, 1048, 7540, 1713,   29, 7437, 2356, 	// 6336 ~ 6351
+	4215,  119, 1895, 4979, 3892, 4615, 5607, 7251, 6028, 6855, 3759, 6401, 6711, 6366, 7700, 1492, 	// 6352 ~ 6367
+	2975, 7827, 7428, 3093,  753, 7790, 4870, 6991, 1245, 4662, 5696, 5134, 5241, 1936, 7271,  331, 	// 6368 ~ 6383
+	7611, 3042, 4409, 3594, 2047, 4923, 3730, 1262, 7296, 5975,  746, 3850, 3770,  524, 1178, 7814, 	// 6384 ~ 6399
+	7553, 1116, 7335, 2862, 5801, 2872,  516,  783, 8043, 1464, 4633, 3286, 6754, 6512, 1635, 3155, 	// 6400 ~ 6415
+	5630,  416, 7191, 6772, 2856,  682, 1013, 2770, 7590, 5641,  630, 1796, 1877, 4466, 2738, 1141, 	// 6416 ~ 6431
+	5602, 3725, 5459, 5928, 4897, 3277, 7090, 3467, 4425, 1471, 6469, 2717, 3528, 6483, 1008, 4999, 	// 6432 ~ 6447
+	1699,  651, 6087, 3960, 6981, 7887, 5004, 3680, 4949, 5852, 7034,  459,   94, 5728,  148, 1612, 	// 6448 ~ 6463
+	4848, 3445,  509,  688, 3613, 8120, 4778,  431, 5738, 4827, 5526, 4653, 1358,  735, 7059, 1862, 	// 6464 ~ 6479
+	 287, 7754, 5467,  161, 3166, 3380, 3533, 1313, 6548, 4769,  941, 5555, 7577, 3259,  475, 5916, 	// 6480 ~ 6495
+	4686, 7620, 6600, 2170, 5982, 3798, 1810, 1270, 5962, 6746, 3493, 7153, 1025, 6919, 2019, 2826, 	// 6496 ~ 6511
+	7947, 7652, 4172, 6382, 3357, 5037, 6488, 6672, 2805, 7969, 4145,  611, 6043, 2236, 7374, 6655, 	// 6512 ~ 6527
+	7008, 1377, 3522, 1019, 6164, 5235,  695, 3916, 6618, 6891, 7389, 1506,  924, 2098, 5791, 1549, 	// 6528 ~ 6543
+	6129, 3437, 2527, 5575, 1070, 4545, 6474, 6429, 5778, 8104, 7463, 5950, 1255, 1785, 6186, 6665, 	// 6544 ~ 6559
+	4378,  863, 4330, 1366,  979, 6317, 3655, 5714, 3830, 8050, 5370, 7227, 7014, 2592, 6637, 7487, 	// 6560 ~ 6575
+	4817, 5493, 1658, 5542, 4742, 7263, 2722, 2028, 8073, 4860, 4097, 5752, 5872, 6697, 3978, 7868, 	// 6576 ~ 6591
+	7285,  304,   79, 2776, 2676, 7213, 2945, 5339, 1903, 4714, 3872, 2291, 5883, 6685,  662, 6351, 	// 6592 ~ 6607
+	4520, 5617, 3455, 5893, 6541, 2988, 4430, 6021, 2995,   60, 1133, 2490,  872, 3428, 2077, 3201, 	// 6608 ~ 6623
+	2458,  224,  811,  834, 7303, 3029, 5437, 3071, 3814, 8143, 4677, 2651, 1383, 4485, 4750, 4309, 	// 6624 ~ 6639
+	7983, 2607, 6176, 5355, 2444,  198, 1476, 6193, 2347, 6799, 7200, 6238, 2119,  791, 1407, 4809, 	// 6640 ~ 6655
+	1538, 2147, 3773, 7596,  721, 6578, 3620, 2540, 1517, 5395,  527, 8034, 3501, 7735,  401, 1154, 	// 6656 ~ 6671
+	2157,  181, 1181, 7049, 4269, 7684, 5009, 4340, 2245, 3747, 7817, 5310,  717, 4265, 6156,   68, 	// 6672 ~ 6687
+	2672, 6537, 7299, 2440, 6160, 1066,  975, 4738, 3609, 3162, 5978, 3353, 5797, 2852, 4893, 6977, 	// 6688 ~ 6703
+	3178, 3888,  749, 2043,   72,  502, 3685, 5103, 3345, 6956, 3853, 2709, 6790, 2571,  671, 3901, 	// 6704 ~ 6719
+	4733, 2535, 2050, 5647, 2249, 1081, 4038, 5652, 5997, 5148, 4926, 5114, 7996,  593, 2410, 6449, 	// 6720 ~ 6735
+	5511, 8094, 3733, 5301, 3751, 1125, 6986, 6115, 3462,  778, 1265,  426, 5709, 3911, 3066, 5334, 	// 6736 ~ 6751
+	 218,  857, 7614, 3719, 7821, 5687, 2476, 2055, 8158, 2621, 3045, 3636, 1555,  377,  851, 6531, 	// 6752 ~ 6767
+	5029,  447, 4412, 1667, 5314, 1675, 7892, 8111,  370, 6057, 3597, 6141, 3408, 1929, 6912, 4478, 	// 6768 ~ 6783
+	1210,  906, 5244,  636, 4273, 3301, 8127, 1086, 4941, 3245, 1939, 3337,  171, 2087, 4200, 3192, 	// 6784 ~ 6799
+	4960, 3546, 7274, 5830, 7688, 6826, 6092, 2965, 7172, 2503,  334, 1841, 5020, 7140, 1852, 1981, 	// 6800 ~ 6815
+	7325,  383, 1248, 1870, 5013,  710, 6723, 2254, 5672, 1642, 4665,  897,  930, 6421, 2957, 6872, 	// 6816 ~ 6831
+	2127, 4231, 5699, 2759, 4344, 7935, 3965, 7506,  999, 1737, 5137, 3568, 5090, 1967, 3707, 8015, 	// 6832 ~ 6847
+	2468, 6929,  756, 1802, 2161, 2199, 3112, 5657,  127, 7355, 7793, 3219, 5069, 2002, 3102, 6808, 	// 6848 ~ 6863
+	4079, 5406, 4873, 4284,  185, 7124, 1704, 5060, 5900, 1581, 6994, 1426, 5768, 3478, 3395, 5381, 	// 6864 ~ 6879
+	2562, 1561, 2978, 6305, 1185, 7347, 4706, 4043, 3953, 5535, 7830, 2277, 2104, 6064, 2036, 2752, 	// 6880 ~ 6895
+	3327, 5213, 7431, 2518, 7053, 1629,  656, 5785, 2404,  395, 3096, 4194, 1600, 5809, 3010, 5589, 	// 6896 ~ 6911
+	3083, 2920, 6714, 1883, 3505, 2934, 4785, 5153,  536, 1348, 6369, 4906, 7161, 2379, 5815,  555, 	// 6912 ~ 6927
+	1339, 1455, 7703, 7113, 7739, 5293,  153, 4573, 7367, 1400, 1495, 1171, 2261, 6254, 6905, 3003, 	// 6928 ~ 6943
+	  39, 3642, 6031,  951,  405, 5324, 2338, 6002,  254, 6519, 6858, 6964, 7395, 6438, 1746, 7076, 	// 6944 ~ 6959
+	1592, 6277, 3762, 2111, 1158, 6106, 1617, 1106, 1947, 4004, 6404, 7566, 6204, 5425, 4156, 6563, 	// 6960 ~ 6975
+	8009, 5583, 3895, 4472, 1521, 7901, 6557, 5119, 6942, 7808, 4618, 5940, 7862, 4803, 1606, 6649, 	// 6976 ~ 6991
+	 112, 1229, 5610, 7747, 5399, 8087,   99, 1222, 4527, 2189, 7254, 4585, 6842, 6504, 7727, 2371, 	// 6992 ~ 7007
+	2660, 3051, 4218, 2208,  531,  249, 6937, 4931, 4936, 5667,  122, 3948, 1512, 3604, 5992, 8153, 	// 7008 ~ 7023
+	6613, 3825, 1898, 3809, 8038, 4420, 5733, 5957, 4322, 4398, 4982, 1240, 6224, 3123, 2268, 5125, 	// 7024 ~ 7039
+	4301,  323, 1716, 2744,  725, 3136,  438,  598, 2665, 7318,   32,  575, 5279, 7418, 5595, 4371, 	// 7040 ~ 7055
+	4118,  881, 7440, 2222, 6582, 2068, 7039, 6880, 1824, 7637, 2359, 5261, 6730, 7843, 5049, 8179, 	// 7056 ~ 7071
+	 582, 2627, 4990, 7067, 3624, 4840, 4725, 8001, 3056, 6761, 4054, 6333, 6624, 2689, 2891, 2793, 	// 7072 ~ 7087
+	 799, 1201, 1051, 6071, 2544, 4594,  464, 2835, 7237, 7100, 7543, 5201, 8189, 7713, 3311, 1527, 	// 7088 ~ 7103
+	4364,  548, 3185, 1147, 1542, 3148, 7453, 6454, 4223, 1193, 7525, 5485,   20, 1993, 3016, 4249, 	// 7104 ~ 7119
+	1333,  106, 4112, 1327, 2151, 5505, 4954, 4073, 5624,  281, 6123, 4514, 4387, 3938, 6591, 4209, 	// 7120 ~ 7135
+	4022, 8164, 2317, 2328, 3777, 1686, 3668, 2415, 2213, 5566, 3235, 4441, 6897, 6148, 2730, 1724, 	// 7136 ~ 7151
+	7405, 2637, 3695, 3578, 7600, 4555, 5857, 7470, 6011, 2580, 6781, 5182, 6285, 2880, 6261, 7907, 	// 7152 ~ 7167
+	3561, 2702, 5194, 7559, 3412, 1772, 5745,  452, 6847,   52, 1573,  273, 1033, 4535, 1567, 4256, 	// 7168 ~ 7183
+	  26, 7519, 6363, 4612, 1933, 7787,  521, 4920, 7383, 3866, 4627, 5520, 1649, 1042, 4449, 3209, 	// 7184 ~ 7199
+	 732, 8117, 3256, 3377, 6916, 3795, 2233, 5034, 6509, 2869, 4463,  679, 6480, 3274, 5725, 7884, 	// 7200 ~ 7215
+	6682, 7210, 3425, 2985, 4482, 3026,  788,  195, 2095, 5232, 1782, 4542, 2589, 6314, 6694, 7260, 	// 7216 ~ 7231
+	 590, 1078, 3908, 1122,  374, 5684, 1926, 1672, 7732, 6575, 4262, 7681, 2849, 1063, 2568,  499, 	// 7232 ~ 7247
+	1999, 2196, 3475, 7121, 6061, 7344, 5806, 1626, 2084, 3298, 7137, 6823, 6418,  707, 1964, 7932, 	// 7248 ~ 7263
+	4800, 7898, 6501, 8084, 3601,  246, 3120, 4417, 2376, 2931, 6251, 5290, 6435, 5321, 5422, 6103, 	// 7264 ~ 7279
+	1990, 3145, 3935, 5502, 6145, 1683, 2877, 4552, 7415, 3133, 7840, 2065, 2686, 4837, 7710, 4591, 	// 7280 ~ 7295
+	1060, 5681,  704, 7341, 5318,  243, 4834, 1680, 4532, 1769, 1039, 7784, 3271, 3792, 6311, 3023, 	// 7296 ~ 7311
+	3022, 3791, 7783, 1768, 1679,  242, 7340, 5680, 3789,  240,  238,  239, 5679,  241, 1767, 3790, 	// 7312 ~ 7327
+	3143, 1681, 3131, 4835, 7896,  244, 2929, 5319, 2194, 7342, 3296,  705, 1076, 5682, 6573, 1061, 	// 7328 ~ 7343
+	7208, 3024, 5230, 6312, 8115, 3793, 2867, 3272, 7517, 7785, 3864, 1040, 2700, 1770,   50, 4533, 	// 7344 ~ 7359
+	7883, 3273,  678, 2868, 5033, 3794, 3376, 8116, 7259, 6313, 4541, 5231,  194, 3025, 2984, 7209, 	// 7360 ~ 7375
+	4255, 4534,  272,   51,  451, 1771, 7558, 2701, 3208, 1041, 5519, 3865, 4919, 7786, 4611, 7518, 	// 7376 ~ 7391
+	6102, 5320, 5289, 2930, 4416,  245, 8083, 7897, 4590, 4836, 2064, 3132, 4551, 1682, 5501, 3144, 	// 7392 ~ 7407
+	 498, 1062, 7680, 6574, 1671, 5683, 1121, 1077, 7931,  706, 6822, 3297, 1625, 7343, 7120, 2195, 	// 7408 ~ 7423
+	5211, 1627,  393, 5807, 1559, 7345, 5533, 6062, 5404, 7122, 1579, 3476, 6927, 2197, 7353, 2000, 	// 7424 ~ 7439
+	4229, 7933, 1735, 1965,  381,  708, 1640, 6419, 3544, 6824, 2501, 7138,  904, 3299, 3243, 2085, 	// 7440 ~ 7455
+	 445, 1673, 6055, 1927,  855, 5685, 2619,  375, 8092, 1123,  776, 3909, 2533, 1079, 5146,  591, 	// 7456 ~ 7471
+	3886,  500, 6954, 2569, 6535, 1064, 3160, 2850,  179, 7682, 3745, 4263, 2145, 6576, 5393, 7733, 	// 7472 ~ 7487
+	2635, 4553, 2578, 2878, 8162, 1684, 5564, 6146,  104, 5503,  279, 3936,  546, 3146, 1191, 1991, 	// 7488 ~ 7503
+	1199, 4592, 7098, 7711, 2625, 4838, 6759, 2687,  879, 2066, 7635, 7841,  321, 3134, 7316, 7416, 	// 7504 ~ 7519
+	3823, 4418, 4396, 3121, 3049,  247, 5665, 3602, 1227, 8085, 2187, 6502, 5581, 7899, 7806, 4801, 	// 7520 ~ 7535
+	6275, 6104, 4002, 5423, 3640, 5322, 6517, 6436, 1453, 5291, 1398, 6252, 2918, 2932, 1346, 2377, 	// 7536 ~ 7551
+	3040, 4921, 5973,  522, 7825, 7788, 4660, 1934,  117, 4613, 6853, 6364, 3230, 7520, 4049,   27, 	// 7552 ~ 7567
+	7531, 3210, 5222, 4450, 5691, 1043, 4638, 1650, 3488, 5521, 6464, 4628, 4672, 3867, 5365, 7384, 	// 7568 ~ 7583
+	 605,  453, 6232, 5746, 2480, 1773, 3844, 3413, 1234, 7560, 5176, 5195, 6135, 2703, 4188, 3562, 	// 7584 ~ 7599
+	6246, 4257, 4458, 1568, 2059, 4536, 3291, 1034, 2182,  274,  771, 1574, 4762,   53, 5171, 6848, 	// 7600 ~ 7615
+	2605,  196, 6797,  789,  222, 3027, 8141, 4483, 5615, 2986,   58, 3426,  302, 7211, 4712, 6683, 	// 7616 ~ 7631
+	5491, 7261, 4858, 6695,  861, 6315, 8048, 2590, 3435, 4543, 8102, 1783, 1375, 5233, 6889, 2096, 	// 7632 ~ 7647
+	7650, 5035, 7967, 2234, 7618, 3796, 6744, 6917, 7752, 3378, 4767, 3257, 3443, 8118, 4825,  733, 	// 7648 ~ 7663
+	 649, 7885, 5850, 5726, 3723, 3275, 1469, 6481,  414,  680, 5639, 4464, 1114, 2870, 1462, 6510, 	// 7664 ~ 7679
+	7486, 2591, 7226, 8049, 5713, 6316, 1365,  862, 7867, 6696, 5751, 4859, 2027, 7262, 5541, 5492, 	// 7680 ~ 7695
+	1548, 2097, 1505, 6890, 3915, 5234, 1018, 1376, 6664, 1784, 5949, 8103, 6428, 4544, 5574, 3436, 	// 7696 ~ 7711
+	4308, 4484, 2650, 8142, 3070, 3028,  833,  223, 4808,  790, 6237, 6798, 6192,  197, 5354, 2606, 	// 7712 ~ 7727
+	6350, 6684, 2290, 4713, 5338, 7212, 2775,  303, 3200, 3427, 2489,   59, 6020, 2987, 5892, 5616, 	// 7728 ~ 7743
+	4998, 6482, 2716, 1470, 3466, 3276, 5927, 3724, 1611, 5727,  458, 5851, 3679, 7886, 3959,  650, 	// 7744 ~ 7759
+	3154, 6511, 3285, 1463,  782, 2871, 2861, 1115, 1140, 4465, 1795, 5640, 2769,  681, 6771,  415, 	// 7760 ~ 7775
+	2825, 6918, 7152, 6745, 1269, 3797, 2169, 7619, 6654, 2235,  610, 7968, 6671, 5036, 6381, 7651, 	// 7776 ~ 7791
+	1861,  734, 4652, 4826,  430, 8119,  687, 3444, 5915, 3258, 5554, 4768, 1312, 3379,  160, 7753, 	// 7792 ~ 7807
+	6080, 1651, 3925, 4639, 3755, 1044,  742, 5692, 6947, 4451, 3418, 5223, 5477, 3211, 2283, 7532, 	// 7808 ~ 7823
+	7459, 7385, 4093, 5366, 1129, 3868, 7196, 4673,  626, 4629, 7030, 6465,  937, 5522, 4141, 3489, 	// 7824 ~ 7839
+	 330, 1935, 5133, 4661, 6990, 7789, 3092, 7826, 7813,  523, 3849, 5974, 1261, 4922, 3593, 3041, 	// 7840 ~ 7855
+	2355,   28, 7539, 4050, 6119, 7521, 6777, 3231, 1491, 6365, 6400, 6854, 7250, 4614, 4978,  118, 	// 7856 ~ 7871
+	 234, 1035, 3860, 3292, 5515, 4537, 6818, 2060, 4623, 1569, 1778, 4459, 7133, 4258, 7836, 6247, 	// 7872 ~ 7887
+	6460, 6849,  767, 5172, 8098,   54, 5635, 4763, 2497, 1575, 3741,  772, 7631,  275, 1394, 2183, 	// 7888 ~ 7903
+	7026, 3414, 6396, 3845, 3737, 1774, 4505, 2481, 5945, 5747, 2485, 6233, 1791,  454, 5550,  606, 	// 7904 ~ 7919
+	1836, 3563, 1421, 4189, 5305, 2704,  421, 6136, 5256, 5196, 4509, 5177, 1166, 7561, 4580, 1235, 	// 7920 ~ 7935
+	2792, 2688, 6332, 6760, 8000, 4839, 7066, 2626, 1526, 7712, 5200, 7099, 2834, 4593, 6070, 1200, 	// 7936 ~ 7951
+	4370, 7417,  574, 7317,  597, 3135, 2743,  322, 8178, 7842, 5260, 7636, 6879, 2067, 2221,  880, 	// 7952 ~ 7967
+	1723, 6147, 4440, 5565, 2414, 1685, 2327, 8163, 7906, 2879, 5181, 2579, 7469, 4554, 3577, 2636, 	// 7968 ~ 7983
+	4248, 1992, 5484, 1192, 6453, 3147, 1146,  547, 4208, 3937, 4513,  280, 4072, 5504, 1326,  105, 	// 7984 ~ 7999
+	7075, 6437, 6963, 6518, 6001, 5323,  950, 3641, 6562, 5424, 7565, 4003, 1105, 6105, 2110, 6276, 	// 8000 ~ 8015
+	 554, 2378, 4905, 1347, 5152, 2933, 1882, 2919, 3002, 6253, 1170, 1399, 4572, 5292, 7112, 1454, 	// 8016 ~ 8031
+	8152, 3603, 3947, 5666, 4930,  248, 2207, 3050, 5124, 3122, 1239, 4397, 5956, 4419, 3808, 3824, 	// 8032 ~ 8047
+	6648, 4802, 5939, 7807, 5118, 7900, 4471, 5582, 2370, 6503, 4584, 2188, 1221, 8086, 7746, 1228, 	// 8048 ~ 8063
+	6871, 6420,  896, 1641, 2253,  709, 1869,  382, 8014, 1966, 3567, 1736, 7505, 7934, 2758, 4230, 	// 8064 ~ 8079
+	3191, 2086, 3336, 3244, 1085, 3300,  635,  905, 1980, 7139, 1840, 2502, 2964, 6825, 5829, 3545, 	// 8080 ~ 8095
+	2751, 6063, 2276, 5534, 4042, 7346, 6304, 1560, 5588, 5808, 4193,  394, 5784, 1628, 2517, 5212, 	// 8096 ~ 8111
+	6807, 2001, 3218, 7354, 5656, 2198, 1801, 6928, 5380, 3477, 1425, 1580, 5059, 7123, 4283, 5405, 	// 8112 ~ 8127
+	6976, 2851, 3352, 3161, 4737, 1065, 2439, 6536, 3900, 2570, 2708, 6955, 5102,  501, 2042, 3887, 	// 8128 ~ 8143
+	1153, 7734, 8033, 5394, 2539, 6577, 7595, 2146,   67, 4264, 5309, 3746, 4339, 7683, 7048,  180, 	// 8144 ~ 8159
+	6530,  376, 3635, 2620, 2054, 5686, 3718,  856, 4477, 1928, 6140, 6056, 8110, 1674, 1666,  446, 	// 8160 ~ 8175
+	6448,  592, 5113, 5147, 5651, 1080, 5646, 2534, 5333, 3910,  425,  777, 6114, 1124, 5300, 8093  	// 8176 ~ 8191
+};
+
+const unsigned int BCH_TGRTable[52][2] =
+{
+	{ 0x00000000, 0x00080000 }, { 0x00000001, 0x00000000 }, { 0x00000002, 0x00000000 }, { 0x00000004, 0x00080000 }, //    0 ~    3
+	{ 0x00000008, 0x00000000 }, { 0x00000010, 0x00080000 }, { 0x00000020, 0x00080000 }, { 0x00000040, 0x00080000 }, //    4 ~    7
+	{ 0x00000080, 0x00000000 }, { 0x00000100, 0x00080000 }, { 0x00000200, 0x00000000 }, { 0x00000400, 0x00000000 }, //    8 ~   11
+	{ 0x00000800, 0x00000000 }, { 0x00001000, 0x00080000 }, { 0x00002000, 0x00080000 }, { 0x00004000, 0x00080000 }, //   12 ~   15
+	{ 0x00008000, 0x00080000 }, { 0x00010000, 0x00000000 }, { 0x00020000, 0x00000000 }, { 0x00040000, 0x00080000 }, //   16 ~   19
+	{ 0x00080000, 0x00080000 }, { 0x00100000, 0x00000000 }, { 0x00200000, 0x00000000 }, { 0x00400000, 0x00000000 }, //   20 ~   23
+	{ 0x00800000, 0x00080000 }, { 0x01000000, 0x00080000 }, { 0x02000000, 0x00000000 }, { 0x04000000, 0x00080000 }, //   24 ~   27
+	{ 0x08000000, 0x00080000 }, { 0x10000000, 0x00000000 }, { 0x20000000, 0x00000000 }, { 0x40000000, 0x00000000 }, //   28 ~   31
+	{ 0x80000000, 0x00000000 }, { 0x00000000, 0x00080001 }, { 0x00000000, 0x00080002 }, { 0x00000000, 0x00000004 }, //   32 ~   35
+	{ 0x00000000, 0x00000008 }, { 0x00000000, 0x00000010 }, { 0x00000000, 0x00000020 }, { 0x00000000, 0x00000040 }, //   36 ~   39
+	{ 0x00000000, 0x00000080 }, { 0x00000000, 0x00000100 }, { 0x00000000, 0x00000200 }, { 0x00000000, 0x00000400 }, //   40 ~   43
+	{ 0x00000000, 0x00000800 }, { 0x00000000, 0x00001000 }, { 0x00000000, 0x00002000 }, { 0x00000000, 0x00004000 }, //   44 ~   47
+	{ 0x00000000, 0x00008000 }, { 0x00000000, 0x00010000 }, { 0x00000000, 0x00020000 }, { 0x00000000, 0x00040000 }  //   48 ~   51
+};
diff -ruaN linux-2.6.31/drivers/mtd/nand/lf1000_internal_ECC.c linux-2.6/drivers/mtd/nand/lf1000_internal_ECC.c
--- linux-2.6.31/drivers/mtd/nand/lf1000_internal_ECC.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/lf1000_internal_ECC.c	2011-01-04 15:06:06.000000000 -0800
@@ -0,0 +1,481 @@
+/*
+ *  drivers/mtd/nand/lf1000_internal_ECC.c
+ *
+ * Copyright 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ * Scott Esters <sesters@leapfrog.com>
+ * Robert T. Dowling <rdowling@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains routines and data for dealing with NAND flash devices
+ * that internally calculate, store, check, and correct ECC.  The Micron
+ * MT29F4G08ABADA is an example.
+ */
+
+
+static void lf1000_prepare_for_InternalEcc( struct nand_chip * pchip);
+
+
+static struct nand_ecclayout micron_nand_oob_internal_ecc = {
+	.eccbytes = 32,
+	.eccpos = {0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+		   0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+		   0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+           	   0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f },
+	.oobfree = {
+		{.offset = 0x02,
+		 .length = 4},
+		{.offset = 0x12,
+		 .length = 4},
+		{.offset = 0x22,
+		 .length = 4},
+		{.offset = 0x32,
+		 .length = 4}}
+};
+
+#define MICRON_SET_FEATURES_CMD     0xEF
+#define MICRON_GET_FEATURES_CMD     0xEE
+#define MICRON_ARRAY_OPN_MODE_ADDR  0x90
+#define ARRAY_OPN_MODE_ENABLE_ECC   0x08
+#define ARRAY_OPN_MODE_DISABLE_ECC  0x00
+
+/* Enable or Disable Micron Nand's internal ecc mode
+ * the 'mode' argument indicates enable or disable:
+ *    ARRAY_OPN_MODE_ENABLE_ECC 
+ *    ARRAY_OPN_MODE_DISABLE_ECC 
+ *
+ * Select the nand device
+ * send the Set Features command for the Array Operations
+ * send the mode byte and 3 zeroes
+ * wait for the device to be ready
+ * send the Get Features command for the Array Operations
+ * read and return a byte, which indicates whether or not internal ecc
+ *	is enabled.
+ */
+static unsigned char SetInternalEccMode( struct mtd_info *mtd, 
+		 	      		 struct nand_chip *chip,
+					 unsigned char mode )
+{
+	unsigned char bvalue;
+
+	/* Select the device */
+	chip->select_chip(mtd, 0);
+
+	// enable internal ecc
+	chip->cmdfunc(mtd, MICRON_SET_FEATURES_CMD, 
+		      MICRON_ARRAY_OPN_MODE_ADDR, -1);
+	/* delay briefly */
+	ndelay(100);
+
+	writeb( mode, chip->IO_ADDR_W);
+	writeb(0, chip->IO_ADDR_W);
+	writeb(0, chip->IO_ADDR_W);
+	writeb(0, chip->IO_ADDR_W);
+
+	nand_wait_ready(mtd);
+
+	/* now read back the array operations mode 
+	 * values and check for internal ecc enabled
+	 */
+	chip->cmdfunc(mtd, MICRON_GET_FEATURES_CMD, 
+		      MICRON_ARRAY_OPN_MODE_ADDR, -1);
+	/* delay briefly */
+	ndelay(100);
+
+	bvalue = readb(chip->IO_ADDR_R);
+	return bvalue;
+}
+
+static int DisableInternalECC(struct mtd_info *mtd, 
+		 	      struct nand_chip *chip,
+			      u32 * p_nand_props,
+			      int cart_nand) 
+{
+	unsigned char bvalue;
+
+	bvalue = SetInternalEccMode(mtd, chip, ARRAY_OPN_MODE_DISABLE_ECC);
+	printk(KERN_CRIT "Trying to disable cart intECC; read back %d\n",
+		bvalue);
+	if (bvalue == ARRAY_OPN_MODE_DISABLE_ECC) {
+		*p_nand_props &= ~NAND_INTERNAL_ECC_ENABLED;
+		printk(KERN_CRIT " intECC now disabled\n");
+	}
+	else {
+		printk(KERN_CRIT " intECC still enabled\n");
+	}
+	return (bvalue == ARRAY_OPN_MODE_DISABLE_ECC);
+}
+
+static int EnableInternalECC(struct mtd_info *mtd, 
+			     struct nand_chip *chip,
+			     u32 * p_nand_props,
+			     int cart_nand) 
+{
+	unsigned char bvalue;
+
+	bvalue = SetInternalEccMode(mtd, chip, ARRAY_OPN_MODE_ENABLE_ECC);
+	printk(KERN_CRIT "Trying to enable cart intECC; read back %d\n",bvalue);
+	if (bvalue == ARRAY_OPN_MODE_ENABLE_ECC) {
+		*p_nand_props |= NAND_INTERNAL_ECC_ENABLED;
+		printk(KERN_CRIT " intECC now enabled\n");
+	}
+	else {
+		printk(KERN_CRIT " intECC still disabled\n");
+	}
+	return (bvalue == ARRAY_OPN_MODE_ENABLE_ECC);
+}
+
+
+/* Routines that support the Micron MT29F4G08ABADA SLC NAND flash,
+ * which can take care of ECC internally.
+ *
+ * cart_nand: nonzero ==> cartridge nand; if MT29F4G08ABADA, enable internal ecc
+ */
+static int chip_is_MT29F4G08ABADA(struct mtd_info *mtd, 
+				  struct nand_chip *chip,
+				  u32 * p_nand_props,
+				  int cart_nand) 
+{
+	int dev_id, maf_id, three, four, five;
+
+	/* Select the device */
+	chip->select_chip(mtd, 0);
+
+	/* wait a little bit after reset to see if this helps ID read problem*/
+	mdelay(2);
+
+	/* Send the command for reading device ID */
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	maf_id  = chip->read_byte(mtd);
+	dev_id  = chip->read_byte(mtd);
+	three   = chip->read_byte(mtd);
+	four    = chip->read_byte(mtd);
+	five    = chip->read_byte(mtd);
+	dev_crit(&nand.pdev->dev, 
+		"MT29F... read from %s: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",
+       		 (cart_nand ? "cart" : "base"), 
+		 maf_id, dev_id, three, four, five);
+
+	if (   (maf_id == NAND_MFR_MICRON)
+	    && (dev_id == 0xDC)
+            && (three  == 0x90)
+            && (four   == 0x95)
+            && ((five  == 0xD6) || (five == 0x56))) {
+
+	        int os1, os2, os3, os4;
+
+		/* Send the command for reading ONFI signature device ID @ 0x20 */
+		chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
+		os1 = chip->read_byte(mtd);
+		os2 = chip->read_byte(mtd);
+		os3 = chip->read_byte(mtd);
+		os4 = chip->read_byte(mtd);
+	        if (   ('O' == os1)
+	            && ('N' == os2)
+	            && ('F' == os3)
+	            && ('I' == os4) )
+	        {
+			dev_crit(&nand.pdev->dev, "MT29F... found ONFI\n");
+			*p_nand_props = NAND_SUPPORTS_INTERNAL_ECC
+					| NAND_SUPPORTS_ONFI;
+			if (five == 0xD6) 
+				*p_nand_props |= NAND_INTERNAL_ECC_ENABLED;
+			else if (cart_nand) {
+				unsigned char bvalue;
+
+				bvalue = SetInternalEccMode(mtd, chip,
+						     ARRAY_OPN_MODE_ENABLE_ECC);
+				printk(KERN_CRIT "Trying to enable cart intECC;"
+						 " read back %d\n", bvalue);
+				if (bvalue == ARRAY_OPN_MODE_ENABLE_ECC) {
+					*p_nand_props |= NAND_INTERNAL_ECC_ENABLED;
+					printk(KERN_CRIT " intECC now enabled\n");
+				}
+				else {
+					printk(KERN_CRIT " intECC still disabled\n");
+				}
+			}
+			return 1;
+        	}
+	        dev_crit(&nand.pdev->dev, "MT29F... found 0x%x, 0x%x, 0x%x, 0x%x\n",
+        	        os1, os2, os3, os4);
+	}
+	return 0;
+}
+
+
+/**
+ * lf1000_nand_read_page_internalEcc - Micron NAND page read function, using
+ *                                     the NAND's internal ECC capability.
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ */
+static int lf1000_nand_read_page_internalEcc(struct mtd_info  * mtd, 
+                                      struct nand_chip * chip,
+            	                      uint8_t          * buf)
+{ 
+	tpIO A = chip->IO_ADDR_R;
+	uint8_t *b;
+	int      len;
+	int      rem;
+	char     status;
+
+	/* Read status byte, waiting for the NAND to read the page into its
+	 * internal buffer. */
+	do {
+	        chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	        status = readb(A);
+	} while (!(status & NAND_STATUS_READY));
+
+	/* If FAILed, increment mtd->ecc_stats.failed and return -1 */
+	if (status & NAND_STATUS_FAIL) {
+	        mtd->ecc_stats.failed++;
+	        return -1;
+	}
+#define MT29F_REWRITE_RECOMMENDED   0x08
+	if (status & MT29F_REWRITE_RECOMMENDED) {
+	        mtd->ecc_stats.corrected++;
+	}
+	/* Now reissue the Read Mode command to return to Read Mode */
+	chip->cmd_ctrl(mtd, NAND_CMD_READ0,
+		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+
+	b   = buf;
+	len = mtd->writesize;
+	rem = (3 & (unsigned int)b);
+	if (rem) {
+	        while ( (len > 0) && (rem < 4)) {
+		        *b++ = readb(A);
+		        ++rem;
+		        --len;
+	        }
+	}
+	if (0 == (3 & (unsigned int)b)) {
+	        u32 * p = (u32 *)b;
+
+	        for (; len > 63; len -= 64) {
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+	        }
+	        for (; len > 3; len -= 4) {
+		        *p++ = readl(A);
+	        }
+	        b = (uint8_t *)p;
+		while (len-- > 0) {
+		        *b++ = readb(A);
+	        }
+	}
+	else {
+	        dev_info(&nand.pdev->dev, 
+			"!@#$ lf1000_nand_read_page_internalECC()\n");
+	        for ( ; len > 0; --len) {
+		        *b++ = readb(A);
+	        }
+	}
+	return 0;
+}
+
+
+
+/**
+ * lf1000_nand_write_page_internalECC - write, using NAND's internal ECC
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ *
+ * Writes the buffer's data to the page in one operation.
+ *
+ * @Details:	nand_write_page(), which calls this routine, has already
+ *		supervised processing that prepares for writing a page by
+ * doing the following:
+ *		send a Write command (0x80)
+ *		send the start-of-page address
+ *
+ * This routine does not send a Start Programming command to the device.  It
+ * depends on its caller to do that and to check if the write was completed ok.
+ */
+
+static void lf1000_nand_write_page_internalEcc( struct mtd_info  * mtd, 
+                                         	struct nand_chip * chip,
+		                                const uint8_t    * buf)
+{
+	chip->write_buf(mtd, buf, mtd->writesize);
+}
+
+/**
+ * lf1000_nand_read_subpage_internalEcc - sub-page read function
+ *		for use with a NAND flash that has internal ECC
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @data_offs:	offset of requested data within the page
+ * @readlen:	data length
+ * @bufpoi:	buffer to store read data
+ */
+static int lf1000_nand_read_subpage_internalEcc(struct mtd_info  *mtd, 
+					        struct nand_chip *chip, 
+					        uint32_t	  data_offs, 
+					        uint32_t	  readlen, 
+					        uint8_t		 *buf)
+{
+	tpIO A = chip->IO_ADDR_R;
+	uint8_t *b;
+	int      len;
+	int      rem;
+	char     status;
+
+	/* Read status byte, waiting for the NAND to read the page into its
+	 * internal buffer. */
+	do {
+	        chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	        status = readb(A);
+	} while (!(status & NAND_STATUS_READY));
+
+	/* If FAILed, increment mtd->ecc_stats.failed and return -1 */
+	if (status & NAND_STATUS_FAIL) {
+	        mtd->ecc_stats.failed++;
+	        return -1;
+	}
+#define MT29F_REWRITE_RECOMMENDED   0x08
+	if (status & MT29F_REWRITE_RECOMMENDED) {
+	        mtd->ecc_stats.corrected++;
+	}
+	/* Now reissue the Read Mode command to return to Read Mode */
+	chip->cmd_ctrl(mtd, NAND_CMD_READ0,
+		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+
+	/* and position to the intra-page offset (if necessary) */
+	/* TODO: add the code */
+
+	b   = buf;
+	len = readlen;
+	rem = (3 & (unsigned int)b);
+	if (rem) {
+	        while ( (len > 0) && (rem < 4)) {
+		        *b++ = readb(A);
+		        ++rem;
+		        --len;
+	        }
+	}
+	if (0 == (3 & (unsigned int)b)) {
+	        u32 * p = (u32 *)b;
+
+	        for (; len > 63; len -= 64) {
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+		        *p++ = readl(A);
+	        }
+	        for (; len > 3; len -= 4) {
+		        *p++ = readl(A);
+	        }
+	        b = (uint8_t *)p;
+		while (len-- > 0) {
+		        *b++ = readb(A);
+	        }
+	}
+	else {
+	        dev_info(&nand.pdev->dev, 
+			"!@#$ lf1000_nand_read_subpage_internalEcc()\n");
+	        for ( ; len > 0; --len) {
+		        *b++ = readb(A);
+	        }
+	}
+	return 0;
+}
+
+
+static void lf1000_prepare_for_InternalEcc( struct nand_chip * pchip) {
+/* TODO: FIXME: add call to set feature (internal ECC) */
+/* (For now, depend on emerald-boot to do that */
+
+	pchip->ecc.mode           = NAND_ECC_INTERNAL;
+	pchip->ecc.size           = 512;
+	pchip->ecc.bytes          = 8;
+          /* When ecc.mode is NAND_ECC_HW_SYNDROME, these 3 must be non-null */
+	pchip->ecc.hwctl          = NULL;
+	pchip->ecc.calculate      = NULL;
+	pchip->ecc.correct        = NULL;
+
+	pchip->ecc.read_page      = lf1000_nand_read_page_internalEcc;
+	pchip->ecc.write_page     = lf1000_nand_write_page_internalEcc;
+	pchip->ecc.read_subpage   = lf1000_nand_read_subpage_internalEcc;
+	pchip->ecc.read_page_raw  = nand_read_page_raw;
+	pchip->ecc.write_page_raw = nand_write_page_raw;
+	pchip->ecc.read_oob       = nand_read_oob_std;
+	pchip->ecc.write_oob      = nand_write_oob_std;
+	pchip->ecc.layout         = &micron_nand_oob_internal_ecc;
+}
+
+/* Enable this #define if you don't want to use the internal ECC capability
+ * of the MT29F4G08ABADA nand flash.  
+ * NOTE: You must also change emerald-boot's nand_utils.c so it won't enable
+ * the device's internal ECC mode.
+ * #define DONT_USE_MT29F4G08ABADA_INTERNAL_ECC 1
+ *
+ * NOTE: it would be better to put the mode selection code in
+ *	 chip_is_MT29F4G08ABADA().  Have it set a variable that indicates
+ * whether internal or external ECC mode is enabled.
+ */
+static void lf1000_init_for_MT29F4G08ABADA(struct mtd_info *mtd, 
+                                           struct nand_chip *chip,
+					   u32 * p_nand_props)
+{
+	if (*p_nand_props & NAND_INTERNAL_ECC_ENABLED) {
+		/* Prepare to use internally calculated & checked 4-bit ECC */
+		lf1000_prepare_for_InternalEcc( chip );
+		dev_info(&nand.pdev->dev, "Using Internal ECC\n");
+		mtd->subpage_sft  = 2;
+		chip->verify_buf  = lf1000_verify_SLC_page; 
+		chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
+	}
+	else {
+		lf1000_prepare_for_4BitEcc( chip );
+		dev_info(&nand.pdev->dev, "Using External 4-bit ECC\n");
+		chip->verify_buf  = lf1000_verify_MLC_page;
+		/* TODO: figure out what we ought to do in this case */
+		chip->options    |= NAND_NO_SUBPAGE_WRITE;
+		mtd->subpage_sft  = 0;
+		chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
+	}
+}
+
+
+
+
diff -ruaN linux-2.6.31/drivers/mtd/nand/lf1000_MLC_BCH.c linux-2.6/drivers/mtd/nand/lf1000_MLC_BCH.c
--- linux-2.6.31/drivers/mtd/nand/lf1000_MLC_BCH.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/lf1000_MLC_BCH.c	2011-01-04 15:01:20.000000000 -0800
@@ -0,0 +1,1056 @@
+/*
+ *  drivers/mtd/nand/lf1000_MLC_BCH.c
+ *
+ * Copyright 2007-2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ * Scott Esters <sesters@leapfrog.com>
+ * Robert T. Dowling <rdowling@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This file contains routines and data for dealing with MLC NAND flash and/or
+ * BCH ECC.
+ */
+
+static struct nand_ecclayout nand_oob_64_BCH = {
+	.eccbytes = 28,
+	.eccpos = {36, 37, 38, 39, 40, 41, 42, 
+	           43, 44, 45, 46, 47, 48, 49,
+        	   50, 51, 52, 53, 54, 55, 56, 
+	           57, 58, 59, 60, 61, 62, 63 },
+	.oobfree = {
+		{.offset = 2,
+		 .length = 34}}
+};
+
+static struct nand_ecclayout nand_oob_128_BCH = {
+	.eccbytes = 56,
+	.eccpos = { 72,  73,  74,  75,  76,  77,  78, 
+	            79,  80,  81,  82,  83,  84,  85, 
+	            86,  87,  88,  89,  90,  91,  92, 
+	            93,  94,  95,  96,  97,  98,  99, 
+	           100, 101, 102, 103, 104, 105, 106,
+	           107, 108, 109, 110, 111, 112, 113,
+	           114, 115, 116, 117, 118, 119, 120,
+	           121, 122, 123, 124, 125, 126, 127 },
+	.oobfree = {
+		{.offset = 2,
+		 .length = 70}}
+};
+
+/**
+ * lf1000_nand_read_subpage_BCH  Leapfrog's version for nand_read_subpage()
+ *                               for use with BCH ECC
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @data_offs:	offset of requested data within the page
+ * @readlen:	data length
+ * @bufpoi:	buffer to store read data
+ *
+ * This function sends a RNDOUT command and read the ECC bytes from the OOB,
+ * then send a RNDOUT command for the start of the subpage section, then
+ * (repeating as necessary) reset the NAND controller's ECC engine, load ECC
+ * bytes into the LF1000's ORGECC registers, read an entire 512-byte section
+ * into the buffer, check for errors and correct them if possible.  Continue
+ * until an uncorrectable error is detected or until all requested bytes have
+ * been read into bufpoi.
+ */
+static int lf1000_nand_read_subpage_BCH(struct mtd_info  *mtd, 
+                                        struct nand_chip *chip, 
+                                        uint32_t          data_offs, 
+                                        uint32_t          readlen, 
+                                        uint8_t          *bufpoi)
+{
+	int i;
+	int start_step;
+	int end_step;
+	int num_steps;
+	int data_col_addr;
+	int datafrag_len;
+	int eccfrag_len;
+	int eccOffset;  /* from start of sectionECC[] to start of ECC bytes
+                           for current section */
+	int eccbytes = chip->ecc.bytes;
+	int eccsize  = chip->ecc.size;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	uint8_t  *buf;
+	uint8_t   sectionECC[MAX_ECC_BYTES_PER_PAGE]; 
+                                /* buffer for all of the page's ECC bytes */
+	uint32_t allFF;
+	uint8_t  eccAllFF;
+	uint32_t hdweFoundErrors;
+	tpIO A = chip->IO_ADDR_R;
+
+
+	    /* Column address within the page aligned to ECC size */
+	start_step = data_offs / eccsize;
+	end_step   = (data_offs + readlen - 1) / eccsize;
+	num_steps  = end_step - start_step + 1;
+
+	    /* Data size aligned to ECC ecc.size*/
+	datafrag_len = num_steps * eccsize;
+	eccfrag_len  = num_steps * eccbytes;
+
+        /* first read all of the page's ECC bytes into sectionECC */
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, mtd->writesize + *eccpos, -1);
+	chip->read_buf(mtd, sectionECC, chip->ecc.layout->eccbytes);
+	eccOffset = start_step * eccbytes;
+
+        /* point to the start of the first subpage we'll read */
+	data_col_addr = start_step * eccsize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, data_col_addr, -1);
+
+	buf = bufpoi + data_col_addr;
+	for (i = 0; i < num_steps; 
+	     ++i, data_col_addr += eccsize, eccOffset += eccbytes)
+	{
+       		int      len;
+	        uint8_t *b;
+		int      rem;
+		uint8_t  val8;
+		uint32_t val32;
+		int	 eccSubIndex;
+		uint8_t *pecc;
+    		u32 ctl = readl((tpIO)(NAND_BASE+NFCONTROL));
+	        writel((ctl & (NFC_NFTYPE_MASK | NFC_NFBANK_MASK)) 
+        	        | NFC_ECCRST_MASK, 
+        	        (tpIO)(NAND_BASE+NFCONTROL)); 
+	        val32 = sectionECC[eccOffset] 
+        	        + (sectionECC[eccOffset+1] << 8)
+        	        + (sectionECC[eccOffset+2] << 16)
+        	        + (sectionECC[eccOffset+3] << 24);
+	        writel(val32, (tpIO)(NAND_BASE+NFORGECCL)); 
+
+	        val32 = sectionECC[eccOffset+4] 
+        	        + (sectionECC[eccOffset+5] << 8)
+        	        + (sectionECC[eccOffset+6] << 16);
+        	writel(val32, (tpIO)(NAND_BASE+NFORGECCH)); 
+
+		/* Read 512 bytes into the current section of 'buf'*/
+        	len = eccsize;
+		b   = buf;
+		rem = (3 & (unsigned int)b);
+
+		if (rem) {
+			allFF = 0x000000FF;
+			while ( (len > 0) && (rem < 4)) {
+				val8   = readb((tpIO)A);
+				allFF &= val8;
+				*b++   = val8;
+				++rem;
+				--len;
+			}
+			if (allFF == 0x000000FF) {
+				allFF = 0xFFFFFFFF;
+			}
+		}
+		else {
+			allFF = 0xFFFFFFFF;
+		}
+		if (0 == (3 & (unsigned int)b)) {
+			u32 * p = (u32 *)b;
+
+			for (; len > 63; len -= 64) {
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+			}
+			for (; len > 3; len -= 4) {
+				val32 = readl(A); allFF &= val32; *p++ = val32;
+			}
+			b = (uint8_t *)p;
+			while (len-- > 0) {
+				val8 = readb(A);
+				if (val8 != 0xFF) {
+					allFF = 0;
+				}
+				*b++ = val8;
+			}
+		}
+		else {
+			dev_info(&nand.pdev->dev, 
+				"!@#$ lf1000_nand_read_subpage_BCH()\n");
+			allFF = 0x000000FF;
+			for ( ; len > 0; --len) {
+				val8   = readb(A);
+				allFF &= val8;
+				*b++   = val8;
+			}
+			if (allFF == 0x000000FF) {
+				allFF = 0xFFFFFFFF;
+			}
+		}
+		/* Wait until the NFECCDECDONE bit is set in the 
+		 * NFECCSTATUS register.
+		 */
+		/* while we wait, check if all ECC bytes are FF */
+		eccAllFF = 0xFF;
+		for (eccSubIndex = 0, pecc = &sectionECC[eccOffset]; 
+		     eccSubIndex < eccbytes; ++eccSubIndex)
+		{
+	                eccAllFF &= *pecc++;
+		}
+
+		while(IS_CLR(readl((tpIO)(NAND_BASE+NFECCSTATUS)),NFECCDECDONE))
+			;
+		/* Check the NFCHECKERROR bit in the NFECCSTATUS register.
+		 * If there's an error, read the syndrome values from
+		 * NFSYNDROME31 and NFSYNDROME75 registers, save them, and use
+		 * them to try to correct the error.
+		 */
+		hdweFoundErrors = IS_SET(readl((tpIO)(NAND_BASE+NFECCSTATUS)),
+					 NFCHECKERROR);
+		/* Check for eccAllFF and a few non-FF data bytes
+		 * if lf1000 hdwe indicates error 
+		 *   AND either data or ecc contains non-FF bytes,
+		 * then look a little closer.
+		 *
+		 * Skip this processing if hdwe indicate ok 
+		 *                  OR (all data bytes AND all ECC bytes are FF)
+		 */
+		if (   hdweFoundErrors
+		    && ((allFF != 0xFFFFFFFF) || (eccAllFF != 0xFF)))
+		{
+			/* if all ecc bytes are FF, check if only a few data 
+			 * bytes are not FF.  In that case, set all data bytes
+			 * to FF and report corrected ECC errors.
+			*/
+			if (   (eccAllFF == 0xFF)
+			    && (num_zero_bits_u32(allFF) <= 4)) 
+			{
+				uint8_t *b   = buf;
+				int      count;
+				int      j;
+				/* NOTE: this can be speeded up if necessary;
+				 *       keeping it simple and short for now.
+				 */
+				count = 0;
+				for (j = 0; (j < eccsize) && (count < 5); j++) {
+					count += num_zero_bits_u8(*b++);
+				}
+				/* Now if count < 5, it's the number of zero
+				 * data bits in the buffer.  Treat this as an
+				 * erased section in which a few bits have been
+				 * flipped.  Add 'count' to the number of
+				 * (corrected) errors.
+				 */
+				if (count < 5) {
+					memset( buf, 0xFF, eccsize);
+					total_bitflips           += count;
+					mtd->ecc_stats.corrected += count;
+					allFF = 0xFFFFFFFF;
+					dev_info(&nand.pdev->dev, 
+						"Found %d 0-bits in mostly-FF"
+						" section %d of page;"
+						" set all to FF\n",
+						count, i);
+				}
+			}
+			/* NOTE: we might find it necessary to check if the
+			 *	 total number of zero bits in data and ECC is
+			 * < 5 and force all data bytes to FF in that case.
+			 */
+		}
+		if (   hdweFoundErrors && (allFF != 0xFFFFFFFF)) {
+			int TryToCorrectBCH_Errors(u8 * pData);
+			int numErrors;
+
+			numErrors = TryToCorrectBCH_Errors( buf );
+			if (numErrors < 0) { /* uncorrectable errors */
+				mtd->ecc_stats.failed++;
+				dev_info(&nand.pdev->dev, 
+					"Found uncorrectable ECC errors (%d) "
+					"in section %d of page\n", 
+					 numErrors, i);
+				dev_info(&nand.pdev->dev, 
+					"  Read ECC bytes: %02x %02x "
+					"%02x %02x %02x %02x %02x\n",
+					sectionECC[eccOffset+0], 
+					sectionECC[eccOffset+1], 
+					sectionECC[eccOffset+2], 
+					sectionECC[eccOffset+3], 
+					sectionECC[eccOffset+4], 
+					sectionECC[eccOffset+5], 
+					sectionECC[eccOffset+6]);
+				for (i = 0; i < eccsize; i += 16) {
+					dev_info(&nand.pdev->dev,
+						"%02x %02x %02x %02x "
+						"%02x %02x %02x %02x "
+						"%02x %02x %02x %02x "
+						"%02x %02x %02x %02x\n",
+						buf[i], buf[i+1], buf[i+2], 
+						buf[i+3], buf[i+4], buf[i+5], 
+						buf[i+6], buf[i+7], buf[i+8], 
+						buf[i+9], buf[i+10], buf[i+11],
+						buf[i+12], buf[i+13], buf[i+14], 
+						buf[i+15]);
+				}
+				return numErrors;
+			}
+			else if (numErrors > 0) {
+				total_bitflips           += numErrors;
+				mtd->ecc_stats.corrected += numErrors;
+				dev_info(&nand.pdev->dev, 
+					"Corrected %d ECC errors "
+					"in section %d of page\n", 
+					numErrors, i);
+			}
+		}
+		buf += eccsize;
+	}
+	return 0;
+}
+
+/**
+ * lf1000_nand_read_page_BCH - LF1000 BCH-ecc-based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ */
+static int lf1000_nand_read_page_BCH( struct mtd_info  * mtd, 
+	                              struct nand_chip * chip,
+	    	                      uint8_t          * buf)
+{   
+	int i;
+	int dataOffset; /* from start of page to start of current section */
+	int eccOffset;  /* from start of page to start of current ECC section */
+	int eccsize  = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	tpIO A = chip->IO_ADDR_R;
+	int j;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	uint8_t sectionECC[MAX_ECC_BYTES_PER_PAGE]; 
+                                /* buffer for all of the page's ECC bytes */
+	uint32_t allFF;
+	uint8_t  eccAllFF;
+	uint32_t hdweFoundErrors;
+
+	dataOffset = 0;
+	eccOffset  = mtd->writesize + *eccpos;
+
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, eccOffset, -1);
+	chip->read_buf(mtd, sectionECC, chip->ecc.layout->eccbytes);
+	eccOffset  = 0; /* now eccOffset is offset into sectionECC[] */
+
+	    /* Prepare to read the section's data */
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, dataOffset, -1);
+	for (i = 0; i < eccsteps; ++i, dataOffset += eccsize, 
+					eccOffset += eccbytes) {
+		unsigned int val32;
+	    	u32 ctl = readl((tpIO)(NAND_BASE+NFCONTROL));
+		writel((ctl & (NFC_NFTYPE_MASK | NFC_NFBANK_MASK)) 
+			| NFC_ECCRST_MASK, 
+		        (tpIO)(NAND_BASE+NFCONTROL)); 
+		        /* set ECCRST, keeping NFTYPE and NFBANK */
+		val32 = sectionECC[eccOffset] 
+		        + (sectionECC[eccOffset+1] << 8)
+		        + (sectionECC[eccOffset+2] << 16)
+		        + (sectionECC[eccOffset+3] << 24);
+		writel(val32, (tpIO)(NAND_BASE+NFORGECCL)); 
+
+		val32 = sectionECC[eccOffset+4] 
+		        + (sectionECC[eccOffset+5] << 8)
+		        + (sectionECC[eccOffset+6] << 16);
+		writel(val32, (tpIO)(NAND_BASE+NFORGECCH)); 
+
+		    /* Read 512 bytes and store them into the current section 
+		     * of 'buf'*/
+	        {
+		int      len = eccsize;
+	        uint8_t *b   = buf;
+		int      rem = (3 & (unsigned int)b);
+		uint8_t  val8;
+		uint32_t val32;
+
+		if (rem) {
+			allFF = 0x000000FF;
+                	while ( (len > 0) && (rem < 4)) {
+                		val8   = readb(A);
+		                allFF &= val8;
+				*b++   = val8;
+		                ++rem;
+		                --len;
+	                }
+	                if (allFF == 0x000000FF)
+	                    allFF = 0xFFFFFFFF;
+		}
+	        else allFF = 0xFFFFFFFF;
+
+		if (0 == (3 & (unsigned int)b)) {
+	                u32 * p = (u32 *)b;
+
+		        for (; len > 63; len -= 64) {
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        	val32 = readl(A); allFF &= val32; *p++ = val32;
+		        }
+			for (; len > 3; len -= 4) {
+		            val32 = readl(A); allFF &= val32; *p++ = val32;
+		        }
+		        b = (uint8_t *)p;
+			while (len-- > 0) {
+		        	val8 = readb(A);
+		        	if (val8 != 0xFF) {
+		        	        allFF = 0;
+		        	}
+				*b++ = val8;
+		        }
+		}
+		else { /* unexpected condition (unaligned pointer) */
+		        dev_info(&nand.pdev->dev, 
+				 "!@#$ lf1000_nand_read_page_BCH()\n");
+		        allFF = 0x000000FF;
+			for ( ; len > 0; --len) {
+				val8   = readb(A);
+			        allFF &= val8;
+				*b++   = val8;
+			}
+		        if (allFF == 0x000000FF)
+		            allFF = 0xFFFFFFFF;
+		}
+        	}
+		    /* Wait until the NFECCDECDONE bit is set in the 
+		     * NFECCSTATUS register.
+		     */
+        	{   /* while we wait, check if all ECC bytes are FF */
+		int eccSubIndex;
+		uint8_t * pecc;
+            
+		eccAllFF = 0xFF;
+		for (eccSubIndex = 0, pecc = &sectionECC[eccOffset]; 
+                     eccSubIndex < eccbytes; ++eccSubIndex)
+		{
+	                eccAllFF &= *pecc++;
+		}
+	        }
+
+	        while(IS_CLR(readl((tpIO)(NAND_BASE+NFECCSTATUS)),NFECCDECDONE))
+	            ;
+		/* Check the NFCHECKERROR bit in the NFECCSTATUS register.
+		 * If there's an error, read the syndrome values from
+		 * NFSYNDROME31 and NFSYNDROME75 registers, save them, 
+		 * and use them to try to correct the error.
+		 */
+	        hdweFoundErrors = IS_SET(readl((tpIO)(NAND_BASE+NFECCSTATUS)),
+        	                         NFCHECKERROR);
+            	/* Check for eccAllFF and a few non-FF data bytes
+        	 * if lf1000 hdwe indicates error 
+        	 *   AND either data or ecc contains non-FF bytes,
+        	 * then look a little closer.
+        	 *
+        	 * Skip this processing if hdwe indicate ok 
+        	 *                 OR (all data bytes AND all ECC bytes are FF)
+		 */
+	        if (   hdweFoundErrors
+        	    && ((allFF != 0xFFFFFFFF) || (eccAllFF != 0xFF)))
+        	{
+        		/* if all ecc bytes are FF, check if only a few data 
+			 * bytes are not FF.  In that case, set all data bytes
+			 * to FF and report corrected ECC errors.
+			 */
+		        if (   (eccAllFF == 0xFF)
+			    && (num_zero_bits_u32(allFF) <= 4)) {
+	        		uint8_t *b   = buf;
+                		int      count;
+
+				/* NOTE: this can be speeded up if necessary;
+				 *       keeping it simple and short for now.
+				 */
+				count = 0;
+				for (j = 0; (j < eccsize) && (count < 5); j++) {
+				    count += num_zero_bits_u8(*b++);
+				}
+				/* Now if count < 5, it's the number of zero 
+				 * data bits in the buffer.  Treat this as an
+				 * erased section in which a few bits have been
+				 * flipped.  Add 'count' to the number of
+				 * (corrected) errors.
+				 */
+				if (count < 5) {
+					memset( buf, 0xFF, eccsize);
+					mtd->ecc_stats.corrected += count;
+					allFF = 0xFFFFFFFF;
+					dev_info(&nand.pdev->dev, 
+						 "Found %d 0-bits in mostly-FF "
+						 " section %d of page;"
+						 " set all to FF\n",
+				           	 count, i);
+		                }
+            		}
+		/* NOTE: we might find it necessary to check if the total number
+		 *	 of zero bits in data and ECC is < 5 and force all data
+		 *	 bytes to FF in that case.
+		 */
+	        }
+		if (   hdweFoundErrors && (allFF != 0xFFFFFFFF)) {
+		        int TryToCorrectBCH_Errors(u8 * pData);
+		        int numErrors;
+
+			numErrors = TryToCorrectBCH_Errors( buf );
+			if (numErrors < 0) { /* uncorrectable errors */
+				mtd->ecc_stats.failed++;
+				dev_info(&nand.pdev->dev, 
+					 "Found uncorrectable ECC errors (%d) "
+			                 "in section %d of page\n", 
+					 numErrors, i);
+				dev_info(&nand.pdev->dev,
+					 "  Read ECC bytes: %02x %02x "
+			                 "%02x %02x %02x %02x %02x\n",
+			        	 sectionECC[eccOffset+0], 
+					 sectionECC[eccOffset+1], 
+				         sectionECC[eccOffset+2],
+					 sectionECC[eccOffset+3], 
+				         sectionECC[eccOffset+4],
+					 sectionECC[eccOffset+5], 
+				         sectionECC[eccOffset+6]);
+
+				for (i = 0; i < eccsize; i += 16) {
+				    dev_info(&nand.pdev->dev,
+				      "%02x %02x %02x %02x %02x %02x %02x %02x "
+				      "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+				       buf[i], buf[i+1], buf[i+2], buf[i+3],
+				       buf[i+4], buf[i+5], buf[i+6], buf[i+7],
+				       buf[i+8], buf[i+9], buf[i+10], buf[i+11],
+				       buf[i+12], buf[i+13], buf[i+14], buf[i+15]);
+				}
+		        	return numErrors;
+        		}
+		        else if (numErrors > 0) {
+				total_bitflips += numErrors;
+				mtd->ecc_stats.corrected += numErrors;
+				dev_info(&nand.pdev->dev,
+					 "Corrected %d ECC errors "
+			                 "in section %d of page\n", 
+					 numErrors, i);
+			}
+        	}
+        	buf += eccsize;
+	}
+	return 0;
+}
+
+
+
+/**
+ * lf1000_nand_write_page_BCH - LF1000 BCH-ecc-based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ *
+ * Writes the buffer's data to the page in 512-byte sections.  After each
+ * 512-byte section, reads the 7-byte ECC value from the LF1000's ECC registers
+ * and writes it to the appropriate place eccbuf[].  After all the data bytes
+ * have been written to the page, this routine writes the ECC bytes to the
+ * page's spare area (OOB).
+ *
+ * @Details:	nand_write_page(), which calls this routine, has already
+ *				supervised processing that prepares for writing a page by
+ * doing the following:
+ *		send a Write command (0x80)
+ *		send the start-of-page address
+ *
+ * On each pass through its loop, this routine does what's needed to write a
+ * 512-byte section of the page to the NAND device.
+ *
+ * 		Sets the ECCRST bit in the NFCONTROL register, resetting the ECC
+ *      calculation hardware.
+ *	
+ *		Next the routine calls chip->write_buf() to write the 512 data bytes
+ *		to the device.
+ *
+ *		After the NAND controller completes its calculation of the ECC bytes
+ *		for the section's data, this routine reads the values from the 
+ *		controller's NFECCL and NFECCH registers and stores them in eccbuf[].
+ *
+ *      After writing all the data to the page, the routine calls 
+ *      chip->cmdfunc() to send a RNDIN command, with the offset of location
+ *      in the spare area where ECC bytes ought to be written.  Then it calls
+ *		chip->write_buf() to write the page's ECC bytes to the flash.
+ *
+ * This routine does not send a Start Programming command to the device.  It
+ * depends on its caller to do that and to check if the write was completed ok.
+ */
+
+/*
+ * FIXME: TODO: Do we need a timeout on the wait for 'NFECCENCDONE'?
+ */
+
+static void lf1000_nand_write_page_BCH( struct mtd_info  * mtd, 
+	                                struct nand_chip * chip,
+		                        const uint8_t    * buf)
+{
+	unsigned int  eccl;
+	unsigned int  ecch;
+	unsigned char eccbuf[MAX_ECC_BYTES_PER_PAGE];
+
+	int i;
+	int dataOffset; /* from start of page to start of current section */
+	int eccOffset;  /* from start of page to start of current ECC section */
+	int eccsize  = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int *eccpos  = chip->ecc.layout->eccpos;
+
+	dataOffset = 0;
+	eccOffset  = 0;	    /* offset into eccbuf */
+	/*  for each section of page */
+	for (i = 0; i < eccsteps; ++i, dataOffset += eccsize,
+					eccOffset += eccbytes) {
+	        int allFF;
+
+    		u32 ctl = readl((tpIO)(NAND_BASE+NFCONTROL));
+        	writel( (ctl & (NFC_NFTYPE_MASK | NFC_NFBANK_MASK))
+			 | NFC_ECCRST_MASK, 
+	                (tpIO)(NAND_BASE+NFCONTROL)); 
+		chip->write_buf(mtd, buf + dataOffset, eccsize);
+
+		/* This routine won't be called to write a buffer with all FFs 
+		 * to NAND, but subsections of the buffer might contain only 
+		 * FFs.  If no subpage writes are allowed, and if a subsection
+		 * contains only FFs, go ahead and store the ECC bytes computed
+		 * by the LF1000 hardware.
+		 * If subpage writes are allowed (e.g., SLC), and if a
+		 * subsection contains only FFs, substitute FFs for the 
+		 * section's computed ECC bytes (which are 0xE9, 0x1C, 0x9E,
+		 * 0xD5, 0xB9, 0x92, 0x0B).  This substitution allows another
+		 * write of non-FF values to the same section of the page
+		 * without garbling the stored ECC bytes.
+		 * For example there might be two writes to a page when we use
+		 * 4-bit ECC on SLC and configure UBI to store both EC header
+		 * and VID header in the same page.  After a block is erased,
+		 * its EC header is written to the first section of the block's
+		 * first page.  Later when the physical block is mapped to a
+		 * logical block, a VID header is written to the second section
+		 * of the block's first page.
+		 */
+	        allFF = 0;
+		if (mtd->subpage_sft != 0)
+		        allFF = all_bytes_ff( &buf[dataOffset], eccsize);
+
+	        while(IS_CLR(readl((tpIO)(NAND_BASE+NFECCSTATUS)), NFECCENCDONE))
+	        	;
+
+		eccl = readl((tpIO)(NAND_BASE+NFECCL)); 
+		ecch = readl((tpIO)(NAND_BASE+NFECCH));
+
+		if (!allFF) { /* store the computed ECC bytes */
+			eccbuf[eccOffset+0] =  eccl        & 0x000000FF; 
+			eccbuf[eccOffset+1] = (eccl >> 8)  & 0x000000FF; 
+			eccbuf[eccOffset+2] = (eccl >> 16) & 0x000000FF; 
+			eccbuf[eccOffset+3] = (eccl >> 24) & 0x000000FF; 
+			eccbuf[eccOffset+4] =  ecch        & 0x000000FF; 
+			eccbuf[eccOffset+5] = (ecch >> 8)  & 0x000000FF; 
+			eccbuf[eccOffset+6] = (ecch >> 16) & 0x000000FF; 
+		}
+		else { /* all FF, so just store FF as ECC */
+			eccbuf[eccOffset+0] = 0xFF; 
+			eccbuf[eccOffset+1] = 0xFF; 
+			eccbuf[eccOffset+2] = 0xFF; 
+			eccbuf[eccOffset+3] = 0xFF; 
+			eccbuf[eccOffset+4] = 0xFF; 
+			eccbuf[eccOffset+5] = 0xFF; 
+			eccbuf[eccOffset+6] = 0xFF; 
+			allFF = 0;
+	        }
+	}
+        /* Write all ECC bytes at once */
+	chip->cmdfunc(mtd, NAND_CMD_RNDIN, mtd->writesize + *eccpos, -1);
+	chip->write_buf(mtd, eccbuf, eccOffset);
+}
+
+/*
+ * The LF1000 hardware ECC is always enabled so no initialization is needed 
+ * here.
+ */ 
+static void lf1000_nand_enable_hwecc_BCH(struct mtd_info *mtd, int mode) {
+}
+
+
+/**
+ * lf1000_nand_calculate_BCH - calculate BCH ECC for 512-byte buffer
+ *			 block
+ * @mtd:	MTD block structure
+ * @buf:	input buffer with raw data
+ * @code:	output buffer with ECC
+ */
+static int lf1000_nand_calculate_BCH(struct mtd_info     * mtd, 
+                              const unsigned char * buf,
+		                      unsigned char       * code) 
+{
+	/* not actually needed for BCH; just return 0 */
+	return 0;
+}
+
+
+/**
+ * lf1000_nand_correct_BCH - Detect and correct bit error(s)
+ * @mtd:	MTD block structure
+ * @buf:	raw data read from the chip
+ * @read_ecc:	ECC from the chip
+ * @calc_ecc:	the ECC calculated from raw data
+ *
+ * Detect and correct up to 4 bit errors for 512 byte block
+ */
+static int lf1000_nand_correct_BCH(struct mtd_info * mtd, 
+                            unsigned char   * buf,
+		                    unsigned char   * read_ecc, 
+                            unsigned char   * calc_ecc)
+{
+	/* not actually needed for BCH; just return 0 */
+	return 0;
+}
+
+
+
+static void lf1000_prepare_for_4BitEcc( struct nand_chip * pchip) {
+	pchip->ecc.mode           = NAND_ECC_HW_SYNDROME;
+	pchip->ecc.size           = 512;
+	pchip->ecc.bytes          = 7;
+          /* When ecc.mode is NAND_ECC_HW_SYNDROME, these 3 must be non-null */
+	pchip->ecc.hwctl          = lf1000_nand_enable_hwecc_BCH;
+	pchip->ecc.calculate      = lf1000_nand_calculate_BCH;
+	pchip->ecc.correct        = lf1000_nand_correct_BCH;
+
+	pchip->ecc.read_page      = lf1000_nand_read_page_BCH;
+	pchip->ecc.write_page     = lf1000_nand_write_page_BCH;
+	pchip->ecc.read_page_raw  = nand_read_page_raw;
+	pchip->ecc.write_page_raw = nand_write_page_raw;
+	pchip->ecc.read_oob       = nand_read_oob_std;
+	pchip->ecc.write_oob      = nand_write_oob_std;
+	pchip->ecc.layout         = &nand_oob_64_BCH;
+}
+
+
+/**
+ * MLC_BlockBad - checks if a specified block of a Samsung MLC flash
+ *                   is bad.
+ *          Used for these chips instead of nand_block_bad
+ * @mtd:    MTD device structure
+ * @ofs:    offset from device start
+ * @getchip:    0, if the chip is already selected
+ *
+ * Check if the block has been marked bad.  Return nonzero if it has.
+ *
+ * @Details:	This function calculates the index of the block in which the
+ *		specified offset (ofs) lies.  Then it calculates the index
+ * of the last page of the block.  Finally it reads the first byte of the spare
+ * area of the last page, whose value indicates whether or not the block has 
+ * been marked bad (0xFF == good; anything else == bad).
+ */
+static int MLC_BlockBad(struct mtd_info *mtd, loff_t ofs, int getchip)
+{
+	int page, chipnr, res = 0;
+	struct nand_chip *chip = mtd->priv;
+	int block;
+	int blockSize;
+	int pageSize;
+
+	if (getchip) {
+		page   = (int)(ofs >> chip->page_shift);
+		chipnr = (int)(ofs >> chip->chip_shift);
+
+		nand_get_device(chip, mtd, FL_READING);
+
+		/* Select the NAND device */
+		chip->select_chip(mtd, chipnr);
+	} else
+		page = (int)ofs;
+
+		/* Calculate page as page index of block's last page */
+	blockSize = 1 << chip->phys_erase_shift;
+	pageSize  = 1 << chip->page_shift;
+	block     = ( ((int)ofs) >> chip->phys_erase_shift);
+	ofs       = (block << chip->phys_erase_shift);
+	ofs      += (blockSize - pageSize);
+	page      = (ofs >> chip->page_shift);
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, chip->badblockpos,
+			      page & chip->pagemask);
+	if (chip->read_byte(mtd) != 0xff) {
+		res = 1;
+	        dev_crit(&nand.pdev->dev, "Block 0x%x (page 0x%x) is BAD\n", 
+			 block, page); 
+	}
+	if (getchip)
+		nand_release_device(mtd);
+
+	return res;
+}
+
+/**
+ * MLC_BlockMarkBad - marks a specified block of a Samsung MLC flash
+ *                       bad.
+ *              Used for these chips instead of nand_default_block_markbad
+ * @mtd:    MTD device structure
+ * @ofs:    offset from device start
+ *
+ * This function marks the flash block bad and updates the bad block table.  
+ * It returns zero if it completed its processing without detecting an error.
+*/
+/* FIXME: TODO: Because the chip doesn't allow subpage writes, do we need  
+ *      to erase the block before we can write the bad block indicator?? 
+ */
+static int MLC_BlockMarkBad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint8_t buf[2] = { 0, 0 };
+	int block, ret;
+
+
+	/* Get block number */
+	block = ((int)ofs) >> chip->bbt_erase_shift;
+	if (chip->bbt)
+		chip->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
+
+	/* Do we have a flash based bad block table ? */
+	if (chip->options & NAND_USE_FLASH_BBT)
+		ret = nand_update_bbt(mtd, ofs);
+	else {
+		/* We write two bytes, so we dont have to mess with 16 bit
+		 * access
+		 * Calculate offset to start of last page of block
+		 */
+		int blockSize;
+		int pageSize;
+		blockSize = 1 << chip->phys_erase_shift;
+		pageSize  = 1 << chip->page_shift;
+		block     = ((int)ofs) >> chip->phys_erase_shift;
+		ofs       = block << chip->phys_erase_shift;
+		ofs      += (blockSize - pageSize);
+
+		chip->ops.len     = chip->ops.ooblen = 2;
+		chip->ops.datbuf  = NULL;
+		chip->ops.oobbuf  = buf;
+		chip->ops.ooboffs = chip->badblockpos & ~0x01;
+
+		ret = nand_do_write_oob(mtd, ofs, &chip->ops);
+		/* Return 0 if nand_do_write_oob() fails because of
+	         * a write error -- it might happen on a truly bad block.
+	         * Return 0 so ubi_io_mark_bad() won't return an error indicator
+        	 * to erase_worker(), and erase_worker() won't put the entire
+        	 * ubi device into read-only mode.
+		 */
+		if (-EIO == ret) {
+			ret = 0;
+			dev_crit(&nand.pdev->dev, 
+			 "MLC_BlockMarkBad: -EIO writing bb mark in block %d\n",
+			         block); 
+		}
+	}
+	if (!ret)
+		mtd->ecc_stats.badblocks++;
+	return ret;
+}
+
+
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+static struct nand_bbt_descr mlc_memorybased = {
+	.options = 0,
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+    /* loosely derived from nand_default_bbt()
+     * We need to our own version of nand_scan_bbt() etc
+     * because the standard versions assume the bad block info
+     * is in the OOB of a block's first page.
+     */
+static int MLC_bbt(struct mtd_info * mtd )
+{
+	struct nand_chip *this = mtd->priv;
+	int len;
+	int i, numblocks;
+	int startblock;
+	loff_t from;
+
+	/* For now, always build the bad block table in ram */
+	this->bbt_td = NULL;
+	this->bbt_md = NULL;
+	if (!this->badblock_pattern) {
+		this->badblock_pattern = &mlc_memorybased;
+	}
+        /* Allocate memory (2bit per block) 
+         * and clear the memory bad block table */
+	len = mtd->size >> (this->bbt_erase_shift + 2);
+	this->bbt = kzalloc(len, GFP_KERNEL);
+	if (!this->bbt) {
+	        dev_err(&nand.pdev->dev, "MLC_bbt: Out of memory\n");
+	        return -ENOMEM;
+	}
+
+	/* Note that numblocks is 2 * (real numblocks) here, see i+=2
+	 * below as it makes shifting and masking less painful */
+	numblocks  = mtd->size >> (this->bbt_erase_shift - 1);
+	startblock = 0;
+	from = 0;
+	for (i = startblock; i < numblocks;) {
+        	int ret;
+    
+        	ret = MLC_BlockBad(mtd, from, 1);
+        	if (ret) {  /* if block is bad */
+	    		this->bbt[i >> 3] |= 0x03 << (i & 0x6);
+        		dev_warn(&nand.pdev->dev, 
+				"Bad eraseblock %d at 0x%012llx\n",
+	        	         i >> 1, (unsigned long long)from);
+		        	 mtd->ecc_stats.badblocks++;
+       		}
+		i    += 2;
+		from += (1 << this->bbt_erase_shift);
+	}
+	return 0;
+}
+
+
+/** Leapfrog's replacement for nand_verify_buf()
+ * lf1000_verify_MLC_page - Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ */
+/* TODO: FIXME: Change this to read ECC bytes from OOB, check for errors,
+ *              and correct them if possible.  Report a verification error
+ *              only if there are uncorrectable errors or if the corrected 
+ *		stuff doesn't match the contents of buf.
+ * Alternatively count the number of flipped bits in the values that are read
+ * back from NAND.  If only a few (< 4?), say it's ok -- assuming the ECC can
+ * locate and fix them.
+ */
+static int lf1000_verify_MLC_page(struct mtd_info *mtd, 
+                                  const uint8_t *buf, 
+                                  int len)
+{
+	int rem = (3 & (unsigned int)buf);
+	int olen = len; /* original len; needed just for error reporting */
+	int numErrors = 0;
+	struct nand_chip *chip = mtd->priv;
+	tpIO A = chip->IO_ADDR_R;
+	const uint8_t *b;
+
+	uint8_t  val8;
+	uint32_t val32;
+
+	b = buf;
+	if (rem > 0) {
+	        for (; rem < 4; ++rem, --len, ++b) {
+		        if (*b != (val8 = readb(A))) {
+		                if (0 == numErrors++) {
+                			dev_info(&nand.pdev->dev,
+						 "lf1000_verify_MLC_page;"
+		                                 " verify failed @%x:"
+						 " %02x v. %02x\n", 
+			                          olen - len, *b, val8);
+                		}
+		        }
+	        }
+	}
+	if (0 == (3 & (unsigned int)b)) { /* now the pointer is 32-bit aligned*/
+	        const uint32_t * p = (const uint32_t *)b;
+
+	        for ( ; len >= 4; ++p, len -= 4) {
+		        if (*p != (val32 = readl(A))) {
+		                if (0 == numErrors++) {
+		                	dev_info(&nand.pdev->dev,
+						 "lf1000_verify_MLC_page;"
+		                                 " verify failed @%x:"
+						 " %08x v. %08x\n", 
+			                         olen - len, *p, val32);	
+                		}
+			}
+        	}
+	        b = (const uint8_t *)p;
+	}
+	if (len > 0) {
+	        for ( ; len > 0; ++b, --len) {
+		        if (*b != (val8 = readb(A))) {
+		                if (0 == numErrors++) {
+                			dev_info(&nand.pdev->dev,
+						 "lf1000_verify_MLC_page;"
+		                                 " verify failed @%x:"
+						 " %02x v. %02x\n", 
+			                         olen - len, *b, val8);
+                		}
+		        }
+		}
+	}
+	if (numErrors > 0)
+		return -EFAULT;
+	return 0;
+}
+
+static void lf1000_init_for_MLC_nand(struct mtd_info *mtd, 
+                                     struct nand_chip *chip)
+{
+        /* For now we use 4-bit ECC on every MLC device
+         * and force NO_SUBPAGE_WRITEs and subpagesize == writesize */
+	lf1000_prepare_for_4BitEcc( chip );
+
+        /* We use special bad block detector and marker functions
+	 * for this chip in order to be straightforward about
+         * checking the first byte of the spare area of the last
+         * page of the block.
+	 *
+         * TODO: FIXME: Probably ought to check the mfr/chip IDs and use
+         *              that info to determine the bad block functions
+         * to use and the ecc.layout.
+         */
+	chip->block_bad     = MLC_BlockBad;
+	chip->block_markbad = MLC_BlockMarkBad;
+	chip->scan_bbt      = MLC_bbt;
+	chip->verify_buf    = lf1000_verify_MLC_page;
+	dev_info(&nand.pdev->dev, "Using 4-bit ECC\n");
+
+	chip->options    |= NAND_NO_SUBPAGE_WRITE;
+	mtd->subpage_sft  = 0;
+	chip->subpagesize = mtd->writesize >> mtd->subpage_sft;
+	if (mtd->writesize == 4096) {
+	        chip->ecc.layout = &nand_oob_128_BCH;
+	}
+}
+
+
+
+static void lf1000_set_hw_syndrome_ecc(struct nand_chip *chip)
+{
+	chip->ecc.read_page  = lf1000_nand_read_page_BCH;
+	chip->ecc.write_page = lf1000_nand_write_page_BCH;
+	chip->ecc.read_subpage = lf1000_nand_read_subpage_BCH;
+	chip->ecc.read_oob   = nand_read_oob_std;
+	chip->ecc.write_oob  = nand_write_oob_std;
+	chip->ecc.calculate  = lf1000_nand_calculate_BCH;
+	chip->ecc.correct    = lf1000_nand_correct_BCH;
+	chip->ecc.hwctl      = lf1000_nand_enable_hwecc_BCH;
+	chip->ecc.size       = 512;
+	chip->ecc.bytes      = 7;
+}
+
+
diff -ruaN linux-2.6.31/drivers/mtd/nand/Makefile linux-2.6/drivers/mtd/nand/Makefile
--- linux-2.6.31/drivers/mtd/nand/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/nand/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -40,5 +40,7 @@
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
 obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
+obj-$(CONFIG_MTD_NAND_LF1000)		+= lf1000_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
+lf1000_nand-objs := lf1000.o lf1000_ecc.o lf1000_ecc_tables.o
diff -ruaN linux-2.6.31/drivers/mtd/nand/nand_base.c linux-2.6/drivers/mtd/nand/nand_base.c
--- linux-2.6.31/drivers/mtd/nand/nand_base.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/nand/nand_base.c	2011-01-04 15:01:23.000000000 -0800
@@ -52,8 +52,15 @@
 #include <linux/mtd/partitions.h>
 #endif
 
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+#include "prof.h"
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
-static struct nand_ecclayout nand_oob_8 = {
+#ifndef CPU_LF1000
+static 
+#endif
+struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
 	.eccpos = {0, 1, 2},
 	.oobfree = {
@@ -63,7 +70,10 @@
 		 .length = 2}}
 };
 
-static struct nand_ecclayout nand_oob_16 = {
+#ifndef CPU_LF1000
+static 
+#endif
+struct nand_ecclayout nand_oob_16 = {
 	.eccbytes = 6,
 	.eccpos = {0, 1, 2, 3, 6, 7},
 	.oobfree = {
@@ -71,7 +81,10 @@
 		 . length = 8}}
 };
 
-static struct nand_ecclayout nand_oob_64 = {
+#ifndef CPU_LF1000
+static 
+#endif
+struct nand_ecclayout nand_oob_64 = {
 	.eccbytes = 24,
 	.eccpos = {
 		   40, 41, 42, 43, 44, 45, 46, 47,
@@ -82,7 +95,10 @@
 		 .length = 38}}
 };
 
-static struct nand_ecclayout nand_oob_128 = {
+#ifndef CPU_LF1000
+static 
+#endif
+struct nand_ecclayout nand_oob_128 = {
 	.eccbytes = 48,
 	.eccpos = {
 		   80, 81, 82, 83, 84, 85, 86, 87,
@@ -96,10 +112,16 @@
 		 .length = 78}}
 };
 
-static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
+#ifndef CPU_LF1000
+static 
+#endif
+int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
 
-static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+#ifndef CPU_LF1000
+static 
+#endif
+int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 			     struct mtd_oob_ops *ops);
 
 /*
@@ -114,7 +136,10 @@
  *
  * Deselect, release chip lock and wake up anyone waiting on the device
  */
-static void nand_release_device(struct mtd_info *mtd)
+#ifndef CPU_LF1000
+static
+#endif
+void nand_release_device(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -127,6 +152,11 @@
 	chip->state = FL_READY;
 	wake_up(&chip->controller->wq);
 	spin_unlock(&chip->controller->lock);
+
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+	nand_stats_accum (NS_LOCK, 0);
+#endif
+
 }
 
 /**
@@ -224,6 +254,7 @@
 		buf[i] = readb(chip->IO_ADDR_R);
 }
 
+
 /**
  * nand_verify_buf - [DEFAULT] Verify chip data against buffer
  * @mtd:	MTD device structure
@@ -238,7 +269,7 @@
 	struct nand_chip *chip = mtd->priv;
 
 	for (i = 0; i < len; i++)
-		if (buf[i] != readb(chip->IO_ADDR_R))
+		if (buf[i] != readb(chip->IO_ADDR_R)) 
 			return -EFAULT;
 	return 0;
 }
@@ -398,7 +429,10 @@
  *
  * The function expects, that the device is already selected
  */
-static int nand_check_wp(struct mtd_info *mtd)
+#ifndef CPU_LF1000
+static 
+#endif
+int nand_check_wp(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
@@ -416,7 +450,10 @@
  * Check, if the block is bad. Either by reading the bad block table or
  * calling of the scan function.
  */
-static int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
+#ifndef CPU_LF1000
+static 
+#endif
+int nand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip,
 			       int allowbbt)
 {
 	struct nand_chip *chip = mtd->priv;
@@ -434,17 +471,22 @@
  */
 void nand_wait_ready(struct mtd_info *mtd)
 {
+	int timeout=1;
 	struct nand_chip *chip = mtd->priv;
 	unsigned long timeo = jiffies + 2;
 
 	led_trigger_event(nand_led_trigger, LED_FULL);
 	/* wait until command is processed or timeout occures */
 	do {
-		if (chip->dev_ready(mtd))
+		if (chip->dev_ready(mtd)) {
+			timeout=0;
 			break;
+		}
 		touch_softlockup_watchdog();
 	} while (time_before(jiffies, timeo));
 	led_trigger_event(nand_led_trigger, LED_OFF);
+	
+	if(timeout) printk(KERN_WARNING "nand_wait_ready(...) timeout !\n");	
 }
 EXPORT_SYMBOL_GPL(nand_wait_ready);
 
@@ -459,7 +501,7 @@
  * devices (256/512 Bytes per page)
  */
 static void nand_command(struct mtd_info *mtd, unsigned int command,
-			 int column, int page_addr)
+		            	 int column, int page_addr)
 {
 	register struct nand_chip *chip = mtd->priv;
 	int ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;
@@ -562,7 +604,7 @@
  * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
  */
 static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
-			    int column, int page_addr)
+		            	    int column, int page_addr)
 {
 	register struct nand_chip *chip = mtd->priv;
 
@@ -679,7 +721,10 @@
  *
  * Get the device and lock it for exclusive access
  */
-static int
+#ifndef CPU_LF1000
+static
+#endif
+int
 nand_get_device(struct nand_chip *chip, struct mtd_info *mtd, int new_state)
 {
 	spinlock_t *lock = &chip->controller->lock;
@@ -696,6 +741,9 @@
 	if (chip->controller->active == chip && chip->state == FL_READY) {
 		chip->state = new_state;
 		spin_unlock(lock);
+#ifdef CONFIG_MTD_NAND_LF1000_PROF
+		nand_stats_accum (NS_LOCK, 1);
+#endif
 		return 0;
 	}
 	if (new_state == FL_PM_SUSPENDED) {
@@ -765,8 +813,11 @@
  *
  * Not for syndrome calculating ecc controllers, which use a special oob layout
  */
-static int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-			      uint8_t *buf)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+    			       uint8_t *buf)
 {
 	chip->read_buf(mtd, buf, mtd->writesize);
 	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -862,7 +913,14 @@
  * @readlen:	data length
  * @bufpoi:	buffer to store read data
  */
-static int nand_read_subpage(struct mtd_info *mtd, struct nand_chip *chip, uint32_t data_offs, uint32_t readlen, uint8_t *bufpoi)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_read_subpage(struct mtd_info *mtd, 
+                      struct nand_chip *chip, 
+                      uint32_t data_offs, 
+                      uint32_t readlen, 
+                      uint8_t *bufpoi)
 {
 	int start_step, end_step, num_steps;
 	uint32_t *eccpos = chip->ecc.layout->eccpos;
@@ -1040,8 +1098,11 @@
  * @ops:	oob ops structure
  * @len:	size of oob to transfer
  */
-static uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
-				  struct mtd_oob_ops *ops, size_t len)
+#ifndef CPU_LF1000
+static
+#endif
+uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,
+         				   struct mtd_oob_ops *ops, size_t len)
 {
 	switch(ops->mode) {
 
@@ -1230,7 +1291,7 @@
  * Get hold of the chip and call nand_do_read
  */
 static int nand_read(struct mtd_info *mtd, loff_t from, size_t len,
-		     size_t *retlen, uint8_t *buf)
+		             size_t *retlen, uint8_t *buf)
 {
 	struct nand_chip *chip = mtd->priv;
 	int ret;
@@ -1263,7 +1324,10 @@
  * @page:	page number to read
  * @sndcmd:	flag whether to issue read command or not
  */
-static int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
+#ifndef CPU_LF1000
+static
+#endif
+int nand_read_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
 			     int page, int sndcmd)
 {
 	if (sndcmd) {
@@ -1319,8 +1383,10 @@
  * @chip:	nand chip info structure
  * @page:	page number to write
  */
-static int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip,
-			      int page)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_write_oob_std(struct mtd_info *mtd, struct nand_chip *chip, int page)
 {
 	int status = 0;
 	const uint8_t *buf = chip->oob_poi;
@@ -1403,8 +1469,10 @@
  *
  * NAND read out-of-band data from the spare area
  */
-static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
-			    struct mtd_oob_ops *ops)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_do_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	int page, realpage, chipnr, sndcmd = 1;
 	struct nand_chip *chip = mtd->priv;
@@ -1497,7 +1565,7 @@
  * NAND read data and/or out-of-band data
  */
 static int nand_read_oob(struct mtd_info *mtd, loff_t from,
-			 struct mtd_oob_ops *ops)
+		            	 struct mtd_oob_ops *ops)
 {
 	struct nand_chip *chip = mtd->priv;
 	int ret = -ENOTSUPP;
@@ -1542,8 +1610,11 @@
  *
  * Not for syndrome calculating ecc controllers, which use a special oob layout
  */
-static void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-				const uint8_t *buf)
+#ifndef CPU_LF1000
+static
+#endif
+void nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
+        				 const uint8_t *buf)
 {
 	chip->write_buf(mtd, buf, mtd->writesize);
 	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
@@ -1587,6 +1658,7 @@
 	if (size)
 		chip->write_buf(mtd, oob, size);
 }
+
 /**
  * nand_write_page_swecc - [REPLACABLE] software ecc based page write function
  * @mtd:	mtd info structure
@@ -1748,7 +1820,7 @@
  * @ops:	oob ops structure
  */
 static uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob,
-				  struct mtd_oob_ops *ops)
+			      struct mtd_oob_ops *ops)
 {
 	size_t len = ops->ooblen;
 
@@ -1903,7 +1975,10 @@
  *
  * NAND write with ECC
  */
-static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+#ifndef CPU_LF1000
+static
+#endif
+int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
 			  size_t *retlen, const uint8_t *buf)
 {
 	struct nand_chip *chip = mtd->priv;
@@ -1917,7 +1992,7 @@
 
 	nand_get_device(chip, mtd, FL_WRITING);
 
-	chip->ops.len = len;
+	chip->ops.len	 = len;
 	chip->ops.datbuf = (uint8_t *)buf;
 	chip->ops.oobbuf = NULL;
 
@@ -1938,7 +2013,10 @@
  *
  * NAND write out-of-band
  */
-static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
+#ifndef CPU_LF1000
+static
+#endif
+int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 			     struct mtd_oob_ops *ops)
 {
 	int chipnr, page, status, len;
@@ -2016,7 +2094,10 @@
  * @to:		offset to write to
  * @ops:	oob operation description structure
  */
-static int nand_write_oob(struct mtd_info *mtd, loff_t to,
+#ifndef CPU_LF1000
+static 
+#endif
+int nand_write_oob(struct mtd_info *mtd, loff_t to,
 			  struct mtd_oob_ops *ops)
 {
 	struct nand_chip *chip = mtd->priv;
@@ -2288,7 +2369,10 @@
  *
  * Sync is actually a wait for chip ready function
  */
-static void nand_sync(struct mtd_info *mtd)
+#ifndef CPU_LF1000
+static 
+#endif
+void nand_sync(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2305,7 +2389,10 @@
  * @mtd:	MTD device structure
  * @offs:	offset relative to mtd start
  */
-static int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_block_isbad(struct mtd_info *mtd, loff_t offs)
 {
 	/* Check for invalid offset */
 	if (offs > mtd->size)
@@ -2319,7 +2406,10 @@
  * @mtd:	MTD device structure
  * @ofs:	offset relative to mtd start
  */
-static int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
 	struct nand_chip *chip = mtd->priv;
 	int ret;
@@ -2338,7 +2428,10 @@
  * nand_suspend - [MTD Interface] Suspend the NAND flash
  * @mtd:	MTD device structure
  */
-static int nand_suspend(struct mtd_info *mtd)
+#ifndef CPU_LF1000
+static
+#endif
+int nand_suspend(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2349,7 +2442,10 @@
  * nand_resume - [MTD Interface] Resume the NAND flash
  * @mtd:	MTD device structure
  */
-static void nand_resume(struct mtd_info *mtd)
+#ifndef CPU_LF1000
+static
+#endif
+void nand_resume(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2418,6 +2514,9 @@
 	/* Select the device */
 	chip->select_chip(mtd, 0);
 
+	/* wait a little bit after reset to see if this helps ID read problem*/
+	mdelay(2);
+
 	/*
 	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
 	 * after power-up
@@ -2431,12 +2530,15 @@
 	*maf_id = chip->read_byte(mtd);
 	dev_id = chip->read_byte(mtd);
 
+	printk(KERN_INFO "%s(...): Manu_ID = %02x, Dev_ID = %02x \n",
+	       __func__, *maf_id, dev_id);
+	
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
 	 * possibly credible NAND flash to appear. If the two results do
 	 * not match, ignore the device completely.
 	 */
-
+	mdelay(2);
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
@@ -2697,7 +2799,7 @@
 			       "Hardware ECC not possible\n");
 			BUG();
 		}
-		/* Use standard syndrome read/write page function ? */
+                /* Use standard syndrome read/write page function ? */
 		if (!chip->ecc.read_page)
 			chip->ecc.read_page = nand_read_page_syndrome;
 		if (!chip->ecc.write_page)
diff -ruaN linux-2.6.31/drivers/mtd/nand/nand_bbt.c linux-2.6/drivers/mtd/nand/nand_bbt.c
--- linux-2.6.31/drivers/mtd/nand/nand_bbt.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/nand/nand_bbt.c	2011-01-04 13:50:21.000000000 -0800
@@ -375,6 +375,12 @@
 	loff_t from;
 	size_t readlen;
 
+	if (this->ecc.mode == NAND_ECC_NONE)
+	{
+		printk(KERN_INFO "SKIPPING: Scanning device for bad blocks\n");
+		return 0;
+	}
+		
 	printk(KERN_INFO "Scanning device for bad blocks\n");
 
 	if (bd->options & NAND_BBT_SCANALLPAGES)
@@ -1214,5 +1220,41 @@
 	return 1;
 }
 
+/* RTD: New feature to forget contents of bad block table */
+void bbt_erase (struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	int len = mtd->size >> (chip->bbt_erase_shift + 2);
+	memset (chip->bbt, 0, len);
+	mtd->ecc_stats.badblocks = 0;
+	printk ("bbt_erase: len=%d size=%d\n", len, mtd->size);
+}
+/* RTD: New feature to rescan the BBT */
+void bbt_scan (struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint8_t *buf;
+	int len, x;
+
+	/* Forget old data */
+	bbt_erase (mtd);
+
+	/* Allocate a temporary buffer for one eraseblock incl. oob */
+	len = (1 << chip->bbt_erase_shift);
+	len += (len >> chip->page_shift) * mtd->oobsize;
+	buf = vmalloc(len);
+	if (!buf) {
+		printk(KERN_ERR "bbt_scan: Out of memory\n");
+		/* 
+		kfree(this->bbt);
+		this->bbt = NULL; */
+		return; /*  -ENOMEM; */
+	}
+	x = create_bbt (mtd, buf, chip->badblock_pattern, -1);
+	printk ("bbt_scan len=%d x=%d bbcount=%d\n", len, x, 
+		mtd->ecc_stats.badblocks);
+	vfree(buf);
+}
+
 EXPORT_SYMBOL(nand_scan_bbt);
 EXPORT_SYMBOL(nand_default_bbt);
diff -ruaN linux-2.6.31/drivers/mtd/nand/nand_ids.c linux-2.6/drivers/mtd/nand/nand_ids.c
--- linux-2.6.31/drivers/mtd/nand/nand_ids.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/nand/nand_ids.c	2011-01-04 13:50:21.000000000 -0800
@@ -76,6 +76,7 @@
 	/*512 Megabit */
 	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
+	{"NAND 64MiB 3,3V 8-bit",	0x28, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
 	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
 
diff -ruaN linux-2.6.31/drivers/mtd/nand/prof.h linux-2.6/drivers/mtd/nand/prof.h
--- linux-2.6.31/drivers/mtd/nand/prof.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/nand/prof.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,20 @@
+/*
+ *  drivers/mtd/nand/prof.h
+ *
+ * Copyright 2008 LeapFrog Enterprises Inc.
+ *
+ * Robert Dowling <rdowling@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/* Nand profiling support */
+
+/* Define the types of nand operations we can accumulate data on */
+enum prof_type { NS_READ, NS_WRITE, NS_ERASE, NS_LOCK, NS_MAX };
+
+/* The collector function */
+extern void nand_stats_accum (enum prof_type type, int in);
diff -ruaN linux-2.6.31/drivers/mtd/ubi/build.c linux-2.6/drivers/mtd/ubi/build.c
--- linux-2.6.31/drivers/mtd/ubi/build.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/build.c	2011-03-21 17:39:47.000000000 -0700
@@ -37,19 +37,26 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/stringify.h>
+#include <linux/namei.h>
 #include <linux/stat.h>
 #include <linux/miscdevice.h>
 #include <linux/log2.h>
 #include <linux/kthread.h>
-#include <linux/reboot.h>
 #include "ubi.h"
 
 /* Maximum length of the 'mtd=' parameter */
 #define MTD_PARAM_LEN_MAX 64
 
+#ifdef CONFIG_MTD_UBI_MODULE
+#define ubi_is_module() 1
+#else
+#define ubi_is_module() 0
+#endif
+
 /**
  * struct mtd_dev_param - MTD device parameter description data structure.
- * @name: MTD device name or number string
+ * @name: MTD character device node path, MTD device name, or MTD device number
+ *        string
  * @vid_hdr_offs: VID header offset
  */
 struct mtd_dev_param {
@@ -58,10 +65,10 @@
 };
 
 /* Numbers of elements set in the @mtd_dev_param array */
-static int mtd_devs;
+static int __initdata mtd_devs;
 
 /* MTD devices specification parameters */
-static struct mtd_dev_param mtd_dev_param[UBI_MAX_DEVICES];
+static struct mtd_dev_param __initdata mtd_dev_param[UBI_MAX_DEVICES];
 
 /* Root UBI "class" object (corresponds to '/<sysfs>/class/ubi/') */
 struct class *ubi_class;
@@ -362,11 +369,13 @@
 /**
  * ubi_sysfs_init - initialize sysfs for an UBI device.
  * @ubi: UBI device description object
+ * @ref: set to %1 on exit in case of failure if a reference to @ubi->dev was
+ *       taken
  *
  * This function returns zero in case of success and a negative error code in
  * case of failure.
  */
-static int ubi_sysfs_init(struct ubi_device *ubi)
+static int ubi_sysfs_init(struct ubi_device *ubi, int *ref)
 {
 	int err;
 
@@ -378,6 +387,7 @@
 	if (err)
 		return err;
 
+	*ref = 1;
 	err = device_create_file(&ubi->dev, &dev_eraseblock_size);
 	if (err)
 		return err;
@@ -433,7 +443,7 @@
 }
 
 /**
- * kill_volumes - destroy all volumes.
+ * kill_volumes - destroy all user volumes.
  * @ubi: UBI device description object
  */
 static void kill_volumes(struct ubi_device *ubi)
@@ -446,36 +456,29 @@
 }
 
 /**
- * free_user_volumes - free all user volumes.
- * @ubi: UBI device description object
- *
- * Normally the volumes are freed at the release function of the volume device
- * objects. However, on error paths the volumes have to be freed before the
- * device objects have been initialized.
- */
-static void free_user_volumes(struct ubi_device *ubi)
-{
-	int i;
-
-	for (i = 0; i < ubi->vtbl_slots; i++)
-		if (ubi->volumes[i]) {
-			kfree(ubi->volumes[i]->eba_tbl);
-			kfree(ubi->volumes[i]);
-		}
-}
-
-/**
  * uif_init - initialize user interfaces for an UBI device.
  * @ubi: UBI device description object
+ * @ref: set to %1 on exit in case of failure if a reference to @ubi->dev was
+ *       taken, otherwise set to %0
+ *
+ * This function initializes various user interfaces for an UBI device. If the
+ * initialization fails at an early stage, this function frees all the
+ * resources it allocated, returns an error, and @ref is set to %0. However,
+ * if the initialization fails after the UBI device was registered in the
+ * driver core subsystem, this function takes a reference to @ubi->dev, because
+ * otherwise the release function ('dev_release()') would free whole @ubi
+ * object. The @ref argument is set to %1 in this case. The caller has to put
+ * this reference.
  *
  * This function returns zero in case of success and a negative error code in
- * case of failure. Note, this function destroys all volumes if it fails.
+ * case of failure.
  */
-static int uif_init(struct ubi_device *ubi)
+static int uif_init(struct ubi_device *ubi, int *ref)
 {
 	int i, err;
 	dev_t dev;
 
+	*ref = 0;
 	sprintf(ubi->ubi_name, UBI_NAME_STR "%d", ubi->ubi_num);
 
 	/*
@@ -503,7 +506,7 @@
 		goto out_unreg;
 	}
 
-	err = ubi_sysfs_init(ubi);
+	err = ubi_sysfs_init(ubi, ref);
 	if (err)
 		goto out_sysfs;
 
@@ -521,6 +524,8 @@
 out_volumes:
 	kill_volumes(ubi);
 out_sysfs:
+	if (*ref)
+		get_device(&ubi->dev);
 	ubi_sysfs_close(ubi);
 	cdev_del(&ubi->cdev);
 out_unreg:
@@ -585,6 +590,7 @@
 	ubi->good_peb_count = ubi->peb_count - ubi->bad_peb_count;
 	ubi->max_ec = si->max_ec;
 	ubi->mean_ec = si->mean_ec;
+	ubi_msg("max. sequence number:       %llu", si->max_sqnum);
 
 	err = ubi_read_volume_table(ubi, si);
 	if (err)
@@ -829,34 +835,6 @@
 }
 
 /**
- * ubi_reboot_notifier - halt UBI transactions immediately prior to a reboot.
- * @n: reboot notifier object
- * @state: SYS_RESTART, SYS_HALT, or SYS_POWER_OFF
- * @cmd: pointer to command string for RESTART2
- *
- * This function stops the UBI background thread so that the flash device
- * remains quiescent when Linux restarts the system. Any queued work will be
- * discarded, but this function will block until do_work() finishes if an
- * operation is already in progress.
- *
- * This function solves a real-life problem observed on NOR flashes when an
- * PEB erase operation starts, then the system is rebooted before the erase is
- * finishes, and the boot loader gets confused and dies. So we prefer to finish
- * the ongoing operation before rebooting.
- */
-static int ubi_reboot_notifier(struct notifier_block *n, unsigned long state,
-			       void *cmd)
-{
-	struct ubi_device *ubi;
-
-	ubi = container_of(n, struct ubi_device, reboot_notifier);
-	if (ubi->bgt_thread)
-		kthread_stop(ubi->bgt_thread);
-	ubi_sync(ubi->ubi_num);
-	return NOTIFY_DONE;
-}
-
-/**
  * ubi_attach_mtd_dev - attach an MTD device.
  * @mtd: MTD device description object
  * @ubi_num: number to assign to the new UBI device
@@ -874,7 +852,7 @@
 int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset)
 {
 	struct ubi_device *ubi;
-	int i, err, do_free = 1;
+	int i, err, ref = 0;
 
 	/*
 	 * Check if we already have the same MTD device attached.
@@ -974,9 +952,9 @@
 			goto out_detach;
 	}
 
-	err = uif_init(ubi);
+	err = uif_init(ubi, &ref);
 	if (err)
-		goto out_nofree;
+		goto out_detach;
 
 	ubi->bgt_thread = kthread_create(ubi_thread, ubi, ubi->bgt_name);
 	if (IS_ERR(ubi->bgt_thread)) {
@@ -1001,7 +979,7 @@
 	ubi_msg("number of PEBs reserved for bad PEB handling: %d",
 		ubi->beb_rsvd_pebs);
 	ubi_msg("max/mean erase counter: %d/%d", ubi->max_ec, ubi->mean_ec);
-	ubi_msg("image sequence number: %d", ubi->image_seq);
+	ubi_msg("image sequence number:  %d", ubi->image_seq);
 
 	/*
 	 * The below lock makes sure we do not race with 'ubi_thread()' which
@@ -1013,23 +991,14 @@
 	wake_up_process(ubi->bgt_thread);
 	spin_unlock(&ubi->wl_lock);
 
-	/* Flash device priority is 0 - UBI needs to shut down first */
-	ubi->reboot_notifier.priority = 1;
-	ubi->reboot_notifier.notifier_call = ubi_reboot_notifier;
-	register_reboot_notifier(&ubi->reboot_notifier);
-
 	ubi_devices[ubi_num] = ubi;
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
 out_uif:
 	uif_close(ubi);
-out_nofree:
-	do_free = 0;
 out_detach:
 	ubi_wl_close(ubi);
-	if (do_free)
-		free_user_volumes(ubi);
 	free_internal_volumes(ubi);
 	vfree(ubi->vtbl);
 out_free:
@@ -1038,7 +1007,10 @@
 #ifdef CONFIG_MTD_UBI_DEBUG_PARANOID
 	vfree(ubi->dbg_peb_buf);
 #endif
-	kfree(ubi);
+	if (ref)
+		put_device(&ubi->dev);
+	else
+		kfree(ubi);
 	return err;
 }
 
@@ -1089,13 +1061,12 @@
 	 * Before freeing anything, we have to stop the background thread to
 	 * prevent it from doing anything on this device while we are freeing.
 	 */
-	unregister_reboot_notifier(&ubi->reboot_notifier);
 	if (ubi->bgt_thread)
 		kthread_stop(ubi->bgt_thread);
 
 	/*
 	 * Get a reference to the device in order to prevent 'dev_release()'
-	 * from freeing @ubi object.
+	 * from freeing the @ubi object.
 	 */
 	get_device(&ubi->dev);
 
@@ -1115,13 +1086,50 @@
 }
 
 /**
- * find_mtd_device - open an MTD device by its name or number.
- * @mtd_dev: name or number of the device
+ * open_mtd_by_chdev - open an MTD device by its character device node path.
+ * @mtd_dev: MTD character device node path
+ *
+ * This helper function opens an MTD device by its character node device path.
+ * Returns MTD device description object in case of success and a negative
+ * error code in case of failure.
+ */
+static struct mtd_info * __init open_mtd_by_chdev(const char *mtd_dev)
+{
+	int err, major, minor, mode;
+	struct path path;
+
+	/* Probably this is an MTD character device node path */
+	err = kern_path(mtd_dev, LOOKUP_FOLLOW, &path);
+	if (err)
+		return ERR_PTR(err);
+
+	/* MTD device number is defined by the major / minor numbers */
+	major = imajor(path.dentry->d_inode);
+	minor = iminor(path.dentry->d_inode);
+	mode = path.dentry->d_inode->i_mode;
+	path_put(&path);
+	if (major != MTD_CHAR_MAJOR || !S_ISCHR(mode))
+		return ERR_PTR(-EINVAL);
+
+	if (minor & 1)
+		/*
+		 * Just do not think the "/dev/mtdrX" devices support is need,
+		 * so do not support them to avoid doing extra work.
+		 */
+		return ERR_PTR(-EINVAL);
+
+	return get_mtd_device(NULL, minor / 2);
+}
+
+/**
+ * open_mtd_device - open MTD device by name, character device path, or number.
+ * @mtd_dev: name, character device node path, or MTD device device number
  *
  * This function tries to open and MTD device described by @mtd_dev string,
- * which is first treated as an ASCII number, and if it is not true, it is
- * treated as MTD device name. Returns MTD device description object in case of
- * success and a negative error code in case of failure.
+ * which is first treated as ASCII MTD device number, and if it is not true, it
+ * is treated as MTD device name, and if that is also not true, it is treated
+ * as MTD character device node path. Returns MTD device description object in
+ * case of success and a negative error code in case of failure.
  */
 static struct mtd_info * __init open_mtd_device(const char *mtd_dev)
 {
@@ -1136,6 +1144,9 @@
 		 * MTD device name.
 		 */
 		mtd = get_mtd_device_nm(mtd_dev);
+		if (IS_ERR(mtd) && PTR_ERR(mtd) == -ENODEV)
+			/* Probably this is an MTD character device node path */
+			mtd = open_mtd_by_chdev(mtd_dev);
 	} else
 		mtd = get_mtd_device(NULL, mtd_num);
 
@@ -1191,7 +1202,13 @@
 		mtd = open_mtd_device(p->name);
 		if (IS_ERR(mtd)) {
 			err = PTR_ERR(mtd);
+#ifdef CONFIG_ARCH_LF1000
+			ubi_err("Failed to find MTD device %s.  Skipping.",
+				p->name);
+			continue;
+#else
 			goto out_detach;
+#endif
 		}
 
 		mutex_lock(&ubi_devices_mutex);
@@ -1199,9 +1216,24 @@
 					 p->vid_hdr_offs);
 		mutex_unlock(&ubi_devices_mutex);
 		if (err < 0) {
-			put_mtd_device(mtd);
 			ubi_err("cannot attach mtd%d", mtd->index);
-			goto out_detach;
+			put_mtd_device(mtd);
+
+			/*
+			 * Originally UBI stopped initializing on any error.
+			 * However, later on it was found out that this
+			 * behavior is not very good when UBI is compiled into
+			 * the kernel and the MTD devices to attach are passed
+			 * through the command line. Indeed, UBI failure
+			 * stopped whole boot sequence.
+			 *
+			 * To fix this, we changed the behavior for the
+			 * non-module case, but preserved the old behavior for
+			 * the module case, just for compatibility. This is a
+			 * little inconsistent, though.
+			 */
+			if (ubi_is_module())
+				goto out_detach;
 		}
 	}
 
@@ -1351,13 +1383,15 @@
 
 module_param_call(mtd, ubi_mtd_param_parse, NULL, NULL, 000);
 MODULE_PARM_DESC(mtd, "MTD devices to attach. Parameter format: "
-		      "mtd=<name|num>[,<vid_hdr_offs>].\n"
+		      "mtd=<name|num|path>[,<vid_hdr_offs>].\n"
 		      "Multiple \"mtd\" parameters may be specified.\n"
-		      "MTD devices may be specified by their number or name.\n"
+		      "MTD devices may be specified by their number, name, or "
+		      "path to the MTD character device node.\n"
 		      "Optional \"vid_hdr_offs\" parameter specifies UBI VID "
-		      "header position and data starting position to be used "
-		      "by UBI.\n"
-		      "Example: mtd=content,1984 mtd=4 - attach MTD device"
+		      "header position to be used by UBI.\n"
+		      "Example 1: mtd=/dev/mtd0 - attach MTD device "
+		      "/dev/mtd0.\n"
+		      "Example 2: mtd=content,1984 mtd=4 - attach MTD device "
 		      "with name \"content\" using VID header offset 1984, and "
 		      "MTD device number 4 with default VID header offset.");
 
diff -ruaN linux-2.6.31/drivers/mtd/ubi/cdev.c linux-2.6/drivers/mtd/ubi/cdev.c
--- linux-2.6.31/drivers/mtd/ubi/cdev.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/cdev.c	2011-01-04 14:54:25.000000000 -0800
@@ -798,18 +798,18 @@
 			goto out_free;
 		}
 
-		re = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);
-		if (!re) {
+		re1 = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);
+		if (!re1) {
 			err = -ENOMEM;
 			ubi_close_volume(desc);
 			goto out_free;
 		}
 
-		re->remove = 1;
-		re->desc = desc;
-		list_add(&re->list, &rename_list);
+		re1->remove = 1;
+		re1->desc = desc;
+		list_add(&re1->list, &rename_list);
 		dbg_msg("will remove volume %d, name \"%s\"",
-			re->desc->vol->vol_id, re->desc->vol->name);
+			re1->desc->vol->vol_id, re1->desc->vol->name);
 	}
 
 	mutex_lock(&ubi->device_mutex);
@@ -853,7 +853,6 @@
 			break;
 		}
 
-		req.name[req.name_len] = '\0';
 		err = verify_mkvol_req(ubi, &req);
 		if (err)
 			break;
diff -ruaN linux-2.6.31/drivers/mtd/ubi/debug.c linux-2.6/drivers/mtd/ubi/debug.c
--- linux-2.6.31/drivers/mtd/ubi/debug.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/debug.c	2011-01-04 14:54:25.000000000 -0800
@@ -196,4 +196,36 @@
 	printk(KERN_DEBUG "\t1st 16 characters of name: %s\n", nm);
 }
 
+/**
+ * ubi_dbg_dump_flash - dump a region of flash.
+ * @ubi: UBI device description object
+ * @pnum: the physical eraseblock number to dump
+ * @offset: the starting offset within the physical eraseblock to dump
+ * @len: the length of the region to dump
+ */
+void ubi_dbg_dump_flash(struct ubi_device *ubi, int pnum, int offset, int len)
+{
+	int err;
+	size_t read;
+	void *buf;
+	loff_t addr = (loff_t)pnum * ubi->peb_size + offset;
+
+	buf = vmalloc(len);
+	if (!buf)
+		return;
+	err = ubi->mtd->read(ubi->mtd, addr, len, &read, buf);
+	if (err && err != -EUCLEAN) {
+		ubi_err("error %d while reading %d bytes from PEB %d:%d, "
+			"read %zd bytes", err, len, pnum, offset, read);
+		goto out;
+	}
+
+	dbg_msg("dumping %d bytes of data from PEB %d, offset %d",
+		len, pnum, offset);
+	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);
+out:
+	vfree(buf);
+	return;
+}
+
 #endif /* CONFIG_MTD_UBI_DEBUG */
diff -ruaN linux-2.6.31/drivers/mtd/ubi/debug.h linux-2.6/drivers/mtd/ubi/debug.h
--- linux-2.6.31/drivers/mtd/ubi/debug.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/debug.h	2011-01-04 14:54:25.000000000 -0800
@@ -55,6 +55,7 @@
 void ubi_dbg_dump_sv(const struct ubi_scan_volume *sv);
 void ubi_dbg_dump_seb(const struct ubi_scan_leb *seb, int type);
 void ubi_dbg_dump_mkvol_req(const struct ubi_mkvol_req *req);
+void ubi_dbg_dump_flash(struct ubi_device *ubi, int pnum, int offset, int len);
 
 #ifdef CONFIG_MTD_UBI_DEBUG_MSG
 /* General debugging messages */
@@ -95,8 +96,11 @@
 
 #ifdef CONFIG_MTD_UBI_DEBUG_PARANOID
 int ubi_dbg_check_all_ff(struct ubi_device *ubi, int pnum, int offset, int len);
+int ubi_dbg_check_write(struct ubi_device *ubi, const void *buf, int pnum,
+			int offset, int len);
 #else
 #define ubi_dbg_check_all_ff(ubi, pnum, offset, len) 0
+#define ubi_dbg_check_write(ubi, buf, pnum, offset, len) 0
 #endif
 
 #ifdef CONFIG_MTD_UBI_DEBUG_DISABLE_BGT
@@ -167,6 +171,7 @@
 #define ubi_dbg_dump_sv(sv)              ({})
 #define ubi_dbg_dump_seb(seb, type)      ({})
 #define ubi_dbg_dump_mkvol_req(req)      ({})
+#define ubi_dbg_dump_flash(ubi, pnum, offset, len) ({})
 
 #define UBI_IO_DEBUG               0
 #define DBG_DISABLE_BGT            0
@@ -174,6 +179,7 @@
 #define ubi_dbg_is_write_failure() 0
 #define ubi_dbg_is_erase_failure() 0
 #define ubi_dbg_check_all_ff(ubi, pnum, offset, len) 0
+#define ubi_dbg_check_write(ubi, buf, pnum, offset, len) 0
 
 #endif /* !CONFIG_MTD_UBI_DEBUG */
 #endif /* !__UBI_DEBUG_H__ */
diff -ruaN linux-2.6.31/drivers/mtd/ubi/eba.c linux-2.6/drivers/mtd/ubi/eba.c
--- linux-2.6.31/drivers/mtd/ubi/eba.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/eba.c	2011-01-04 14:54:25.000000000 -0800
@@ -418,7 +418,8 @@
 				 * may try to recover data. FIXME: but this is
 				 * not implemented.
 				 */
-				if (err == UBI_IO_BAD_VID_HDR) {
+				if (err == UBI_IO_BAD_HDR_READ ||
+				    err == UBI_IO_BAD_HDR) {
 					ubi_warn("corrupted VID header at PEB "
 						 "%d, LEB %d:%d", pnum, vol_id,
 						 lnum);
@@ -961,8 +962,8 @@
  */
 static int is_error_sane(int err)
 {
-	if (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_VID_HDR ||
-	    err == -ETIMEDOUT)
+	if (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_HDR ||
+	    err == UBI_IO_BAD_HDR_READ || err == -ETIMEDOUT)
 		return 0;
 	return 1;
 }
@@ -1165,6 +1166,44 @@
 }
 
 /**
+ * print_rsvd_warning - warn about not having enough reserved PEBs.
+ * @ubi: UBI device description object
+ *
+ * This is a helper function for 'ubi_eba_init_scan()' which is called when UBI
+ * cannot reserve enough PEBs for bad block handling. This function makes a
+ * decision whether we have to print a warning or not. The algorithm is as
+ * follows:
+ *   o if this is a new UBI image, then just print the warning
+ *   o if this is an UBI image which has already been used for some time, print
+ *     a warning only if we can reserve less than 10% of the expected amount of
+ *     the reserved PEB.
+ *
+ * The idea is that when UBI is used, PEBs become bad, and the reserved pool
+ * of PEBs becomes smaller, which is normal and we do not want to scare users
+ * with a warning every time they attach the MTD device. This was an issue
+ * reported by real users.
+ */
+static void print_rsvd_warning(struct ubi_device *ubi,
+			       struct ubi_scan_info *si)
+{
+	/*
+	 * The 1 << 18 (256KiB) number is picked randomly, just a reasonably
+	 * large number to distinguish between newly flashed and used images.
+	 */
+	if (si->max_sqnum > (1 << 18)) {
+		int min = ubi->beb_rsvd_level / 10;
+
+		if (!min)
+			min = 1;
+		if (ubi->beb_rsvd_pebs > min)
+			return;
+	}
+
+	ubi_warn("cannot reserve enough PEBs for bad PEB handling, reserved %d,"
+		 " need %d", ubi->beb_rsvd_pebs, ubi->beb_rsvd_level);
+}
+
+/**
  * ubi_eba_init_scan - initialize the EBA sub-system using scanning information.
  * @ubi: UBI device description object
  * @si: scanning information
@@ -1236,9 +1275,7 @@
 		if (ubi->avail_pebs < ubi->beb_rsvd_level) {
 			/* No enough free physical eraseblocks */
 			ubi->beb_rsvd_pebs = ubi->avail_pebs;
-			ubi_warn("cannot reserve enough PEBs for bad PEB "
-				 "handling, reserved %d, need %d",
-				 ubi->beb_rsvd_pebs, ubi->beb_rsvd_level);
+			print_rsvd_warning(ubi, si);
 		} else
 			ubi->beb_rsvd_pebs = ubi->beb_rsvd_level;
 
diff -ruaN linux-2.6.31/drivers/mtd/ubi/io.c linux-2.6/drivers/mtd/ubi/io.c
--- linux-2.6.31/drivers/mtd/ubi/io.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/io.c	2011-01-04 14:54:25.000000000 -0800
@@ -64,9 +64,9 @@
  * device, e.g., make @ubi->min_io_size = 512 in the example above?
  *
  * A: because when writing a sub-page, MTD still writes a full 2K page but the
- * bytes which are no relevant to the sub-page are 0xFF. So, basically, writing
- * 4x512 sub-pages is 4 times slower then writing one 2KiB NAND page. Thus, we
- * prefer to use sub-pages only for EV and VID headers.
+ * bytes which are not relevant to the sub-page are 0xFF. So, basically,
+ * writing 4x512 sub-pages is 4 times slower than writing one 2KiB NAND page.
+ * Thus, we prefer to use sub-pages only for EC and VID headers.
  *
  * As it was noted above, the VID header may start at a non-aligned offset.
  * For example, in case of a 2KiB page NAND flash with a 512 bytes sub-page,
@@ -143,12 +143,14 @@
 
 	err = paranoid_check_not_bad(ubi, pnum);
 	if (err)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	addr = (loff_t)pnum * ubi->peb_size + offset;
 retry:
 	err = ubi->mtd->read(ubi->mtd, addr, len, &read, buf);
 	if (err) {
+		const char *errstr = (err == -EBADMSG) ? " (ECC error)" : "";
+
 		if (err == -EUCLEAN) {
 			/*
 			 * -EUCLEAN is reported if there was a bit-flip which
@@ -164,15 +166,15 @@
 		}
 
 		if (read != len && retries++ < UBI_IO_RETRIES) {
-			dbg_io("error %d while reading %d bytes from PEB %d:%d,"
+			dbg_io("error %d%s while reading %d bytes from PEB %d:%d,"
 			       " read only %zd bytes, retry",
-			       err, len, pnum, offset, read);
+			       err, errstr, len, pnum, offset, read);
 			yield();
 			goto retry;
 		}
 
-		ubi_err("error %d while reading %d bytes from PEB %d:%d, "
-			"read %zd bytes", err, len, pnum, offset, read);
+		ubi_err("error %d%s while reading %d bytes from PEB %d:%d, "
+			"read %zd bytes", err, errstr, len, pnum, offset, read);
 		ubi_dbg_dump_stack();
 
 		/*
@@ -236,12 +238,12 @@
 
 	err = paranoid_check_not_bad(ubi, pnum);
 	if (err)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	/* The area we are writing to has to contain all 0xFF bytes */
 	err = ubi_dbg_check_all_ff(ubi, pnum, offset, len);
 	if (err)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	if (offset >= ubi->leb_start) {
 		/*
@@ -250,10 +252,10 @@
 		 */
 		err = paranoid_check_peb_ec_hdr(ubi, pnum);
 		if (err)
-			return err > 0 ? -EINVAL : err;
+			return err;
 		err = paranoid_check_peb_vid_hdr(ubi, pnum);
 		if (err)
-			return err > 0 ? -EINVAL : err;
+			return err;
 	}
 
 	if (ubi_dbg_is_write_failure()) {
@@ -269,9 +271,25 @@
 		ubi_err("error %d while writing %d bytes to PEB %d:%d, written "
 			"%zd bytes", err, len, pnum, offset, written);
 		ubi_dbg_dump_stack();
+		ubi_dbg_dump_flash(ubi, pnum, offset, len);
 	} else
 		ubi_assert(written == len);
 
+	if (!err) {
+		err = ubi_dbg_check_write(ubi, buf, pnum, offset, len);
+		if (err)
+			return err;
+
+		/*
+		 * Since we always write sequentially, the rest of the PEB has
+		 * to contain only 0xFF bytes.
+		 */
+		offset += len;
+		len = ubi->peb_size - offset;
+		if (len)
+			err = ubi_dbg_check_all_ff(ubi, pnum, offset, len);
+	}
+
 	return err;
 }
 
@@ -347,7 +365,7 @@
 
 	err = ubi_dbg_check_all_ff(ubi, pnum, 0, ubi->peb_size);
 	if (err)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	if (ubi_dbg_is_erase_failure() && !err) {
 		dbg_err("cannot erase PEB %d (emulated)", pnum);
@@ -475,30 +493,46 @@
  */
 static int nor_erase_prepare(struct ubi_device *ubi, int pnum)
 {
-	int err;
+	int err, err1;
 	size_t written;
 	loff_t addr;
 	uint32_t data = 0;
+	struct ubi_vid_hdr vid_hdr;
 
-	addr = (loff_t)pnum * ubi->peb_size;
+	addr = (loff_t)pnum * ubi->peb_size + ubi->vid_hdr_aloffset;
 	err = ubi->mtd->write(ubi->mtd, addr, 4, &written, (void *)&data);
-	if (err) {
-		ubi_err("error %d while writing 4 bytes to PEB %d:%d, written "
-			"%zd bytes", err, pnum, 0, written);
-		ubi_dbg_dump_stack();
-		return err;
+	if (!err) {
+		addr -= ubi->vid_hdr_aloffset;
+		err = ubi->mtd->write(ubi->mtd, addr, 4, &written,
+				      (void *)&data);
+		if (!err)
+			return 0;
 	}
 
-	addr += ubi->vid_hdr_aloffset;
-	err = ubi->mtd->write(ubi->mtd, addr, 4, &written, (void *)&data);
-	if (err) {
-		ubi_err("error %d while writing 4 bytes to PEB %d:%d, written "
-			"%zd bytes", err, pnum, ubi->vid_hdr_aloffset, written);
-		ubi_dbg_dump_stack();
-		return err;
-	}
+	/*
+	 * We failed to write to the media. This was observed with Spansion
+	 * S29GL512N NOR flash. Most probably the eraseblock erasure was
+	 * interrupted at a very inappropriate moment, so it became unwritable.
+	 * In this case we probably anyway have garbage in this PEB.
+	 */
+	err1 = ubi_io_read_vid_hdr(ubi, pnum, &vid_hdr, 0);
+	if (err1 == UBI_IO_BAD_HDR_READ || err1 == UBI_IO_BAD_HDR)
+		/*
+		 * The VID header is corrupted, so we can safely erase this
+		 * PEB and not afraid that it will be treated as a valid PEB in
+		 * case of an unclean reboot.
+		 */
+		return 0;
 
-	return 0;
+	/*
+	 * The PEB contains a valid VID header, but we cannot invalidate it.
+	 * Supposedly the flash media or the driver is screwed up, so return an
+	 * error.
+	 */
+	ubi_err("cannot invalidate PEB %d, write returned %d read returned %d",
+		pnum, err, err1);
+	ubi_dbg_dump_flash(ubi, pnum, 0, ubi->peb_size);
+	return -EIO;
 }
 
 /**
@@ -525,7 +559,7 @@
 
 	err = paranoid_check_not_bad(ubi, pnum);
 	if (err != 0)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	if (ubi->ro_mode) {
 		ubi_err("read-only mode");
@@ -676,7 +710,7 @@
  * o %UBI_IO_BITFLIPS if the CRC is correct, but bit-flips were detected
  *   and corrected by the flash driver; this is harmless but may indicate that
  *   this eraseblock may become bad soon (but may be not);
- * o %UBI_IO_BAD_EC_HDR if the erase counter header is corrupted (a CRC error);
+ * o %UBI_IO_BAD_HDR if the erase counter header is corrupted (a CRC error);
  * o %UBI_IO_PEB_EMPTY if the physical eraseblock is empty;
  * o a negative error code in case of failure.
  */
@@ -703,23 +737,21 @@
 		 * header is still OK, we just report this as there was a
 		 * bit-flip.
 		 */
-		read_err = err;
+		if (err == -EBADMSG)
+			read_err = UBI_IO_BAD_HDR_READ;
 	}
 
 	magic = be32_to_cpu(ec_hdr->magic);
 	if (magic != UBI_EC_HDR_MAGIC) {
+		if (read_err)
+			return read_err;
+
 		/*
 		 * The magic field is wrong. Let's check if we have read all
 		 * 0xFF. If yes, this physical eraseblock is assumed to be
 		 * empty.
-		 *
-		 * But if there was a read error, we do not test it for all
-		 * 0xFFs. Even if it does contain all 0xFFs, this error
-		 * indicates that something is still wrong with this physical
-		 * eraseblock and we anyway cannot treat it as empty.
 		 */
-		if (read_err != -EBADMSG &&
-		    check_pattern(ec_hdr, 0xFF, UBI_EC_HDR_SIZE)) {
+		if (check_pattern(ec_hdr, 0xFF, UBI_EC_HDR_SIZE)) {
 			/* The physical eraseblock is supposedly empty */
 			if (verbose)
 				ubi_warn("no EC header found at PEB %d, "
@@ -741,7 +773,7 @@
 		} else if (UBI_IO_DEBUG)
 			dbg_msg("bad magic number at PEB %d: %08x instead of "
 				"%08x", pnum, magic, UBI_EC_HDR_MAGIC);
-		return UBI_IO_BAD_EC_HDR;
+		return UBI_IO_BAD_HDR;
 	}
 
 	crc = crc32(UBI_CRC32_INIT, ec_hdr, UBI_EC_HDR_SIZE_CRC);
@@ -755,7 +787,7 @@
 		} else if (UBI_IO_DEBUG)
 			dbg_msg("bad EC header CRC at PEB %d, calculated "
 				"%#08x, read %#08x", pnum, crc, hdr_crc);
-		return UBI_IO_BAD_EC_HDR;
+		return read_err ?: UBI_IO_BAD_HDR;
 	}
 
 	/* And of course validate what has just been read from the media */
@@ -765,6 +797,10 @@
 		return -EINVAL;
 	}
 
+	/*
+	 * If there was %-EBADMSG, but the header CRC is still OK, report about
+	 * a bit-flip to force scrubbing on this PEB.
+	 */
 	return read_err ? UBI_IO_BITFLIPS : 0;
 }
 
@@ -802,7 +838,7 @@
 
 	err = paranoid_check_ec_hdr(ubi, pnum, ec_hdr);
 	if (err)
-		return -EINVAL;
+		return err;
 
 	err = ubi_io_write(ubi, ec_hdr, pnum, 0, ubi->ec_hdr_alsize);
 	return err;
@@ -944,7 +980,7 @@
  * o %UBI_IO_BITFLIPS if the CRC is correct, but bit-flips were detected
  *   and corrected by the flash driver; this is harmless but may indicate that
  *   this eraseblock may become bad soon;
- * o %UBI_IO_BAD_VID_HDR if the volume identifier header is corrupted (a CRC
+ * o %UBI_IO_BAD_HDR if the volume identifier header is corrupted (a CRC
  *   error detected);
  * o %UBI_IO_PEB_FREE if the physical eraseblock is free (i.e., there is no VID
  *   header there);
@@ -975,22 +1011,20 @@
 		 * CRC check-sum and we will identify this. If the VID header is
 		 * still OK, we just report this as there was a bit-flip.
 		 */
-		read_err = err;
+		if (err == -EBADMSG)
+			read_err = UBI_IO_BAD_HDR_READ;
 	}
 
 	magic = be32_to_cpu(vid_hdr->magic);
 	if (magic != UBI_VID_HDR_MAGIC) {
+		if (read_err)
+			return read_err;
+
 		/*
 		 * If we have read all 0xFF bytes, the VID header probably does
 		 * not exist and the physical eraseblock is assumed to be free.
-		 *
-		 * But if there was a read error, we do not test the data for
-		 * 0xFFs. Even if it does contain all 0xFFs, this error
-		 * indicates that something is still wrong with this physical
-		 * eraseblock and it cannot be regarded as free.
 		 */
-		if (read_err != -EBADMSG &&
-		    check_pattern(vid_hdr, 0xFF, UBI_VID_HDR_SIZE)) {
+		if (check_pattern(vid_hdr, 0xFF, UBI_VID_HDR_SIZE)) {
 			/* The physical eraseblock is supposedly free */
 			if (verbose)
 				ubi_warn("no VID header found at PEB %d, "
@@ -1012,7 +1046,7 @@
 		} else if (UBI_IO_DEBUG)
 			dbg_msg("bad magic number at PEB %d: %08x instead of "
 				"%08x", pnum, magic, UBI_VID_HDR_MAGIC);
-		return UBI_IO_BAD_VID_HDR;
+		return UBI_IO_BAD_HDR;
 	}
 
 	crc = crc32(UBI_CRC32_INIT, vid_hdr, UBI_VID_HDR_SIZE_CRC);
@@ -1026,7 +1060,7 @@
 		} else if (UBI_IO_DEBUG)
 			dbg_msg("bad CRC at PEB %d, calculated %#08x, "
 				"read %#08x", pnum, crc, hdr_crc);
-		return UBI_IO_BAD_VID_HDR;
+		return read_err ?: UBI_IO_BAD_HDR;
 	}
 
 	/* Validate the VID header that we have just read */
@@ -1036,6 +1070,10 @@
 		return -EINVAL;
 	}
 
+	/*
+	 * If there was a read error (%-EBADMSG), but the header CRC is still
+	 * OK, report about a bit-flip to force scrubbing on this PEB.
+	 */
 	return read_err ? UBI_IO_BITFLIPS : 0;
 }
 
@@ -1066,7 +1104,7 @@
 
 	err = paranoid_check_peb_ec_hdr(ubi, pnum);
 	if (err)
-		return err > 0 ? -EINVAL : err;
+		return err;
 
 	vid_hdr->magic = cpu_to_be32(UBI_VID_HDR_MAGIC);
 	vid_hdr->version = UBI_VERSION;
@@ -1075,7 +1113,7 @@
 
 	err = paranoid_check_vid_hdr(ubi, pnum, vid_hdr);
 	if (err)
-		return -EINVAL;
+		return err;
 
 	p = (char *)vid_hdr - ubi->vid_hdr_shift;
 	err = ubi_io_write(ubi, p, pnum, ubi->vid_hdr_aloffset,
@@ -1090,8 +1128,8 @@
  * @ubi: UBI device description object
  * @pnum: physical eraseblock number to check
  *
- * This function returns zero if the physical eraseblock is good, a positive
- * number if it is bad and a negative error code if an error occurred.
+ * This function returns zero if the physical eraseblock is good, %-EINVAL if
+ * it is bad and a negative error code if an error occurred.
  */
 static int paranoid_check_not_bad(const struct ubi_device *ubi, int pnum)
 {
@@ -1103,7 +1141,7 @@
 
 	ubi_err("paranoid check failed for PEB %d", pnum);
 	ubi_dbg_dump_stack();
-	return err;
+	return err > 0 ? -EINVAL : err;
 }
 
 /**
@@ -1113,7 +1151,7 @@
  * @ec_hdr: the erase counter header to check
  *
  * This function returns zero if the erase counter header contains valid
- * values, and %1 if not.
+ * values, and %-EINVAL if not.
  */
 static int paranoid_check_ec_hdr(const struct ubi_device *ubi, int pnum,
 				 const struct ubi_ec_hdr *ec_hdr)
@@ -1139,7 +1177,7 @@
 fail:
 	ubi_dbg_dump_ec_hdr(ec_hdr);
 	ubi_dbg_dump_stack();
-	return 1;
+	return -EINVAL;
 }
 
 /**
@@ -1147,8 +1185,8 @@
  * @ubi: UBI device description object
  * @pnum: the physical eraseblock number to check
  *
- * This function returns zero if the erase counter header is all right, %1 if
- * not, and a negative error code if an error occurred.
+ * This function returns zero if the erase counter header is all right and and
+ * a negative error code if not or if an error occurred.
  */
 static int paranoid_check_peb_ec_hdr(const struct ubi_device *ubi, int pnum)
 {
@@ -1171,7 +1209,7 @@
 		ubi_err("paranoid check failed for PEB %d", pnum);
 		ubi_dbg_dump_ec_hdr(ec_hdr);
 		ubi_dbg_dump_stack();
-		err = 1;
+		err = -EINVAL;
 		goto exit;
 	}
 
@@ -1189,7 +1227,7 @@
  * @vid_hdr: the volume identifier header to check
  *
  * This function returns zero if the volume identifier header is all right, and
- * %1 if not.
+ * %-EINVAL if not.
  */
 static int paranoid_check_vid_hdr(const struct ubi_device *ubi, int pnum,
 				  const struct ubi_vid_hdr *vid_hdr)
@@ -1216,7 +1254,7 @@
 	ubi_err("paranoid check failed for PEB %d", pnum);
 	ubi_dbg_dump_vid_hdr(vid_hdr);
 	ubi_dbg_dump_stack();
-	return 1;
+	return -EINVAL;
 
 }
 
@@ -1226,7 +1264,7 @@
  * @pnum: the physical eraseblock number to check
  *
  * This function returns zero if the volume identifier header is all right,
- * %1 if not, and a negative error code if an error occurred.
+ * and a negative error code if not or if an error occurred.
  */
 static int paranoid_check_peb_vid_hdr(const struct ubi_device *ubi, int pnum)
 {
@@ -1253,7 +1291,7 @@
 		ubi_err("paranoid check failed for PEB %d", pnum);
 		ubi_dbg_dump_vid_hdr(vid_hdr);
 		ubi_dbg_dump_stack();
-		err = 1;
+		err = -EINVAL;
 		goto exit;
 	}
 
@@ -1265,6 +1303,61 @@
 }
 
 /**
+ * ubi_dbg_check_write - make sure write succeeded.
+ * @ubi: UBI device description object
+ * @buf: buffer with data which were written
+ * @pnum: physical eraseblock number the data were written to
+ * @offset: offset within the physical eraseblock the data were written to
+ * @len: how many bytes were written
+ *
+ * This functions reads data which were recently written and compares it with
+ * the original data buffer - the data have to match. Returns zero if the data
+ * match and a negative error code if not or in case of failure.
+ */
+int ubi_dbg_check_write(struct ubi_device *ubi, const void *buf, int pnum,
+			int offset, int len)
+{
+	int err, i;
+
+	mutex_lock(&ubi->dbg_buf_mutex);
+	err = ubi_io_read(ubi, ubi->dbg_peb_buf, pnum, offset, len);
+	if (err)
+		goto out_unlock;
+
+	for (i = 0; i < len; i++) {
+		uint8_t c = ((uint8_t *)buf)[i];
+		uint8_t c1 = ((uint8_t *)ubi->dbg_peb_buf)[i];
+		int dump_len;
+
+		if (c == c1)
+			continue;
+
+		ubi_err("paranoid check failed for PEB %d:%d, len %d",
+			pnum, offset, len);
+		ubi_msg("data differ at position %d", i);
+		dump_len = max_t(int, 128, len - i);
+		ubi_msg("hex dump of the original buffer from %d to %d",
+			i, i + dump_len);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+			       buf + i, dump_len, 1);
+		ubi_msg("hex dump of the read buffer from %d to %d",
+			i, i + dump_len);
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
+			       ubi->dbg_peb_buf + i, dump_len, 1);
+		ubi_dbg_dump_stack();
+		err = -EINVAL;
+		goto out_unlock;
+	}
+	mutex_unlock(&ubi->dbg_buf_mutex);
+
+	return 0;
+
+out_unlock:
+	mutex_unlock(&ubi->dbg_buf_mutex);
+	return err;
+}
+
+/**
  * ubi_dbg_check_all_ff - check that a region of flash is empty.
  * @ubi: UBI device description object
  * @pnum: the physical eraseblock number to check
@@ -1272,8 +1365,8 @@
  * @len: the length of the region to check
  *
  * This function returns zero if only 0xFF bytes are present at offset
- * @offset of the physical eraseblock @pnum, %1 if not, and a negative error
- * code if an error occurred.
+ * @offset of the physical eraseblock @pnum, and a negative error code if not
+ * or if an error occurred.
  */
 int ubi_dbg_check_all_ff(struct ubi_device *ubi, int pnum, int offset, int len)
 {
@@ -1304,7 +1397,7 @@
 	ubi_msg("hex dump of the %d-%d region", offset, offset + len);
 	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 32, 1,
 		       ubi->dbg_peb_buf, len, 1);
-	err = 1;
+	err = -EINVAL;
 error:
 	ubi_dbg_dump_stack();
 	mutex_unlock(&ubi->dbg_buf_mutex);
diff -ruaN linux-2.6.31/drivers/mtd/ubi/kapi.c linux-2.6/drivers/mtd/ubi/kapi.c
--- linux-2.6.31/drivers/mtd/ubi/kapi.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/kapi.c	2011-01-04 14:54:25.000000000 -0800
@@ -22,6 +22,8 @@
 
 #include <linux/module.h>
 #include <linux/err.h>
+#include <linux/namei.h>
+#include <linux/fs.h>
 #include <asm/div64.h>
 #include "ubi.h"
 
@@ -280,6 +282,43 @@
 EXPORT_SYMBOL_GPL(ubi_open_volume_nm);
 
 /**
+ * ubi_open_volume_path - open UBI volume by its character device node path.
+ * @pathname: volume character device node path
+ * @mode: open mode
+ *
+ * This function is similar to 'ubi_open_volume()', but opens a volume the path
+ * to its character device node.
+ */
+struct ubi_volume_desc *ubi_open_volume_path(const char *pathname, int mode)
+{
+	int error, ubi_num, vol_id, mod;
+	struct inode *inode;
+	struct path path;
+
+	dbg_gen("open volume %s, mode %d", pathname, mode);
+
+	if (!pathname || !*pathname)
+		return ERR_PTR(-EINVAL);
+
+	error = kern_path(pathname, LOOKUP_FOLLOW, &path);
+	if (error)
+		return ERR_PTR(error);
+
+	inode = path.dentry->d_inode;
+	mod = inode->i_mode;
+	ubi_num = ubi_major2num(imajor(inode));
+	vol_id = iminor(inode) - 1;
+	path_put(&path);
+
+	if (!S_ISCHR(mod))
+		return ERR_PTR(-EINVAL);
+	if (vol_id >= 0 && ubi_num >= 0)
+		return ubi_open_volume(ubi_num, vol_id, mode);
+	return ERR_PTR(-ENODEV);
+}
+EXPORT_SYMBOL_GPL(ubi_open_volume_path);
+
+/**
  * ubi_close_volume - close UBI volume.
  * @desc: volume descriptor
  */
@@ -448,7 +487,7 @@
  *
  * This function changes the contents of a logical eraseblock atomically. @buf
  * has to contain new logical eraseblock data, and @len - the length of the
- * data, which has to be aligned. The length may be shorter then the logical
+ * data, which has to be aligned. The length may be shorter than the logical
  * eraseblock size, ant the logical eraseblock may be appended to more times
  * later on. This function guarantees that in case of an unclean reboot the old
  * contents is preserved. Returns zero in case of success and a negative error
@@ -531,7 +570,7 @@
  *
  * This function un-maps logical eraseblock @lnum and schedules the
  * corresponding physical eraseblock for erasure, so that it will eventually be
- * physically erased in background. This operation is much faster then the
+ * physically erased in background. This operation is much faster than the
  * erase operation.
  *
  * Unlike erase, the un-map operation does not guarantee that the logical
@@ -550,7 +589,7 @@
  *
  * The main and obvious use-case of this function is when the contents of a
  * logical eraseblock has to be re-written. Then it is much more efficient to
- * first un-map it, then write new data, rather then first erase it, then write
+ * first un-map it, then write new data, rather than first erase it, then write
  * new data. Note, once new data has been written to the logical eraseblock,
  * UBI guarantees that the old contents has gone forever. In other words, if an
  * unclean reboot happens after the logical eraseblock has been un-mapped and
diff -ruaN linux-2.6.31/drivers/mtd/ubi/Kconfig linux-2.6/drivers/mtd/ubi/Kconfig
--- linux-2.6.31/drivers/mtd/ubi/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/Kconfig	2011-01-04 14:54:25.000000000 -0800
@@ -29,7 +29,7 @@
 	  The default value should be OK for SLC NAND flashes, NOR flashes and
 	  other flashes which have eraseblock life-cycle 100000 or more.
 	  However, in case of MLC NAND flashes which typically have eraseblock
-	  life-cycle less then 10000, the threshold should be lessened (e.g.,
+	  life-cycle less than 10000, the threshold should be lessened (e.g.,
 	  to 128 or 256, although it does not have to be power of 2).
 
 config MTD_UBI_BEB_RESERVE
diff -ruaN linux-2.6.31/drivers/mtd/ubi/Kconfig.debug linux-2.6/drivers/mtd/ubi/Kconfig.debug
--- linux-2.6.31/drivers/mtd/ubi/Kconfig.debug	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/Kconfig.debug	2011-01-04 14:54:25.000000000 -0800
@@ -6,7 +6,7 @@
 	depends on SYSFS
 	depends on MTD_UBI
 	select DEBUG_FS
-	select KALLSYMS_ALL
+	select KALLSYMS_ALL if KALLSYMS && DEBUG_KERNEL
 	help
 	  This option enables UBI debugging.
 
diff -ruaN linux-2.6.31/drivers/mtd/ubi/scan.c linux-2.6/drivers/mtd/ubi/scan.c
--- linux-2.6.31/drivers/mtd/ubi/scan.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/scan.c	2011-01-04 14:54:25.000000000 -0800
@@ -43,6 +43,7 @@
 #include <linux/err.h>
 #include <linux/crc32.h>
 #include <linux/math64.h>
+#include <linux/random.h>
 #include "ubi.h"
 
 #ifdef CONFIG_MTD_UBI_DEBUG_PARANOID
@@ -71,15 +72,19 @@
 {
 	struct ubi_scan_leb *seb;
 
-	if (list == &si->free)
+	if (list == &si->free) {
 		dbg_bld("add to free: PEB %d, EC %d", pnum, ec);
-	else if (list == &si->erase)
+		si->free_peb_count += 1;
+	} else if (list == &si->erase) {
 		dbg_bld("add to erase: PEB %d, EC %d", pnum, ec);
-	else if (list == &si->corr)
+		si->erase_peb_count += 1;
+	} else if (list == &si->corr) {
 		dbg_bld("add to corrupted: PEB %d, EC %d", pnum, ec);
-	else if (list == &si->alien)
+		si->corr_peb_count += 1;
+	} else if (list == &si->alien) {
 		dbg_bld("add to alien: PEB %d, EC %d", pnum, ec);
-	else
+		si->alien_peb_count += 1;
+	} else
 		BUG();
 
 	seb = kmalloc(sizeof(struct ubi_scan_leb), GFP_KERNEL);
@@ -229,7 +234,7 @@
  * case of success this function returns a positive value, in case of failure, a
  * negative error code is returned. The success return codes use the following
  * bits:
- *     o bit 0 is cleared: the first PEB (described by @seb) is newer then the
+ *     o bit 0 is cleared: the first PEB (described by @seb) is newer than the
  *       second PEB (described by @pnum and @vid_hdr);
  *     o bit 0 is set: the second PEB is newer;
  *     o bit 1 is cleared: no bit-flips were detected in the newer LEB;
@@ -450,7 +455,7 @@
 
 		if (cmp_res & 1) {
 			/*
-			 * This logical eraseblock is newer then the one
+			 * This logical eraseblock is newer than the one
 			 * found earlier.
 			 */
 			err = validate_vid_hdr(vid_hdr, sv, pnum);
@@ -515,6 +520,7 @@
 	sv->leb_count += 1;
 	rb_link_node(&seb->u.rb, parent, p);
 	rb_insert_color(&seb->u.rb, &sv->root);
+	si->used_peb_count += 1;
 	return 0;
 }
 
@@ -743,19 +749,17 @@
 		bitflips = 1;
 	else if (err == UBI_IO_PEB_EMPTY)
 		return add_to_list(si, pnum, UBI_SCAN_UNKNOWN_EC, &si->erase);
-	else if (err == UBI_IO_BAD_EC_HDR) {
+	else if (err == UBI_IO_BAD_HDR_READ || err == UBI_IO_BAD_HDR) {
 		/*
 		 * We have to also look at the VID header, possibly it is not
 		 * corrupted. Set %bitflips flag in order to make this PEB be
 		 * moved and EC be re-created.
 		 */
-		ec_corr = 1;
+		ec_corr = err;
 		ec = UBI_SCAN_UNKNOWN_EC;
 		bitflips = 1;
 	}
 
-	si->is_empty = 0;
-
 	if (!ec_corr) {
 		int image_seq;
 
@@ -793,16 +797,15 @@
 		 * number.
 		 */
 		image_seq = be32_to_cpu(ech->image_seq);
-		if (!si->image_seq_set) {
+		if (!ubi->image_seq && image_seq)
 			ubi->image_seq = image_seq;
-			si->image_seq_set = 1;
-		} else if (ubi->image_seq && ubi->image_seq != image_seq) {
+		if (ubi->image_seq && image_seq &&
+		    ubi->image_seq != image_seq) {
 			ubi_err("bad image sequence number %d in PEB %d, "
 				"expected %d", image_seq, pnum, ubi->image_seq);
 			ubi_dbg_dump_ec_hdr(ech);
 			return -EINVAL;
 		}
-
 	}
 
 	/* OK, we've done with the EC header, let's look at the VID header */
@@ -812,9 +815,12 @@
 		return err;
 	else if (err == UBI_IO_BITFLIPS)
 		bitflips = 1;
-	else if (err == UBI_IO_BAD_VID_HDR ||
+	else if (err == UBI_IO_BAD_HDR_READ || err == UBI_IO_BAD_HDR ||
 		 (err == UBI_IO_PEB_FREE && ec_corr)) {
 		/* VID header is corrupted */
+		if (err == UBI_IO_BAD_HDR_READ ||
+		    ec_corr == UBI_IO_BAD_HDR_READ)
+			si->read_err_count += 1;
 		err = add_to_list(si, pnum, ec, &si->corr);
 		if (err)
 			return err;
@@ -835,11 +841,11 @@
 		switch (vidh->compat) {
 		case UBI_COMPAT_DELETE:
 			ubi_msg("\"delete\" compatible internal volume %d:%d"
-				" found, remove it", vol_id, lnum);
-			err = add_to_list(si, pnum, ec, &si->corr);
+				" found, will remove it", vol_id, lnum);
+			err = add_to_list(si, pnum, ec, &si->erase);
 			if (err)
 				return err;
-			break;
+			return 0;
 
 		case UBI_COMPAT_RO:
 			ubi_msg("read-only compatible internal volume %d:%d"
@@ -854,7 +860,6 @@
 			err = add_to_list(si, pnum, ec, &si->alien);
 			if (err)
 				return err;
-			si->alien_peb_count += 1;
 			return 0;
 
 		case UBI_COMPAT_REJECT:
@@ -864,7 +869,9 @@
 		}
 	}
 
-	/* Both UBI headers seem to be fine */
+	if (ec_corr)
+		ubi_warn("valid VID header but corrupted EC header at PEB %d",
+			 pnum);
 	err = ubi_scan_add_used(ubi, si, pnum, ec, vidh, bitflips);
 	if (err)
 		return err;
@@ -883,6 +890,85 @@
 }
 
 /**
+ * check_what_we_have - check what PEB were found by scanning.
+ * @ubi: UBI device description object
+ * @si: scanning information
+ *
+ * This is a helper function which takes a look what PEBs were found by
+ * scanning, and decides whether the flash is empty and should be formatted and
+ * whether there are too many corrupted PEBs and we should not attach this
+ * MTD device. Returns zero if we should proceed with attaching the MTD device,
+ * and %-EINVAL if we should not.
+ */
+static int check_what_we_have(struct ubi_device *ubi, struct ubi_scan_info *si)
+{
+	struct ubi_scan_leb *seb;
+	int max_corr;
+
+	max_corr = ubi->peb_count - si->bad_peb_count - si->alien_peb_count;
+	max_corr = max_corr / 20 ?: 8;
+
+	/*
+	 * Few corrupted PEBs are not a problem and may be just a result of
+	 * unclean reboots. However, many of them may indicate some problems
+	 * with the flash HW or driver.
+	 */
+	if (si->corr_peb_count >= 8) {
+		ubi_warn("%d PEBs are corrupted", si->corr_peb_count);
+		printk(KERN_WARNING "corrupted PEBs are:");
+		list_for_each_entry(seb, &si->corr, u.list)
+			printk(KERN_CONT " %d", seb->pnum);
+		printk(KERN_CONT "\n");
+
+		/*
+		 * If too many PEBs are corrupted, we refuse attaching,
+		 * otherwise, only print a warning.
+		 */
+		if (si->corr_peb_count >= max_corr) {
+			ubi_err("too many corrupted PEBs, refusing this device");
+			return -EINVAL;
+		}
+	}
+
+	if (si->free_peb_count + si->used_peb_count +
+	    si->alien_peb_count == 0) {
+		/* No UBI-formatted eraseblocks were found */
+		if (si->corr_peb_count == si->read_err_count &&
+		    si->corr_peb_count < 8) {
+			/* No or just few corrupted PEBs, and all of them had a
+			 * read error. We assume that those are bad PEBs, which
+			 * were just not marked as bad so far.
+			 *
+			 * This piece of code basically tries to distinguish
+			 * between the following 2 situations:
+			 *
+			 * 1. Flash is empty, but there are few bad PEBs, which
+			 *    are not marked as bad so far, and which were read
+			 *    with error. We want to go ahead and format this
+			 *    flash. While formating, the faulty PEBs will
+			 *    probably be marked as bad.
+			 *
+			 * 2. Flash probably contains non-UBI data and we do
+			 * not want to format it and destroy possibly needed
+			 * data (e.g., consider the case when the bootloader
+			 * MTD partition was accidentally fed to UBI).
+			 */
+			si->is_empty = 1;
+			ubi_msg("empty MTD device detected");
+			get_random_bytes(&ubi->image_seq, sizeof(ubi->image_seq));
+		} else {
+			ubi_err("MTD device possibly contains non-UBI data, "
+				"refusing it");
+			return -EINVAL;
+		}
+	}
+
+	if (si->corr_peb_count > 0)
+		ubi_msg("corrupted PEBs will be formatted");
+	return 0;
+}
+
+/**
  * ubi_scan - scan an MTD device.
  * @ubi: UBI device description object
  *
@@ -906,7 +992,6 @@
 	INIT_LIST_HEAD(&si->erase);
 	INIT_LIST_HEAD(&si->alien);
 	si->volumes = RB_ROOT;
-	si->is_empty = 1;
 
 	err = -ENOMEM;
 	ech = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);
@@ -932,8 +1017,9 @@
 	if (si->ec_count)
 		si->mean_ec = div_u64(si->ec_sum, si->ec_count);
 
-	if (si->is_empty)
-		ubi_msg("empty MTD device detected");
+	err = check_what_we_have(ubi, si);
+	if (err)
+		goto out_vidh;
 
 	/*
 	 * In case of unknown erase counter we use the mean erase counter
@@ -959,11 +1045,8 @@
 			seb->ec = si->mean_ec;
 
 	err = paranoid_check_si(ubi, si);
-	if (err) {
-		if (err > 0)
-			err = -EINVAL;
+	if (err)
 		goto out_vidh;
-	}
 
 	ubi_free_vid_hdr(ubi, vidh);
 	kfree(ech);
@@ -1071,8 +1154,8 @@
  * @ubi: UBI device description object
  * @si: scanning information
  *
- * This function returns zero if the scanning information is all right, %1 if
- * not and a negative error code if an error occurred.
+ * This function returns zero if the scanning information is all right, and a
+ * negative error code if not or if an error occurred.
  */
 static int paranoid_check_si(struct ubi_device *ubi, struct ubi_scan_info *si)
 {
@@ -1331,7 +1414,7 @@
 
 out:
 	ubi_dbg_dump_stack();
-	return 1;
+	return -EINVAL;
 }
 
 #endif /* CONFIG_MTD_UBI_DEBUG_PARANOID */
diff -ruaN linux-2.6.31/drivers/mtd/ubi/scan.h linux-2.6/drivers/mtd/ubi/scan.h
--- linux-2.6.31/drivers/mtd/ubi/scan.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/scan.h	2011-01-04 14:54:25.000000000 -0800
@@ -91,10 +91,16 @@
  * @erase: list of physical eraseblocks which have to be erased
  * @alien: list of physical eraseblocks which should not be used by UBI (e.g.,
  *         those belonging to "preserve"-compatible internal volumes)
+ * @used_peb_count: count of used PEBs
+ * @corr_peb_count: count of PEBs in the @corr list
+ * @read_err_count: count of PEBs read with error (%UBI_IO_BAD_HDR_READ was
+ *                  returned)
+ * @free_peb_count: count of PEBs in the @free list
+ * @erase_peb_count: count of PEBs in the @erase list
+ * @alien_peb_count: count of PEBs in the @alien list
  * @bad_peb_count: count of bad physical eraseblocks
  * @vols_found: number of volumes found during scanning
  * @highest_vol_id: highest volume ID
- * @alien_peb_count: count of physical eraseblocks in the @alien list
  * @is_empty: flag indicating whether the MTD device is empty or not
  * @min_ec: lowest erase counter value
  * @max_ec: highest erase counter value
@@ -102,7 +108,6 @@
  * @mean_ec: mean erase counter value
  * @ec_sum: a temporary variable used when calculating @mean_ec
  * @ec_count: a temporary variable used when calculating @mean_ec
- * @image_seq_set: indicates @ubi->image_seq is known
  *
  * This data structure contains the result of scanning and may be used by other
  * UBI sub-systems to build final UBI data structures, further error-recovery
@@ -114,10 +119,15 @@
 	struct list_head free;
 	struct list_head erase;
 	struct list_head alien;
+	int used_peb_count;
+	int corr_peb_count;
+	int read_err_count;
+	int free_peb_count;
+	int erase_peb_count;
+	int alien_peb_count;
 	int bad_peb_count;
 	int vols_found;
 	int highest_vol_id;
-	int alien_peb_count;
 	int is_empty;
 	int min_ec;
 	int max_ec;
@@ -125,7 +135,6 @@
 	int mean_ec;
 	uint64_t ec_sum;
 	int ec_count;
-	int image_seq_set;
 };
 
 struct ubi_device;
@@ -135,7 +144,7 @@
  * ubi_scan_move_to_list - move a PEB from the volume tree to a list.
  *
  * @sv: volume scanning information
- * @seb: scanning eraseblock infprmation
+ * @seb: scanning eraseblock information
  * @list: the list to move to
  */
 static inline void ubi_scan_move_to_list(struct ubi_scan_volume *sv,
diff -ruaN linux-2.6.31/drivers/mtd/ubi/ubiblock.c linux-2.6/drivers/mtd/ubi/ubiblock.c
--- linux-2.6.31/drivers/mtd/ubi/ubiblock.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/mtd/ubi/ubiblock.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,287 @@
+/*
+ * Sample disk driver, from the beginning.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>	/* printk() */
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/fs.h>		/* everything... */
+#include <linux/errno.h>	/* error codes */
+#include <linux/types.h>	/* size_t */
+#include <linux/fcntl.h>	/* O_ACCMODE */
+#include <linux/hdreg.h>	/* HDIO_GETGEO */
+#include <linux/kdev_t.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/buffer_head.h>	/* invalidate_bdev */
+#include <linux/bio.h>
+#include <linux/mtd/ubi.h>
+#include <linux/err.h>
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+static int ubiblk_major = 61;
+module_param(ubiblk_major, int, 0);
+static int nsectors = 1024;	/* How big the drive is */
+module_param(nsectors, int, 0);
+static int ndevices = 1;
+module_param(ndevices, int, 0);
+
+/*
+ * Minor number and partition management.
+ */
+#define UBIBLK_MINORS	16
+#define MINOR_SHIFT	4
+#define DEVNUM(kdevnum)	(MINOR(kdev_t_to_nr(kdevnum)) >> MINOR_SHIFT
+
+/*
+ * We can tweak our hardware sector size, but the kernel talks to us
+ * in terms of small sectors, always.
+ */
+#define KERNEL_SECTOR_SIZE	512
+
+/*
+ * The internal representation of our device.
+ */
+struct ubiblk_dev {
+        int size; /* Device size in sectors */
+        spinlock_t lock;
+        struct request_queue *queue; /* The device request queue */
+        struct gendisk *gd;
+	struct ubi_device_info ubi_dev;
+	int hardsect_size;
+	struct ubi_volume_desc *ubi_vol;
+};
+
+static struct ubiblk_dev *Devices = NULL;
+
+/*
+ * Handle an I/O request.
+ */
+static void ubiblk_transfer(struct ubiblk_dev *dev, unsigned long sector,
+		unsigned long nsect, char *buffer, int write)
+{
+	unsigned long offset = sector*KERNEL_SECTOR_SIZE;
+	unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;
+
+	if((offset + nbytes) > dev->size) {
+		printk(KERN_NOTICE "Beyond-end write\n");
+		return;
+	}
+
+	printk("%s some data.\n", write?"wrote":"read");
+}
+
+/*
+ * The simple form of the request function.
+ */
+static void ubiblk_request(request_queue_t *q)
+{
+	struct request *req;
+
+	while ((req = elv_next_request(q)) != NULL) {
+		struct ubiblk_dev *dev = req->rq_disk->private_data;
+		if(! blk_fs_request(req)) {
+			printk (KERN_NOTICE "Skip non-fs request\n");
+			end_request(req, 0);
+			continue;
+		}
+		ubiblk_transfer(dev, req->sector, req->current_nr_sectors,
+				req->buffer, rq_data_dir(req));
+		end_request(req, 1);
+	}
+}
+
+static int ubiblk_open(struct inode *inode, struct file *filp)
+{
+	struct ubiblk_dev *dev = inode->i_bdev->bd_disk->private_data;
+
+	filp->private_data = dev;
+	return 0;
+}
+
+static int ubiblk_release(struct inode *inode, struct file *filp)
+{
+	struct ubiblk_dev *dev = inode->i_bdev->bd_disk->private_data;
+
+	return 0;
+}
+
+int ubiblk_ioctl (struct inode *inode, struct file *filp,
+                 unsigned int cmd, unsigned long arg)
+{
+	long size;
+	struct hd_geometry geo;
+	struct ubiblk_dev *dev = filp->private_data;
+
+	switch(cmd) {
+	case HDIO_GETGEO:
+        	/*
+		 * Get geometry: since we are a virtual device, we have to make
+		 * up something plausible.  So we claim 16 sectors, four heads,
+		 * and calculate the corresponding number of cylinders.  We set the
+		 * start of data at sector four.
+		 */
+		size = dev->size*(dev->hardsect_size/KERNEL_SECTOR_SIZE);
+		geo.cylinders = (size & ~0x3f) >> 6;
+		geo.heads = 4;
+		geo.sectors = 16;
+		geo.start = 4;
+		printk("Responding with geometry c/h/s %d/%d/%d\n",
+		       geo.cylinders, geo.heads, geo.sectors);
+		if (copy_to_user((void __user *) arg, &geo, sizeof(geo)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return -ENOTTY; /* unknown command */
+}
+
+static int ubiblk_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+{
+	struct ubiblk_dev *dev = bdev->bd_disk->private_data;
+	long size;
+
+	size = dev->size*(dev->hardsect_size/KERNEL_SECTOR_SIZE);
+	geo->cylinders = (size & ~0x3f) >> 6;
+	geo->heads = 4;
+	geo->sectors = 16;
+	geo->start = 4;
+	printk("Responding with geometry c/h/s %d/%d/%d\n",
+	       geo->cylinders, geo->heads, geo->sectors);
+	
+	return 0;
+}
+
+
+/*
+ * The device operations structure.
+ */
+static struct block_device_operations ubiblk_ops = {
+	.owner           = THIS_MODULE,
+	.open 	         = ubiblk_open,
+	.release 	 = ubiblk_release,
+	.ioctl	         = ubiblk_ioctl,
+	.getgeo	         = ubiblk_getgeo,
+};
+
+
+/*
+ * Set up our internal device.
+ */
+static void setup_device(struct ubiblk_dev *dev, int which)
+{
+	memset (dev, 0, sizeof (struct ubiblk_dev));
+
+	spin_lock_init(&dev->lock);
+
+	/* get each ubi device that we're working with.  Each mtd device claimed
+	 * by the ubi layer is a device.  Note that this can be a chip or a
+	 * partition.
+	 */
+	if(ubi_get_device_info(which, &dev->ubi_dev)) {
+		printk("ubiblk: Failed to get device info for ubi%d\n", which);
+		goto out_vfree;
+	}
+
+	/* each ubi device is either empty, corrupted, or contains some number
+	 * of volumes.  For now, I'm assuming that there's exactly one volume,
+	 * and it's volume id is 0.  This is a bit inapproriate, because ubi
+	 * volumes are supposed to be like partitions.  The proper solution
+	 * would be to allow the ubi userspace tools to create partitions much
+	 * like fdisk would.
+	 */
+
+	dev->ubi_vol = ubi_open_volume(which, 0, UBI_READWRITE);
+	if(IS_ERR(dev->ubi_vol)) {
+		printk("Failed to open ubi volume 0 on device %d\n", which);
+		dev->ubi_vol = 0;
+		goto out_vfree;
+	}
+
+	dev->hardsect_size = dev->ubi_dev.min_io_size;
+	dev->size = nsectors*dev->hardsect_size;
+
+	/* setup blk dev queuing */
+	dev->queue = blk_init_queue(ubiblk_request, &dev->lock);
+	if (dev->queue == NULL)
+		goto out_vfree;
+
+	blk_queue_hardsect_size(dev->queue, dev->hardsect_size);
+	dev->queue->queuedata = dev;
+
+	/* setup gendisk structure */
+	dev->gd = alloc_disk(UBIBLK_MINORS);
+	if (! dev->gd) {
+		printk (KERN_NOTICE "alloc_disk failure\n");
+		goto out_vfree;
+	}
+	dev->gd->major = ubiblk_major;
+	dev->gd->first_minor = which*UBIBLK_MINORS;
+	dev->gd->fops = &ubiblk_ops;
+	dev->gd->queue = dev->queue;
+	dev->gd->private_data = dev;
+	snprintf (dev->gd->disk_name, 32, "ubiblk%c", which + 'a');
+	set_capacity(dev->gd, nsectors*(dev->hardsect_size/KERNEL_SECTOR_SIZE));
+	add_disk(dev->gd);
+	return;
+
+  out_vfree:
+	if (dev->queue)
+		blk_cleanup_queue(dev->queue);
+}
+
+
+
+static int __init ubiblk_init(void)
+{
+	int i, ret;
+
+	ret = register_blkdev(ubiblk_major, "ubiblk");
+	if (ret) {
+		printk(KERN_WARNING "ubiblk: unable to get major number\n");
+		return -EBUSY;
+	}
+
+	Devices = kmalloc(ndevices*sizeof (struct ubiblk_dev), GFP_KERNEL);
+	if (Devices == NULL)
+		goto out_unregister;
+	for (i = 0; i < ndevices; i++) 
+		setup_device(Devices + i, i);
+    
+	return 0;
+
+ out_unregister:
+	unregister_blkdev(ubiblk_major, "ubiblk");
+	return -ENOMEM;
+}
+
+static void ubiblk_exit(void)
+{
+	int i;
+
+	for (i = 0; i < ndevices; i++) {
+		struct ubiblk_dev *dev = Devices + i;
+		
+		if (dev->gd) {
+			del_gendisk(dev->gd);
+			put_disk(dev->gd);
+		}
+		if (dev->queue) {
+			blk_cleanup_queue(dev->queue);
+		}
+		if (dev->ubi_vol) {
+			ubi_close_volume(dev->ubi_vol);
+		}
+	}
+	unregister_blkdev(ubiblk_major, "ubiblk");
+	kfree(Devices);
+}
+	
+module_init(ubiblk_init);
+module_exit(ubiblk_exit);
diff -ruaN linux-2.6.31/drivers/mtd/ubi/ubi.h linux-2.6/drivers/mtd/ubi/ubi.h
--- linux-2.6.31/drivers/mtd/ubi/ubi.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/ubi.h	2011-01-04 14:54:25.000000000 -0800
@@ -88,16 +88,16 @@
  *                   %0xFF bytes
  * UBI_IO_PEB_FREE: the physical eraseblock is free, i.e. it contains only a
  *                  valid erase counter header, and the rest are %0xFF bytes
- * UBI_IO_BAD_EC_HDR: the erase counter header is corrupted (bad magic or CRC)
- * UBI_IO_BAD_VID_HDR: the volume identifier header is corrupted (bad magic or
- *                     CRC)
+ * UBI_IO_BAD_HDR: the EC or VID header is corrupted (bad magic or CRC)
+ * UBI_IO_BAD_HDR_READ: the same as %UBI_IO_BAD_HDR, but also there was a read
+ * 			error reported by the flash driver
  * UBI_IO_BITFLIPS: bit-flips were detected and corrected
  */
 enum {
 	UBI_IO_PEB_EMPTY = 1,
 	UBI_IO_PEB_FREE,
-	UBI_IO_BAD_EC_HDR,
-	UBI_IO_BAD_VID_HDR,
+	UBI_IO_BAD_HDR,
+	UBI_IO_BAD_HDR_READ,
 	UBI_IO_BITFLIPS
 };
 
@@ -349,7 +349,6 @@
  * @bgt_thread: background thread description object
  * @thread_enabled: if the background thread is enabled
  * @bgt_name: background thread name
- * @reboot_notifier: notifier to terminate background thread before rebooting
  *
  * @flash_size: underlying MTD device size (in bytes)
  * @peb_count: count of physical eraseblocks on the MTD device
@@ -435,7 +434,6 @@
 	struct task_struct *bgt_thread;
 	int thread_enabled;
 	char bgt_name[sizeof(UBI_BGT_NAME_PATTERN)+2];
-	struct notifier_block reboot_notifier;
 
 	/* I/O sub-system's stuff */
 	long long flash_size;
@@ -579,7 +577,8 @@
 	for (rb = rb_first(root),                                            \
 	     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL);     \
 	     rb;                                                             \
-	     rb = rb_next(rb), pos = container_of(rb, typeof(*pos), member))
+	     rb = rb_next(rb),                                               \
+	     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL))
 
 /**
  * ubi_zalloc_vid_hdr - allocate a volume identifier header object.
diff -ruaN linux-2.6.31/drivers/mtd/ubi/upd.c linux-2.6/drivers/mtd/ubi/upd.c
--- linux-2.6.31/drivers/mtd/ubi/upd.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/upd.c	2011-01-04 14:54:25.000000000 -0800
@@ -147,12 +147,15 @@
 	}
 
 	if (bytes == 0) {
+		err = ubi_wl_flush(ubi);
+		if (err)
+			return err;
+
 		err = clear_update_marker(ubi, vol, 0);
 		if (err)
 			return err;
-		err = ubi_wl_flush(ubi);
-		if (!err)
-			vol->updating = 0;
+		vol->updating = 0;
+		return 0;
 	}
 
 	vol->upd_buf = vmalloc(ubi->leb_size);
@@ -362,16 +365,16 @@
 
 	ubi_assert(vol->upd_received <= vol->upd_bytes);
 	if (vol->upd_received == vol->upd_bytes) {
+		err = ubi_wl_flush(ubi);
+		if (err)
+			return err;
 		/* The update is finished, clear the update marker */
 		err = clear_update_marker(ubi, vol, vol->upd_bytes);
 		if (err)
 			return err;
-		err = ubi_wl_flush(ubi);
-		if (err == 0) {
-			vol->updating = 0;
-			err = to_write;
-			vfree(vol->upd_buf);
-		}
+		vol->updating = 0;
+		err = to_write;
+		vfree(vol->upd_buf);
 	}
 
 	return err;
diff -ruaN linux-2.6.31/drivers/mtd/ubi/vtbl.c linux-2.6/drivers/mtd/ubi/vtbl.c
--- linux-2.6.31/drivers/mtd/ubi/vtbl.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/vtbl.c	2011-01-04 14:54:25.000000000 -0800
@@ -413,7 +413,7 @@
 	 * 0 contains more recent information.
 	 *
 	 * So the plan is to first check LEB 0. Then
-	 * a. if LEB 0 is OK, it must be containing the most resent data; then
+	 * a. if LEB 0 is OK, it must be containing the most recent data; then
 	 *    we compare it with LEB 1, and if they are different, we copy LEB
 	 *    0 to LEB 1;
 	 * b. if LEB 0 is corrupted, but LEB 1 has to be OK, and we copy LEB 1
@@ -566,6 +566,7 @@
 		vol->reserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);
 		vol->alignment = be32_to_cpu(vtbl[i].alignment);
 		vol->data_pad = be32_to_cpu(vtbl[i].data_pad);
+		vol->upd_marker = vtbl[i].upd_marker;
 		vol->vol_type = vtbl[i].vol_type == UBI_VID_DYNAMIC ?
 					UBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;
 		vol->name_len = be16_to_cpu(vtbl[i].name_len);
@@ -846,7 +847,7 @@
 		goto out_free;
 
 	/*
-	 * Get sure that the scanning information is consistent to the
+	 * Make sure that the scanning information is consistent to the
 	 * information stored in the volume table.
 	 */
 	err = check_scanning_info(ubi, si);
diff -ruaN linux-2.6.31/drivers/mtd/ubi/wl.c linux-2.6/drivers/mtd/ubi/wl.c
--- linux-2.6.31/drivers/mtd/ubi/wl.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/mtd/ubi/wl.c	2011-01-04 14:54:25.000000000 -0800
@@ -350,7 +350,7 @@
  * @max: highest possible erase counter
  *
  * This function looks for a wear leveling entry with erase counter closest to
- * @max and less then @max.
+ * @max and less than @max.
  */
 static struct ubi_wl_entry *find_wl_entry(struct rb_root *root, int max)
 {
@@ -464,7 +464,7 @@
 				   ubi->peb_size - ubi->vid_hdr_aloffset);
 	if (err) {
 		ubi_err("new PEB %d does not contain all 0xFF bytes", e->pnum);
-		return err > 0 ? -EINVAL : err;
+		return err;
 	}
 
 	return e->pnum;
@@ -513,7 +513,7 @@
 	dbg_wl("erase PEB %d, old EC %llu", e->pnum, ec);
 
 	err = paranoid_check_ec(ubi, e->pnum, e->ec);
-	if (err > 0)
+	if (err)
 		return -EINVAL;
 
 	ec_hdr = kzalloc(ubi->ec_hdr_alsize, GFP_NOFS);
@@ -1212,7 +1212,8 @@
 retry:
 	spin_lock(&ubi->wl_lock);
 	e = ubi->lookuptbl[pnum];
-	if (e == ubi->move_from || in_wl_tree(e, &ubi->scrub)) {
+	if (e == ubi->move_from || in_wl_tree(e, &ubi->scrub) ||
+				   in_wl_tree(e, &ubi->erroneous)) {
 		spin_unlock(&ubi->wl_lock);
 		return 0;
 	}
@@ -1572,8 +1573,7 @@
  * @ec: the erase counter to check
  *
  * This function returns zero if the erase counter of physical eraseblock @pnum
- * is equivalent to @ec, %1 if not, and a negative error code if an error
- * occurred.
+ * is equivalent to @ec, and a negative error code if not or if an error occurred.
  */
 static int paranoid_check_ec(struct ubi_device *ubi, int pnum, int ec)
 {
@@ -1611,8 +1611,8 @@
  * @e: the wear-leveling entry to check
  * @root: the root of the tree
  *
- * This function returns zero if @e is in the @root RB-tree and %1 if it is
- * not.
+ * This function returns zero if @e is in the @root RB-tree and %-EINVAL if it
+ * is not.
  */
 static int paranoid_check_in_wl_tree(struct ubi_wl_entry *e,
 				     struct rb_root *root)
@@ -1623,7 +1623,7 @@
 	ubi_err("paranoid check failed for PEB %d, EC %d, RB-tree %p ",
 		e->pnum, e->ec, root);
 	ubi_dbg_dump_stack();
-	return 1;
+	return -EINVAL;
 }
 
 /**
@@ -1632,7 +1632,7 @@
  * @ubi: UBI device description object
  * @e: the wear-leveling entry to check
  *
- * This function returns zero if @e is in @ubi->pq and %1 if it is not.
+ * This function returns zero if @e is in @ubi->pq and %-EINVAL if it is not.
  */
 static int paranoid_check_in_pq(struct ubi_device *ubi, struct ubi_wl_entry *e)
 {
@@ -1647,6 +1647,6 @@
 	ubi_err("paranoid check failed for PEB %d, EC %d, Protect queue",
 		e->pnum, e->ec);
 	ubi_dbg_dump_stack();
-	return 1;
+	return -EINVAL;
 }
 #endif /* CONFIG_MTD_UBI_DEBUG_PARANOID */
diff -ruaN linux-2.6.31/drivers/net/cs89x0.c linux-2.6/drivers/net/cs89x0.c
--- linux-2.6.31/drivers/net/cs89x0.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/net/cs89x0.c	2011-01-04 13:50:21.000000000 -0800
@@ -154,6 +154,11 @@
 
 #include "cs89x0.h"
 
+/* IRQ on GPIO pin intead of EIRQ pin */
+#include <asm/arch/gpio.h>
+#define ETHER_GPIO_PORT		GPIO_PORT_B
+#define ETHER_GPIO_PIN		8
+
 static char version[] __initdata =
 "cs89x0.c: v2.4.3-pre1 Russell Nelson <nelson@crynwr.com>, Andrew Morton\n";
 
@@ -195,6 +200,9 @@
 	PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300, 0
 };
 static unsigned cs8900_irq_map[] = {EXPIO_INT_ENET_INT, 0, 0, 0};
+#elif defined(CONFIG_ARCH_LF1000)
+static unsigned int netcard_portlist[] __initdata = { IO_ADDRESS( LF1000_ETH_BASE), 0};
+static unsigned int cs8900_irq_map[] = {10,0,0,0};
 #else
 static unsigned int netcard_portlist[] __used __initdata =
    { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
@@ -316,10 +324,20 @@
 	int err = 0;
 	int irq;
 	int io;
+#if defined(CONFIG_ARCH_LF1000)
+	static char once = 0;	// LF1000 has only one ether limit to that
+	/* use nCS2 for chip select */
+	gpio_configure_pin(GPIO_PORT_C, 15, GPIO_ALT1, 1, 0, 0);
+#endif /* CONFIG_ARCH_LF1000 */
 
 	if (!dev)
 		return ERR_PTR(-ENODEV);
 
+#if defined(CONFIG_ARCH_LF1000)
+	if (once)
+		return ERR_PTR(-ENODEV);
+#endif
+
 	sprintf(dev->name, "eth%d", unit);
 	netdev_boot_setup_check(dev);
 	io = dev->base_addr;
@@ -343,6 +361,9 @@
 	}
 	if (err)
 		goto out;
+#if defined(CONFIG_ARCH_LF1000)
+	once = 1;
+#endif
 	return dev;
 out:
 	free_netdev(dev);
@@ -573,6 +594,30 @@
 		readreg(dev, 0);
 #endif
 
+#ifdef	CONFIG_ARCH_LF1000
+#ifdef CONFIG_MACH_ME_LF1000
+#define	LF1000_irq			13	/* GPIO pin */
+#else
+#define LF1000_irq			9	/* EIRQ pin */
+#endif
+
+#if	1
+	// set MAC to 00:01:02:03:04:05
+	for (i = 0; i < ETH_ALEN/2; i++) {
+		dev->dev_addr[i*2  ] = i*2;
+		dev->dev_addr[i*2+1] = i*2+1;
+	}
+#else
+{
+/* Borrowing it from U-Boot settings */
+unsigned char MACaddr[] = { 0x00, 0x50, 0xc2, 0x1e, 0xaf, 0xfb};
+	for (i = 0; i < ETH_ALEN/2; i++) {
+		dev->dev_addr[i*2  ] = MACaddr[i*2];
+		dev->dev_addr[i*2+1] = MACaddr[i*2+1];
+	}
+}
+#endif
+#endif
 	/* Grab the region so we can find another board if autoIRQ fails. */
 	/* WTF is going on here? */
 	if (!request_region(ioaddr & ~3, NETCARD_IO_EXTENT, DRV_NAME)) {
@@ -1292,7 +1337,15 @@
 
 		for (i = 2; i < CS8920_NO_INTS; i++) {
 			if ((1 << i) & lp->irq_map) {
+#ifndef	CONFIG_ARCH_LF1000
 				if (request_irq(i, net_interrupt, 0, dev->name, dev) == 0) {
+#else
+				#ifdef CONFIG_MACH_ME_LF1000 /* on GPIO */
+				if (gpio_request_normal_irq(ETHER_GPIO_PORT, ETHER_GPIO_PIN, net_interrupt, dev) == 0) {
+				#else /* on EIRQ */
+				if (request_irq( LF1000_irq, net_interrupt, SA_INTERRUPT, dev->name, dev) == 0) {
+				#endif
+#endif
 					dev->irq = i;
 					write_irq(dev, lp->chip_type, i);
 					/* writereg(dev, PP_BufCFG, GENERATE_SW_INTERRUPT); */
@@ -1326,10 +1379,22 @@
 		writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);
 #endif
 		write_irq(dev, lp->chip_type, dev->irq);
+#ifndef	CONFIG_ARCH_LF1000
 		ret = request_irq(dev->irq, &net_interrupt, 0, dev->name, dev);
+#else
+		#ifdef CONFIG_MACH_ME_LF1000 /* on GPIO pin */
+		ret = gpio_request_normal_irq(ETHER_GPIO_PORT, ETHER_GPIO_PIN, net_interrupt, dev);
+		#else /* on EIRQ pin */
+		ret = request_irq( LF1000_irq, &net_interrupt, SA_INTERRUPT, dev->name, dev);
+		#endif
+#endif
 		if (ret) {
 			if (net_debug)
+#ifndef	CONFIG_ARCH_LF1000
 				printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
+#else
+				printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", LF1000_irq);
+#endif
 			goto bad_out;
 		}
 	}
@@ -1408,7 +1473,11 @@
 		release_dma_buff(lp);
 #endif
                 writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));
+#ifndef	CONFIG_ARCH_LF1000
                 free_irq(dev->irq, dev);
+#else
+                free_irq( LF1000_irq, dev);
+#endif
 		ret = -EAGAIN;
 		goto bad_out;
 	}
@@ -1416,12 +1485,16 @@
         /* set the hardware to the configured choice */
 	switch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {
 	case A_CNF_MEDIA_10B_T:
+#ifndef	CONFIG_ARCH_LF1000
                 result = detect_tp(dev);
                 if (result==DETECTED_NONE) {
                         printk(KERN_WARNING "%s: 10Base-T (RJ-45) has no cable\n", dev->name);
                         if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
                                 result = DETECTED_RJ45H; /* Yes! I don't care if I see a link pulse */
                 }
+#else
+		result = DETECTED_RJ45H;
+#endif
 		break;
 	case A_CNF_MEDIA_AUI:
                 result = detect_aui(dev);
@@ -1504,6 +1577,13 @@
 #endif
                  );
         netif_start_queue(dev);
+#ifdef CONFIG_MACH_ME_LF1000
+        gpio_set_fn(ETHER_GPIO_PORT, ETHER_GPIO_PIN, 0);
+        gpio_set_pu(ETHER_GPIO_PORT, ETHER_GPIO_PIN, false);
+        gpio_set_int_mode(ETHER_GPIO_PORT, ETHER_GPIO_PIN, 
+			GPIO_IMODE_HIGH_LEVEL);
+	gpio_set_int(ETHER_GPIO_PORT, ETHER_GPIO_PIN, true);
+#endif
 	if (net_debug > 1)
 		printk("cs89x0: net_open() succeeded\n");
 	return 0;
@@ -1664,6 +1744,12 @@
 			break;
 		}
 	}
+#if defined (CONFIG_MACH_ME_LF1000)
+	gpio_set_int_mode(ETHER_GPIO_PORT, ETHER_GPIO_PIN, 
+			GPIO_IMODE_HIGH_LEVEL);
+	gpio_set_int(ETHER_GPIO_PORT, ETHER_GPIO_PIN, true);
+	gpio_clear_pend(ETHER_GPIO_PORT, ETHER_GPIO_PIN);
+#endif
 	return IRQ_RETVAL(handled);
 }
 
diff -ruaN linux-2.6.31/drivers/net/wireless/libertas/if_spi.c linux-2.6/drivers/net/wireless/libertas/if_spi.c
--- linux-2.6.31/drivers/net/wireless/libertas/if_spi.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/net/wireless/libertas/if_spi.c	2011-01-04 13:50:21.000000000 -0800
@@ -19,6 +19,7 @@
 
 #include <linux/moduleparam.h>
 #include <linux/firmware.h>
+#include <linux/gpio.h>
 #include <linux/jiffies.h>
 #include <linux/kthread.h>
 #include <linux/list.h>
@@ -32,6 +33,13 @@
 #include "dev.h"
 #include "if_spi.h"
 
+#if defined CONFIG_ARCH_LF1000
+#include <mach/gpio.h>
+#include <mach/gpio_map.h>
+#endif
+
+#define FIRMWARE_NAME_MAX 30
+
 struct if_spi_packet {
 	struct list_head		list;
 	u16				blen;
@@ -43,13 +51,20 @@
 	struct lbs_private		*priv;
 	struct libertas_spi_platform_data *pdata;
 
-	char				helper_fw_name[IF_SPI_FW_NAME_MAX];
-	char				main_fw_name[IF_SPI_FW_NAME_MAX];
+	char				helper_fw_name[FIRMWARE_NAME_MAX];
+	char				main_fw_name[FIRMWARE_NAME_MAX];
 
 	/* The card ID and card revision, as reported by the hardware. */
 	u16				card_id;
 	u8				card_rev;
 
+	/* Pin number for our GPIO chip-select. */
+	/* TODO: Once the generic SPI layer has some additional features, we
+	 * should take this out and use the normal chip select here.
+	 * We need support for chip select delays, and not dropping chipselect
+	 * after each word. */
+	int				gpio_cs;
+
 	/* The last time that we initiated an SPU operation */
 	unsigned long			prev_xfer_time;
 
@@ -77,6 +92,67 @@
 	spinlock_t			buffer_lock;
 };
 
+#if defined CONFIG_ARCH_LF1000
+static int lf1000_request_irq(unsigned int irq,
+		irq_handler_t handler,
+		unsigned long flags, const char *devname, void *dev)
+{
+	int ret;
+	enum gpio_interrupt_mode mode;
+
+	ret = gpio_request_normal_irq(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, handler, dev);
+
+	if(ret == 0)
+	{
+		switch(flags & IRQF_TRIGGER_MASK) {
+		case IRQF_TRIGGER_RISING:
+			mode = GPIO_IMODE_RISING_EDGE;
+			break;
+		case IRQF_TRIGGER_FALLING:
+			mode = GPIO_IMODE_FALLING_EDGE;
+			break;
+		case IRQF_TRIGGER_HIGH:
+			mode = GPIO_IMODE_HIGH_LEVEL;
+			break;
+		case IRQF_TRIGGER_LOW:
+			mode = GPIO_IMODE_LOW_LEVEL;
+			break;
+		}
+
+		gpio_set_fn(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, GPIO_GPIOFN);
+		gpio_set_int_mode(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN,
+		                  mode);
+		gpio_clear_pend(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN);
+		gpio_set_int(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, 1);
+	}
+
+	return ret;
+}
+
+void lf1000_free_irq(unsigned int irq, void *dev)
+{
+	gpio_free_irq(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, dev);
+}
+
+void lf1000_enable_irq(unsigned int irq)
+{
+	gpio_set_int(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, 1);
+}
+
+irqreturn_t lf1000_disable_irq(unsigned int irq)
+{
+	if(gpio_get_pend(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN))
+	{
+		gpio_set_int(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN, 0);
+		gpio_clear_pend(LIBERTAS_SPI_INTERRUPT_PORT, LIBERTAS_SPI_INTERRUPT_PIN);
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+#endif
+
 static void free_if_spi_card(struct if_spi_card *card)
 {
 	struct list_head *cursor, *next;
@@ -111,6 +187,9 @@
  * First we have to put a SPU register name on the bus. Then we can
  * either read from or write to that register.
  *
+ * For 16-bit transactions, byte order on the bus is big-endian.
+ * We don't have to worry about that here, though.
+ * The translation takes place in the SPI routines.
  */
 
 static void spu_transaction_init(struct if_spi_card *card)
@@ -122,10 +201,21 @@
 		 * If not, we have to busy-wait to be on the safe side. */
 		ndelay(400);
 	}
+
+#ifndef CONFIG_ARCH_LF1000
+	gpio_set_value(card->gpio_cs, 0); /* assert CS */
+#else
+	gpio_set_val(GPIO_PORT_B, GPIO_PIN5, 0);
+#endif
 }
 
 static void spu_transaction_finish(struct if_spi_card *card)
 {
+#ifndef CONFIG_ARCH_LF1000
+	gpio_set_value(card->gpio_cs, 1); /* drop CS */
+#else
+	gpio_set_val(GPIO_PORT_B, GPIO_PIN5, 1);
+#endif
 	card->prev_xfer_time = jiffies;
 }
 
@@ -134,14 +224,7 @@
 static int spu_write(struct if_spi_card *card, u16 reg, const u8 *buf, int len)
 {
 	int err = 0;
-	u16 reg_out = cpu_to_le16(reg | IF_SPI_WRITE_OPERATION_MASK);
-	struct spi_message m;
-	struct spi_transfer reg_trans;
-	struct spi_transfer data_trans;
-
-	spi_message_init(&m);
-	memset(&reg_trans, 0, sizeof(reg_trans));
-	memset(&data_trans, 0, sizeof(data_trans));
+	u16 reg_out = reg | IF_SPI_WRITE_OPERATION_MASK;
 
 	/* You must give an even number of bytes to the SPU, even if it
 	 * doesn't care about the last one.  */
@@ -150,26 +233,29 @@
 	spu_transaction_init(card);
 
 	/* write SPU register index */
-	reg_trans.tx_buf = &reg_out;
-	reg_trans.len = sizeof(reg_out);
-
-	data_trans.tx_buf = buf;
-	data_trans.len = len;
+	err = spi_write(card->spi, (u8 *)&reg_out, sizeof(u16));
+	if (err)
+		goto out;
 
-	spi_message_add_tail(&reg_trans, &m);
-	spi_message_add_tail(&data_trans, &m);
+	err = spi_write(card->spi, buf, len);
 
-	err = spi_sync(card->spi, &m);
+out:
 	spu_transaction_finish(card);
 	return err;
 }
 
 static inline int spu_write_u16(struct if_spi_card *card, u16 reg, u16 val)
 {
-	u16 buff;
+	return spu_write(card, reg, (u8 *)&val, sizeof(u16));
+}
 
-	buff = cpu_to_le16(val);
-	return spu_write(card, reg, (u8 *)&buff, sizeof(u16));
+static inline int spu_write_u32(struct if_spi_card *card, u16 reg, u32 val)
+{
+	/* The lower 16 bits are written first. */
+	u16 out[2];
+	out[0] = val & 0xffff;
+	out[1] = (val & 0xffff0000) >> 16;
+	return spu_write(card, reg, (u8 *)&out, sizeof(u32));
 }
 
 static inline int spu_reg_is_port_reg(u16 reg)
@@ -186,13 +272,10 @@
 
 static int spu_read(struct if_spi_card *card, u16 reg, u8 *buf, int len)
 {
-	unsigned int delay;
+	unsigned int i, delay;
 	int err = 0;
-	u16 reg_out = cpu_to_le16(reg | IF_SPI_READ_OPERATION_MASK);
-	struct spi_message m;
-	struct spi_transfer reg_trans;
-	struct spi_transfer dummy_trans;
-	struct spi_transfer data_trans;
+	u16 zero = 0;
+	u16 reg_out = reg | IF_SPI_READ_OPERATION_MASK;
 
 	/* You must take an even number of bytes from the SPU, even if you
 	 * don't care about the last one.  */
@@ -200,34 +283,29 @@
 
 	spu_transaction_init(card);
 
-	spi_message_init(&m);
-	memset(&reg_trans, 0, sizeof(reg_trans));
-	memset(&dummy_trans, 0, sizeof(dummy_trans));
-	memset(&data_trans, 0, sizeof(data_trans));
-
 	/* write SPU register index */
-	reg_trans.tx_buf = &reg_out;
-	reg_trans.len = sizeof(reg_out);
-	spi_message_add_tail(&reg_trans, &m);
+	err = spi_write(card->spi, (u8 *)&reg_out, sizeof(u16));
+	if (err)
+		goto out;
 
 	delay = spu_reg_is_port_reg(reg) ? card->spu_port_delay :
 						card->spu_reg_delay;
 	if (card->use_dummy_writes) {
 		/* Clock in dummy cycles while the SPU fills the FIFO */
-		dummy_trans.len = delay / 8;
-		spi_message_add_tail(&dummy_trans, &m);
+		for (i = 0; i < delay / 16; ++i) {
+			err = spi_write(card->spi, (u8 *)&zero, sizeof(u16));
+			if (err)
+				return err;
+		}
 	} else {
 		/* Busy-wait while the SPU fills the FIFO */
-		reg_trans.delay_usecs =
-			DIV_ROUND_UP((100 + (delay * 10)), 1000);
+		ndelay(100 + (delay * 10));
 	}
 
 	/* read in data */
-	data_trans.rx_buf = buf;
-	data_trans.len = len;
-	spi_message_add_tail(&data_trans, &m);
+	err = spi_read(card->spi, buf, len);
 
-	err = spi_sync(card->spi, &m);
+out:
 	spu_transaction_finish(card);
 	return err;
 }
@@ -235,25 +313,19 @@
 /* Read 16 bits from an SPI register */
 static inline int spu_read_u16(struct if_spi_card *card, u16 reg, u16 *val)
 {
-	u16 buf;
-	int ret;
-
-	ret = spu_read(card, reg, (u8 *)&buf, sizeof(buf));
-	if (ret == 0)
-		*val = le16_to_cpup(&buf);
-	return ret;
+	return spu_read(card, reg, (u8 *)val, sizeof(u16));
 }
 
 /* Read 32 bits from an SPI register.
  * The low 16 bits are read first. */
 static int spu_read_u32(struct if_spi_card *card, u16 reg, u32 *val)
 {
-	u32 buf;
+	u16 buf[2];
 	int err;
 
-	err = spu_read(card, reg, (u8 *)&buf, sizeof(buf));
+	err = spu_read(card, reg, (u8 *)buf, sizeof(u32));
 	if (!err)
-		*val = le32_to_cpup(&buf);
+		*val = buf[0] | (buf[1] << 16);
 	return err;
 }
 
@@ -737,7 +809,7 @@
 		goto out;
 	} else if (len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {
 		lbs_pr_err("%s: error: card has %d bytes of data, but "
-			   "our maximum skb size is %lu\n",
+			   "our maximum skb size is %u\n",
 			   __func__, len, MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);
 		err = -EINVAL;
 		goto out;
@@ -812,6 +884,7 @@
 static void if_spi_e2h(struct if_spi_card *card)
 {
 	int err = 0;
+	unsigned long flags;
 	u32 cause;
 	struct lbs_private *priv = card->priv;
 
@@ -819,14 +892,10 @@
 	if (err)
 		goto out;
 
-	/* re-enable the card event interrupt */
-	spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG,
-			~IF_SPI_HICU_CARD_EVENT);
-
-	/* generate a card interrupt */
-	spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG, IF_SPI_CIC_HOST_EVENT);
-
+	spin_lock_irqsave(&priv->driver_lock, flags);
 	lbs_queue_event(priv, cause & 0xff);
+	spin_unlock_irqrestore(&priv->driver_lock, flags);
+
 out:
 	if (err)
 		lbs_pr_err("%s: error %d\n", __func__, err);
@@ -847,6 +916,9 @@
 		 * data, which we might be able to send.
 		 */
 		do {
+#ifdef CONFIG_ARCH_LF1000
+			lf1000_enable_irq(0);
+#endif
 			err = down_interruptible(&card->spi_ready);
 			if (!card->run_thread) {
 				up(&card->spi_thread_terminated);
@@ -871,12 +943,7 @@
 			err = if_spi_c2h_data(card);
 			if (err)
 				goto err;
-
-		/* workaround: in PS mode, the card does not set the Command
-		 * Download Ready bit, but it sets TX Download Ready. */
-		if (hiStatus & IF_SPI_HIST_CMD_DOWNLOAD_RDY ||
-		   (card->priv->psstate != PS_STATE_FULL_POWER &&
-		    (hiStatus & IF_SPI_HIST_TX_DOWNLOAD_RDY))) {
+		if (hiStatus & IF_SPI_HIST_CMD_DOWNLOAD_RDY) {
 			/* This means two things. First of all,
 			 * if there was a previous command sent, the card has
 			 * successfully received it.
@@ -999,6 +1066,9 @@
 static irqreturn_t if_spi_host_interrupt(int irq, void *dev_id)
 {
 	struct if_spi_card *card = dev_id;
+#ifdef CONFIG_ARCH_LF1000
+	lf1000_disable_irq(irq);
+#endif
 
 	up(&card->spi_ready);
 	return IRQ_HANDLED;
@@ -1020,9 +1090,9 @@
 		lbs_pr_err("Unsupported chip_id: 0x%02x\n", card_id);
 		return -EAFNOSUPPORT;
 	}
-	snprintf(helper_fw, IF_SPI_FW_NAME_MAX, "libertas/gspi%d_hlp.bin",
+	snprintf(helper_fw, FIRMWARE_NAME_MAX, "libertas/gspi%d_hlp.bin",
 		 chip_id_to_device_name[i].name);
-	snprintf(main_fw, IF_SPI_FW_NAME_MAX, "libertas/gspi%d.bin",
+	snprintf(main_fw, FIRMWARE_NAME_MAX, "libertas/gspi%d.bin",
 		 chip_id_to_device_name[i].name);
 	return 0;
 }
@@ -1034,7 +1104,6 @@
 	struct libertas_spi_platform_data *pdata = spi->dev.platform_data;
 	int err = 0;
 	u32 scratch;
-	struct sched_param param = { .sched_priority = 1 };
 
 	lbs_deb_enter(LBS_DEB_SPI);
 
@@ -1058,6 +1127,7 @@
 	spi_set_drvdata(spi, card);
 	card->pdata = pdata;
 	card->spi = spi;
+	card->gpio_cs = pdata->gpio_cs;
 	card->prev_xfer_time = jiffies;
 
 	sema_init(&card->spi_ready, 0);
@@ -1065,19 +1135,27 @@
 	INIT_LIST_HEAD(&card->cmd_packet_list);
 	INIT_LIST_HEAD(&card->data_packet_list);
 	spin_lock_init(&card->buffer_lock);
-
+#ifndef CONFIG_ARCH_LF1000
+	/* set up GPIO CS line. TODO: use  regular CS line */
+	err = gpio_request(card->gpio_cs, "if_spi_gpio_chip_select");
+	if (err)
+		goto free_card;
+	err = gpio_direction_output(card->gpio_cs, 1);
+	if (err)
+		goto free_gpio;
+#endif
 	/* Initialize the SPI Interface Unit */
 	err = spu_init(card, pdata->use_dummy_writes);
 	if (err)
-		goto free_card;
+		goto free_gpio;
 	err = spu_get_chip_revision(card, &card->card_id, &card->card_rev);
 	if (err)
-		goto free_card;
+		goto free_gpio;
 
 	/* Firmware load */
 	err = spu_read_u32(card, IF_SPI_SCRATCH_4_REG, &scratch);
 	if (err)
-		goto free_card;
+		goto free_gpio;
 	if (scratch == SUCCESSFUL_FW_DOWNLOAD_MAGIC)
 		lbs_deb_spi("Firmware is already loaded for "
 			    "Marvell WLAN 802.11 adapter\n");
@@ -1085,7 +1163,7 @@
 		err = if_spi_calculate_fw_names(card->card_id,
 				card->helper_fw_name, card->main_fw_name);
 		if (err)
-			goto free_card;
+			goto free_gpio;
 
 		lbs_deb_spi("Initializing FW for Marvell WLAN 802.11 adapter "
 				"(chip_id = 0x%04x, chip_rev = 0x%02x) "
@@ -1096,23 +1174,23 @@
 				spi->max_speed_hz);
 		err = if_spi_prog_helper_firmware(card);
 		if (err)
-			goto free_card;
+			goto free_gpio;
 		err = if_spi_prog_main_firmware(card);
 		if (err)
-			goto free_card;
+			goto free_gpio;
 		lbs_deb_spi("loaded FW for Marvell WLAN 802.11 adapter\n");
 	}
 
 	err = spu_set_interrupt_mode(card, 0, 1);
 	if (err)
-		goto free_card;
+		goto free_gpio;
 
 	/* Register our card with libertas.
 	 * This will call alloc_etherdev */
 	priv = lbs_add_card(card, &spi->dev);
 	if (!priv) {
 		err = -ENOMEM;
-		goto free_card;
+		goto free_gpio;
 	}
 	card->priv = priv;
 	priv->card = card;
@@ -1129,11 +1207,13 @@
 		lbs_pr_err("error creating SPI thread: err=%d\n", err);
 		goto remove_card;
 	}
-	if (sched_setscheduler(card->spi_thread, SCHED_FIFO, &param))
-		lbs_pr_err("Error setting scheduler, using default.\n");
-
+#ifndef CONFIG_ARCH_LF1000
 	err = request_irq(spi->irq, if_spi_host_interrupt,
 			IRQF_TRIGGER_FALLING, "libertas_spi", card);
+#else
+	err = lf1000_request_irq(spi->irq, if_spi_host_interrupt,
+			IRQF_TRIGGER_FALLING, "libertas_spi", card);
+#endif
 	if (err) {
 		lbs_pr_err("can't get host irq line-- request_irq failed\n");
 		goto terminate_thread;
@@ -1152,11 +1232,19 @@
 	goto out;
 
 release_irq:
+#ifndef CONFIG_ARCH_LF1000
 	free_irq(spi->irq, card);
+#else
+	lf1000_free_irq(spi->irq, card);
+#endif
 terminate_thread:
 	if_spi_terminate_spi_thread(card);
 remove_card:
 	lbs_remove_card(priv); /* will call free_netdev */
+free_gpio:
+#ifndef CONFIG_ARCH_LF1000
+	gpio_free(card->gpio_cs);
+#endif
 free_card:
 	free_if_spi_card(card);
 out:
@@ -1174,9 +1262,16 @@
 	priv->surpriseremoved = 1;
 
 	lbs_stop_card(priv);
+#ifndef CONFIG_ARCH_LF1000
 	free_irq(spi->irq, card);
+#else
+	lf1000_free_irq(spi->irq, card);
+#endif
 	if_spi_terminate_spi_thread(card);
 	lbs_remove_card(priv); /* will call free_netdev */
+#ifndef CONFIG_ARCH_LF1000
+	gpio_free(card->gpio_cs);
+#endif
 	if (card->pdata->teardown)
 		card->pdata->teardown(spi);
 	free_if_spi_card(card);
diff -ruaN linux-2.6.31/drivers/net/wireless/libertas/if_spi.h linux-2.6/drivers/net/wireless/libertas/if_spi.h
--- linux-2.6.31/drivers/net/wireless/libertas/if_spi.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/net/wireless/libertas/if_spi.h	2011-01-04 13:50:21.000000000 -0800
@@ -22,9 +22,6 @@
 #define IF_SPI_CMD_BUF_SIZE 2400
 
 /***************** Firmware *****************/
-
-#define IF_SPI_FW_NAME_MAX 30
-
 struct chip_ident {
 	u16 chip_id;
 	u16 name;
diff -ruaN linux-2.6.31/drivers/rtc/Kconfig linux-2.6/drivers/rtc/Kconfig
--- linux-2.6.31/drivers/rtc/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/rtc/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -691,6 +691,12 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-bfin.
 
+config RTC_DRV_LF1000
+	tristate "LF1000 RTC"
+	depends on ARCH_LF1000
+	help
+	  RTC driver for LeapFrog LF1000
+
 config RTC_DRV_RS5C313
 	tristate "Ricoh RS5C313"
 	depends on SH_LANDISK
diff -ruaN linux-2.6.31/drivers/rtc/Makefile linux-2.6/drivers/rtc/Makefile
--- linux-2.6.31/drivers/rtc/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/rtc/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -40,6 +40,7 @@
 obj-$(CONFIG_RTC_DRV_EP93XX)	+= rtc-ep93xx.o
 obj-$(CONFIG_RTC_DRV_FM3130)	+= rtc-fm3130.o
 obj-$(CONFIG_RTC_DRV_ISL1208)	+= rtc-isl1208.o
+obj-$(CONFIG_RTC_DRV_LF1000)	+= rtc-lf1000.o
 obj-$(CONFIG_RTC_DRV_M41T80)	+= rtc-m41t80.o
 obj-$(CONFIG_RTC_DRV_M41T94)	+= rtc-m41t94.o
 obj-$(CONFIG_RTC_DRV_M48T35)	+= rtc-m48t35.o
diff -ruaN linux-2.6.31/drivers/rtc/rtc-dev.c linux-2.6/drivers/rtc/rtc-dev.c
--- linux-2.6.31/drivers/rtc/rtc-dev.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/rtc/rtc-dev.c	2011-01-04 14:21:02.000000000 -0800
@@ -233,8 +233,11 @@
 	switch (cmd) {
 	case RTC_EPOCH_SET:
 	case RTC_SET_TIME:
+/* for ttpro 2462, break security */
+#if 0
 		if (!capable(CAP_SYS_TIME))
 			err = -EACCES;
+#endif
 		break;
 
 	case RTC_IRQP_SET:
diff -ruaN linux-2.6.31/drivers/rtc/rtc-lf1000.c linux-2.6/drivers/rtc/rtc-lf1000.c
--- linux-2.6.31/drivers/rtc/rtc-lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/rtc/rtc-lf1000.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,594 @@
+/*
+ *	Real Time Clock interface for LeapFrog LF1000
+ *
+ *      Scott Esters <sesters@leapfrog.com>
+ *
+ *      Based on rtc-lf1000rm9200.c driver
+ *
+ *	Converted to RTC class model by Andrew Victor
+ *
+ *	Ported to Linux 2.6 by Steven Scholz
+ *	Based on s3c2410-rtc.c Simtec Electronics
+ *
+ *	Based on sa1100-rtc.c by Nils Faerber
+ *	Based on rtc.c by Paul Gortmaker
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+#include <linux/interrupt.h>
+#include <linux/ioctl.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <asm/mach/time.h>
+#include <mach/common.h>
+
+#define LF1000_RTC_FREQ		1
+#define LF1000_RTC_EPOCH	1900UL	/* just like arch/arm/common/rtctime.c*/
+#define RTC_FREE_TIMER		LF1000_FREE_TIMER
+#define RTC_FREE_TIMER_SIZE	32	/* timer size in bits */
+#define RTC_FREE_TIMER_MAX	0xFFFFFFFF /* max timer value */
+
+typedef struct tagRTC_REGS {
+	volatile u32 RTCCNTWRITE;
+	volatile u32 RTCCNTREAD;
+	volatile u32 RTCALARM;
+	volatile u32 RTCCTRL;
+	volatile u32 RTCINTENB;
+	volatile u32 RTCINTPND;
+} RTC_REGS;
+
+RTC_REGS *rtcRegs = NULL;		// RTC registers
+
+struct rtc_pll_info rtc_timer;
+
+/********************
+ * RTCCTRL Register *
+ *******************/
+#define RTCCNTWAIT	4
+#define ALARMCNTWAIT	3
+#define RTCCNTWRITEENB	0
+
+/**********************
+ * RTCINTENB Register *
+ *********************/
+#define ALARMINTENB	1
+#define _RTCINTENB	0
+
+/**********************
+ * RTCINTPND Register *
+ *********************/
+#define ALARMINTPEND	1
+#define RTCINTPEND	0
+
+
+DECLARE_COMPLETION(lf1000_rtc_updated);
+
+/*
+ * Read current time and date in RTC
+ */
+static int lf1000_rtc_readtime(struct device *dev, struct rtc_time *tm)
+{
+	unsigned long ulTime;
+	u32 reg32;
+
+	reg32 = ioread32(&rtcRegs->RTCCTRL);
+	BIT_SET(reg32, RTCCNTWRITEENB);		// enable access
+	iowrite32(reg32, &rtcRegs->RTCCTRL);	// enable RTC
+	ulTime = ioread32(&rtcRegs->RTCCNTREAD);
+	BIT_CLR(reg32, RTCCNTWRITEENB);		// read-only
+	iowrite32(reg32, &rtcRegs->RTCCTRL);	// disable access
+	
+	rtc_time_to_tm(ulTime, tm);
+	
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon + 1, tm->tm_mday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+/*
+ * Set current time and date in RTC
+ */
+static int lf1000_rtc_settime(struct device *dev, struct rtc_time *tm)
+{
+	unsigned int uiTime;
+	unsigned long ulTime;
+	u32 reg32;
+	int ret = 0;
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	rtc_tm_to_time(tm, &ulTime);
+
+	// ensure value fits in 32 bits
+	if (ulTime > 0xFFFFFFFF)
+		printk(KERN_ALERT "%s: ulTime value (%lu) out of range\n",
+			__FUNCTION__, ulTime);
+	uiTime = ulTime  & 0xFFFFFFFF;	// keep just lower 32 bits
+
+	reg32 = ioread32(&rtcRegs->RTCCTRL);
+	BIT_SET(reg32, RTCCNTWRITEENB);		// enable access
+	iowrite32(reg32, &rtcRegs->RTCCTRL);	// enable RTC
+	iowrite32(uiTime, &rtcRegs->RTCCNTWRITE);
+
+	// wait for RTC write to complete (2/32768 sec ~ 61 us)
+	msleep(1);				// let write finish
+	reg32 = ioread32(&rtcRegs->RTCCTRL);	// write should have finished
+	if (IS_SET(reg32, RTCCNTWAIT))
+		ret = -EDEADLOCK;		// write failed
+
+	reg32 = ioread32(&rtcRegs->RTCCTRL);
+	BIT_CLR(reg32, RTCCNTWRITEENB);		// read-only
+	iowrite32(reg32, &rtcRegs->RTCCTRL);	// disable access
+	//wait_for_completion(&lf1000_rtc_updated);	/* wait for ACKUPD interrupt */
+	
+	return ret;
+}
+
+/*
+ * Read alarm time and date in RTC
+ */
+static int lf1000_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	unsigned long ulTime;
+	struct rtc_time *tm = &alrm->time;
+
+	ulTime = ioread32(&rtcRegs->RTCALARM);
+	rtc_time_to_tm(ulTime, tm);
+
+	tm->tm_mday = -1;
+	tm->tm_mon = -1;
+	tm->tm_year = -1;
+	tm->tm_wday = -1;
+	tm->tm_yday = -1;
+	tm->tm_isdst = -1;
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm->tm_year, tm->tm_mon+1, tm->tm_mday,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+/*
+ * Set alarm time and date in RTC
+ * Note only hour, minute, second set.  Other values are -1
+ */
+static int lf1000_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct rtc_time *tm = &alrm->time;
+	unsigned int uiTime;
+	unsigned long ulTime;
+	u32 reg32;
+	int ret=0;
+
+	rtc_tm_to_time(tm, &ulTime);
+
+	// ensure value fits in 32 bits
+	if (ulTime > 0xFFFFFFFF)
+		printk(KERN_ALERT "%s: ulTime value (%lu) out of range\n",
+			__FUNCTION__, ulTime);
+	uiTime = ulTime  & 0xFFFFFFFF;	// keep just lower 32 bits
+
+	iowrite32(uiTime, &rtcRegs->RTCALARM);
+	
+	// wait for ALARM write to complete (2/32768 sec ~ 61 us)
+	msleep(1);			// 1000us long, let write finish
+	reg32 = ioread32(&rtcRegs->RTCCTRL);	// write should have finished
+	if (IS_SET(reg32, ALARMCNTWAIT))
+		ret = -EDEADLOCK;		// write failed
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		alrm->time.tm_year, alrm->time.tm_mon,
+		alrm->time.tm_mday, alrm->time.tm_hour,
+		alrm->time.tm_min, alrm->time.tm_sec);
+
+	return ret;
+}
+
+/*
+ * Handle commands from user-space
+ */
+static int lf1000_rtc_ioctl(struct device *dev, unsigned int cmd,
+			unsigned long arg)
+{
+	int ret = 0;
+	u32 reg32;
+	unsigned int uiTime;
+	unsigned long ulTime;
+
+	pr_debug("%s(): cmd=%08x, arg=%08lx.\n", __FUNCTION__, cmd, arg);
+
+	switch (cmd) {
+	case RTC_RD_TIME:	/* will use rd_time function */
+		ret = -ENOIOCTLCMD;
+		break;
+	case RTC_SET_TIME:	/* will use set_time function */
+		ret = -ENOIOCTLCMD;
+		break;
+	case RTC_AIE_OFF:	/* alarm off */
+		reg32 = ioread32(&rtcRegs->RTCINTENB);
+		BIT_CLR(reg32, ALARMINTENB);
+		iowrite32(reg32, &rtcRegs->RTCINTENB);
+		break;
+	case RTC_AIE_ON:	/* alarm on */
+		reg32 = ioread32(&rtcRegs->RTCINTENB);
+		BIT_SET(reg32, ALARMINTENB);
+		iowrite32(reg32, &rtcRegs->RTCINTENB);
+		break;
+	case RTC_UIE_OFF:	/* update off */
+	case RTC_PIE_OFF:	/* periodic off */
+		// FIXME: check write completion bit
+		reg32 = ioread32(&rtcRegs->RTCINTENB);
+		BIT_CLR(reg32, _RTCINTENB);
+		iowrite32(reg32, &rtcRegs->RTCINTENB);
+		break;
+	case RTC_UIE_ON:	/* update on */
+	case RTC_PIE_ON:	/* periodic on */
+		// FIXME: check write completion bit
+		reg32 = ioread32(&rtcRegs->RTCINTENB);
+		BIT_SET(reg32, _RTCINTENB);
+		iowrite32(reg32, &rtcRegs->RTCINTENB);
+		break;
+	case RTC_IRQP_READ:	/* read periodic alarm frequency */
+		uiTime = ioread32(&rtcRegs->RTCALARM);
+		ret = put_user((unsigned long)uiTime, (unsigned long *) arg);
+		break;
+	case RTC_IRQP_SET:	/* set periodic alarm frequency */
+		ret = get_user(ulTime, (unsigned long *) arg);
+		if (ulTime > 0xFFFFFFFF) {
+			printk(KERN_ALERT "ulTime (%lu) out of range\n",
+				ulTime);
+			return -ENOIOCTLCMD;
+		}
+		uiTime = ulTime & 0xFFFFFFFF;
+		reg32 = iowrite32(uiTime, &rtcRegs->RTCALARM);
+		// wait for ALARM write to complete (2/32768 sec ~ 61 us)
+		msleep(1);		// 1000us long, let write finish
+		// write should have finished
+		reg32 = ioread32(&rtcRegs->RTCCTRL);
+		if (IS_SET(reg32, ALARMCNTWAIT))
+			ret = -EDEADLOCK;	// write failed
+		break;
+	
+        case RTC_WIE_ON:
+		printk(KERN_ALERT "%s():%d RTC_WIE_ON not implemented\n",
+			       	__FUNCTION__, __LINE__);
+		ret = -ENOIOCTLCMD;
+		break;
+
+	case RTC_WIE_OFF:
+		printk(KERN_ALERT "%s():%d RTC_WIE_OFF not implemented\n",
+			__FUNCTION__, __LINE__);
+		ret = -ENOIOCTLCMD;
+		break;
+
+	case RTC_PLL_SET:
+		printk(KERN_ALERT "%s():%d RTC_PLL_SET not implemented\n",
+			__FUNCTION__, __LINE__);
+		ret = -ENOIOCTLCMD;
+		break;
+
+	/*
+	 * reuse exiting RTC IOCTL call, allowing access to high-speed timer
+	 */
+
+	/* read timer value */	
+	case RTC_PLL_GET:
+		/* read raw seconds from RTC	*/
+		reg32 = ioread32(&rtcRegs->RTCCTRL);
+		BIT_SET(reg32, RTCCNTWRITEENB);		// enable access
+		iowrite32(reg32, &rtcRegs->RTCCTRL);	// enable RTC
+		rtc_timer.pll_min = ioread32(&rtcRegs->RTCCNTREAD);
+		BIT_CLR(reg32, RTCCNTWRITEENB);		// read-only
+		iowrite32(reg32, &rtcRegs->RTCCTRL);	// disable access
+		
+		/* get high-speed timer values */
+		rtc_timer.pll_value = get_timer_cnt(RTC_FREE_TIMER);
+		rtc_timer.pll_clock = get_timer_freq(RTC_FREE_TIMER);
+		rtc_timer.pll_ctrl = 
+			RTC_FREE_TIMER_MAX / get_timer_freq(RTC_FREE_TIMER); 
+		ret = copy_to_user((struct rtc_pll_info *)arg, &rtc_timer, 
+			sizeof(struct rtc_pll_info));
+		break;
+
+	default:
+		printk(KERN_ALERT "%s(): RTC: default ioctl _IOC_NR(cmd)=%d\n",
+		       	__FUNCTION__, _IOC_NR(cmd));
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Provide additional RTC information in /proc/driver/rtc
+ */
+#ifdef CONFIG_PROC_FS
+static int lf1000_rtc_proc(struct device *dev, struct seq_file *seq)
+{
+	u32 reg32;
+
+	reg32 = ioread32(&rtcRegs->RTCCTRL);
+	BIT_SET(reg32, RTCCNTWRITEENB);		// enable access
+	iowrite32(reg32, &rtcRegs->RTCCTRL);
+	seq_printf(seq, "RTCCNTWRITE    : 0x%08X\n",
+			ioread32(&rtcRegs->RTCCNTWRITE));
+	seq_printf(seq, "RTCCNTREAD     : 0x%08X\n",
+			ioread32(&rtcRegs->RTCCNTREAD));
+	BIT_CLR(reg32, RTCCNTWRITEENB);		// read-only
+	iowrite32(reg32, &rtcRegs->RTCCTRL);	// disable access
+	seq_printf(seq, "RTCALARM       : 0x%08X\n",
+			ioread32(&rtcRegs->RTCALARM));
+	seq_printf(seq, "RTCCTRL        : 0x%08X\n",
+			ioread32(&rtcRegs->RTCCTRL));
+	seq_printf(seq, "RTCINTENB      : 0x%08X\n",
+			ioread32(&rtcRegs->RTCINTENB));
+	seq_printf(seq, "RTCINTPND      : 0x%08X\n",
+			ioread32(&rtcRegs->RTCINTPND));
+	seq_printf(seq, "RTC_FREE_TIMER_FREQ  : 0x%p\n",
+			(void *)get_timer_freq(RTC_FREE_TIMER));
+	seq_printf(seq, "RTC_FREE_TIMER_COUNT : 0x%p\n",
+			(void *)get_timer_cnt(RTC_FREE_TIMER));
+	seq_printf(seq, "RTC_FREE_TIMER_SECS  : %d\n",
+			RTC_FREE_TIMER_MAX / get_timer_freq(RTC_FREE_TIMER));
+	return 0;
+}
+#endif
+
+/*
+ * IRQ handler for the RTC
+ */
+static irqreturn_t lf1000_rtc_interrupt(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+	u32 reg32;
+	u32 intReg32;
+	u32 tmpReg32;
+
+	unsigned long events = 0;
+
+	reg32 = ioread32(&rtcRegs->RTCINTPND);
+	intReg32 = ioread32(&rtcRegs->RTCINTENB);		// save reg
+
+	if (reg32) { // our interrupt occurred	
+		if (IS_SET(reg32,RTCINTPEND)) {
+			events |= (RTC_UF | RTC_IRQF);
+			complete(&lf1000_rtc_updated);
+			tmpReg32 = intReg32;			// clear int
+			BIT_CLR(tmpReg32, _RTCINTENB);
+			iowrite32(tmpReg32, &rtcRegs->RTCINTENB);
+		}
+		if (IS_SET(reg32,ALARMINTPEND)) {
+			events |= (RTC_AF | RTC_IRQF);
+			tmpReg32 = intReg32;			// clear int
+			BIT_CLR(tmpReg32, ALARMINTENB);
+			iowrite32(tmpReg32, &rtcRegs->RTCINTENB);
+		}
+		rtc_update_irq(rtc, 1, events);
+
+		iowrite32(intReg32, &rtcRegs->RTCINTENB);	// restore reg
+		return IRQ_HANDLED;
+	}
+
+	printk(KERN_ALERT "RTC: Interrupt unhandled!\n");
+	return IRQ_NONE;		/* not handled */
+}
+
+static const struct rtc_class_ops lf1000_rtc_ops = {
+	.ioctl		= lf1000_rtc_ioctl,
+	.read_time	= lf1000_rtc_readtime,
+	.set_time	= lf1000_rtc_settime,
+	.read_alarm	= lf1000_rtc_readalarm,
+	.set_alarm	= lf1000_rtc_setalarm,
+#ifdef CONFIG_PROC_FS
+	.proc		= lf1000_rtc_proc,
+#endif
+};
+
+/*
+ * Initialize and install RTC driver
+ */
+static int __init lf1000_rtc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct rtc_device *rtc;
+	int ret;
+	u32 reg32;
+
+	struct resource *mem_rtc = NULL;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk(KERN_ERR "RTC: failed to get resource\n");
+		return -ENXIO;
+	}
+
+	mem_rtc = request_mem_region(res->start, (res->end - res->start)+1, 
+				     "lf1000_rtc");
+	if (mem_rtc == NULL) {
+		printk(KERN_ERR "RTC: failed to map RTC region\n");
+		return -EBUSY;
+	}
+
+	rtcRegs = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(rtcRegs == NULL) {
+		printk(KERN_ERR "RTC: failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	/* initialize RTC registers */
+	reg32 = ioread32(&rtcRegs->RTCCTRL);	// disable access
+	BIT_CLR(reg32, RTCCNTWRITEENB);
+	iowrite32(reg32, &rtcRegs->RTCCTRL);
+	iowrite32(0, &rtcRegs->RTCALARM);
+	iowrite32(0, &rtcRegs->RTCINTENB);
+	iowrite32(0, &rtcRegs->RTCINTPND);
+
+	ret = request_irq(LF1000_RTC_IRQ, lf1000_rtc_interrupt,
+				IRQF_DISABLED | IRQF_SHARED,
+				"lf1000-rtc", pdev);
+	if (ret) {
+		printk(KERN_ERR "lf1000-rtc: IRQ %d already in use.\n",
+				LF1000_RTC_IRQ);
+		goto fail_irq;
+	}
+
+
+	rtc = rtc_device_register(pdev->name, &pdev->dev,
+				&lf1000_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)) {
+		ret = PTR_ERR(rtc);
+		goto fail_dev;
+	}
+	platform_set_drvdata(pdev, rtc);
+	device_init_wakeup(&pdev->dev, 1);
+
+	printk(KERN_INFO "LF1000 Real Time Clock driver.\n");
+	return 0;
+
+fail_dev:
+	free_irq(LF1000_RTC_IRQ, pdev);
+fail_irq:
+	iounmap(rtcRegs);
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	return ret;
+}
+
+/*
+ * Disable and remove the RTC driver
+ */
+static int __exit lf1000_rtc_remove(struct platform_device *pdev)
+{
+	struct rtc_device *rtc = platform_get_drvdata(pdev);
+	struct resource *res;
+       
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	/* Disable all interrupts */
+	iowrite32(1 << ALARMINTENB | 1 << _RTCINTENB, &rtcRegs->RTCINTENB);
+	free_irq(LF1000_RTC_IRQ, pdev);
+
+	iounmap(rtcRegs);
+	release_mem_region(res->start, (res->end - res->start) + 1);
+
+	rtc_device_unregister(rtc);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+/* LF1000R RTC Power management control */
+
+
+static int lf1000_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#if 0
+	struct rtc_time tm;
+	struct timespec time;
+
+	time.tv_nsec = 0;
+
+	/* calculate time delta for suspend */
+	lf1000_rtc_readtime(&pdev->dev, &tm);
+	rtc_tm_to_time(&tm, &time.tv_sec);
+	save_time_delta(&lf1000_rtc_delta, &time);
+
+	/* this IRQ is shared with DBGU and other hardware which isn't
+	 * necessarily doing PM like we are...
+	 */
+	lf1000_rtc_imr = lf1000_sys_read(LF1000_RTC_IMR)
+			& (LF1000_RTC_ALARM|LF1000_RTC_SECEV);
+	if (lf1000_rtc_imr) {
+		if (device_may_wakeup(&pdev->dev))
+			enable_irq_wake(LF1000_ID_SYS);
+		else
+			lf1000_sys_write(LF1000_RTC_IDR, lf1000_rtc_imr);
+	}
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm.tm_year, tm.tm_mon, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec);
+#endif
+	return 0;
+}
+
+static int lf1000_rtc_resume(struct platform_device *pdev)
+{
+#if 0
+	struct rtc_time tm;
+	struct timespec time;
+
+	time.tv_nsec = 0;
+
+	lf1000_rtc_readtime(&pdev->dev, &tm);
+	rtc_tm_to_time(&tm, &time.tv_sec);
+	restore_time_delta(&lf1000_rtc_delta, &time);
+
+	if (lf1000_rtc_imr) {
+		if (device_may_wakeup(&pdev->dev))
+			disable_irq_wake(LF1000_ID_SYS);
+		else
+			lf1000_sys_write(LF1000_RTC_IER, lf1000_rtc_imr);
+	}
+
+	pr_debug("%s(): %4d-%02d-%02d %02d:%02d:%02d\n", __FUNCTION__,
+		1900 + tm.tm_year, tm.tm_mon, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec);
+#endif
+	return 0;
+}
+#else
+#define lf1000_rtc_suspend NULL
+#define lf1000_rtc_resume  NULL
+#endif
+
+static struct platform_driver lf1000_rtc_driver = {
+	.remove		= __exit_p(lf1000_rtc_remove),
+	.suspend	= lf1000_rtc_suspend,
+	.resume		= lf1000_rtc_resume,
+	.driver		= {
+		.name	= "lf1000-rtc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lf1000_rtc_init(void)
+{
+	return platform_driver_probe(&lf1000_rtc_driver, lf1000_rtc_probe);
+}
+
+static void __exit lf1000_rtc_exit(void)
+{
+	platform_driver_unregister(&lf1000_rtc_driver);
+}
+
+module_init(lf1000_rtc_init);
+module_exit(lf1000_rtc_exit);
+
+MODULE_AUTHOR("Scott Esters");
+MODULE_DESCRIPTION("RTC driver for LF1000");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/serial/8250_early.c linux-2.6/drivers/serial/8250_early.c
--- linux-2.6.31/drivers/serial/8250_early.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/serial/8250_early.c	2011-01-04 13:50:21.000000000 -0800
@@ -38,6 +38,8 @@
 #include <asm/fixmap.h>
 #endif
 
+#include <mach/uart.h>
+
 struct early_serial8250_device {
 	struct uart_port port;
 	char options[16];		/* e.g., 115200n8 */
diff -ruaN linux-2.6.31/drivers/serial/8250-lf1000.c linux-2.6/drivers/serial/8250-lf1000.c
--- linux-2.6.31/drivers/serial/8250-lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/serial/8250-lf1000.c	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,1774 @@
+/*
+ *  linux/drivers/char/8250-lf1000.c
+ *
+ *  Driver for LF1000 16550-type serial ports
+ *
+ *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.
+ *
+ *  Copyright (C) 2001 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * A note about mapbase / membase
+ *
+ *  mapbase is the physical address of the IO port.
+ *  membase is an 'ioremapped' cookie.
+ */
+
+#if defined(CONFIG_SERIAL_8250_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <mach/serial_reg-lf1000.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "8250.h"
+
+#include <mach/development.h>
+
+/*
+ * Configuration:
+ *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
+ *                is unsafe when used on edge-triggered interrupts.
+ */
+static unsigned int share_irqs = SERIAL8250_SHARE_IRQS;
+
+static unsigned int nr_uarts = CONFIG_SERIAL_8250_RUNTIME_UARTS;
+
+/*
+ * Debugging.
+ */
+#if	0
+#define DEBUG_AUTOCONF(fmt...)	printk(fmt)
+#else
+#define DEBUG_AUTOCONF(fmt...)	do { } while (0)
+#endif
+
+#if	0
+#define DEBUG_INTR(fmt...)	printk(fmt)
+#else
+#define DEBUG_INTR(fmt...)	do { } while (0)
+#endif
+
+#define PASS_LIMIT	256
+
+/*
+ * We default to IRQ0 for the "no irq" hack.   Some
+ * machine types want others as well - they're free
+ * to redefine this in their header file.
+ */
+#define is_real_interrupt(irq)	((irq) != 0)
+
+#ifdef CONFIG_SERIAL_8250_DETECT_IRQ
+#define CONFIG_SERIAL_DETECT_IRQ 1
+#endif
+#ifdef CONFIG_SERIAL_8250_MANY_PORTS
+#define CONFIG_SERIAL_MANY_PORTS 1
+#endif
+
+/*
+ * HUB6 is always on.  This will be removed once the header
+ * files have been cleaned.
+ */
+#define CONFIG_HUB6 1
+
+#include <asm/serial.h>
+/*
+ * SERIAL_PORT_DFNS tells us about built-in ports that have no
+ * standard enumeration mechanism.   Platforms that can find all
+ * serial ports via mechanisms like ACPI or PCI need not supply it.
+ */
+#ifndef SERIAL_PORT_DFNS
+#define SERIAL_PORT_DFNS
+#endif
+
+static const struct old_serial_port old_serial_port[] = {
+	SERIAL_PORT_DFNS /* defined in asm/serial.h */
+};
+
+#define UART_NR	CONFIG_SERIAL_8250_NR_UARTS
+
+struct uart_8250_port {
+	struct uart_port	port;
+	struct timer_list	timer;		/* "no irq" timer */
+	struct list_head	list;		/* ports on this IRQ */
+	unsigned short		capabilities;	/* port capabilities */
+	unsigned short		bugs;		/* port bugs */
+	unsigned int		tx_loadsz;	/* transmit fifo load size */
+	unsigned char		acr;
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned char		mcr_mask;	/* mask of user bits */
+	unsigned char		mcr_force;	/* mask of forced bits */
+	unsigned char		lsr_break_flag;
+
+	/*
+	 * We provide a per-port pm hook.
+	 */
+	void			(*pm)(struct uart_port *port,
+				      unsigned int state, unsigned int old);
+};
+
+struct irq_info {
+	spinlock_t		lock;
+	struct list_head	*head;
+};
+
+static struct irq_info irq_lists[NR_IRQS];
+
+/*
+ * Here we define the default xmit fifo size used for each type of UART.
+ */
+static const struct serial8250_config uart_config[] = {
+	[PORT_UNKNOWN] = {
+		.name		= "unknown",
+		.fifo_size	= 1,
+		.tx_loadsz	= 1,
+	},
+	[PORT_8250] = {
+		.name		= "8250",
+		.fifo_size	= 16,
+		.tx_loadsz	= 16,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_12,
+		.flags		= UART_CAP_FIFO,
+	},
+};
+
+
+/* sane hardware needs no mapping */
+#define map_8250_in_reg(up, offset) (offset)
+#define map_8250_out_reg(up, offset) (offset)
+
+static unsigned int serial_in(struct uart_8250_port *up, int offset)
+{
+	offset = map_8250_in_reg(up, offset) << up->port.regshift;
+
+	switch (up->port.iotype) {
+	case UPIO_HUB6:
+		outb(up->port.hub6 - 1 + offset, up->port.iobase);
+		return inb(up->port.iobase + 1);
+
+	case UPIO_MEM:
+		return readb(up->port.membase + offset);
+
+	case UPIO_MEM32:
+		return readl(up->port.membase + offset);
+
+	default:
+		return inb(up->port.iobase + offset);
+	}
+}
+
+static void
+serial_out(struct uart_8250_port *up, int offset, int value)
+{
+	offset = map_8250_out_reg(up, offset) << up->port.regshift;
+
+	switch (up->port.iotype) {
+	case UPIO_HUB6:
+		outb(up->port.hub6 - 1 + offset, up->port.iobase);
+		outb(value, up->port.iobase + 1);
+		break;
+
+	case UPIO_MEM:
+		writeb(value, up->port.membase + offset);
+		break;
+
+	case UPIO_MEM32:
+		writel(value, up->port.membase + offset);
+		break;
+
+	default:
+		outb(value, up->port.iobase + offset);
+	}
+}
+
+/*
+ * We used to support using pause I/O for certain machines.  We
+ * haven't supported this for a while, but just in case it's badly
+ * needed for certain old 386 machines, I've left these #define's
+ * in....
+ */
+#define serial_inp(up, offset)		serial_in(up, offset)
+#define serial_outp(up, offset, value)	serial_out(up, offset, value)
+
+/* Uart divisor latch read */
+static inline int _serial_dl_read(struct uart_8250_port *up)
+{
+   return 0;
+}
+
+/* Uart divisor latch write */
+static inline void _serial_dl_write(struct uart_8250_port *up, int value)
+{
+}
+
+#define serial_dl_read(up) _serial_dl_read(up)
+#define serial_dl_write(up, value) _serial_dl_write(up, value)
+
+/*
+ * FIFO support.
+ */
+static inline void serial8250_clear_fifos(struct uart_8250_port *p)
+{
+	if (p->capabilities & UART_CAP_FIFO) {
+		serial_outp(p, UART_FCR, UART_FCR_ENABLE_FIFO |
+			       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT
+				| 0x70				// 4 TX & 12 RX bytes
+								);
+	}
+}
+
+/*
+ * IER sleep support.  UARTs which have EFRs need the "extended
+ * capability" bit enabled.  Note that on XR16C850s, we need to
+ * reset LCR to write to IER.
+ */
+static inline void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
+{
+	if (p->capabilities & UART_CAP_SLEEP) {
+		if (p->capabilities & UART_CAP_EFR) {
+			serial_outp(p, UART_LCR, 0xBF);
+			serial_outp(p, UART_EFR, UART_EFR_ECB);
+			serial_outp(p, UART_LCR, 0);
+		}
+		if (p->capabilities & UART_CAP_EFR) {
+			serial_outp(p, UART_LCR, 0xBF);
+			serial_outp(p, UART_EFR, 0);
+			serial_outp(p, UART_LCR, 0);
+		}
+	}
+}
+
+/*
+ * We detected a chip without a FIFO.  Only two fall into
+ * this category - the original 8250 and the 16450.  The
+ * 16450 has a scratch register (accessible with LCR=0)
+ */
+static void autoconfig_8250(struct uart_8250_port *up)
+{
+	up->port.type = PORT_8250;
+}
+
+/*
+ * This routine is called by rs_init() to initialize a specific serial
+ * port.  It determines what type of UART chip this serial port is
+ * using: 8250, 16450, 16550, 16550A.  The important question is
+ * whether or not this UART is a 16550A or not, since this will
+ * determine whether or not we can use its FIFO features or not.
+ */
+static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
+{
+	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
+		return;
+
+	DEBUG_AUTOCONF("ttyS%d: autoconf (0x%04x, 0x%p): ",
+			up->port.line, up->port.iobase, up->port.membase);
+
+	up->capabilities = UART_CAP_FIFO;
+	up->bugs = 0;
+
+	if (up->capabilities != uart_config[PORT_8250].flags) {
+		printk(KERN_WARNING
+		       "ttyS%d: detected caps %08x should be %08x\n",
+			up->port.line, up->capabilities,
+			uart_config[PORT_8250].flags);
+	}
+
+	up->port.fifosize = uart_config[PORT_8250].fifo_size;
+	up->capabilities  = uart_config[PORT_8250].flags;
+	up->tx_loadsz     = uart_config[PORT_8250].tx_loadsz;
+
+	/*
+	 * Reset the UART.
+	 */
+	serial8250_clear_fifos(up);
+	(void)serial_in(up, UART_RX);
+	serial_outp(up, UART_IER, 0x0f);
+	serial_outp(up, UART_LCR, serial_in( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);
+
+	autoconfig_8250(up);
+	DEBUG_AUTOCONF("type=%s\n", uart_config[up->port.type].name);
+}
+
+static void autoconfig_irq(struct uart_8250_port *up)
+{
+	switch( ( unsigned int)up->port.membase) {
+	    case IO_ADDRESS( LF1000_UART0_BASE):
+		up->port.irq = LF1000_UART0_IRQ;
+		break;
+	    case IO_ADDRESS( LF1000_UART1_BASE):
+		up->port.irq = LF1000_UART1_IRQ;
+		break;
+	    case IO_ADDRESS( LF1000_UART2_BASE):
+		up->port.irq = LF1000_UART2_IRQ;
+		break;
+	    case IO_ADDRESS( LF1000_UART3_BASE):
+		up->port.irq = LF1000_UART3_IRQ;
+		break;
+	}
+
+	serial_outp( up, UART_CR  , 0x03);
+	serial_outp( up, UART_CR+1, 0x85);
+	serial_outp( up, UART_FCR , 0x51);
+	serial_outp( up, UART_IER , 0xf0);
+}
+
+static inline void __stop_tx(struct uart_8250_port *p)
+{
+	if (p->ier & UART_IER_THRI) {
+		p->ier &= ~UART_IER_THRI;
+		serial_out(p, UART_IER, p->ier);
+	}
+}
+
+static void serial8250_stop_tx(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	__stop_tx(up);
+}
+
+static void serial8250_start_tx(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	if (!(up->ier & UART_IER_THRI)) {
+		up->ier |= UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static void serial8250_stop_rx(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	up->ier &= ~UART_IER_RLSI;
+	up->port.read_status_mask &= ~UART_TRSR_DR;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static void serial8250_enable_ms(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	/* no MSR capabilities */
+	if (up->bugs & UART_BUG_NOMSR)
+		return;
+
+	up->ier |= UART_IER_MSI;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static unsigned char get_uart_status( struct uart_8250_port *up)
+{
+unsigned char status, status1;
+
+    if( serial_inp( up, UART_FCR) & UART_FCR_ENABLE_FIFO) {
+	status  = serial_inp(up, UART_FSR);	// read fifo counts
+	status1 = serial_inp(up, UART_FSR+1);	// read fifo status
+	status = (((status & UART_FSR_RX_FIFO_COUNT_MASK) != ( 0<<0))?(1<<0):0) + 
+		 (((status & UART_FSR_TX_FIFO_COUNT_MASK) <= (12<<4))?(1<<1):0);
+    } else
+	status = serial_inp(up, UART_TRSR);
+
+    return status;
+}
+
+static void
+receive_chars(struct uart_8250_port *up)
+{
+	struct tty_struct *tty = up->port.info->port.tty;
+	unsigned char ch, lsr = serial_inp( up, UART_LSR);
+	int max_count = 256;
+	char flag;
+
+	do {
+		ch = serial_inp(up, UART_RX);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(lsr & (UART_LSR_BI | UART_LSR_PE |
+				    UART_LSR_FE | UART_LSR_OE))) {
+			/*
+			 * For statistics only
+			 */
+			if (lsr & UART_LSR_BI) {
+				lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char;
+			} else if (lsr & UART_LSR_PE)
+				up->port.icount.parity++;
+			else if (lsr & UART_LSR_FE)
+				up->port.icount.frame++;
+			if (lsr & UART_LSR_OE)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			lsr &= up->port.read_status_mask;
+
+			if (lsr & UART_LSR_BI) {
+				DEBUG_INTR("handling break....");
+				flag = TTY_BREAK;
+			} else if (lsr & UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			goto ignore_char;
+
+		uart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);
+
+	ignore_char:
+		lsr = serial_inp(up, UART_LSR);
+	} while ((get_uart_status( up) & UART_TRSR_DR) && (max_count-- > 0));
+	spin_unlock(&up->port.lock);
+	tty_flip_buffer_push(tty);
+	spin_lock(&up->port.lock);
+}
+
+static void transmit_chars(struct uart_8250_port *up)
+{
+	struct circ_buf *xmit = &up->port.info->xmit;
+
+	if (up->port.x_char) {
+		serial_outp(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_tx_stopped(&up->port)) {
+		serial8250_stop_tx(&up->port);
+		return;
+	}
+	if (uart_circ_empty(xmit)) {
+		__stop_tx(up);
+		return;
+	}
+
+	do {
+		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit)) {
+			break;
+		}
+	} while ( (get_uart_status( up) & UART_TRSR_THRE));
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	DEBUG_INTR("THRE...");
+
+	if (uart_circ_empty(xmit))
+		__stop_tx(up);
+}
+
+static unsigned int check_modem_status(struct uart_8250_port *up)
+{
+	unsigned int status = serial_in(up, UART_MSR);
+
+	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI) {
+		if (status & UART_MSR_TERI)
+			up->port.icount.rng++;
+		if (status & UART_MSR_DDSR)
+			up->port.icount.dsr++;
+		if (status & UART_MSR_DDCD)
+			uart_handle_dcd_change(&up->port, status & UART_MSR_DCD);
+		if (status & UART_MSR_DCTS)
+			uart_handle_cts_change(&up->port, status & UART_MSR_CTS);
+
+		wake_up_interruptible(&up->port.info->delta_msr_wait);
+	}
+
+	return status;
+}
+
+/*
+ * This handles the interrupt from one port.
+ */
+static inline void
+serial8250_handle_port(struct uart_8250_port *up)
+{
+	unsigned int status;
+
+	spin_lock(&up->port.lock);
+
+	status = get_uart_status( up);
+
+	    DEBUG_INTR("status = %x...", status);
+
+	    if (status & UART_TRSR_DR)
+		receive_chars(up);
+	    // clear receive pending flag
+	    status = get_uart_status( up);
+	    if (!(status & UART_TRSR_DR)) CLR_IIR_RDI();
+
+	    check_modem_status(up);
+	    status = get_uart_status( up);
+	    if (status & UART_TRSR_THRE)
+		transmit_chars(up);
+	    // clear transmit pending flag
+	    status = get_uart_status( up);
+	    if (!(status & UART_TRSR_THRE)) CLR_IIR_THRI();
+
+	spin_unlock(&up->port.lock);
+}
+
+/*
+ * This is the serial driver's interrupt routine.
+ *
+ * Arjan thinks the old way was overly complex, so it got simplified.
+ * Alan disagrees, saying that need the complexity to handle the weird
+ * nature of ISA shared interrupts.  (This is a special exception.)
+ *
+ * In order to handle ISA shared interrupts properly, we need to check
+ * that all ports have been serviced, and therefore the ISA interrupt
+ * line has been de-asserted.
+ *
+ * This means we need to loop through all ports. checking that they
+ * don't have an interrupt pending.
+ */
+static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
+{
+	struct irq_info *i = dev_id;
+	struct list_head *l, *end = NULL;
+	int pass_counter = 0, handled = 0;
+
+	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
+
+	spin_lock(&i->lock);
+
+	l = i->head;
+	do {
+		struct uart_8250_port *up;
+		unsigned int iir;
+
+		up = list_entry(l, struct uart_8250_port, list);
+
+		// clear modem & error pending flags
+		CLR_IIR_MSI_ERR();
+		iir = serial_in(up, UART_IIR);
+
+		if (iir & UART_IIR_MASK_INT) {
+			serial8250_handle_port(up);
+
+			handled = 1;
+
+			end = NULL;
+		} else if (end == NULL)
+			end = l;
+
+		l = l->next;
+
+		if (l == i->head && pass_counter++ > PASS_LIMIT) {
+			/* If we hit this, we're dead. */
+			printk(KERN_ERR "serial8250: too much work for "
+				"irq%d iir=0x%02x fifocount=0x%02x\n", irq, iir, serial_inp( up, UART_FSR));
+			break;
+		}
+	} while (0);
+
+	spin_unlock(&i->lock);
+
+	DEBUG_INTR("end.\n");
+
+	return IRQ_RETVAL(handled);
+}
+
+/*
+ * To support ISA shared interrupts, we need to have one interrupt
+ * handler that ensures that the IRQ line has been deasserted
+ * before returning.  Failing to do this will result in the IRQ
+ * line being stuck active, and, since ISA irqs are edge triggered,
+ * no more IRQs will be seen.
+ */
+static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
+{
+	spin_lock_irq(&i->lock);
+
+	if (!list_empty(i->head)) {
+		if (i->head == &up->list)
+			i->head = i->head->next;
+		list_del(&up->list);
+	} else {
+		BUG_ON(i->head != &up->list);
+		i->head = NULL;
+	}
+
+	spin_unlock_irq(&i->lock);
+}
+
+static int serial_link_irq_chain(struct uart_8250_port *up)
+{
+	struct irq_info *i = irq_lists + up->port.irq;
+	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+
+	spin_lock_irq(&i->lock);
+
+	if (i->head) {
+		list_add(&up->list, i->head);
+		spin_unlock_irq(&i->lock);
+
+		ret = 0;
+	} else {
+		INIT_LIST_HEAD(&up->list);
+		i->head = &up->list;
+		spin_unlock_irq(&i->lock);
+
+		ret = request_irq(up->port.irq, serial8250_interrupt,
+				  irq_flags, "serial", i);
+		if (ret < 0)
+			serial_do_unlink(i, up);
+	}
+
+	return ret;
+}
+
+static void serial_unlink_irq_chain(struct uart_8250_port *up)
+{
+	struct irq_info *i = irq_lists + up->port.irq;
+
+	BUG_ON(i->head == NULL);
+
+	if (list_empty(i->head))
+		free_irq(up->port.irq, i);
+
+	serial_do_unlink(i, up);
+}
+
+/*
+ * This function is used to handle ports that do not have an
+ * interrupt.  This doesn't work very well for 16450's, but gives
+ * barely passable results for a 16550A.  (Although at the expense
+ * of much CPU overhead).
+ */
+static void serial8250_timeout(unsigned long data)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)data;
+	unsigned int timeout;
+	unsigned int iir;
+
+	iir = serial_in(up, UART_IIR);
+	if (!(!(iir & UART_IIR_MASK_INT)))
+		serial8250_handle_port(up);
+
+	timeout = up->port.timeout;
+	timeout = timeout > 6 ? (timeout / 2 - 2) : 1;
+	mod_timer(&up->timer, jiffies + timeout);
+}
+
+static unsigned int serial8250_tx_empty(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret = serial_in(up, UART_TRSR) & UART_TRSR_TEMT ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static unsigned int serial8250_get_mctrl(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned int status;
+	unsigned int ret;
+
+	status = check_modem_status(up);
+
+	ret = 0;
+	if (status & UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (status & UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (status & UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (status & UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	return ret;
+}
+
+static void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned char mcr = 0;
+
+	if (mctrl & TIOCM_RTS)
+		mcr |= UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= UART_MCR_DTR;
+
+	mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
+
+	serial_out(up, UART_MCR, mcr);
+}
+
+static void serial8250_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned long flags;
+	unsigned short cr;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	cr = serial_in(up, UART_CR);
+	if (break_state == -1)
+		cr |= UART_CR_SBC;
+	else
+		cr &= ~UART_CR_SBC;
+	serial_out(up, UART_CR, cr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int serial8250_startup(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	int retval;
+
+	up->capabilities = uart_config[up->port.type].flags;
+	up->mcr = (1<<SCRXENB);		/* always enable console UART RX */ 
+
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reenabled in set_termios())
+	 */
+	serial8250_clear_fifos(up);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_inp(up, UART_RX);
+	serial_outp( up, UART_IER, ~(UART_IER_MSI | UART_IER_RLSI | UART_IER_THRI | UART_IER_RDI));
+	serial_outp(up, UART_LCR, serial_inp( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);
+
+	/*
+	 * If the "interrupt" for this port doesn't correspond with any
+	 * hardware interrupt, we use a timer-based system.  The original
+	 * driver used to do this with IRQ0.
+	 */
+	if (!is_real_interrupt(up->port.irq)) {
+		unsigned int timeout = up->port.timeout;
+
+		timeout = timeout > 6 ? (timeout / 2 - 2) : 1;
+
+		up->timer.data = (unsigned long)up;
+		mod_timer(&up->timer, jiffies + timeout);
+	} else {
+		retval = serial_link_irq_chain(up);
+		if (retval)
+			return retval;
+	}
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_outp(up, UART_LCR, UART_LCR_WLEN8);
+
+	/*
+	 * Finally, enable interrupts.  Note: Modem status interrupts
+	 * are set via set_termios(), which will be occurring imminently
+	 * anyway, so we don't enable them here.
+	 */
+	up->ier = UART_IER_RLSI | UART_IER_RDI;
+
+	if (up->port.flags & UPF_FOURPORT) {
+		unsigned int icp;
+		/*
+		 * Enable interrupts on the AST Fourport board
+		 */
+		icp = (up->port.iobase & 0xfe0) | 0x01f;
+		outb_p(0x80, icp);
+		(void) inb_p(icp);
+	}
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void) serial_inp(up, UART_RX);
+	serial_outp( up, UART_IIR, serial_inp( up, UART_IIR) | UART_IIR_MASK_INT);
+	serial_outp(up, UART_LCR, serial_in( up, UART_LCR) | UART_LCR_SYNC_PENDCLR);
+
+	return 0;
+}
+
+static void serial8250_shutdown(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned long flags;
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	up->ier = 0;
+	serial_outp(up, UART_IER, up->ier | UART_IIR_MASK_INT);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (up->port.flags & UPF_FOURPORT) {
+		/* reset interrupts on the AST Fourport board */
+		inb((up->port.iobase & 0xfe0) | 0x1f);
+		up->port.mctrl |= TIOCM_OUT1;
+	} else
+		up->port.mctrl &= ~TIOCM_OUT2;
+
+	serial8250_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Disable break condition and FIFOs
+	 */
+	serial_out(up, UART_CR, serial_inp(up, UART_CR) & ~UART_CR_SBC);
+	serial8250_clear_fifos(up);
+
+	/*
+	 * Read data port to reset things, and then unlink from
+	 * the IRQ chain.
+	 */
+	(void) serial_in(up, UART_RX);
+
+	if (!is_real_interrupt(up->port.irq))
+		del_timer_sync(&up->timer);
+	else
+		serial_unlink_irq_chain(up);
+}
+
+static unsigned int serial8250_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	/*
+	 * Handle magic divisors for baud rates above baud_base on
+	 * SMSC SuperIO chips.
+	 */
+	if ((port->flags & UPF_MAGIC_MULTIPLIER) &&
+	    baud == (port->uartclk/4))
+		quot = 0x8001;
+	else if ((port->flags & UPF_MAGIC_MULTIPLIER) &&
+		 baud == (port->uartclk/8))
+		quot = 0x8002;
+	else
+		quot = uart_get_divisor(port, baud);
+
+	return quot;
+}
+
+static void
+serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
+		       struct ktermios *old)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	unsigned char cval, fcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = UART_LCR_WLEN5;
+		break;
+	case CS6:
+		cval = UART_LCR_WLEN6;
+		break;
+	case CS7:
+		cval = UART_LCR_WLEN7;
+		break;
+	default:
+	case CS8:
+		cval = UART_LCR_WLEN8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= UART_LCR_STOP;
+	if (termios->c_cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(termios->c_cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
+	quot = serial8250_get_divisor(port, baud);
+
+	if (up->capabilities & UART_CAP_FIFO && up->port.fifosize > 1) {
+		if (baud < 2400)
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;
+		else
+			fcr = uart_config[up->port.type].fcr;
+	}
+
+	/*
+	 * MCR-based auto flow control.  When AFE is enabled, RTS will be
+	 * deasserted when the receive FIFO contains more characters than
+	 * the trigger, or the MCR RTS bit is cleared.  In the case where
+	 * the remote UART is not using CTS auto flow control, we must
+	 * have sufficient FIFO entries for the latency of the remote
+	 * UART to respond.  IOW, at least 32 bytes of FIFO.
+	 */
+	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 32) {
+		up->mcr &= ~UART_MCR_AFE;
+		if (termios->c_cflag & CRTSCTS)
+			up->mcr |= UART_MCR_AFE;
+	}
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = UART_LSR_OE | UART_TRSR_THRE | UART_TRSR_DR;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_TRSR_DR;
+
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
+	up->ier &= ~UART_IER_MSI;
+	if (!(up->bugs & UART_BUG_NOMSR) &&
+			UART_ENABLE_MS(&up->port, termios->c_cflag))
+		up->ier |= UART_IER_MSI;
+	if (up->capabilities & UART_CAP_UUE)
+		up->ier |= UART_IER_UUE | UART_IER_RTOIE;
+
+	up->ier &= 0xf0;
+	serial_out(up, UART_IER, up->ier);
+
+	serial_dl_write(up, quot);
+
+	/*
+	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
+	 * is written without DLAB set, this mode will be disabled.
+	 */
+	serial_outp(up, UART_LCR, cval);		/* reset DLAB */
+	up->lcr = cval;					/* Save LCR */
+	if (up->port.type != PORT_16750) {
+		if (fcr & UART_FCR_ENABLE_FIFO) {
+			/* emulated UARTs (Lucent Venus 167x) need two steps */
+			serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
+		}
+		serial_outp(up, UART_FCR, fcr);		/* set fcr */
+	}
+	serial8250_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void
+serial8250_pm(struct uart_port *port, unsigned int state,
+	      unsigned int oldstate)
+{
+	struct uart_8250_port *p = (struct uart_8250_port *)port;
+
+	serial8250_set_sleep(p, state != 0);
+
+	if (p->pm)
+		p->pm(port, state, oldstate);
+}
+
+/*
+ * Resource handling.
+ */
+static int serial8250_request_std_resource(struct uart_8250_port *up)
+{
+	unsigned int size = 8 << up->port.regshift;
+	int ret = 0;
+
+	switch (up->port.iotype) {
+	case UPIO_AU:
+		size = 0x100000;
+		/* fall thru */
+	case UPIO_MEM32:
+	case UPIO_MEM:
+		if (!up->port.mapbase)
+			break;
+
+		if (!request_mem_region(up->port.mapbase, size, "serial")) {
+			ret = -EBUSY;
+			break;
+		}
+
+		if (up->port.flags & UPF_IOREMAP) {
+			up->port.membase = ioremap(up->port.mapbase, size);
+			if (!up->port.membase) {
+				release_mem_region(up->port.mapbase, size);
+				ret = -ENOMEM;
+			}
+		}
+		break;
+
+	case UPIO_HUB6:
+	case UPIO_PORT:
+		if (!request_region(up->port.iobase, size, "serial"))
+			ret = -EBUSY;
+		break;
+	}
+	return ret;
+}
+
+static void serial8250_release_std_resource(struct uart_8250_port *up)
+{
+	unsigned int size = 8 << up->port.regshift;
+
+	switch (up->port.iotype) {
+	case UPIO_AU:
+		size = 0x100000;
+		/* fall thru */
+	case UPIO_MEM32:
+	case UPIO_MEM:
+		if (!up->port.mapbase)
+			break;
+
+		if (up->port.flags & UPF_IOREMAP) {
+			iounmap(up->port.membase);
+			up->port.membase = NULL;
+		}
+
+		release_mem_region(up->port.mapbase, size);
+		break;
+
+	case UPIO_HUB6:
+	case UPIO_PORT:
+		release_region(up->port.iobase, size);
+		break;
+	}
+}
+
+static int serial8250_request_rsa_resource(struct uart_8250_port *up)
+{
+	unsigned long start = UART_RSA_BASE << up->port.regshift;
+	unsigned int size = 8 << up->port.regshift;
+	int ret = -EINVAL;
+
+	switch (up->port.iotype) {
+	case UPIO_HUB6:
+	case UPIO_PORT:
+		start += up->port.iobase;
+		if (request_region(start, size, "serial-rsa"))
+			ret = 0;
+		else
+			ret = -EBUSY;
+		break;
+	}
+
+	return ret;
+}
+
+static void serial8250_release_rsa_resource(struct uart_8250_port *up)
+{
+	unsigned long offset = UART_RSA_BASE << up->port.regshift;
+	unsigned int size = 8 << up->port.regshift;
+
+	switch (up->port.iotype) {
+	case UPIO_HUB6:
+	case UPIO_PORT:
+		release_region(up->port.iobase + offset, size);
+		break;
+	}
+}
+
+static void serial8250_release_port(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	serial8250_release_std_resource(up);
+	if (up->port.type == PORT_RSA)
+		serial8250_release_rsa_resource(up);
+}
+
+static int serial8250_request_port(struct uart_port *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	int ret = 0;
+
+	ret = serial8250_request_std_resource(up);
+
+	return ret;
+}
+
+static void serial8250_config_port(struct uart_port *port, int flags)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	int probeflags = PROBE_ANY;
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = serial8250_request_std_resource(up);
+	if (ret < 0)
+		return;
+
+	ret = serial8250_request_rsa_resource(up);
+	if (ret < 0)
+		probeflags &= ~PROBE_RSA;
+
+	if (flags & UART_CONFIG_TYPE)
+		autoconfig(up, probeflags);
+	if (up->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)
+		autoconfig_irq(up);
+
+	if (up->port.type != PORT_RSA && probeflags & PROBE_RSA)
+		serial8250_release_rsa_resource(up);
+	if (up->port.type == PORT_UNKNOWN)
+		serial8250_release_std_resource(up);
+}
+
+static int
+serial8250_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->irq >= NR_IRQS || ser->irq < 0 ||
+	    ser->baud_base < 9600 || ser->type < PORT_UNKNOWN ||
+	    ser->type >= ARRAY_SIZE(uart_config) || ser->type == PORT_CIRRUS ||
+	    ser->type == PORT_STARTECH)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *
+serial8250_type(struct uart_port *port)
+{
+	int type = port->type;
+
+	if (type >= ARRAY_SIZE(uart_config))
+		type = 0;
+	return uart_config[type].name;
+}
+
+static struct uart_ops serial8250_pops = {
+	.tx_empty	= serial8250_tx_empty,
+	.set_mctrl	= serial8250_set_mctrl,
+	.get_mctrl	= serial8250_get_mctrl,
+	.stop_tx	= serial8250_stop_tx,
+	.start_tx	= serial8250_start_tx,
+	.stop_rx	= serial8250_stop_rx,
+	.enable_ms	= serial8250_enable_ms,
+	.break_ctl	= serial8250_break_ctl,
+	.startup	= serial8250_startup,
+	.shutdown	= serial8250_shutdown,
+	.set_termios	= serial8250_set_termios,
+	.pm		= serial8250_pm,
+	.type		= serial8250_type,
+	.release_port	= serial8250_release_port,
+	.request_port	= serial8250_request_port,
+	.config_port	= serial8250_config_port,
+	.verify_port	= serial8250_verify_port,
+};
+
+static struct uart_8250_port serial8250_ports[UART_NR];
+
+static void __init serial8250_isa_init_ports(void)
+{
+	struct uart_8250_port *up;
+	static int first = 1;
+	int i;
+
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < nr_uarts; i++) {
+		struct uart_8250_port *up = &serial8250_ports[i];
+
+		up->port.line = i;
+		spin_lock_init(&up->port.lock);
+
+		init_timer(&up->timer);
+		up->timer.function = serial8250_timeout;
+
+		up->port.ops = &serial8250_pops;
+	}
+
+	for (i = 0, up = serial8250_ports;
+	     i < ARRAY_SIZE(old_serial_port) && i < nr_uarts;
+	     i++, up++) {
+		up->port.iobase   = old_serial_port[i].port;
+		up->port.irq      = irq_canonicalize(old_serial_port[i].irq);
+		up->port.uartclk  = old_serial_port[i].baud_base * 16;
+		up->port.flags    = old_serial_port[i].flags;
+		up->port.hub6     = old_serial_port[i].hub6;
+		up->port.membase  = old_serial_port[i].iomem_base;
+		up->port.iotype   = old_serial_port[i].io_type;
+		up->port.regshift = old_serial_port[i].iomem_reg_shift;
+		if (share_irqs)
+			up->port.flags |= UPF_SHARE_IRQ;
+	}
+}
+
+static void __init
+serial8250_register_ports(struct uart_driver *drv, struct device *dev)
+{
+	int i;
+
+	serial8250_isa_init_ports();
+
+	for (i = 0; i < nr_uarts; i++) {
+		struct uart_8250_port *up = &serial8250_ports[i];
+
+		up->port.dev = dev;
+		uart_add_one_port(drv, &up->port);
+	}
+}
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+
+#define BOTH_EMPTY (UART_TRSR_TEMT | UART_TRSR_THRE)
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct uart_8250_port *up, int bits)
+{
+	unsigned int status, status1, tmout = 10000;
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	do {
+		status = serial_in(up, UART_LSR);
+		status1 = serial_in(up, UART_TRSR);
+
+		if (status & UART_LSR_BI)
+			up->lsr_break_flag = UART_LSR_BI;
+
+		if (--tmout == 0)
+			break;
+		udelay(1);
+	} while ((status1 & bits) != bits);
+
+	/* Wait up to 1s for flow control if necessary */
+	if (up->port.flags & UPF_CONS_FLOW) {
+		tmout = 1000000;
+		while (!(serial_in(up, UART_MSR) & UART_MSR_CTS) && --tmout) {
+			udelay(1);
+			touch_nmi_watchdog();
+		}
+	}
+}
+
+static void serial8250_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+
+	wait_for_xmitr(up, UART_TRSR_THRE);
+	serial_out(up, UART_TX, ch);
+}
+
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+serial8250_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_8250_port *up = &serial8250_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	touch_nmi_watchdog();
+
+	local_irq_save(flags);
+	if (up->port.sysrq) {
+		/* serial8250_handle_port() already took the lock */
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&up->port.lock);
+	} else
+		spin_lock(&up->port.lock);
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_IER);
+
+		serial_out(up, UART_IER, 0);
+
+	uart_console_write(&up->port, s, count, serial8250_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(up, BOTH_EMPTY);
+	serial_out(up, UART_IER, ier & ~UART_IIR_MASK_INT);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init serial8250_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= nr_uarts)
+		co->index = 0;
+	port = &serial8250_ports[co->index].port;
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static int serial8250_console_early_setup(void)
+{
+	return serial8250_find_port_for_earlycon();
+}
+
+static struct uart_driver serial8250_reg;
+static struct console serial8250_console = {
+	.name		= "ttyS",
+	.write		= serial8250_console_write,
+	.device		= uart_console_device,
+	.setup		= serial8250_console_setup,
+	.early_setup	= serial8250_console_early_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial8250_reg,
+};
+
+static int __init serial8250_console_init(void)
+{
+	if (nr_uarts > UART_NR)
+		nr_uarts = UART_NR;
+
+	serial8250_isa_init_ports();
+	register_console(&serial8250_console);
+	return 0;
+}
+console_initcall(serial8250_console_init);
+
+int serial8250_find_port(struct uart_port *p)
+{
+	int line;
+	struct uart_port *port;
+
+	for (line = 0; line < nr_uarts; line++) {
+		port = &serial8250_ports[line].port;
+		if (uart_match_port(p, port))
+			return line;
+	}
+	return -ENODEV;
+}
+
+#define SERIAL8250_CONSOLE	&serial8250_console
+#else
+#define SERIAL8250_CONSOLE	NULL
+#endif
+
+static struct uart_driver serial8250_reg = {
+	.owner			= THIS_MODULE,
+	.driver_name		= "serial",
+	.dev_name		= "ttyS",
+	.major			= TTY_MAJOR,
+	.minor			= 64,
+	.nr			= UART_NR,
+	.cons			= SERIAL8250_CONSOLE,
+};
+
+/*
+ * early_serial_setup - early registration for 8250 ports
+ *
+ * Setup an 8250 port structure prior to console initialisation.  Use
+ * after console initialisation will cause undefined behaviour.
+ */
+int __init early_serial_setup(struct uart_port *port)
+{
+	if (port->line >= ARRAY_SIZE(serial8250_ports))
+		return -ENODEV;
+
+	serial8250_isa_init_ports();
+	serial8250_ports[port->line].port	= *port;
+	serial8250_ports[port->line].port.ops	= &serial8250_pops;
+	return 0;
+}
+
+/**
+ *	serial8250_suspend_port - suspend one serial port
+ *	@line:  serial line number
+ *
+ *	Suspend one serial port.
+ */
+void serial8250_suspend_port(int line)
+{
+	uart_suspend_port(&serial8250_reg, &serial8250_ports[line].port);
+}
+
+/**
+ *	serial8250_resume_port - resume one serial port
+ *	@line:  serial line number
+ *
+ *	Resume one serial port.
+ */
+void serial8250_resume_port(int line)
+{
+	uart_resume_port(&serial8250_reg, &serial8250_ports[line].port);
+}
+
+/*
+ * Register a set of serial devices attached to a platform device.  The
+ * list is terminated with a zero flags entry, which means we expect
+ * all entries to have at least UPF_BOOT_AUTOCONF set.
+ */
+static int __devinit serial8250_probe(struct platform_device *dev)
+{
+	struct plat_serial8250_port *p = dev->dev.platform_data;
+	struct uart_port port;
+	int ret, i;
+
+	memset(&port, 0, sizeof(struct uart_port));
+
+	for (i = 0; p && p->flags != 0; p++, i++) {
+		port.iobase	= p->iobase;
+		port.membase	= p->membase;
+		port.irq	= p->irq;
+		port.uartclk	= p->uartclk;
+		port.regshift	= p->regshift;
+		port.iotype	= p->iotype;
+		port.flags	= p->flags;
+		port.mapbase	= p->mapbase;
+		port.hub6	= p->hub6;
+		port.dev	= &dev->dev;
+		if (share_irqs)
+			port.flags |= UPF_SHARE_IRQ;
+		ret = serial8250_register_port(&port);
+		if (ret < 0) {
+			dev_err(&dev->dev, "unable to register port at index %d "
+				"(IO%lx MEM%llx IRQ%d): %d\n", i,
+				p->iobase, (unsigned long long)p->mapbase,
+				p->irq, ret);
+		}
+	}
+	return 0;
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int __exit serial8250_remove(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i < nr_uarts; i++) {
+		struct uart_8250_port *up = &serial8250_ports[i];
+
+		if (up->port.dev == &dev->dev)
+			serial8250_unregister_port(i);
+	}
+	return 0;
+}
+
+static int serial8250_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_8250_port *up = &serial8250_ports[i];
+
+		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+			uart_suspend_port(&serial8250_reg, &up->port);
+	}
+
+	return 0;
+}
+
+static int serial8250_resume(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_8250_port *up = &serial8250_ports[i];
+
+		if (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)
+			uart_resume_port(&serial8250_reg, &up->port);
+	}
+
+	return 0;
+}
+
+static struct platform_driver serial8250_isa_driver = {
+	.probe		= serial8250_probe,
+	.remove		= __exit_p(serial8250_remove),
+	.suspend	= serial8250_suspend,
+	.resume		= serial8250_resume,
+	.driver		= {
+		.name	= "serial8250",
+		.owner	= THIS_MODULE,
+	},
+};
+
+/*
+ * This "device" covers _all_ ISA 8250-compatible serial devices listed
+ * in the table in include/asm/serial.h
+ */
+static struct platform_device *serial8250_isa_devs;
+
+/*
+ * serial8250_register_port and serial8250_unregister_port allows for
+ * 16x50 serial ports to be configured at run-time, to support PCMCIA
+ * modems and PCI multiport cards.
+ */
+static DEFINE_MUTEX(serial_mutex);
+
+static struct uart_8250_port *serial8250_find_match_or_unused(struct uart_port *port)
+{
+	int i;
+
+	/*
+	 * First, find a port entry which matches.
+	 */
+	for (i = 0; i < nr_uarts; i++)
+		if (uart_match_port(&serial8250_ports[i].port, port))
+			return &serial8250_ports[i];
+
+	/*
+	 * We didn't find a matching entry, so look for the first
+	 * free entry.  We look for one which hasn't been previously
+	 * used (indicated by zero iobase).
+	 */
+	for (i = 0; i < nr_uarts; i++)
+		if (serial8250_ports[i].port.type == PORT_UNKNOWN &&
+		    serial8250_ports[i].port.iobase == 0)
+			return &serial8250_ports[i];
+
+	/*
+	 * That also failed.  Last resort is to find any entry which
+	 * doesn't have a real port associated with it.
+	 */
+	for (i = 0; i < nr_uarts; i++)
+		if (serial8250_ports[i].port.type == PORT_UNKNOWN)
+			return &serial8250_ports[i];
+
+	return NULL;
+}
+
+/**
+ *	serial8250_register_port - register a serial port
+ *	@port: serial port template
+ *
+ *	Configure the serial port specified by the request. If the
+ *	port exists and is in use, it is hung up and unregistered
+ *	first.
+ *
+ *	The port is then probed and if necessary the IRQ is autodetected
+ *	If this fails an error is returned.
+ *
+ *	On success the port is ready to use and the line number is returned.
+ */
+int serial8250_register_port(struct uart_port *port)
+{
+	struct uart_8250_port *uart;
+	int ret = -ENOSPC;
+
+	if (port->uartclk == 0)
+		return -EINVAL;
+
+	mutex_lock(&serial_mutex);
+
+	uart = serial8250_find_match_or_unused(port);
+	if (uart) {
+		uart_remove_one_port(&serial8250_reg, &uart->port);
+
+		uart->port.iobase   = port->iobase;
+		uart->port.membase  = port->membase;
+		uart->port.irq      = port->irq;
+		uart->port.uartclk  = port->uartclk;
+		uart->port.fifosize = port->fifosize;
+		uart->port.regshift = port->regshift;
+		uart->port.iotype   = port->iotype;
+		uart->port.flags    = port->flags | UPF_BOOT_AUTOCONF;
+		uart->port.mapbase  = port->mapbase;
+		if (port->dev)
+			uart->port.dev = port->dev;
+
+		ret = uart_add_one_port(&serial8250_reg, &uart->port);
+		if (ret == 0)
+			ret = uart->port.line;
+	}
+	mutex_unlock(&serial_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(serial8250_register_port);
+
+/**
+ *	serial8250_unregister_port - remove a 16x50 serial port at runtime
+ *	@line: serial line number
+ *
+ *	Remove one serial port.  This may not be called from interrupt
+ *	context.  We hand the port back to the our control.
+ */
+void serial8250_unregister_port(int line)
+{
+	struct uart_8250_port *uart = &serial8250_ports[line];
+
+	mutex_lock(&serial_mutex);
+	uart_remove_one_port(&serial8250_reg, &uart->port);
+	if (serial8250_isa_devs) {
+		uart->port.flags &= ~UPF_BOOT_AUTOCONF;
+		uart->port.type = PORT_UNKNOWN;
+		uart->port.dev = &serial8250_isa_devs->dev;
+		uart_add_one_port(&serial8250_reg, &uart->port);
+	} else {
+		uart->port.dev = NULL;
+	}
+	mutex_unlock(&serial_mutex);
+}
+EXPORT_SYMBOL(serial8250_unregister_port);
+
+static int __init serial8250_init(void)
+{
+	int ret, i;
+
+	if (nr_uarts > UART_NR)
+		nr_uarts = UART_NR;
+
+	printk(KERN_INFO "Serial: 8250/16550 driver $Revision: 1.90 $ "
+		"%d ports, IRQ sharing %sabled\n", nr_uarts,
+		share_irqs ? "en" : "dis");
+
+	for (i = 0; i < NR_IRQS; i++)
+		spin_lock_init(&irq_lists[i].lock);
+
+	ret = uart_register_driver(&serial8250_reg);
+	if (ret)
+		goto out;
+
+	serial8250_isa_devs = platform_device_alloc("serial8250",
+						    PLAT8250_DEV_LEGACY);
+	if (!serial8250_isa_devs) {
+		ret = -ENOMEM;
+		goto unreg_uart_drv;
+	}
+
+	ret = platform_device_add(serial8250_isa_devs);
+	if (ret)
+		goto put_dev;
+
+	serial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);
+
+	ret = platform_driver_register(&serial8250_isa_driver);
+	if (ret == 0)
+		goto out;
+
+	platform_device_del(serial8250_isa_devs);
+ put_dev:
+	platform_device_put(serial8250_isa_devs);
+ unreg_uart_drv:
+	uart_unregister_driver(&serial8250_reg);
+ out:
+	return ret;
+}
+
+static void __exit serial8250_exit(void)
+{
+	struct platform_device *isa_dev = serial8250_isa_devs;
+
+	/*
+	 * This tells serial8250_unregister_port() not to re-register
+	 * the ports (thereby making serial8250_isa_driver permanently
+	 * in use.)
+	 */
+	serial8250_isa_devs = NULL;
+
+	platform_driver_unregister(&serial8250_isa_driver);
+	platform_device_unregister(isa_dev);
+
+	uart_unregister_driver(&serial8250_reg);
+}
+
+module_init(serial8250_init);
+module_exit(serial8250_exit);
+
+EXPORT_SYMBOL(serial8250_suspend_port);
+EXPORT_SYMBOL(serial8250_resume_port);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic 8250/16x50 serial driver $Revision: 1.90 $");
+
+module_param(share_irqs, uint, 0644);
+MODULE_PARM_DESC(share_irqs, "Share IRQs with other non-8250/16x50 devices"
+	" (unsafe)");
+
+module_param(nr_uarts, uint, 0644);
+MODULE_PARM_DESC(nr_uarts, "Maximum number of UARTs supported. (1-" __MODULE_STRING(CONFIG_SERIAL_8250_NR_UARTS) ")");
+
+#ifdef CONFIG_SERIAL_8250_RSA
+module_param_array(probe_rsa, ulong, &probe_rsa_count, 0444);
+MODULE_PARM_DESC(probe_rsa, "Probe I/O ports for RSA");
+#endif
+MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
diff -ruaN linux-2.6.31/drivers/serial/Makefile linux-2.6/drivers/serial/Makefile
--- linux-2.6.31/drivers/serial/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/serial/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -14,7 +14,11 @@
 obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
 obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 
+ifeq ($(CONFIG_ARCH_LF1000),y)
+obj-$(CONFIG_SERIAL_8250) += 8250-lf1000.o
+else
 obj-$(CONFIG_SERIAL_8250) += 8250.o
+endif
 obj-$(CONFIG_SERIAL_8250_PNP) += 8250_pnp.o
 obj-$(CONFIG_SERIAL_8250_GSC) += 8250_gsc.o
 obj-$(CONFIG_SERIAL_8250_PCI) += 8250_pci.o
diff -ruaN linux-2.6.31/drivers/spi/Kconfig linux-2.6/drivers/spi/Kconfig
--- linux-2.6.31/drivers/spi/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/spi/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -123,6 +123,39 @@
 	  This enables using the Freescale iMX SPI controller in master
 	  mode.
 
+config SPI_LF1000
+	bool "LF1000 SPI controller"
+	depends on ARCH_LF1000
+	help
+	  This enables using the LF1000 SPI controller in master mode.
+
+config SPI_LF1000_CHANNEL_0
+	tristate "LF1000 SPI Channel 0"
+	depends on SPI_LF1000
+	default y
+	help
+	  Enable channel 0 of the LF1000 SPI controller.  On all current
+	  platforms, this is used for LCD control, so say Y.
+
+config SPI_LF1000_CHANNEL_1
+	tristate "LF1000 SPI Channel 1"
+	depends on SPI_LF1000
+	default n
+	help
+	  Enable channel 1 of the LF1000 SPI controller.  On all current
+	  platforms, these signals are wired as GPIOs to push-buttons, so
+	  say N.
+
+config SPI_LF1000_CHANNEL_2
+	tristate "LF1000 SPI Channel 2"
+	depends on SPI_LF1000
+	default n
+	help
+	  Enable channel 2 of the LF1000 SPI controller.  On all current
+	  platforms, these signals are routed to the cartridge connector
+	  for potential future expansion, but conflicts with the GPIOs
+	  allotted for cartridge identification, so say N.
+
 config SPI_LM70_LLP
 	tristate "Parallel port adapter for LM70 eval board (DEVELOPMENT)"
 	depends on PARPORT && EXPERIMENTAL
diff -ruaN linux-2.6.31/drivers/spi/Makefile linux-2.6/drivers/spi/Makefile
--- linux-2.6.31/drivers/spi/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/spi/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -31,6 +31,7 @@
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_LF1000)		+= spi_lf1000.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff -ruaN linux-2.6.31/drivers/spi/README.lf1000 linux-2.6/drivers/spi/README.lf1000
--- linux-2.6.31/drivers/spi/README.lf1000	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/spi/README.lf1000	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,10 @@
+###############################################################################
+# LF1000 SPI Bus Driver                                                       #
+#                                                                             #
+# 06/07/2007 by Scott Esters <sesters@leapfrog.com>                           #
+###############################################################################
+
+I2S driver documentation and notes.
+
+1.  Build the code by recompling the linux kernel
+2.  You can show registers with 'cat /proc/driver/audio_spi'
diff -ruaN linux-2.6.31/drivers/spi/spi_lf1000.c linux-2.6/drivers/spi/spi_lf1000.c
--- linux-2.6.31/drivers/spi/spi_lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/spi/spi_lf1000.c	2011-01-04 14:07:51.000000000 -0800
@@ -0,0 +1,671 @@
+/* 
+ * drivers/spi/spi_lf1000.c
+ *
+ * LF1000 SPI/SSP Driver
+ *
+ * Copyright 2009 LeapFrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ * Andrey Yurovsky <andrey@cozybit.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/spi/spi.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <linux/lf1000/spi_ioctl.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+#include <mach/common.h>
+#include <mach/gpio.h>
+#include <mach/platform.h>
+
+#include "spi_lf1000_hal.h"
+#include "spi_lf1000.h"
+
+#define MIN(a,b) \
+	(( (a) < (b) ) ? (a) : (b) )
+
+#define MAX(a,b) \
+	(( (a) > (b) ) ? (a) : (b) )
+
+#define LF1000_SPI_MAX_FREQ		25000000
+#define LF1000_SPI_FIFO_DEPTH		32
+
+extern void lf1000_dpc_register_spi(struct spi_device *slave);
+
+static int lf1000_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t);
+
+struct lf1000_pin_cfg {
+	const enum gpio_port		port;
+	const enum gpio_pin		pin;
+	const enum gpio_function	fn;
+};
+
+struct lf1000_spi_pins {
+	const struct lf1000_pin_cfg	clk;
+	const struct lf1000_pin_cfg	frm;
+	const struct lf1000_pin_cfg	rx;
+	const struct lf1000_pin_cfg	tx;
+};
+
+static const struct lf1000_spi_pins pins[] = {
+	[0] = {
+		.clk	=	{ GPIO_PORT_B, GPIO_PIN13, GPIO_ALT1 },
+		.frm	=	{ GPIO_PORT_B, GPIO_PIN12, GPIO_ALT1 },
+		.rx	=	{ GPIO_PORT_B, GPIO_PIN14, GPIO_ALT1 },
+		.tx	=	{ GPIO_PORT_B, GPIO_PIN15, GPIO_ALT1 },
+	},
+	[1] = {
+		.clk	=	{ GPIO_PORT_C, GPIO_PIN4, GPIO_ALT1 },
+		.frm	=	{ GPIO_PORT_C, GPIO_PIN3, GPIO_ALT1 },
+		.rx	=	{ GPIO_PORT_C, GPIO_PIN5, GPIO_ALT1 },
+		.tx	=	{ GPIO_PORT_C, GPIO_PIN6, GPIO_ALT1 },
+	},
+	[2] = {
+		.clk	=	{ GPIO_PORT_B, GPIO_PIN0, GPIO_ALT2 },
+		.frm	=	{ GPIO_PORT_B, GPIO_PIN5, GPIO_ALT2 },
+		.rx	=	{ GPIO_PORT_B, GPIO_PIN1, GPIO_ALT2 },
+		.tx	=	{ GPIO_PORT_B, GPIO_PIN2, GPIO_ALT2 },
+	},
+};
+
+struct lf1000_spi {
+	void __iomem		*base;
+	unsigned long		phys;
+	int			irq;		// assigned IRQ number
+
+	spinlock_t		lock;
+	struct work_struct	work;		// bottom half
+	struct list_head	msg_queue;
+	
+	struct spi_master	*master;
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*proc_port;
+#endif
+};
+
+static struct workqueue_struct *lf1000_spi_wq;
+
+/*******************
+ * sysfs Interface *
+ *******************/
+#ifdef CONFIG_SPI_DEBUG
+static ssize_t show_registers(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t len = 0;
+	struct spi_master	*master;
+	struct lf1000_spi	*lf1000spi;
+
+	master = dev_get_drvdata(dev);
+	lf1000spi = spi_master_get_devdata(master);
+
+	len += sprintf(buf+len,"SPI_CONT0  = 0x%04X\n",
+		ioread16(lf1000spi->base+SSPSPICONT0));
+	len += sprintf(buf+len,"SPI_CONT1  = 0x%04X\n",
+		ioread16(lf1000spi->base+SSPSPICONT1));
+	len += sprintf(buf+len,"SPI_DATA   = 0x%04X\n",
+		ioread16(lf1000spi->base+SSPSPIDATA));
+	len += sprintf(buf+len,"SPI_STATE  = 0x%04X\n",
+		ioread16(lf1000spi->base+SSPSPISTATE));
+	len += sprintf(buf+len,"SPI_CLKENB = 0x%08X\n",
+		ioread32(lf1000spi->base+SSPSPICLKENB));
+	len += sprintf(buf+len,"SPI_CLKGEN = 0x%04X\n",
+		ioread16(lf1000spi->base+SSPSPICLKGEN));
+
+	return len;
+}
+
+static DEVICE_ATTR(registers, S_IRUSR|S_IRGRP, show_registers, NULL);
+
+static struct attribute *spi_attributes[] = {
+	&dev_attr_registers.attr,
+	NULL
+};
+
+static struct attribute_group spi_attr_group = {
+	.attrs = spi_attributes
+};
+#endif /* CONFIG_SPI_DEBUG */
+
+/**********************
+ * Interrupt Handling *
+ *********************/
+static void lf1000_spi_interrupt(struct lf1000_spi *lf1000spi, u8 en) {
+	u16 reg = ioread16(lf1000spi->base+SSPSPISTATE);
+
+	if(en) {
+		BIT_SET(reg, IRQEENB);			// RX, TX completed
+		BIT_SET(reg, IRQWENB);			// TX Buffer Empty
+		BIT_SET(reg, IRQRENB);			// RX Buffer Full
+		BIT_SET(reg, IRQE);			// clear status bits
+		BIT_SET(reg, IRQW);
+		BIT_SET(reg, IRQR);
+	}
+	else {
+		BIT_CLR(reg, IRQEENB);			// RX, TX completed
+		BIT_CLR(reg, IRQWENB);			// TX Buffer Empty
+		BIT_CLR(reg, IRQRENB);			// RX Buffer Full
+	}
+	iowrite16(reg, lf1000spi->base+SSPSPISTATE);
+}
+
+static irqreturn_t lf1000_spi_irq(int irq, void *dev_id)
+{
+	struct spi_master	*master = dev_id;
+	struct lf1000_spi	*lf1000spi = spi_master_get_devdata(master);
+
+	u16 reg;
+
+	reg = ioread16(lf1000spi->base+SSPSPISTATE);
+	
+	if (IS_CLR(reg,IRQE)) {	/* interrupt not from SPI */
+		return(IRQ_NONE);
+	}
+
+	lf1000_spi_interrupt(lf1000spi, 0);
+//	wake_up_interruptible(&lf1000spi->intqueue);	/* wake any tasks */
+	return(IRQ_HANDLED);
+}
+
+static unsigned int
+lf1000_spi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
+{
+	struct lf1000_spi	*lf1000spi;
+	unsigned int		count, extra, tx_c, rx_c, chan;
+	int			c;
+	void __iomem		*txrx_reg, *status;
+
+	chan = spi->master->bus_num;
+	lf1000spi = spi_master_get_devdata(spi->master);
+	c = count = xfer->len;
+
+	txrx_reg = lf1000spi->base + SSPSPIDATA;
+	status = lf1000spi->base + SSPSPISTATE;
+
+	/*
+	 * Since SPI is full-duplex, we want to use as much of the LF1000
+	 * SPI TX FIFO as possible to prevent data starvation.  Some slaves
+	 * (e.g., SST25VF010A) expect a continuous command stream, and will
+	 * not recognize commands that are broken by rising CE#
+	 *
+	 * So, the strategy is to fill the TX FIFO as quickly as possible.
+	 * Meanwhile, the hardware is populating the RX FIFO, which the
+	 * driver can dump later.  This is in contrast to other SPI PIO
+	 * drivers which implement a write-read-write-read-... scheme, which
+	 * is undesirable as described above.
+	 */
+
+	/* wait for FIFOs */
+	while(IS_CLR(ioread16(status), WFFEMPTY) ) ;
+	while(IS_CLR(ioread16(status), RFFEMPTY) ) ioread16(txrx_reg);
+
+	if(spi->bits_per_word <= 8)
+	{
+		u8		*rx;
+		const u8	*tx;
+
+		rx = xfer->rx_buf;
+		tx = xfer->tx_buf;
+
+		do {
+			/* if we have more than a FIFO's worth to deal with */
+			extra = MAX(0, (c - LF1000_SPI_FIFO_DEPTH));
+			tx_c = rx_c = MIN(c, LF1000_SPI_FIFO_DEPTH);
+			c = extra;
+
+			tx_c--;
+
+			/* Fill Tx */
+			if(tx != NULL)
+			{
+				do {
+					iowrite8(*tx++, txrx_reg);
+				} while(tx_c--);
+
+			}
+			else
+			{
+				do {
+					iowrite8(0, txrx_reg);
+				} while (tx_c--);
+			}
+
+			/* Dump Rx */	
+			do
+			{
+				/* Wait for FIFOs to catch up */
+				while(IS_SET(ioread16(status), RFFEMPTY) ) ;
+				if(rx != NULL)
+				{
+					*rx++ = ioread8(txrx_reg);
+				}
+				else
+				{
+					ioread8(txrx_reg);
+				}
+				rx_c -= 1;
+			} while (rx_c);
+
+		} while(c);
+	}
+	else if(xfer->bits_per_word <= 16)
+	{
+		u16		*rx;
+		const u16	*tx;
+
+		rx = xfer->rx_buf;
+		tx = xfer->tx_buf;
+
+		do {
+			/* if we have more than a FIFO's worth to deal with */
+			extra = MAX(0, (c - LF1000_SPI_FIFO_DEPTH));
+			tx_c = rx_c = MIN(c, LF1000_SPI_FIFO_DEPTH);
+			c = extra;
+
+			/* Fill Tx */
+			do {
+				if(tx != NULL)
+				{
+					iowrite16(*tx++, txrx_reg);
+				}
+				else
+				{
+					iowrite16(0, txrx_reg);
+				}
+				tx_c -= 2;	/* bytes, not words */
+			} while (tx_c);
+
+			/* Dump Rx */	
+			do
+			{
+				/* Wait for FIFOs to catch up */
+				while(IS_SET(ioread16(status), RFFEMPTY) ) ;
+				if(rx != NULL)
+				{
+					*rx++ = ioread16(txrx_reg);
+				}
+				else
+				{
+					ioread16(txrx_reg);
+				}
+				rx_c -= 2;
+			} while (rx_c);
+
+		} while (c);
+	}
+
+	return count - c;
+}
+
+static void lf1000_spi_work(struct work_struct *work)
+{
+	struct lf1000_spi	*lf1000spi;
+
+	lf1000spi = container_of(work, struct lf1000_spi, work);
+	spin_lock_irq(&lf1000spi->lock);
+
+	while(!list_empty(&lf1000spi->msg_queue))
+	{
+		struct spi_message	*m;
+		struct spi_device	*spi;
+		struct spi_transfer	*t = NULL;
+		int			par_override = 0;
+		int			status = 0;
+		
+		m = container_of(lf1000spi->msg_queue.next, struct spi_message,
+		                 queue);
+
+		list_del_init(&m->queue);
+		spin_unlock_irq(&lf1000spi->lock);
+
+		spi = m->spi;
+
+		list_for_each_entry(t, &m->transfers, transfer_list)
+		{
+			if(t->tx_buf == NULL && t->rx_buf == NULL && t->len)
+			{
+				status = -EINVAL;
+				break;
+			}
+			if(par_override || t->speed_hz || t->bits_per_word)
+			{
+				status = lf1000_spi_setup_transfer(spi, t);
+				if(status < 0)
+					break;
+				if(!t->speed_hz && !t->bits_per_word)
+					par_override = 0;
+			}
+
+			if(t->len)
+			{
+				unsigned	count;
+				count = lf1000_spi_txrx_pio(spi, t);
+
+				if(count != t->len)
+				{
+					status = -EIO;
+					break;
+				}
+			}
+
+			if(t->delay_usecs)
+				udelay(t->delay_usecs);
+
+		}
+
+		if(par_override)
+		{
+			par_override = 0;
+			status = lf1000_spi_setup_transfer(spi, NULL);
+		}
+
+		m->status = status;
+		m->complete(m->context);
+
+		spin_lock_irq(&lf1000spi->lock);
+	}
+
+	spin_unlock_irq(&lf1000spi->lock);
+}
+
+static int lf1000_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct lf1000_spi 	*lf1000spi;
+	u8			word_len = spi->bits_per_word;
+	u16			fmt;
+
+	lf1000spi = spi_master_get_devdata(spi->master);
+
+	if(t != NULL && t->bits_per_word)
+		word_len = t->bits_per_word;
+
+	fmt = ioread16(lf1000spi->base+SSPSPICONT1);
+
+	if(spi->mode & SPI_CPOL)
+		BIT_CLR(fmt, SCLKPOL);
+	else
+		BIT_SET(fmt, SCLKPOL);
+
+	if(spi->mode & SPI_CPHA)
+		BIT_SET(fmt, SCLKSH);
+	else
+		BIT_CLR(fmt, SCLKSH);
+
+	iowrite16(fmt, lf1000spi->base+SSPSPICONT1);
+
+	fmt = ioread16(lf1000spi->base+SSPSPICONT0);
+
+	fmt &= ~NUMBIT_MASK;
+	fmt |= NUMBIT_MASK & ((word_len-1) << NUMBIT);
+	
+	iowrite16(fmt, lf1000spi->base+SSPSPICONT0);
+
+	return 0;
+}
+static int lf1000_spi_setup(struct spi_device *spi)
+{
+	struct lf1000_spi *lf1000spi;
+	int ret = 0;
+
+	if(spi->bits_per_word == 0)
+		spi->bits_per_word = 8;
+	else if (spi->bits_per_word < 8 || spi->bits_per_word > 16) {
+		return -EINVAL;
+	}
+
+	lf1000spi = spi_master_get_devdata(spi->master);
+
+	ret = lf1000_spi_setup_transfer(spi, NULL);
+
+	return ret;
+}
+
+static int lf1000_spi_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct lf1000_spi	*lf1000spi;
+	unsigned long		flags;
+	struct spi_transfer	*t;
+
+	m->actual_length = 0;
+	m->status = 0;
+
+	/* reject invalid messages and transfers */
+	if (list_empty(&m->transfers) || !m->complete)
+		return -EINVAL;
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		const void	*tx_buf = t->tx_buf;
+		void		*rx_buf = t->rx_buf;
+		unsigned	len = t->len;
+
+		if( t->speed_hz > LF1000_SPI_MAX_FREQ ||
+		    (len && !(rx_buf || tx_buf)) ||
+		    (t->bits_per_word && (t->bits_per_word < 8 ||
+		                          t->bits_per_word > 16))) {
+			return -EINVAL;
+		}
+	}
+
+	/* parameters are valid.  queue work */
+	lf1000spi = spi_master_get_devdata(spi->master);
+
+	spin_lock_irqsave(&lf1000spi->lock, flags);
+	list_add_tail(&m->queue, &lf1000spi->msg_queue);
+	queue_work(lf1000_spi_wq, &lf1000spi->work);
+	spin_unlock_irqrestore(&lf1000spi->lock, flags);
+
+	return 0;
+}
+
+static void lf1000_spi_cleanup(struct spi_device *spi)
+{
+}
+
+
+/****************************************
+ *  module functions and initialization *
+ ****************************************/
+
+static int lf1000_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master	*master;
+	struct lf1000_spi	*lf1000spi;
+	int			ret = 0, chan;
+	int			div;
+	struct resource		*res;
+
+	master = spi_alloc_master(&pdev->dev, sizeof *lf1000spi);
+	if(master == NULL)
+	{
+		return -ENOMEM;
+	}
+
+	master->bus_num = chan = pdev->id;
+	master->setup = lf1000_spi_setup;
+	master->transfer = lf1000_spi_transfer;
+	master->cleanup = lf1000_spi_cleanup;
+	master->num_chipselect = 1;
+
+	platform_set_drvdata(pdev, master);
+
+	lf1000spi = spi_master_get_devdata(master);
+	lf1000spi->master = master;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!res) {
+		printk(KERN_ERR "spi: failed to get resource\n");
+		ret = -ENODEV;
+		goto fail_resource;
+	}
+
+	if(!request_mem_region(res->start, (res->end - res->start)+1,
+				"lf1000-spi")) {
+		printk(KERN_ERR "spi: failed to map region\n");
+		ret = -EBUSY;
+		goto fail_request;
+	}
+
+	lf1000spi->phys = res->start;
+	lf1000spi->base = ioremap_nocache(res->start, (res->end - res->start)+1);
+	if(lf1000spi->base == NULL) {
+		printk(KERN_ERR "spi: failed to ioremap\n");
+		ret = -ENOMEM;
+		goto fail_remap;
+	}
+
+	INIT_WORK(&lf1000spi->work, lf1000_spi_work);
+
+	spin_lock_init(&lf1000spi->lock);
+	INIT_LIST_HEAD(&lf1000spi->msg_queue);
+
+	div = lf1000_CalcDivider(get_pll_freq(SPI_CLK_SRC), SPI_SRC_HZ);
+	if(div < 0) {
+		printk(KERN_ERR "spi: failed to find a clock divider!\n");
+		return -EFAULT;
+	}
+
+	/* set SPI for 1 MHz devices */
+	iowrite16(((div-1)<<SPI_CLKDIV)|(SPI_CLK_SRC<<SPI_CLKSRCSEL), 
+			lf1000spi->base+SSPSPICLKGEN);
+	/* start clock generation */
+	iowrite32((1<<SPI_PCLKMODE)|(1<<SPI_CLKGENENB), 
+			lf1000spi->base+SSPSPICLKENB);
+	/* output only for transmission, enable, 16 bits, divide internal 
+	   clock by 20 to get ~1MHz */
+	iowrite16((0<<ZENB)|(0<<RXONLY)|(1<<ENB)|((16-1)<<NUMBIT)|(20<<DIVCNT),
+		  lf1000spi->base+SSPSPICONT0);
+	/* invert SPI clock, Format B, SPI type */
+	iowrite16((0<<SCLKPOL)|(1<<SCLKSH)|(1<<TYPE), lf1000spi->base+SSPSPICONT1);
+	/* clear status flags */
+	iowrite16(0x0000, lf1000spi->base+SSPSPISTATE);
+
+	/* configure SPI IO pins */
+	gpio_configure_pin( pins[chan].tx.port,
+	                    pins[chan].tx.pin,
+	                    pins[chan].tx.fn, 1, 0, 0);
+	gpio_configure_pin( pins[chan].rx.port,
+	                    pins[chan].rx.pin,
+	                    pins[chan].rx.fn, 0, 0, 0);
+	gpio_configure_pin( pins[chan].clk.port,
+	                    pins[chan].clk.pin,
+	                    pins[chan].clk.fn, 1, 0, 0);
+	gpio_configure_pin( pins[chan].frm.port,
+	                    pins[chan].frm.pin,
+	                    pins[chan].frm.fn, 1, 0, 1);
+
+	lf1000spi->irq = platform_get_irq(pdev, 0);
+	if(lf1000spi->irq < 0) {
+		printk(KERN_ERR "spi: failed to get an IRQ\n");
+		ret = lf1000spi->irq;
+		goto fail_irq;
+	}
+	ret = request_irq(lf1000spi->irq, lf1000_spi_irq, IRQF_DISABLED|IRQF_SAMPLE_RANDOM,
+			"spi", master);
+	if(ret) {
+		printk(KERN_INFO "spi: requesting IRQ failed\n");
+		goto fail_irq;
+	}
+
+#ifdef CONFIG_SPI_DEBUG
+	sysfs_create_group(&pdev->dev.kobj, &spi_attr_group);
+#endif
+
+	spi_register_master(master);
+
+	return 0;
+
+fail_irq:
+	iounmap(lf1000spi->base);
+fail_remap:
+	release_mem_region(res->start, (res->end - res->start) + 1);
+fail_request:
+fail_resource:
+	spi_master_put(master);
+	return ret;
+}
+
+static int lf1000_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master	*master;
+	struct lf1000_spi	*lf1000spi;
+	struct resource *res  = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	master = platform_get_drvdata(pdev);
+	lf1000spi = spi_master_get_devdata(master);
+
+	flush_workqueue(lf1000_spi_wq);
+	destroy_workqueue(lf1000_spi_wq);
+
+#ifdef CONFIG_SPI_DEBUG
+	sysfs_remove_group(&pdev->dev.kobj, &spi_attr_group);
+#endif
+	if(lf1000spi->irq != -1)
+		free_irq(lf1000spi->irq, master);
+
+	if(lf1000spi->base != NULL)
+		iounmap(lf1000spi->base);
+
+	release_mem_region(res->start, (res->end - res->start) + 1);
+	spi_unregister_master(master);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int lf1000_spi_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+#else
+#define lf1000_spi_suspend NULL
+#define lf1000_spi_resume NULL
+#endif
+
+static struct platform_driver lf1000_spi_driver = {
+	.driver		= {
+		.name	= "lf1000-spi",
+		.owner	= THIS_MODULE,
+	},
+	.suspend	= lf1000_spi_suspend,
+	.resume		= lf1000_spi_resume,
+	.remove		= __devexit_p(lf1000_spi_remove),
+};
+
+static void __exit lf1000_spi_exit(void)
+{
+	platform_driver_unregister(&lf1000_spi_driver);
+}
+
+static int __init lf1000_spi_init(void)
+{
+	lf1000_spi_wq = create_singlethread_workqueue(
+	                       lf1000_spi_driver.driver.name);
+	if(lf1000_spi_wq == NULL)
+		return -1;
+
+	return platform_driver_probe(&lf1000_spi_driver, lf1000_spi_probe);
+}
+
+module_init(lf1000_spi_init);
+module_exit(lf1000_spi_exit);
+MODULE_AUTHOR("Scott Esters");
+MODULE_VERSION("1:1.0");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/spi/spi_lf1000.h linux-2.6/drivers/spi/spi_lf1000.h
--- linux-2.6.31/drivers/spi/spi_lf1000.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/spi/spi_lf1000.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,24 @@
+/* LF1000 SPI Driver
+ *
+ * spi.h -- SPI control.
+ *
+ * Scott Esters
+ * LeapFrog Enterprises
+ *
+ * Andrey Yurovsky <andrey@cozybit.com>
+ */
+
+#ifndef _LF1000_SPI_H
+#define _LF1000_SPI_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+
+/* clock settings */
+#define SPI_SRC_HZ      10000000
+#define SPI_CLK_SRC     PLL1
+
+#endif
diff -ruaN linux-2.6.31/drivers/spi/spi_lf1000_hal.h linux-2.6/drivers/spi/spi_lf1000_hal.h
--- linux-2.6.31/drivers/spi/spi_lf1000_hal.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/spi/spi_lf1000_hal.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,72 @@
+/*
+ * spi_hal.h
+ * Hardware specific defines for spi driver
+ *
+ * Scott Esters
+ * LeapFrog Enterprises
+ */
+
+#ifndef SPI_HAL_H
+#define SPI_HAL_H
+
+/* SPI registers as offsets */
+#define SSPSPICONT0	0x00
+#define SSPSPICONT1	0x02
+#define SSPSPIDATA	0x04
+#define SSPSPISTATE	0x06
+#define SSPSPICLKENB	0x40
+#define SSPSPICLKGEN	0x44
+
+/******************
+ * CONT0 Register *
+ *****************/
+#define ZENB		   14
+#define RXONLY		   13
+#define DMAENB		   12
+#define ENB		   11
+#define FFCLR		   10
+#define	EXTCLKSEL	    9
+#define NUMBIT		    5
+#define NUMBIT_MASK	0x1E0
+#define DIVCNT		    0
+#define DIVCNT_MASK      0x1F
+
+
+/******************
+ * CONT1 Register *
+ *****************/
+#define SLAV_SEL	    4
+#define SCLKPOL		    3
+#define SCLKSH		    2
+#define TYPE		    0
+#define TYPE_MASK	  0x3
+
+/******************
+ * STATE Register *
+ *****************/
+#define IRQEENB		   15
+#define IRQWENB		   14
+#define IRQRENB		   13
+#define IRQE		    6
+#define IRQW		    5
+#define IRQR		    4
+#define WFFFULL		    3
+#define WFFEMPTY	    2
+#define RFFFULL		    1
+#define RFFEMPTY	    0
+
+/*******************
+ * CLKENB Register *
+ ******************/
+#define SPI_PCLKMODE	    3
+#define SPI_CLKGENENB	    2
+
+/*******************
+ * CLKGEN Register *
+ ******************/
+#define SPI_CLKDIV	     4
+#define SPI_CLKDIV_MASK	 0x3F0
+#define SPI_CLKSRCSEL	     1
+#define SPI_CLKSRCSEL_MASK 0xE
+
+#endif
diff -ruaN linux-2.6.31/drivers/usb/core/hcd.c linux-2.6/drivers/usb/core/hcd.c
--- linux-2.6.31/drivers/usb/core/hcd.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/core/hcd.c	2011-01-04 13:50:21.000000000 -0800
@@ -2018,6 +2018,10 @@
 	hcd->authorized_default = hcd->wireless? 0 : 1;
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    return -1;
+#endif  // 28aug09
+
 	/* HC is in reset state, but accessible.  Now do the one-time init,
 	 * bottom up so that hcds can customize the root hubs before khubd
 	 * starts talking to them.  (Note, bus id is assigned early too.)
@@ -2027,9 +2031,17 @@
 		return retval;
 	}
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    return -2;
+#endif  // 28aug09
+
 	if ((retval = usb_register_bus(&hcd->self)) < 0)
 		goto err_register_bus;
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    retval = -3;
+	goto err_register_bus;
+#endif  // 28aug09
 	if ((rhdev = usb_alloc_dev(NULL, &hcd->self, 0)) == NULL) {
 		dev_err(hcd->self.controller, "unable to allocate root hub\n");
 		retval = -ENOMEM;
@@ -2051,12 +2063,20 @@
 	}
 	hcd->self.root_hub = rhdev;
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    retval = -4;
+	goto err_hcd_driver_setup;
+#endif  // 28aug09
 	/* wakeup flag init defaults to "everything works" for root hubs,
 	 * but drivers can override it in reset() if needed, along with
 	 * recording the overall controller's system wakeup capability.
 	 */
 	device_init_wakeup(&rhdev->dev, 1);
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    retval = -5;
+	goto err_hcd_driver_setup;
+#endif  // 28aug09
 	/* "reset" is misnamed; its role is now one-time init. the controller
 	 * should already have been reset (and boot firmware kicked off etc).
 	 */
@@ -2070,6 +2090,10 @@
 			&& device_can_wakeup(&hcd->self.root_hub->dev))
 		dev_dbg(hcd->self.controller, "supports USB remote wakeup\n");
 
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    retval = -6;
+	goto err_hcd_driver_setup;
+#endif  // 28aug09
 	/* enable irqs just before we start the controller */
 	if (hcd->driver->irq) {
 
@@ -2101,12 +2125,22 @@
 					"io mem" : "io base",
 					(unsigned long long)hcd->rsrc_start);
 	}
+#if 0   // 28aug09  just for debugging; boots ok when this is enabled
+    retval = -7;
+	goto err_hcd_driver_start;
+#endif  // 28aug09
 
 	if ((retval = hcd->driver->start(hcd)) < 0) {
 		dev_err(hcd->self.controller, "startup error %d\n", retval);
 		goto err_hcd_driver_start;
 	}
 
+#if 0   // 28aug09  just for debugging;
+    retval = -8;
+	goto err_hcd_driver_start;
+#else
+printk("after hcd->driver->start\n");
+#endif  // 28aug09
 	/* starting here, usbcore will pay attention to this root hub */
 	rhdev->bus_mA = min(500u, hcd->power_budget);
 	if ((retval = register_root_hub(hcd)) != 0)
@@ -2120,24 +2154,48 @@
 	}
 	if (hcd->uses_new_polling && hcd->poll_rh)
 		usb_hcd_poll_rh_status(hcd);
+#if 1   //  30aug09
+printk("usb_add_hcd() returns %d\n", retval);
+#endif  // 30aug09
 	return retval;
 
 error_create_attr_group:
+#if 1   //  30aug09
+printk("usb_add_hcd: error_create_attr_group\n");
+#endif  // 30aug09
 	mutex_lock(&usb_bus_list_lock);
 	usb_disconnect(&hcd->self.root_hub);
 	mutex_unlock(&usb_bus_list_lock);
 err_register_root_hub:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_register_root_hub\n");
+#endif  // 30aug09
 	hcd->driver->stop(hcd);
 err_hcd_driver_start:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_hcd_driver_start\n");
+#endif  // 30aug09
 	if (hcd->irq >= 0)
 		free_irq(irqnum, hcd);
 err_request_irq:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_request_irq\n");
+#endif  // 30aug09
 err_hcd_driver_setup:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_driver_setup\n");
+#endif  // 30aug09
 	hcd->self.root_hub = NULL;
 	usb_put_dev(rhdev);
 err_allocate_root_hub:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_allocate_root_hub\n");
+#endif  // 30aug09
 	usb_deregister_bus(&hcd->self);
 err_register_bus:
+#if 1   //  30aug09
+printk("usb_add_hcd: err_register_bus\n");
+#endif  // 30aug09
 	hcd_buffer_destroy(hcd);
 	return retval;
 } 
diff -ruaN linux-2.6.31/drivers/usb/gadget/ether.c linux-2.6/drivers/usb/gadget/ether.c
--- linux-2.6.31/drivers/usb/gadget/ether.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/ether.c	2011-02-23 11:17:36.000000000 -0800
@@ -24,6 +24,7 @@
 
 #include <linux/kernel.h>
 #include <linux/utsname.h>
+#include <mach/gpio.h>
 
 #include "u_ether.h"
 
@@ -63,7 +64,16 @@
  * needlessly complex.  They borrow more from CDC ACM than CDC ECM.
  */
 
-#define DRIVER_DESC		"Ethernet Gadget"
+#define DRIVER_DESC		        "Ethernet Gadget"
+#ifdef CONFIG_ARCH_LF1000
+#define DRIVER_VERSION	        "Veterans Day 2009"
+#define PREFIX			        ""
+#define PRODUCT_ID_STRING       "Leapster Explorer"
+#define PRODUCT_ID_STRING_MADRID       "LeapPad Explorer"
+#define MANUFACTURER_ID_STRING  "LeapFrog Enterprises, Inc."
+#define SERIAL_ID_STRING	""
+#else   
+
 #define DRIVER_VERSION		"Memorial Day 2008"
 
 #ifdef CONFIG_USB_ETH_RNDIS
@@ -72,6 +82,8 @@
 #define PREFIX			""
 #endif
 
+#endif  // ndef CONFIG_ARCH_LF1000
+
 /*
  * This driver aims for interoperability by using CDC ECM unless
  *
@@ -122,11 +134,19 @@
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
 
+#ifdef CONFIG_ARCH_LF1000
+/* Match Belcarra Windows Driver */
+#define CDC_VENDOR_NUM		0x0f63	/* LeapFrog */
+#define CDC_PRODUCT_NUM		0x0010	/* Linux-USB Ethernet Gadget */
+#define CDC_PRODUCT_NUM_MADRID		0x0011
+
+#else
 /* Thanks to NetChip Technologies for donating this product ID.
  * It's for devices with only CDC Ethernet configurations.
  */
 #define CDC_VENDOR_NUM		0x0525	/* NetChip */
 #define CDC_PRODUCT_NUM		0xa4a1	/* Linux-USB Ethernet Gadget */
+#endif
 
 /* For hardware that can't talk CDC, we use the same vendor ID that
  * ARM Linux has used for ethernet-over-usb, both with sa1100 and
@@ -196,7 +216,16 @@
 
 #define STRING_MANUFACTURER_IDX		0
 #define STRING_PRODUCT_IDX		1
+#define STRING_SERIAL_IDX		2
 
+#ifdef CONFIG_ARCH_LF1000
+static struct usb_string strings_dev[] = {
+	[STRING_MANUFACTURER_IDX].s = MANUFACTURER_ID_STRING,
+	[STRING_PRODUCT_IDX].s      = PRODUCT_ID_STRING,
+	[STRING_SERIAL_IDX].s	    = SERIAL_ID_STRING,
+	{  } /* end of list */
+};
+#else
 static char manufacturer[50];
 
 static struct usb_string strings_dev[] = {
@@ -204,6 +233,7 @@
 	[STRING_PRODUCT_IDX].s = PREFIX DRIVER_DESC,
 	{  } /* end of list */
 };
+#endif
 
 static struct usb_gadget_strings stringtab_dev = {
 	.language	= 0x0409,	/* en-us */
@@ -252,7 +282,6 @@
 static int __init eth_do_config(struct usb_configuration *c)
 {
 	/* FIXME alloc iConfiguration string, set it in c->strings */
-
 	if (gadget_is_otg(c->cdev->gadget)) {
 		c->descriptors = otg_desc;
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
@@ -289,6 +318,13 @@
 	if (can_support_ecm(cdev->gadget)) {
 		/* ECM */
 		eth_config_driver.label = "CDC Ethernet (ECM)";
+		/* Override product name and product ID for madrid */
+		if(gpio_have_gpio_madrid())
+		{
+			device_desc.idProduct = cpu_to_le16(CDC_PRODUCT_NUM_MADRID);
+			strings_dev[STRING_PRODUCT_IDX].s = PRODUCT_ID_STRING_MADRID;
+		}
+			
 	} else {
 		/* CDC Subset */
 		eth_config_driver.label = "CDC Subset/SAFE";
@@ -328,9 +364,11 @@
 	 */
 
 	/* device descriptor strings: manufacturer, product */
+#ifndef CONFIG_ARCH_LF1000
 	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
 		init_utsname()->sysname, init_utsname()->release,
 		gadget->name);
+#endif
 	status = usb_string_id(cdev);
 	if (status < 0)
 		goto fail;
@@ -339,6 +377,12 @@
 
 	status = usb_string_id(cdev);
 	if (status < 0)
+		goto fail;
+	strings_dev[STRING_SERIAL_IDX].id = status;
+	device_desc.iSerialNumber = status;
+
+	status = usb_string_id(cdev);
+	if (status < 0)
 		goto fail;
 	strings_dev[STRING_PRODUCT_IDX].id = status;
 	device_desc.iProduct = status;
diff -ruaN linux-2.6.31/drivers/usb/gadget/f_ecm.c linux-2.6/drivers/usb/gadget/f_ecm.c
--- linux-2.6.31/drivers/usb/gadget/f_ecm.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/f_ecm.c	2011-01-04 13:50:21.000000000 -0800
@@ -19,7 +19,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-/* #define VERBOSE_DEBUG */
+#define VERBOSE_DEBUG
 
 #include <linux/kernel.h>
 #include <linux/device.h>
@@ -27,7 +27,6 @@
 
 #include "u_ether.h"
 
-
 /*
  * This function is a "CDC Ethernet Networking Control Model" (CDC ECM)
  * Ethernet link.  The data transfer model is simple (packets sent and
@@ -118,7 +117,11 @@
 
 	/* .bInterfaceNumber = DYNAMIC */
 	/* status endpoint is optional; this could be patched later */
+#ifndef CPU_LF1000
 	.bNumEndpoints =	1,
+#else
+	.bNumEndpoints =	0,
+#endif
 	.bInterfaceClass =	USB_CLASS_COMM,
 	.bInterfaceSubClass =	USB_CDC_SUBCLASS_ETHERNET,
 	.bInterfaceProtocol =	USB_CDC_PROTO_NONE,
@@ -219,7 +222,9 @@
 	(struct usb_descriptor_header *) &ecm_union_desc,
 	(struct usb_descriptor_header *) &ecm_desc,
 	/* NOTE: status endpoint might need to be removed */
+#ifndef CPU_LF1000
 	(struct usb_descriptor_header *) &fs_ecm_notify_desc,
+#endif
 	/* data interface, altsettings 0 and 1 */
 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
 	(struct usb_descriptor_header *) &ecm_data_intf,
@@ -239,6 +244,7 @@
 	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
 	.bInterval =		LOG2_STATUS_INTERVAL_MSEC + 4,
 };
+
 static struct usb_endpoint_descriptor hs_ecm_in_desc __initdata = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
@@ -264,7 +270,9 @@
 	(struct usb_descriptor_header *) &ecm_union_desc,
 	(struct usb_descriptor_header *) &ecm_desc,
 	/* NOTE: status endpoint might need to be removed */
+#ifndef CPU_LF1000
 	(struct usb_descriptor_header *) &hs_ecm_notify_desc,
+#endif
 	/* data interface, altsettings 0 and 1 */
 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
 	(struct usb_descriptor_header *) &ecm_data_intf,
@@ -302,10 +310,16 @@
 	__le32				*data;
 	int				status;
 
+
+	/* have notification endpoint? */
+	if (!ecm->notify)
+		return;
+	
 	/* notification already in flight? */
 	if (!req)
 		return;
 
+	
 	event = req->buf;
 	switch (ecm->notify_state) {
 	case ECM_NOTIFY_NONE:
@@ -368,6 +382,10 @@
 	struct usb_composite_dev	*cdev = ecm->port.func.config->cdev;
 	struct usb_cdc_notification	*event = req->buf;
 
+	/* have notification endpoint? */
+	if (!ecm->notify)
+		return;
+	
 	switch (req->status) {
 	case 0:
 		/* no fault */
@@ -460,17 +478,20 @@
 		if (alt != 0)
 			goto fail;
 
-		if (ecm->notify->driver_data) {
-			VDBG(cdev, "reset ecm control %d\n", intf);
-			usb_ep_disable(ecm->notify);
-		} else {
-			VDBG(cdev, "init ecm ctrl %d\n", intf);
-			ecm->notify_desc = ep_choose(cdev->gadget,
-					ecm->hs.notify,
-					ecm->fs.notify);
+		/* have notification endpoint? */
+		if (ecm->notify) {
+			if (ecm->notify->driver_data) {
+				VDBG(cdev, "reset ecm control %d\n", intf);
+				usb_ep_disable(ecm->notify);
+			} else {
+				VDBG(cdev, "init ecm ctrl %d\n", intf);
+				ecm->notify_desc = ep_choose(cdev->gadget,
+						   ecm->hs.notify,
+						   ecm->fs.notify);
+			}
+			usb_ep_enable(ecm->notify, ecm->notify_desc);
+			ecm->notify->driver_data = ecm;
 		}
-		usb_ep_enable(ecm->notify, ecm->notify_desc);
-		ecm->notify->driver_data = ecm;
 
 	/* Data interface has two altsettings, 0 and 1 */
 	} else if (intf == ecm->data_id) {
@@ -548,10 +569,14 @@
 	if (ecm->port.in_ep->driver_data)
 		gether_disconnect(&ecm->port);
 
-	if (ecm->notify->driver_data) {
-		usb_ep_disable(ecm->notify);
-		ecm->notify->driver_data = NULL;
-		ecm->notify_desc = NULL;
+
+	/* have notification endpoint? */
+	if (ecm->notify) {
+		if (ecm->notify->driver_data) {
+			usb_ep_disable(ecm->notify);
+			ecm->notify->driver_data = NULL;
+			ecm->notify_desc = NULL;
+		}
 	}
 }
 
@@ -640,27 +665,30 @@
 	ecm->port.out_ep = ep;
 	ep->driver_data = cdev;	/* claim */
 
-	/* NOTE:  a status/notification endpoint is *OPTIONAL* but we
-	 * don't treat it that way.  It's simpler, and some newer CDC
-	 * profiles (wireless handsets) no longer treat it as optional.
-	 */
+	/* NOTE:  treat the status/notification endpoint as *OPTIONAL*	*/ 
+#ifndef CPU_LF1000
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_notify_desc);
-	if (!ep)
-		goto fail;
-	ecm->notify = ep;
-	ep->driver_data = cdev;	/* claim */
-
-	status = -ENOMEM;
-
-	/* allocate notification request and buffer */
-	ecm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);
-	if (!ecm->notify_req)
-		goto fail;
-	ecm->notify_req->buf = kmalloc(ECM_STATUS_BYTECOUNT, GFP_KERNEL);
-	if (!ecm->notify_req->buf)
-		goto fail;
-	ecm->notify_req->context = ecm;
-	ecm->notify_req->complete = ecm_notify_complete;
+#else
+    ep = NULL;
+#endif
+	if (!ep) {
+		ecm->notify = NULL;	/* no notification endpoint */
+		ecm->notify_req = NULL;	/* no notification buffer */
+	} else {
+		ecm->notify = ep;
+		ep->driver_data = cdev;	/* claim */
+		status = -ENOMEM;
+
+		/* allocate notification request and buffer */
+		ecm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);
+		if (!ecm->notify_req)
+			goto fail;
+		ecm->notify_req->buf = kmalloc(ECM_STATUS_BYTECOUNT, GFP_KERNEL);
+		if (!ecm->notify_req->buf)
+			goto fail;
+		ecm->notify_req->context = ecm;
+		ecm->notify_req->complete = ecm_notify_complete;
+	}
 
 	/* copy descriptors, and track endpoint copies */
 	f->descriptors = usb_copy_descriptors(ecm_fs_function);
@@ -671,8 +699,12 @@
 			f->descriptors, &fs_ecm_in_desc);
 	ecm->fs.out = usb_find_endpoint(ecm_fs_function,
 			f->descriptors, &fs_ecm_out_desc);
+#ifndef CPU_LF1000
 	ecm->fs.notify = usb_find_endpoint(ecm_fs_function,
 			f->descriptors, &fs_ecm_notify_desc);
+#else
+	ecm->fs.notify = NULL;
+#endif
 
 	/* support all relevant hardware speeds... we expect that when
 	 * hardware is dual speed, all bulk-capable endpoints work at
@@ -686,6 +718,7 @@
 		hs_ecm_notify_desc.bEndpointAddress =
 				fs_ecm_notify_desc.bEndpointAddress;
 
+
 		/* copy descriptors, and track endpoint copies */
 		f->hs_descriptors = usb_copy_descriptors(ecm_hs_function);
 		if (!f->hs_descriptors)
@@ -695,8 +728,12 @@
 				f->hs_descriptors, &hs_ecm_in_desc);
 		ecm->hs.out = usb_find_endpoint(ecm_hs_function,
 				f->hs_descriptors, &hs_ecm_out_desc);
+#ifndef CPU_LF1000
 		ecm->hs.notify = usb_find_endpoint(ecm_hs_function,
 				f->hs_descriptors, &hs_ecm_notify_desc);
+#else
+		ecm->hs.notify = NULL;
+#endif
 	}
 
 	/* NOTE:  all that is done without knowing or caring about
@@ -710,7 +747,7 @@
 	DBG(cdev, "CDC Ethernet: %s speed IN/%s OUT/%s NOTIFY/%s\n",
 			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
 			ecm->port.in_ep->name, ecm->port.out_ep->name,
-			ecm->notify->name);
+			(ecm->notify) ? ecm->notify->name : "NULL");
 	return 0;
 
 fail:
@@ -746,8 +783,10 @@
 		usb_free_descriptors(f->hs_descriptors);
 	usb_free_descriptors(f->descriptors);
 
-	kfree(ecm->notify_req->buf);
-	usb_ep_free_request(ecm->notify, ecm->notify_req);
+	if (ecm->notify_req != NULL)
+		kfree(ecm->notify_req->buf);
+	if (ecm->notify != NULL)
+		usb_ep_free_request(ecm->notify, ecm->notify_req);
 
 	ecm_string_defs[1].s = NULL;
 	kfree(ecm);
@@ -770,6 +809,7 @@
 	struct f_ecm	*ecm;
 	int		status;
 
+
 	if (!can_support_ecm(c->cdev->gadget) || !ethaddr)
 		return -EINVAL;
 
diff -ruaN linux-2.6.31/drivers/usb/gadget/file_storage.c linux-2.6/drivers/usb/gadget/file_storage.c
--- linux-2.6.31/drivers/usb/gadget/file_storage.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/file_storage.c	2011-03-08 14:52:57.000000000 -0800
@@ -90,6 +90,8 @@
  *					the files or block devices used for
  *					backing storage
  *	ro=b[,b...]		Default false, booleans for read-only access
+ *	locked=b[,b...]		Default false, per lun booleans for lock status
+ *	enabled=b[,b...]	Default false, per lun booleans for enabling LUNs
  *	removable		Default false, boolean for removable media
  *	luns=N			Default N = number of filenames, number of
  *					LUNs to support
@@ -110,6 +112,10 @@
  *					rounded down to a multiple of
  *					PAGE_CACHE_SIZE)
  *
+ *	serial=XXXXXXXXXXXXXXXX	This is a hex string of up to 16 characters with
+ *				no leading 0x.
+ *	needs_repair=b[,b...]	Default false, boolean signals file system corrupt
+ *
  * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
  * "removable", "luns", "stall", and "cdrom" options are available; default
  * values are used for everything else.
@@ -225,8 +231,9 @@
  * of the Gadget, USB Mass Storage, and SCSI protocols.
  */
 
+#define USE_LEAPFROG_USB_DATA
 
-/* #define VERBOSE_DEBUG */
+#define VERBOSE_DEBUG
 /* #define DUMP_MSGS */
 
 
@@ -253,9 +260,12 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
-#include "gadget_chips.h"
+#include <linux/rtc.h>
 
+#include <mach/power.h>
+#include "gadget_chips.h"
 
+extern enum lf1000_power_status lf1000_get_battery_status(void);
 
 /*
  * Kbuild is not very cooperative with respect to linking separately
@@ -270,9 +280,15 @@
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef USE_LEAPFROG_USB_DATA
+#define DRIVER_DESC		"Leapfrog Mass Storage"
+#define DRIVER_NAME		"g_file_storage"
+#define DRIVER_VERSION		"0.9"
+#else
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
 #define DRIVER_VERSION		"20 November 2008"
+#endif
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -281,13 +297,21 @@
 MODULE_AUTHOR("Alan Stern");
 MODULE_LICENSE("Dual BSD/GPL");
 
+#ifdef USE_LEAPFROG_USB_DATA
+#define DRIVER_VENDOR_ID	0x0f63	// Leap Frog VID
+#define DRIVER_PRODUCT_ID	0x0800	// Lightning
+static char vendor_id[] = "LeapFrog";
+static char product_id[] = "Didj            ";
+#else
 /* Thanks to NetChip Technologies for donating this product ID.
  *
  * DO NOT REUSE THESE IDs with any other driver!!  Ever!!
  * Instead:  allocate your own, using normal USB-IF procedures. */
 #define DRIVER_VENDOR_ID	0x0525	// NetChip
 #define DRIVER_PRODUCT_ID	0xa4a5	// Linux-USB File-backed Storage Gadget
-
+static char vendor_id[] = "Linux   ";
+static char product_id[] = "File-Stor Gadget";
+#endif
 
 /*
  * This driver assumes self-powered hardware and has no way for users to
@@ -349,6 +373,10 @@
 	unsigned int	num_filenames;
 	unsigned int	num_ros;
 	unsigned int	nluns;
+	int		locked[MAX_LUNS];
+	int		enabled[MAX_LUNS];
+	int		num_locks;
+	int		num_enables;
 
 	int		removable;
 	int		can_stall;
@@ -365,7 +393,15 @@
 	char		*transport_name;
 	int		protocol_type;
 	char		*protocol_name;
-
+	/* The CBI specification limits the serial string to 12 uppercase
+ 	 * hexadecimal characters. */
+	/* NOTE: Leapfrog serial number is 16 hex digits.  We're using BBB, so
+	 * this should be okay.  But if you turn on CBI and things stop working,
+	 * this is * probably why!
+	 */
+	char serial[17];
+	int		needs_repair[MAX_LUNS];
+	int		num_needs_repair;
 } mod_data = {					// Default values
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
@@ -376,8 +412,12 @@
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
 	.buflen			= 16384,
+	.serial			= "0000000000000000"
 	};
 
+module_param_named(cdrom, mod_data.cdrom, bool, S_IRUGO);
+MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
+
 
 module_param_array_named(file, mod_data.file, charp, &mod_data.num_filenames,
 		S_IRUGO);
@@ -386,6 +426,12 @@
 module_param_array_named(ro, mod_data.ro, bool, &mod_data.num_ros, S_IRUGO);
 MODULE_PARM_DESC(ro, "true to force read-only");
 
+module_param_array_named(locked, mod_data.locked, bool, &mod_data.num_locks, S_IRUGO);
+MODULE_PARM_DESC(locked, "true to force locked");
+
+module_param_array_named(enabled, mod_data.enabled, bool, &mod_data.num_enables, S_IRUGO);
+MODULE_PARM_DESC(enabled, "true to enable");
+
 module_param_named(luns, mod_data.nluns, uint, S_IRUGO);
 MODULE_PARM_DESC(luns, "number of LUNs");
 
@@ -395,9 +441,11 @@
 module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
 MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
 
-module_param_named(cdrom, mod_data.cdrom, bool, S_IRUGO);
-MODULE_PARM_DESC(cdrom, "true to emulate cdrom instead of disk");
+module_param_string(serial, mod_data.serial, sizeof(mod_data.serial), S_IRUGO);
+MODULE_PARM_DESC(serial, "Serial number string up to 16 ascii chars.");
 
+module_param_array_named(needs_repair, mod_data.needs_repair, bool, &mod_data.num_needs_repair, S_IRUGO);
+MODULE_PARM_DESC(needs_repair, "true signals PC should fix file system");
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -520,6 +568,8 @@
 #define SC_WRITE_6			0x0a
 #define SC_WRITE_10			0x2a
 #define SC_WRITE_12			0xaa
+#define SC_VENDOR_DEFINED_BEGIN		0xc0
+#define SC_VENDOR_DEFINED_END		0xff
 
 /* SCSI Sense Key/Additional Sense Code/ASC Qualifier values */
 #define SS_NO_SENSE				0
@@ -565,8 +615,9 @@
 
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
 
-
+#define MAX_FNAME_LEN 256
 struct lun {
+	char		fname[MAX_FNAME_LEN];
 	struct file	*filp;
 	loff_t		file_length;
 	loff_t		num_sectors;
@@ -581,6 +632,18 @@
 	u32		unit_attention_data;
 
 	struct device	dev;
+
+	/* Each LUN can be locked or unlocked.  If it is locked, it's not
+	 * visible over USB.  This is meant to be controlled using custom scsi
+	 * commands, but it can also be controlled at load time or runtime.
+	 */
+	int		locked;
+	/* Each LUN can be enabled or disabled.  This is just like locked, but
+	 * it is meant to be controlled by the device at runtime.
+	 */
+	int		enabled;
+	/* Each LUN can have its file system marked as needing repair */
+	int		needs_repair;
 };
 
 #define backing_file_is_open(curlun)	((curlun)->filp != NULL)
@@ -606,6 +669,7 @@
 
 struct fsg_buffhd {
 	void				*buf;
+	dma_addr_t			dma;
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
@@ -714,6 +778,8 @@
 	unsigned int		nluns;
 	struct lun		*luns;
 	struct lun		*curlun;
+	
+	int disconnect_ok;
 };
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
@@ -739,6 +805,8 @@
 static struct fsg_dev			*the_fsg;
 static struct usb_gadget_driver		fsg_driver;
 
+static void fsync_all(struct fsg_dev *fsg);
+static int open_backing_file(struct lun *curlun, const char *filename);
 static void	close_backing_file(struct lun *curlun);
 
 
@@ -852,7 +920,7 @@
 	.bConfigurationValue =	CONFIG_VALUE,
 	.iConfiguration =	STRING_CONFIG,
 	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		CONFIG_USB_GADGET_VBUS_DRAW / 2,
+	.bMaxPower =		1,	// self-powered
 };
 
 static struct usb_otg_descriptor
@@ -997,13 +1065,14 @@
 /* The CBI specification limits the serial string to 12 uppercase hexadecimal
  * characters. */
 static char				manufacturer[64];
-static char				serial[13];
+static char			serial_no_null[sizeof(mod_data.serial)-1];
+static int			serial_len;
 
 /* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
 static struct usb_string		strings[] = {
 	{STRING_MANUFACTURER,	manufacturer},
 	{STRING_PRODUCT,	longname},
-	{STRING_SERIAL,		serial},
+	{STRING_SERIAL,		serial_no_null},
 	{STRING_CONFIG,		"Self-powered"},
 	{STRING_INTERFACE,	"Mass Storage"},
 	{}
@@ -1692,9 +1761,8 @@
 		curlun->sense_data = SS_WRITE_PROTECTED;
 		return -EINVAL;
 	}
-	spin_lock(&curlun->filp->f_lock);
-	curlun->filp->f_flags &= ~O_SYNC;	// Default is not to wait
-	spin_unlock(&curlun->filp->f_lock);
+	//curlun->filp->f_flags &= ~O_SYNC;	// Default is not to wait
+	curlun->filp->f_flags |= O_SYNC;	// The medium is shared, so we sync
 
 	/* Get the starting Logical Block Address and check that it's
 	 * not too big */
@@ -1861,6 +1929,276 @@
 	return -EIO;		// No default reply
 }
 
+/*-------------------------------------------------------------------------*/
+
+/*
+ * These are leapfrog specific functions.  They should be migrated to another
+ * module and registered somehow with this module to provide custom vendor
+ * commands.  This fanciness will have to be implemented at some other time.
+ * Also, it only works on little endian machines!  I know.  Sinful.
+ */
+#define LF_LOCK_DEVICE 0xC1
+#define LF_UNLOCK_DEVICE 0xC2
+#define LF_GET_SETTING 0xC3
+#define LF_SET_SETTING 0xC4
+#define LF_DISCONNECT_OK 0xC6
+
+/* Now for some settings that we can get */
+#define LF_RTC_COUNTER 1
+#define LF_BATTERY_LEVEL 2
+#define LF_SERIAL_NUMBER 3
+#define LF_NEEDS_REPAIR	6
+
+struct custom_cmd {
+	unsigned char opcode;
+	unsigned char setting; /* only used for kDeviceCmdGetSetting */
+	unsigned char unused[8];
+} __attribute__((packed));
+
+struct rtc_reply {
+	unsigned long value;
+} __attribute__((packed));
+
+struct battery_reply {
+	unsigned char value;
+} __attribute__((packed));
+
+struct st_needs_repair {
+	unsigned char value;
+} __attribute__((packed));
+
+/* values for battery levels */
+#define BATT_UNKNOWN 0
+#define BATT_CRITICAL 1
+#define BATT_LOW 2
+#define BATT_GOOD 3
+#define BATT_FULL 4
+
+/*
+ * get the battery status from the hwmon and convert it for user app
+ */
+unsigned char get_battery_value(void)
+{
+	enum lf1000_power_status s = lf1000_get_battery_status();
+
+	switch(s) {
+		case CRITICAL_BATTERY:	return BATT_CRITICAL;
+		case LOW_BATTERY:	return BATT_LOW;
+		case NIMH:
+		case BATTERY:		return BATT_GOOD;
+		case NIMH_CHARGER:
+		case EXTERNAL:		return BATT_FULL;
+		case UNKNOWN:		return BATT_UNKNOWN;
+	}
+	return BATT_UNKNOWN;
+}
+
+static int do_vendor_command(struct fsg_dev *fsg, struct fsg_buffhd *bh)
+{
+	int ret = 0, i;
+	u8 *buf = (u8 *)bh->buf;
+	struct rtc_reply rtcr;
+	struct battery_reply batr;
+	struct st_needs_repair repair;
+	struct custom_cmd *cc = (struct custom_cmd *)&fsg->cmnd[0];
+	struct lun *curlun;
+	struct rtc_time tm;
+	struct rtc_device *rtc_dev;
+
+	switch(fsg->cmnd[0]) {
+	case LF_LOCK_DEVICE:
+		/* This should be per lun, but the command is not defined that
+		 * way.  Lame. 
+		 */
+		fsync_all(fsg);
+		for(i=0; i<fsg->nluns; i++) {
+			curlun = &fsg->luns[i];
+			if(curlun->locked)
+				continue;
+			
+			up_read(&fsg->filesem);
+			down_write(&fsg->filesem);
+
+			/* Eject current medium thus locking device */
+			if (backing_file_is_open(curlun)) {
+				close_backing_file(curlun);
+				curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+			}
+			
+			curlun->locked = 1;
+			up_write(&fsg->filesem);
+			down_read(&fsg->filesem);
+		}
+		break;
+	case LF_UNLOCK_DEVICE:
+		for(i=0; i<fsg->nluns; i++) {
+			curlun = &fsg->luns[i];
+			if(!curlun->locked)
+				continue;
+
+			up_read(&fsg->filesem);
+			down_write(&fsg->filesem);
+			if (curlun->fname[0] && curlun->enabled) {
+				ret = open_backing_file(curlun, curlun->fname);
+				if (ret == 0)
+					curlun->unit_attention_data =
+						SS_NOT_READY_TO_READY_TRANSITION;
+			}
+			if (ret == 0)
+				curlun->locked = 0;
+			up_write(&fsg->filesem);
+			down_read(&fsg->filesem);
+			if (ret != 0)
+				break;
+		}
+		break;
+	case LF_GET_SETTING:
+		switch (cc->setting) {
+		case LF_BATTERY_LEVEL:
+			batr.value = get_battery_value();
+			memcpy(&buf[0], &batr, sizeof(struct battery_reply));
+			ret = sizeof(struct battery_reply);
+			break;
+
+		case LF_RTC_COUNTER:
+			rtcr.value = 0xFFFFFFFF;
+			rtc_dev = rtc_class_open("rtc0");
+			if(!rtc_dev) {
+				printk("failed to open rtc\n");
+			} else {
+				if(rtc_read_time(rtc_dev, &tm) != 0)
+					printk("failed to read time.\n");
+				else
+					rtc_tm_to_time(&tm, &rtcr.value);
+				rtc_class_close(rtc_dev);
+			}
+			memcpy(&buf[0], &rtcr, sizeof(struct rtc_reply));
+			ret = sizeof(struct rtc_reply);
+			break;
+		case LF_SERIAL_NUMBER:
+			memcpy(&buf[0], serial_no_null, serial_len);
+			buf[serial_len] = 0;
+			ret = serial_len + 1;
+			break;
+		case LF_NEEDS_REPAIR:
+		/* This should be per lun, but the command is not 
+		 * defined that way.
+		 */
+			repair.value=0;	// assume repair not needed
+			for(i=0; i<fsg->nluns; i++) {
+				curlun = &fsg->luns[i];
+				if(curlun->needs_repair) {
+					repair.value=1;
+					break;
+				}
+			}
+					
+			memcpy(&buf[0], &repair, sizeof(repair));
+			ret = sizeof(repair);
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case LF_SET_SETTING:
+		switch (cc->setting) {
+		case LF_NEEDS_REPAIR:
+			memcpy(&repair, &(fsg->cmnd[2]), sizeof(repair));
+			for(i=0; i<fsg->nluns; i++) {
+				curlun = &fsg->luns[i];
+				curlun->needs_repair=repair.value;
+			}
+			ret = sizeof(repair);
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case LF_DISCONNECT_OK:
+		fsg->disconnect_ok = 1;
+		ret = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int check_vendor_command(struct fsg_dev *fsg)
+{
+	struct lun *curlun;
+	int i;
+	struct custom_cmd *cc = (struct custom_cmd *)&fsg->cmnd[0];
+
+	switch(fsg->cmnd[0]) {
+	case LF_LOCK_DEVICE:
+		if(fsg->data_dir != DATA_DIR_NONE)
+			return -EINVAL;
+		fsg->data_size_from_cmnd = 0;
+		for(i=0; i<fsg->nluns; i++) {
+			curlun = &fsg->luns[i];
+			if(curlun->locked)
+				continue;
+			
+			if (curlun->prevent_medium_removal &&
+			    backing_file_is_open(curlun)) {
+				LDBG(curlun, "eject attempt prevented\n");
+				return -EBUSY;
+			}
+		}
+		break;
+	case LF_UNLOCK_DEVICE:
+		if(fsg->data_dir != DATA_DIR_NONE)
+			return -EINVAL;
+		fsg->data_size_from_cmnd = 0;
+		break;
+	case LF_GET_SETTING:
+		if(fsg->data_dir != DATA_DIR_TO_HOST)
+			return -EINVAL;
+		switch (cc->setting) {
+		case LF_BATTERY_LEVEL:
+			fsg->data_size_from_cmnd = sizeof(struct battery_reply);
+			break;
+
+		case LF_RTC_COUNTER:
+			fsg->data_size_from_cmnd = sizeof(struct rtc_reply);
+			break;
+
+		case LF_SERIAL_NUMBER:
+			fsg->data_size_from_cmnd = 256;
+			break;
+
+		case LF_NEEDS_REPAIR:
+			fsg->data_size_from_cmnd =
+				sizeof(struct st_needs_repair);
+			break;
+			
+		default:
+			return -EINVAL;
+		}
+		break;
+	case LF_SET_SETTING:
+		if(fsg->data_dir != DATA_DIR_FROM_HOST)
+			return -EINVAL;
+		switch (cc->setting) {
+		case LF_NEEDS_REPAIR:
+			fsg->data_size_from_cmnd =
+				sizeof(struct st_needs_repair);
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case LF_DISCONNECT_OK:
+		if(fsg->data_dir != DATA_DIR_NONE)
+			return -EINVAL;
+		fsg->data_size_from_cmnd = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
 
 /*-------------------------------------------------------------------------*/
 
@@ -2011,29 +2349,22 @@
 {
 	u8	*buf = (u8 *) bh->buf;
 
-	static char vendor_id[] = "Linux   ";
-	static char product_disk_id[] = "File-Stor Gadget";
-	static char product_cdrom_id[] = "File-CD Gadget  ";
 
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
 		memset(buf, 0, 36);
 		buf[0] = 0x7f;		// Unsupported, no device-type
-		buf[4] = 31;		// Additional length
 		return 36;
 	}
 
-	memset(buf, 0, 8);
-	buf[0] = (mod_data.cdrom ? TYPE_CDROM : TYPE_DISK);
+	memset(buf, 0, 8);	// Non-removable, direct-access device
 	if (mod_data.removable)
 		buf[1] = 0x80;
 	buf[2] = 2;		// ANSI SCSI level 2
 	buf[3] = 2;		// SCSI-2 INQUIRY data format
 	buf[4] = 31;		// Additional length
 				// No special options
-	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id,
-			(mod_data.cdrom ? product_cdrom_id :
-				product_disk_id),
+	sprintf(buf + 8, "%-8s%-16s%04x", vendor_id, product_id,
 			mod_data.release);
 	return 36;
 }
@@ -2669,6 +3000,7 @@
 
 		fsg->intr_buffhd = bh;		// Point to the right buffhd
 		fsg->intreq->buf = bh->inreq->buf;
+		fsg->intreq->dma = bh->inreq->dma;
 		fsg->intreq->context = bh;
 		start_transfer(fsg, fsg->intr_in, fsg->intreq,
 				&fsg->intreq_busy, &bh->state);
@@ -3043,12 +3375,22 @@
 
 	default:
  unknown_cmnd:
-		fsg->data_size_from_cmnd = 0;
-		sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
-		if ((reply = check_command(fsg, fsg->cmnd_size,
-				DATA_DIR_UNKNOWN, 0xff, 0, unknown)) == 0) {
-			fsg->curlun->sense_data = SS_INVALID_COMMAND;
-			reply = -EINVAL;
+		/* Vendor specific commands should probably use a registration
+		 * mechanism.  But for now we do it all in this file.
+		 */
+		if((fsg->cmnd[0] >= SC_VENDOR_DEFINED_BEGIN) &&
+		   ((reply = check_vendor_command(fsg)) == 0) &&
+		   (check_command(fsg, 10, fsg->data_dir, 0xff, 0, "VENDOR") == 0)) {
+			reply = do_vendor_command(fsg, bh);
+		} else {
+			fsg->data_size_from_cmnd = 0;
+			sprintf(unknown, "Unknown x%02x", fsg->cmnd[0]);
+			if ((reply = check_command(fsg, fsg->cmnd_size,
+						   DATA_DIR_UNKNOWN, 0xff,
+						   0, unknown)) == 0) {
+				fsg->curlun->sense_data = SS_INVALID_COMMAND;
+				reply = -EINVAL;
+			}
 		}
 		break;
 	}
@@ -3304,6 +3646,7 @@
 		if ((rc = alloc_request(fsg, fsg->bulk_out, &bh->outreq)) != 0)
 			goto reset;
 		bh->inreq->buf = bh->outreq->buf = bh->buf;
+		bh->inreq->dma = bh->outreq->dma = bh->dma;
 		bh->inreq->context = bh->outreq->context = bh;
 		bh->inreq->complete = bulk_in_complete;
 		bh->outreq->complete = bulk_out_complete;
@@ -3699,25 +4042,24 @@
 	return sprintf(buf, "%d\n", curlun->ro);
 }
 
+static ssize_t show_disconnect(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", the_fsg->disconnect_ok);
+}
+
 static ssize_t show_file(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
 	struct lun	*curlun = dev_to_lun(dev);
 	struct fsg_dev	*fsg = dev_get_drvdata(dev);
-	char		*p;
 	ssize_t		rc;
 
 	down_read(&fsg->filesem);
-	if (backing_file_is_open(curlun)) {	// Get the complete pathname
-		p = d_path(&curlun->filp->f_path, buf, PAGE_SIZE - 1);
-		if (IS_ERR(p))
-			rc = PTR_ERR(p);
-		else {
-			rc = strlen(p);
-			memmove(buf, p, rc);
-			buf[rc] = '\n';		// Add a newline
-			buf[++rc] = 0;
-		}
+	if (curlun->fname[0]) {
+		rc = strlen(curlun->fname);
+		memmove(buf, curlun->fname, rc);
+		buf[rc] = '\n';		// Add a newline
+		buf[++rc] = 0;
 	} else {				// No file, return 0 bytes
 		*buf = 0;
 		rc = 0;
@@ -3726,6 +4068,43 @@
 	return rc;
 }
 
+static ssize_t show_locked(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+
+	return sprintf(buf, "%d\n", curlun->locked);
+}
+
+/* Yet another hack.  The watchdog functionality is in the lf1000 controller
+ * driver, but it needs to know if the mass storage driver is enabled.  The
+ * solution is to migrate the watchdog to this driver, but that breaks
+ * userspace. 
+ */
+static int fsg_enabled(struct usb_gadget *gadget)
+{
+	struct lun *curlun;
+	int i;
+	for (i = 0; i < the_fsg->nluns; ++i) {
+		curlun = &the_fsg->luns[i];
+		if(curlun->enabled)
+			return 1;
+	}
+	return 0;
+}
+
+static ssize_t show_enabled(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+
+	return sprintf(buf, "%d\n", curlun->enabled);
+}
+
+static ssize_t show_needs_repair(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+
+	return sprintf(buf, "%d\n", curlun->needs_repair);
+}
 
 static ssize_t store_ro(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
@@ -3763,34 +4142,148 @@
 		LDBG(curlun, "eject attempt prevented\n");
 		return -EBUSY;				// "Door is locked"
 	}
+	
+	if (count >= MAX_FNAME_LEN) {
+		ERROR(fsg, "Filename too long\n");
+		return -EINVAL;
+	}
 
 	/* Remove a trailing newline */
 	if (count > 0 && buf[count-1] == '\n')
 		((char *) buf)[count-1] = 0;		// Ugh!
 
-	/* Eject current medium */
+
+	/* Change the filename */
 	down_write(&fsg->filesem);
-	if (backing_file_is_open(curlun)) {
-		close_backing_file(curlun);
-		curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+	if (curlun->enabled) {
+		LDBG(curlun, "Can't change file while enbaled.\n");
+		rc = -EBUSY;
+	} else {
+		curlun->fname[0] = 0;
+		if (count > 0 && buf[0])
+			strcpy(&curlun->fname[0], buf);
+	}
+	up_write(&fsg->filesem);
+	return (rc < 0 ? rc : count);
+}
+
+static ssize_t store_locked(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	ssize_t		rc = count;
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	int		lockme;
+
+	if (sscanf(buf, "%d", &lockme) != 1)
+		return -EINVAL;
+	lockme = !!lockme;
+
+	if(lockme == curlun->locked)
+		return count;
+
+	if (curlun->prevent_medium_removal && backing_file_is_open(curlun)) {
+		LDBG(curlun, "eject attempt prevented\n");
+		return -EBUSY;
 	}
 
-	/* Load new medium */
-	if (count > 0 && buf[0]) {
-		rc = open_backing_file(curlun, buf);
-		if (rc == 0)
-			curlun->unit_attention_data =
+	down_write(&fsg->filesem);
+	if (lockme) {
+		/* Eject current medium thus locking device */
+		if (backing_file_is_open(curlun)) {
+			fsync_sub(curlun);
+			close_backing_file(curlun);
+			curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+		}
+	} else {
+		/* Unlock LUN */
+		if (curlun->fname[0] && curlun->enabled) {
+			rc = open_backing_file(curlun, curlun->fname);
+			if (rc == 0)
+				curlun->unit_attention_data =
 					SS_NOT_READY_TO_READY_TRANSITION;
+		}
 	}
+	curlun->locked = lockme;
+
+	up_write(&fsg->filesem);
+	return (rc < 0 ? rc : count);
+}
+
+static ssize_t store_enabled(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	struct fsg_dev	*fsg = dev_get_drvdata(dev);
+	int		rc = 0, enableme;
+	
+	if (sscanf(buf, "%d", &enableme) != 1)
+		return -EINVAL;
+	enableme = !!enableme;
+
+	if(enableme == curlun->enabled)
+		return count;
+
+	if (curlun->prevent_medium_removal && backing_file_is_open(curlun)) {
+		LDBG(curlun, "eject attempt prevented\n");
+		return -EBUSY;				// "Door is locked"
+	}
+
+	if (curlun->fname[0] == 0) {
+		ERROR(fsg, "Can't enable until file is set.\n");
+		return -EINVAL;
+	}
+
+	/* Eject current medium */
+	down_write(&fsg->filesem);
+	if (enableme) {
+		if(curlun->fname[0] == 0) {
+			/* we can't enable unless there's a filename */
+			rc = -EINVAL;
+		} else {
+			/* enable LUN */
+			if (!curlun->locked) {
+				rc = open_backing_file(curlun, curlun->fname);
+				if (rc == 0)
+					curlun->unit_attention_data =
+						SS_NOT_READY_TO_READY_TRANSITION;
+			}
+		}
+	} else {
+		/* Eject current medium thus disabling device */
+		if (backing_file_is_open(curlun)) {
+			fsync_sub(curlun);
+			close_backing_file(curlun);
+			curlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;
+		}
+	}
+	curlun->enabled = enableme;
 	up_write(&fsg->filesem);
 	return (rc < 0 ? rc : count);
 }
 
+static ssize_t store_needs_repair(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct lun	*curlun = dev_to_lun(dev);
+	int		needs_repair;
+	
+	if (sscanf(buf, "%d", &needs_repair) != 1)
+		return -EINVAL;
+	
+	needs_repair = !!needs_repair;
+
+	curlun->needs_repair = needs_repair;
+	return count;
+}
 
 /* The write permissions and store_xxx pointers are set in fsg_bind() */
 static DEVICE_ATTR(ro, 0444, show_ro, NULL);
 static DEVICE_ATTR(file, 0444, show_file, NULL);
-
+static DEVICE_ATTR(locked, 0644, show_locked, store_locked);
+static DEVICE_ATTR(enabled, 0644, show_enabled, store_enabled);
+static DEVICE_ATTR(disconnect, 0444, show_disconnect, NULL);
+static DEVICE_ATTR(needs_repair, 0644, show_needs_repair, store_needs_repair);
 
 /*-------------------------------------------------------------------------*/
 
@@ -3820,14 +4313,18 @@
 	clear_bit(REGISTERED, &fsg->atomic_bitflags);
 
 	/* Unregister the sysfs attribute files and the LUNs */
+	device_remove_file(&gadget->dev, &dev_attr_disconnect);
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
 		if (curlun->registered) {
 			device_remove_file(&curlun->dev, &dev_attr_ro);
 			device_remove_file(&curlun->dev, &dev_attr_file);
-			close_backing_file(curlun);
+			device_remove_file(&gadget->dev, &dev_attr_locked);
+			device_remove_file(&gadget->dev, &dev_attr_enabled);
+			device_remove_file(&gadget->dev, &dev_attr_needs_repair);
 			device_unregister(&curlun->dev);
 			curlun->registered = 0;
+			curlun->fname[0] = 0;
 		}
 	}
 
@@ -3961,6 +4458,8 @@
 	if ((rc = check_parameters(fsg)) != 0)
 		goto out;
 
+	fsg->disconnect_ok = 1;
+
 	if (mod_data.removable) {	// Enable the store_xxx attributes
 		dev_attr_file.attr.mode = 0644;
 		dev_attr_file.store = store_file;
@@ -3988,12 +4487,18 @@
 		goto out;
 	}
 	fsg->nluns = i;
+	if ((rc = device_create_file(&gadget->dev,
+				     &dev_attr_disconnect)) != 0)
+		goto out;
 
 	for (i = 0; i < fsg->nluns; ++i) {
 		curlun = &fsg->luns[i];
 		curlun->ro = mod_data.ro[i];
 		if (mod_data.cdrom)
 			curlun->ro = 1;
+		curlun->locked = mod_data.locked[i];
+		curlun->enabled = mod_data.enabled[i];
+		curlun->needs_repair=mod_data.needs_repair[i];
 		curlun->dev.release = lun_release;
 		curlun->dev.parent = &gadget->dev;
 		curlun->dev.driver = &fsg_driver.driver;
@@ -4008,22 +4513,47 @@
 		if ((rc = device_create_file(&curlun->dev,
 					&dev_attr_ro)) != 0 ||
 				(rc = device_create_file(&curlun->dev,
-					&dev_attr_file)) != 0) {
+					&dev_attr_file)) != 0 ||
+		    (rc = device_create_file(&curlun->dev,
+					     &dev_attr_locked)) != 0 ||
+		    (rc = device_create_file(&curlun->dev,
+					     &dev_attr_enabled)) != 0 ||
+		    (rc = device_create_file(&curlun->dev,
+					     &dev_attr_needs_repair))) {
 			device_unregister(&curlun->dev);
 			goto out;
 		}
 		curlun->registered = 1;
 		kref_get(&fsg->ref);
 
+		curlun->fname[0] = 0;
 		if (mod_data.file[i] && *mod_data.file[i]) {
-			if ((rc = open_backing_file(curlun,
-					mod_data.file[i])) != 0)
+			if (strlen(mod_data.file[i]) >= MAX_FNAME_LEN) {
+				ERROR(fsg, "Filename too long for LUN%d\n", i);
+				rc = -EINVAL;
 				goto out;
-		} else if (!mod_data.removable) {
+			} else {
+				strcpy(&curlun->fname[0], mod_data.file[i]);
+			}
+		}
+
+		if ( !(curlun->fname[0]) && (curlun->enabled) ) {
+			ERROR(fsg, "Can't enable LUN%d without file\n", i);
+			rc = -EINVAL;
+			goto out;
+		}
+		
+		if ( !(curlun->fname[0]) && !mod_data.removable ) {
 			ERROR(fsg, "no file given for LUN%d\n", i);
 			rc = -EINVAL;
 			goto out;
 		}
+
+		if (curlun->enabled && !curlun->locked) {
+			rc = open_backing_file(curlun, curlun->fname);
+			if (rc != 0)
+				goto out;
+		}
 	}
 
 	/* Find all the endpoints we will use */
@@ -4109,16 +4639,9 @@
 	snprintf(manufacturer, sizeof manufacturer, "%s %s with %s",
 			init_utsname()->sysname, init_utsname()->release,
 			gadget->name);
-
-	/* On a real device, serial[] would be loaded from permanent
-	 * storage.  We just encode it from the driver version string. */
-	for (i = 0; i < sizeof(serial) - 2; i += 2) {
-		unsigned char		c = DRIVER_VERSION[i / 2];
-
-		if (!c)
-			break;
-		sprintf(&serial[i], "%02X", c);
-	}
+	serial_len = sizeof(serial_no_null)>strlen(mod_data.serial)?
+		strlen(mod_data.serial):sizeof(serial_no_null);
+	memcpy(serial_no_null, mod_data.serial, serial_len);
 
 	fsg->thread_task = kthread_create(fsg_main_thread, fsg,
 			"file-storage-gadget");
@@ -4194,6 +4717,11 @@
 	clear_bit(SUSPENDED, &fsg->atomic_bitflags);
 }
 
+void fsg_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct fsg_dev		*fsg = get_gadget_data(gadget);
+	fsg->disconnect_ok = !is_active;
+}
 
 /*-------------------------------------------------------------------------*/
 
@@ -4218,6 +4746,8 @@
 		// .suspend = ...
 		// .resume = ...
 	},
+	.vbus_session	= fsg_vbus_session,
+	.is_enabled	= fsg_enabled,
 };
 
 
@@ -4243,6 +4773,8 @@
 	int		rc;
 	struct fsg_dev	*fsg;
 
+	if(mod_data.product == 0x1300)
+		strcpy(product_id, "LeapsterAdvance");
 	if ((rc = fsg_alloc()) != 0)
 		return rc;
 	fsg = the_fsg;
diff -ruaN linux-2.6.31/drivers/usb/gadget/f_serial.c linux-2.6/drivers/usb/gadget/f_serial.c
--- linux-2.6.31/drivers/usb/gadget/f_serial.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/f_serial.c	2011-01-04 13:50:21.000000000 -0800
@@ -54,7 +54,7 @@
 	.bDescriptorType =	USB_DT_INTERFACE,
 	/* .bInterfaceNumber = DYNAMIC */
 	.bNumEndpoints =	2,
-	.bInterfaceClass =	USB_CLASS_VENDOR_SPEC,
+	.bInterfaceClass =	USB_CLASS_CDC_DATA,
 	.bInterfaceSubClass =	0,
 	.bInterfaceProtocol =	0,
 	/* .iInterface = DYNAMIC */
diff -ruaN linux-2.6.31/drivers/usb/gadget/gadget_chips.h linux-2.6/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.31/drivers/usb/gadget/gadget_chips.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/gadget_chips.h	2011-01-04 13:50:21.000000000 -0800
@@ -169,6 +169,13 @@
 #define gadget_is_ci13xxx(g)	0
 #endif
 
+/* LF1000 USB controller */
+#ifdef CONFIG_USB_GADGET_LF1000
+#define gadget_is_lf1000(g)	!strcmp("lf1000_udc", (g)->name)
+#else
+#define gadget_is_lf1000(g)	0
+#endif
+
 // CONFIG_USB_GADGET_SX2
 // CONFIG_USB_GADGET_AU1X00
 // ...
@@ -239,6 +246,8 @@
 		return 0x23;
 	else if (gadget_is_langwell(gadget))
 		return 0x24;
+	else if (gadget_is_lf1000(gadget))
+		return 0x25;
 	return -ENOENT;
 }
 
diff -ruaN linux-2.6.31/drivers/usb/gadget/Kconfig linux-2.6/drivers/usb/gadget/Kconfig
--- linux-2.6.31/drivers/usb/gadget/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -495,6 +495,18 @@
 	default USB_GADGET
 	select USB_GADGET_SELECTED
 
+config USB_GADGET_LF1000
+	boolean "LF1000 USB Device Controller"
+	depends on ARCH_LF1000
+	select USB_GADGET_DUALSPEED
+	help
+		USB Gadget support for LF1000
+
+config USB_LF1000
+	tristate
+	depends on USB_GADGET_LF1000
+	default USB_GADGET
+	select USB_GADGET_SELECTED
 
 #
 # LAST -- dummy/emulated controller
@@ -534,6 +546,12 @@
 
 endchoice
 
+config USB_LF1000_DEBUG
+	boolean "LF1000 USB Device Controller Debugging."
+	depends on USB_LF1000
+	help
+		USB Gadget debugging for LF1000
+
 config USB_GADGET_DUALSPEED
 	bool
 	depends on USB_GADGET
diff -ruaN linux-2.6.31/drivers/usb/gadget/lf1000_udc.c linux-2.6/drivers/usb/gadget/lf1000_udc.c
--- linux-2.6.31/drivers/usb/gadget/lf1000_udc.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/usb/gadget/lf1000_udc.c	2011-01-04 14:28:21.000000000 -0800
@@ -0,0 +1,1916 @@
+/*
+ * linux/drivers/usb/gadget/lf1000_udc.c
+ *
+ * Based on:
+ * linux/drivers/usb/gadget/s3c2410_udc.c
+ * Samsung on-chip full speed USB device controllers
+ *
+ * Copyright (C) 2004-2007 Herbert Ptzl - Arnaud Patard
+ *	Additional cleanups by Ben Dooks <ben-linux@fluff.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <linux/debugfs.h>
+#include <linux/input.h>
+
+#include <linux/usb.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+
+#include <asm/mach-types.h>
+
+#include <mach/gpio.h>
+
+#include "lf1000_udc.h"
+
+#define DRIVER_NAME		"lf1000-usbgadget"
+#define RESSIZE(res)		(((res)->end - (res)->start)+1)
+
+static const char gadget_name[] = "lf1000_udc";
+
+static inline void set_mask(struct lf1000_udc *udc, u16 bits, u32 reg)
+{
+	u16 tmp = readw(udc->base_addr + reg);
+	
+	writew(tmp | bits, udc->base_addr + reg);
+}
+
+static inline void clear_mask(struct lf1000_udc *udc, u16 bits, u32 reg)
+{
+	u16 tmp = readw(udc->base_addr + reg);
+	
+	writew(tmp & ~(bits), udc->base_addr + reg);
+}
+
+#define BIT_SET(v,b)    ((v) |= (1<<(b)))
+#define BIT_CLR(v,b)    ((v) &= ~(1<<(b)))
+#define IS_SET(v,b)     ((v) & (1<<(b)))
+#define IS_CLR(v,b)     !((v) & (1<<(b)))
+
+/*************************** DEBUG FUNCTION ***************************/
+#define DEBUG_NORMAL	1
+#define DEBUG_VERBOSE	2
+
+#ifdef CONFIG_USB_LF1000_DEBUG
+#define USB_LF1000_DEBUG_LEVEL 2
+
+static uint32_t lf1000_ticks=0;
+
+static int dprintk(int level, const char *fmt, ...)
+{
+	static char printk_buf[1024];
+	static long prevticks;
+	static int invocation;
+	va_list args;
+	int len;
+
+	if (level > USB_LF1000_DEBUG_LEVEL)
+		return 0;
+
+	if (lf1000_ticks != prevticks) {
+		prevticks = lf1000_ticks;
+		invocation = 0;
+	}
+
+	len = scnprintf(printk_buf, \
+			sizeof(printk_buf), "%1lu.%02d USB: ", \
+			prevticks, invocation++);
+
+	va_start(args, fmt);
+	len = vscnprintf(printk_buf+len, \
+			sizeof(printk_buf)-len, fmt, args);
+	va_end(args);
+
+	return printk(KERN_DEBUG "%s", printk_buf);
+}
+#else
+static int dprintk(int level, const char *fmt, ...)
+{
+	return 0;
+}
+#endif
+
+static ssize_t lf1000udc_vbus_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct lf1000_udc *udc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", udc->vbus);
+}
+
+static DEVICE_ATTR(vbus, 0444, lf1000udc_vbus_show, NULL);
+
+static void show_reg(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct lf1000_udc *udc = s->private;
+
+	seq_printf(s, "%10s:\t0x%04X\n", nm, readw(udc->base_addr + reg));
+}
+
+static int lf1000_udc_regs_show(struct seq_file *s, void *v)
+{
+	show_reg(s, "EPINDEX", UDC_EPINDEX);
+	show_reg(s, "EPINT", UDC_EPINT);
+	show_reg(s, "EPINTEN", UDC_EPINTEN);
+	show_reg(s, "FUNCADDR", UDC_FUNCADDR);
+	show_reg(s, "FRAMENUM", UDC_FRAMENUM);
+	show_reg(s, "EPDIR", UDC_EPDIR);
+	show_reg(s, "TEST", UDC_TEST);
+	show_reg(s, "SYSSTAT", UDC_SYSSTAT);
+	show_reg(s, "SYSCTL", UDC_SYSCTL);
+	show_reg(s, "EP0STAT", UDC_EP0STAT);
+	show_reg(s, "EP0CTL", UDC_EP0CTL);
+	show_reg(s, "EPSTAT", UDC_EPSTAT);
+	show_reg(s, "EPCTL", UDC_EPCTL);
+	show_reg(s, "BRCR", UDC_BRCR);
+	show_reg(s, "BWCR", UDC_BWCR);
+	show_reg(s, "MPR", UDC_MPR);
+	show_reg(s, "DCR", UDC_DCR);
+	show_reg(s, "DTCR", UDC_DTCR);
+	show_reg(s, "DFCR", UDC_DFCR);
+	show_reg(s, "DTTCR", UDC_DTTCR);
+	show_reg(s, "PLICR", UDC_PLICR);
+	show_reg(s, "PCR", UDC_PCR);
+	show_reg(s, "CIKSEL", UDC_CIKSEL);
+	show_reg(s, "VBUSINTENB", UDC_VBUSINTENB);
+	show_reg(s, "VBUSPEND", UDC_VBUSPEND);
+	show_reg(s, "POR", UDC_POR);
+	show_reg(s, "SUSPEND", UDC_SUSPEND);
+	show_reg(s, "USER0", UDC_USER0);
+	show_reg(s, "USER1", UDC_USER1);
+	show_reg(s, "CLKEN", UDC_CLKEN);
+	show_reg(s, "CLKGEN", UDC_CLKGEN);
+
+	return 0;
+}
+
+static int lf1000_udc_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lf1000_udc_regs_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_udc_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_udc_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/*------------------------- I/O ----------------------------------*/
+
+static void udc_disable(struct lf1000_udc *dev);
+static void udc_enable(struct lf1000_udc *dev);
+
+#define LF1000_UDC_VBUS_INIT 0
+#define LF1000_UDC_VBUS_ENABLE 1
+#define LF1000_UDC_VBUS_DISABLE 2
+#define LF1000_UDC_VBUS_RESET 3
+#define LF1000_UDC_VBUS_SHUTDOWN 4
+
+static int lf1000_vbus_command(struct lf1000_udc *udc, unsigned char cmd)
+{
+	int retval = 0;
+	u16 tmp;
+
+	if (!udc)
+		return -EINVAL;
+
+	switch (cmd) {
+	case LF1000_UDC_VBUS_INIT:
+		udc->vbus = 0;
+		break;
+	case LF1000_UDC_VBUS_ENABLE:
+		/* enable vbus detect interrupts */
+		tmp = readw(udc->base_addr + UDC_SYSCTL);
+		tmp |= ((1<<VBUSOFFEN)|(1<<VBUSONEN));
+		writew(tmp, udc->base_addr + UDC_SYSCTL);
+
+		/* set up the VBUSENB bit. */
+		tmp = readw(udc->base_addr + UDC_USER1);
+		writew(tmp | (1<<VBUSENB), udc->base_addr + UDC_USER1);
+		break;
+	case LF1000_UDC_VBUS_DISABLE:
+		/* disable the VBUSENB bit. */
+		tmp = readw(udc->base_addr + UDC_USER1) & ~(1<<VBUSENB);
+		writew(tmp, udc->base_addr + UDC_USER1);
+
+		/* disable vbus detect interrupts */
+		tmp = readw(udc->base_addr + UDC_SYSCTL);
+		tmp &= ~((1<<VBUSOFFEN)|(1<<VBUSONEN));
+		writew(tmp, udc->base_addr + UDC_SYSCTL);
+		break;
+	case LF1000_UDC_VBUS_SHUTDOWN:
+		lf1000_vbus_command(udc, LF1000_UDC_VBUS_DISABLE);
+		break;
+	case LF1000_UDC_VBUS_RESET:
+		/* What to do here? */
+		break;
+	default:
+		break;
+	}
+	return retval;
+}
+
+static int lf1000_udc_vbus_session(struct usb_gadget *_gadget, int is_active)
+{
+	struct lf1000_udc  *udc;
+
+	udc = container_of(_gadget, struct lf1000_udc, gadget);
+	
+	/* FIXME: we currently generate a keyboard event to notify userspace,
+	 * 	  find a better way to do this. */
+	input_report_switch(udc->input, SW_LID, is_active);
+
+	if (udc->driver && udc->driver->vbus_session)
+		udc->driver->vbus_session(&udc->gadget, is_active);
+
+	udc->vbus = is_active;
+	
+	if (udc->vbus == 0 &&
+	    udc->gadget.speed != USB_SPEED_UNKNOWN &&
+	    udc->driver && udc->driver->disconnect) {
+		udc->driver->disconnect(&udc->gadget);
+	}
+
+	return 0;
+}
+
+static void done(struct lf1000_ep *ep, struct lf1000_request *req, int status)
+{
+	unsigned halted = ep->halted;
+
+	list_del_init(&req->queue);
+
+	if (likely(req->req.status == -EINPROGRESS))
+		req->req.status = status;
+
+	ep->halted = 1; /* do we need this? */
+	if(req->req.complete)
+		req->req.complete(&ep->ep, &req->req);
+	ep->halted = halted;
+}
+
+static void nuke(struct lf1000_ep *ep, int status)
+{
+	struct lf1000_request  *req;
+
+	if (&ep->queue == NULL) /* FIXME */
+		return;
+
+	while (!list_empty (&ep->queue)) {
+		req = list_entry(ep->queue.next, struct lf1000_request, queue);
+		done(ep, req, status);
+	}
+}
+
+static inline void clear_ep_state (struct lf1000_udc *dev)
+{
+	unsigned i;
+
+	for (i = 1; i < LF1000_ENDPOINTS; i++)
+		nuke(&dev->ep[i], -ECONNRESET);
+}
+
+static void udc_reinit(struct lf1000_udc *dev);
+
+static int write_fifo(struct lf1000_ep *ep, char *buf, int len)
+{
+	struct lf1000_udc *udc = ep->dev;
+	int idx = ep->bEndpointAddress & 0x7F;
+	unsigned long fifo_reg = UDC_EPBUFS + 2*idx;
+	int bytes_written = 0;
+	u16 tmp;
+	int fifo_nonempty;
+
+	writew(idx, udc->base_addr + UDC_EPINDEX);
+
+	fifo_nonempty = (readw(udc->base_addr + UDC_EPSTAT)>>PSIF) & 0x3;
+	if (ep->num != 0 && fifo_nonempty)
+		return 0;
+
+	if (len > ep->ep.maxpacket)
+		len = ep->ep.maxpacket;
+
+	writew(len, udc->base_addr + UDC_BWCR);
+
+	if (unlikely((int)buf & 0x1)) {
+		/* source buffer is not aligned.  Yuck. */
+		while (len > 1) {
+			tmp = (*buf++) & 0xff;
+			tmp |= ((*buf++)<<8);
+			writew(tmp, udc->base_addr + fifo_reg);
+			bytes_written += 2;
+			len -= 2;
+		}
+	} else {
+		while (len > 1) {
+			writew(*((u16 *)buf), udc->base_addr + fifo_reg);
+			buf += 2;
+			bytes_written += 2;
+			len -= 2;
+		}
+	}
+
+	if (len) {
+		/* write odd byte */
+		tmp = *buf++;
+		writew(tmp & 0xFF, udc->base_addr + fifo_reg);
+		bytes_written += 1;
+		len -= 1;
+	}
+
+	return bytes_written;
+}
+
+static int read_fifo(struct lf1000_ep *ep, char *buf, int len)
+{
+	struct lf1000_udc *udc = ep->dev;
+	int bytes_read = 0;
+	int fifo_count = 0;
+	int idx = ep->bEndpointAddress&0x7F;
+	unsigned long fifo_reg = UDC_EPBUFS + 2*idx;
+	unsigned short tmp;
+	int flush = 0;
+	int fifo_empty;
+
+	writew(idx, udc->base_addr + UDC_EPINDEX);
+
+	/* We can't read the BRCR unless there's a valid packet. */
+	fifo_empty = !((readw(udc->base_addr + UDC_EPSTAT)>>PSIF) & 0x3);
+	if (ep->num != 0 && fifo_empty)
+		return 0;
+
+	fifo_count = 2*readw(udc->base_addr + UDC_BRCR);
+
+	if (fifo_count == 0)
+		return 0;
+
+	if ((ep->num == 0 &&
+	    IS_SET(readw(udc->base_addr + UDC_EP0STAT), EP0LWO)) ||
+	   (ep->num != 0 &&
+	    IS_SET(readw(udc->base_addr + UDC_EPSTAT), EPLWO))) {
+		fifo_count--;
+	}
+
+	if (len < fifo_count) {
+		fifo_count = len;
+		if (ep->num != 0)
+			flush = 1;
+	}
+
+	if (unlikely((int)buf & 0x1)) {
+		/* destination buffer is not aligned.  Yuck. */
+		while (fifo_count > 1) {
+			tmp = readw(udc->base_addr + fifo_reg);
+			*buf++ = (char)(tmp & 0xff);
+			*buf++ = (char)((tmp >> 8) & 0xff);
+			bytes_read += 2;
+			fifo_count -= 2;
+		}
+	} else {
+		while (fifo_count > 1) {
+			*((short *)buf) = readw(udc->base_addr + fifo_reg);
+			buf += 2;
+			bytes_read += 2;
+			fifo_count -= 2;
+		}
+	}
+
+	if (fifo_count) {
+		/* read odd byte */
+		tmp = readw(udc->base_addr + fifo_reg);
+		*buf++ = (char)(tmp & 0xff);
+		bytes_read++;
+		fifo_count--;
+	}
+
+	/* A packet must not cross a req boundary.  Flush any extra data. */
+	if (flush)
+		writew(1<<FLUSH, udc->base_addr + UDC_EPCTL);
+
+	return bytes_read;
+}
+
+static int lf1000_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gf);
+static int lf1000_set_halt(struct usb_ep *_ep, int value);
+
+static int lf1000_get_status(struct lf1000_udc *dev,
+		struct usb_ctrlrequest  *crq)
+{
+	u8 ep_num = crq->wIndex & 0x7F;
+
+	switch(crq->bRequestType & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			/* All interface status bits are reserved.  Return 0. */
+			dev->ifstatus = 0;
+			dev->statreq.req.buf = &dev->ifstatus;
+			break;
+		case USB_RECIP_DEVICE:
+			dev->statreq.req.buf = &dev->devstatus;
+			break;
+		case USB_RECIP_ENDPOINT:
+			if (ep_num > LF1000_ENDPOINTS || crq->wLength > 2)
+				return 1;
+			writew(ep_num, dev->base_addr + UDC_EPINDEX);
+
+			dev->ep[ep_num].status = dev->ep[ep_num].halted;
+			dev->statreq.req.buf = &dev->ep[ep_num].status;
+			break;
+		default:
+			return 1;
+	}
+
+	dev->statreq.req.length = 2;
+	dev->statreq.req.actual = 0;
+	dev->statreq.req.status = -EINPROGRESS;
+	dev->statreq.req.complete = NULL;
+	dev->statreq.req.zero = 0;
+	lf1000_queue(&dev->ep[0].ep, &dev->statreq.req, GFP_ATOMIC);
+	return 0;
+}
+
+static int lf1000_set_feature(struct lf1000_udc *dev,
+		struct usb_ctrlrequest *crq)
+{
+	struct lf1000_ep *ep;
+	u8 ep_num = crq->wIndex & 0x7F;
+ 
+	WARN_ON(ep_num >= LF1000_ENDPOINTS);
+	ep = &dev->ep[ep_num];
+
+	switch(crq->bRequestType & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			/* How will we support interface features? */
+			return 1;
+		case USB_RECIP_DEVICE:
+			if (crq->wValue != USB_DEVICE_REMOTE_WAKEUP)
+				return 1;
+			/* What do we do here? */
+			break;
+		case USB_RECIP_ENDPOINT:
+			if (crq->wValue != USB_ENDPOINT_HALT ||
+			    ep_num > LF1000_ENDPOINTS)
+				return 1;
+			if (!ep->desc)
+				return 1;
+			if ((crq->wIndex & USB_DIR_IN)) {
+				if (!ep->is_in)
+					return 1;
+			} else if (ep->is_in)
+				return 1;
+			lf1000_set_halt(&ep->ep, 1);
+			break;
+
+		default:
+			return 1;
+	}
+
+	return 0;
+}
+
+static int lf1000_clear_feature(struct lf1000_udc *dev,
+		struct usb_ctrlrequest *crq)
+{
+	struct lf1000_ep *ep;
+	u8 ep_num = crq->wIndex & 0x7F;
+ 
+	WARN_ON(ep_num >= LF1000_ENDPOINTS);
+	ep = &dev->ep[ep_num];
+	
+	switch(crq->bRequestType & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			return 1;
+		case USB_RECIP_DEVICE:
+			if (crq->wValue != USB_DEVICE_REMOTE_WAKEUP)
+				return 1;
+			break;
+		case USB_RECIP_ENDPOINT:
+			if (crq->wValue != USB_ENDPOINT_HALT ||
+			    ep_num > LF1000_ENDPOINTS)
+				return 1;
+			
+			writew(ep_num, dev->base_addr + UDC_EPINDEX);
+			
+			if (!ep->desc)
+				return 1;
+			
+			if ((crq->wIndex & USB_DIR_IN)) {
+				if (!ep->is_in)
+					return 1;
+			} else if (ep->is_in)
+				return 1;
+
+			lf1000_set_halt(&ep->ep, 0);
+			break;
+
+		default:
+			return 1;
+	}
+
+	return 0;
+}
+
+/*------------------------- usb helpers -------------------------------*/
+
+static void clear_ep_stall(struct lf1000_udc *udc, int ep)
+{
+	if (ep == 0) {
+		writew(1<<SHT, udc->base_addr + UDC_EP0STAT);
+		clear_mask(udc, 1<<EP0ESS, UDC_EP0CTL);
+		writew(1<<SHT, udc->base_addr + UDC_EP0STAT);
+	} else if(ep < LF1000_ENDPOINTS) {
+		writew(ep, udc->base_addr + UDC_EPINDEX);
+		set_mask(udc, (1<<FLUSH), UDC_EPCTL);
+		clear_mask(udc, (1<<ESS)|(1<<INPKTHLD)|(1<<OUTPKTHLD),
+				UDC_EPCTL);
+		writew((1<<FSC)|(1<<FFS), udc->base_addr + UDC_EPSTAT);
+		writew((1<<ep), udc->base_addr + UDC_EPINT);
+	} else {
+		printk(KERN_ERR "No such endpoint: %d\n", ep);
+	}
+}
+
+static void set_ep_stall(struct lf1000_udc *udc, int ep)
+{
+	if (ep == 0) {
+		set_mask(udc, (1<<EP0ESS), UDC_EP0CTL);
+	} else if(ep < LF1000_ENDPOINTS) {
+		writew(ep, udc->base_addr + UDC_EPINDEX);
+		set_mask(udc, (1<<ESS), UDC_EPCTL);
+	} else {
+		printk(KERN_ERR "No such endpoint: %d\n", ep);
+	}
+}
+
+/*------------------------- usb state machine -------------------------------*/
+
+/* return 1 for complete, 0 for incomplete */
+int write_req(struct lf1000_ep *ep, struct lf1000_request *req)
+{
+	int res = req->req.length - req->req.actual;
+	char *src = req->req.buf + req->req.actual;
+	
+	if (res > (ep->ep.maxpacket & 0x7ff))
+		res = ep->ep.maxpacket & 0x7ff;
+	
+	dprintk(DEBUG_VERBOSE, "Writing %d/%d bytes.\n", res + req->req.actual,
+		req->req.length);
+
+	req->req.actual += write_fifo(ep, src, res);
+
+        /* If we've sent the requested # of bytes, we're done unless the
+         * most-recently-sent packet was max-size and the transfer must end
+         * with a short packet (less than max-size). */
+	if(req->req.actual == req->req.length) {
+		if ((res >= (ep->ep.maxpacket & 0x7ff)) && req->req.zero) {
+			dprintk(DEBUG_VERBOSE,
+				"Full final pkt (%d); will send zlp\n", res);
+			return 0;
+		}
+
+		dprintk(DEBUG_VERBOSE, "Transfer complete.\n");
+
+		/* FIXME: We should call done on this packet when we see its TX
+		 * interrupt.  But when we try that, we end up with some weird
+		 * inconsistent list state.  Why?
+		 */
+		done(ep, req, 0);
+		return 1;
+	}
+	return 0;
+}
+
+/* return 1 for complete, 0 for incomplete */
+/* do not call unless you're holding the eplock */
+int read_req(struct lf1000_ep *ep, struct lf1000_request *req)
+{
+	int res = req->req.length - req->req.actual;
+	int pkt_len;
+	char *dst = req->req.buf + req->req.actual;
+	unsigned is_short;
+
+	pkt_len = read_fifo(ep, dst, res);
+	req->req.actual += pkt_len;
+	is_short = (pkt_len < ep->ep.maxpacket);
+	dprintk(DEBUG_VERBOSE, "\"%s\" read %d/%d bytes [%d] (z=%d, s=%d).\n", 
+			ep->ep.name,
+			req->req.actual, req->req.length, pkt_len,
+			req->req.zero, is_short);
+
+	if (pkt_len == 0 && req->req.actual == 0)
+		return 0;
+
+	if (is_short || req->req.actual == req->req.length) {
+		dprintk(DEBUG_VERBOSE, "Transfer complete.\n");
+		done(ep, req, 0);
+		return 1;
+	}
+	return 0;
+}
+
+/* Return the recommended next state */
+static int handle_setup(struct lf1000_udc *udc, struct lf1000_ep *ep, u32 csr)
+{
+	unsigned rxcount;
+	struct usb_ctrlrequest creq;
+	int next_state = EP0_IDLE, status = 0;
+	u8 is_in;
+
+	/* read SETUP; hard-fail for bogus packets */
+	rxcount = read_fifo(ep, (char *)&creq, 8);
+	if(unlikely(rxcount != 8)) {
+		// REVISIT this happens sometimes under load; why??
+		printk(KERN_ERR "setup: len %d, csr %08x\n", rxcount, csr);
+		/* set stall */
+		return EP0_STALL;
+	}
+
+	dprintk(DEBUG_VERBOSE, "setup: bRequestType: %02x\n"
+		"bRequest: %02x\nwValue: %04x\nwIndex: %04x\nwLength: %04x\n",
+		creq.bRequestType, creq.bRequest, creq.wValue, creq.wIndex,
+		creq.wLength);
+
+	is_in = creq.bRequestType & USB_DIR_IN;
+	/* either invoke the driver or handle the request. */
+	switch (creq.bRequest) {
+
+	case USB_REQ_GET_STATUS:
+		dprintk(DEBUG_VERBOSE, "get device status\n");
+		if(lf1000_get_status(udc, &creq))
+			return EP0_STALL;
+		return EP0_IN_DATA_PHASE;
+
+	case USB_REQ_CLEAR_FEATURE:
+		dprintk(DEBUG_VERBOSE, "clear feature\n");
+		if(lf1000_clear_feature(udc, &creq))
+			return EP0_STALL;
+		return EP0_STATUS_PHASE;
+
+	case USB_REQ_SET_FEATURE:
+		dprintk(DEBUG_VERBOSE, "set feature\n");
+		if(lf1000_set_feature(udc, &creq))
+			return EP0_STALL;
+		return EP0_STATUS_PHASE;
+
+	case USB_REQ_SET_ADDRESS:
+		dprintk(DEBUG_VERBOSE, "set address\n");
+		/* do we take action here?  Confirm address? */
+		return EP0_STATUS_PHASE;
+
+	case USB_REQ_GET_DESCRIPTOR:
+	case USB_REQ_GET_CONFIGURATION:
+	case USB_REQ_GET_INTERFACE:
+		dprintk(DEBUG_VERBOSE, "get descriptor/config/interface\n");
+		next_state = EP0_IN_DATA_PHASE;
+		/* Invoke driver */
+		break;
+
+	case USB_REQ_SET_DESCRIPTOR:
+		dprintk(DEBUG_VERBOSE, "set descriptor\n");
+		next_state = EP0_OUT_DATA_PHASE;
+		/* Invoke driver */
+		break;
+
+	case USB_REQ_SET_CONFIGURATION:
+	case USB_REQ_SET_INTERFACE:
+		dprintk(DEBUG_VERBOSE, "set config/interface\n");
+		/* Invoke driver */
+		next_state = EP0_STATUS_PHASE;
+		break;
+	default:
+		/* Possibly a vendor-specific request. */
+		if(is_in)
+			next_state = EP0_IN_DATA_PHASE;
+		else
+			next_state = EP0_STATUS_PHASE;
+	}
+
+	/* pass request up to the gadget driver */
+	if(udc->driver) {
+		status = udc->driver->setup(&udc->gadget, &creq);
+		if(status < 0) {
+			if(status != -EOPNOTSUPP) {
+				printk(KERN_ERR "Unknown USB request: ERR: %d\n",
+				       status);
+			}
+			next_state = EP0_STALL;
+		}
+	} else {
+		next_state = EP0_STALL;
+	}
+
+	return next_state;
+}
+
+static void handle_ep0(struct lf1000_udc *udc)
+{
+	struct lf1000_ep *ep = &udc->ep[0];
+	struct lf1000_request *req;
+	u32 ep0csr;
+
+	writew(0, udc->base_addr + UDC_EPINDEX);
+	ep0csr = readw(udc->base_addr + UDC_EP0STAT);
+
+	if(unlikely(IS_SET(ep0csr, SHT))) {
+		dprintk(DEBUG_VERBOSE, "Clearing stall...\n");
+		nuke(ep, -EPIPE);
+	    	dprintk(DEBUG_NORMAL, "... clear SENT_STALL ...\n");
+	    	clear_ep_stall(udc, 0);
+		udc->ep0state = EP0_IDLE;
+	}
+
+	if((!IS_SET(ep0csr, RSR)) && (!IS_SET(ep0csr, TST))) {
+		dprintk(DEBUG_NORMAL,
+			"Unknown ep0 interrupt: ep0 state: 0x%04x\n", ep0csr);
+		return;
+	}
+
+	while(1) {
+
+		if(list_empty(&ep->queue))
+			req = NULL;
+		else
+			req = list_entry(ep->queue.next,
+					 struct lf1000_request, queue);
+
+		dprintk(DEBUG_VERBOSE, "ep0state %s\n",
+			ep0states[udc->ep0state]);
+
+		switch (udc->ep0state) {
+		case EP0_IDLE:
+			if (IS_SET(ep0csr, TST)) {
+				/* just finished an IN data transfer */
+				writew(1<<TST, udc->base_addr + UDC_EP0STAT);
+				return;
+			} else if (IS_SET(ep0csr, RSR)) {
+				udc->ep0state = handle_setup(udc, ep, ep0csr);
+				writew(1<<RSR, udc->base_addr + UDC_EP0STAT);
+			} else {
+				/* This means all TSTs and RSRs have been
+				 * handled, and somebody changed the state to
+				 * IDLE.  Time to return from interrupt.
+				 */
+				return;
+			}
+			break;
+
+		case EP0_IN_DATA_PHASE:
+			/* We're either here because we are launching or
+			 * continuing a control data transer to the host.
+			 */
+			if (IS_SET(ep0csr, TST)) {
+				/* successfully tx'd a fragment of
+				 * current req. */
+				writew(1<<TST, udc->base_addr + UDC_EP0STAT);
+			}
+
+			if(req != NULL) {
+				if (write_req(ep, req))
+					udc->ep0state = EP0_STATUS_PHASE;
+				else
+					/* wait until TST interrupt */
+					return;
+			} else {
+				dev_info(&udc->pdev->dev,
+					"probably don't wanna be here.\n");
+				return;
+			}
+			break;
+
+		case EP0_OUT_DATA_PHASE:
+			/* We're either here because we are launching or
+			 * continuing a control data transer from the host.
+			 */
+			/* Note: If we receive a setup packet in this phase, we
+			 * must handle it.  This may be a bit tricky.
+			 */
+			dev_warn(&udc->pdev->dev,
+					"unsupported OUT transfer.\n");
+			udc->ep0state = EP0_STALL;
+			break;
+
+		case EP0_STATUS_PHASE:
+			if (IS_SET(ep0csr, TST)) {
+				/* successfully tx'd a fragment of current req. */
+				writew(1<<TST, udc->base_addr + UDC_EP0STAT);
+			}
+			udc->ep0state = EP0_IDLE;
+			return;
+
+		case EP0_STALL:
+			/* If we stall, next invocation should be either a new
+			 * setup transaction or a stall sent interrupt.
+			 */
+			set_ep_stall(udc, 0);
+			udc->ep0state = EP0_IDLE;
+			return;
+		}
+	}
+}
+
+static void handle_ep(struct lf1000_ep *ep)
+{
+	struct lf1000_udc *udc = ep->dev;
+	struct lf1000_request *req;
+	u32 ep_status; /* name ambiguous with ep int status */
+	u32 idx;
+
+	req = NULL;
+	if (likely(!list_empty(&ep->queue)))
+		req = list_entry(ep->queue.next,
+				 struct lf1000_request, queue);
+
+	idx = (u32)(ep->bEndpointAddress&0x7F);
+	writew(idx, udc->base_addr + UDC_EPINDEX);
+	ep_status = readw(udc->base_addr + UDC_EPSTAT);
+	dprintk(DEBUG_VERBOSE, "ep%01d status:%04x.  Req pending: %s\n",
+		idx, ep_status, req ? "yes" : "no");
+	if (unlikely(IS_SET(ep_status, FUDR))) {
+		/* handle fifo underflow */
+		/* Only for ISO endpoints.  Not supported yet. */
+		writew(1<<FUDR, udc->base_addr + UDC_EPSTAT);
+	}
+
+	if (unlikely(IS_SET(ep_status, FOVF))) {
+		/* handle fifo overflow */
+		/* Only for ISO endpoints.  Not supported yet. */
+		writew(1<<FOVF, udc->base_addr + UDC_EPSTAT);
+	}
+
+	if (unlikely(IS_SET(ep_status, FFS))) {
+		/* handle fifo flushed.  We probably just init'd an endpoint */
+		writew(1<<FFS, udc->base_addr + UDC_EPSTAT);
+	}
+
+	if (IS_SET(ep_status, TPS)) {
+		/* handle IN success */
+		writew(1<<TPS, udc->base_addr + UDC_EPSTAT);
+		if(req != NULL) {
+			if (write_req(ep, req)) {
+				/* if we just completed a req, and there is
+				 * another pending, we must launch it.
+				 */
+				if(!list_empty(&ep->queue)) {
+					req = list_entry(ep->queue.next,
+							 struct lf1000_request,
+							 queue);
+					write_req(ep, req);
+				}
+			}
+		} else {
+			/* should we stall? */
+		}
+	}
+
+	if(IS_SET(ep_status, RPS)) {
+		/* handle OUT success */
+		if(req != NULL)
+			read_req(ep, req);
+
+		if(ep->halted == 1) {
+			dprintk(DEBUG_VERBOSE,
+				"Dumping packet for halted ep\n");
+			/* stall the ep and flush the data */
+			set_ep_stall(udc, ep->num);
+			writew(idx, udc->base_addr + UDC_EPINDEX);
+			set_mask(udc, (1<<FLUSH), UDC_EPCTL);
+		}
+
+		/* If the request is NULL, but the ep is configured, we leave
+		 * the data in the queue. */
+		writew(1<<RPS, udc->base_addr + UDC_EPSTAT);
+		return;
+	}
+}
+
+static irqreturn_t lf1000_udc_irq(int irq, void *_dev)
+{
+
+	struct lf1000_udc *dev = _dev;
+	void __iomem *base = dev->base_addr;
+	int usb_status, tmp;
+	int ep_int, ep_status;
+	int test_reg;
+	int ep0csr;
+	int     i;
+	u32	idx;
+
+	/* Driver connected ? */
+	if (!dev->driver) {
+		/* Clear interrupts */
+		tmp = readw(base + UDC_EPINT);
+		writew(tmp, base + UDC_EPINT);
+		tmp = readw(base + UDC_TEST);
+		writew(tmp, base + UDC_TEST);
+		tmp = readw(base + UDC_SYSSTAT);
+		writew(tmp, base + UDC_SYSSTAT);
+	}
+
+	idx = readw(base + UDC_EPINDEX);
+
+	/* Read status registers */
+	usb_status = readw(base + UDC_SYSSTAT);
+	ep_int = readw(base + UDC_EPINT);
+	test_reg = readw(base + UDC_TEST);
+	ep_status = readw(base + UDC_EPSTAT);
+	ep0csr = readw(base + UDC_EP0STAT);
+
+	dprintk(DEBUG_NORMAL, "usbs=%04x, ep_int=%04x, test=%04x "
+		"ep0csr=%04x epstat=%04x\n",
+		usb_status, ep_int, test_reg, ep0csr, ep_status);
+
+	/* count VBUS interrupts separate from processing them */
+	if (IS_SET(usb_status, VBUSOFF))
+		if (IS_SET(usb_status, VBUSON))
+			dev->vbus_int_high_low++; /* VBUS high and low set */
+		else
+			dev->vbus_int_low++;	  /* VBUS low only */
+	else if (IS_SET(usb_status, VBUSON))
+		dev->vbus_int_high++;		  /* VBUS high only */
+
+	// may have one or both VBUSOFF and VBUSON interrupts set
+	if (IS_SET(usb_status, VBUSOFF) || IS_SET(usb_status, VBUSON)) {
+		udelay(20); /* debounce */
+		if (IS_SET(usb_status, VBUSOFF)) {	// VBUSOFF
+			dprintk(DEBUG_VERBOSE, "VBUS off IRQ\n");
+			if(dev->vbus == 1 && IS_CLR(test_reg, VBUS)) {
+				lf1000_udc_vbus_session(&dev->gadget, 0);
+				dev->vbus_report_low++;  // processed low
+			}
+			writew(1<<VBUSOFF, base + UDC_SYSSTAT);
+		}
+
+		if (IS_SET(usb_status, VBUSON)) {	// VBUSON
+			dprintk(DEBUG_VERBOSE, "VBUS on IRQ\n");
+			if(dev->vbus == 0 && IS_SET(test_reg, VBUS)) {
+				lf1000_udc_vbus_session(&dev->gadget, 1);
+				dev->vbus_report_high++;  // processed high
+			}
+			writew(1<<VBUSON, base + UDC_SYSSTAT);
+		}
+		goto irq_done;
+	}
+
+	/* RESET */
+	if (IS_SET(usb_status, HFRES)) {
+		dprintk(DEBUG_NORMAL, "USB reset csr %x\n", ep0csr);
+		if (dev->driver && dev->driver->disconnect)
+			dev->driver->disconnect(&dev->gadget);
+		nuke(&dev->ep[0], -ECONNRESET);
+		writew(1<<TST, base + UDC_EP0STAT);
+		dev->gadget.speed = USB_SPEED_UNKNOWN;
+		writew(0x00, base + UDC_EPINDEX);
+		writew(dev->ep[0].ep.maxpacket & 0x7FF, base + UDC_MPR);
+		dev->address = 0;
+		dev->ep0state = EP0_IDLE;
+		clear_ep_state(dev);
+		/* clear interrupt */
+		writew(1<<HFRES, base + UDC_SYSSTAT);
+		goto irq_done;
+	}
+
+	/* Speed Detect */
+	if (IS_SET(usb_status, SDE)) {
+		dprintk(DEBUG_NORMAL, "USB speed detect\n");
+		if(dev->gadget.speed == USB_SPEED_UNKNOWN) {
+			if(IS_SET(usb_status, HSP))
+				dev->gadget.speed = USB_SPEED_HIGH;
+			else
+				dev->gadget.speed = USB_SPEED_FULL;
+		}
+		/* clear interrupt */
+		writew(1<<SDE, base + UDC_SYSSTAT);
+	}
+
+	/* RESUME */
+	if (IS_SET(usb_status, HFRM)) {
+
+		dprintk(DEBUG_NORMAL, "USB resume\n");
+
+		/* clear interrupt */
+		writew(1<<HFRM, base + UDC_SYSSTAT);
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->resume)
+			dev->driver->resume(&dev->gadget);
+	}
+
+	/* SUSPEND */
+	if (IS_SET(usb_status, HFSUSP)) {
+		dprintk(DEBUG_NORMAL, "USB suspend\n");
+
+		/* clear interrupt */
+		writew(1<<HFSUSP, base + UDC_SYSSTAT);
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+				&& dev->driver
+				&& dev->driver->suspend)
+			dev->driver->suspend(&dev->gadget);
+
+		dev->ep0state = EP0_IDLE;
+	}
+
+	/* EP */
+	if (IS_SET(ep_int, EP0INT)) {
+		dprintk(DEBUG_VERBOSE, "USB ep0 irq\n");
+		writew(1<<EP0INT, base + UDC_EPINT);
+		handle_ep0(dev);
+		goto irq_done;
+	}
+	/* endpoint data transfers */
+	for (i = 1; i < LF1000_ENDPOINTS; i++) {
+		if(IS_SET(ep_int, i)) {
+			dprintk(DEBUG_VERBOSE, "USB ep%d irq\n", i);
+			writew(1<<i, base + UDC_EPINT);
+			handle_ep(&dev->ep[i]);
+		}
+	}
+
+ irq_done:
+	dprintk(DEBUG_VERBOSE,"irq: %d done.\n\n\n", irq);
+	writew(idx, base + UDC_EPINDEX);
+
+	return IRQ_HANDLED;
+}
+
+static int lf1000_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct lf1000_udc *dev;
+	struct lf1000_ep *ep;
+	unsigned int max, tmp;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct lf1000_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name ||
+			desc->bDescriptorType != USB_DT_ENDPOINT)
+		return -EINVAL;
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	local_irq_save(flags);
+
+	max = le16_to_cpu(desc->wMaxPacketSize) & 0x1fff;
+
+	_ep->maxpacket = max & 0x7ff;
+	ep->desc = desc;
+	ep->halted = 0;
+	ep->bEndpointAddress = desc->bEndpointAddress;
+
+	/* disable interrupts */
+	tmp = readw(dev->base_addr + UDC_EPINTEN);
+	writew(tmp & ~(1<<ep->num), dev->base_addr + UDC_EPINTEN);
+	writew(1<<ep->num, dev->base_addr + UDC_EPINT);
+
+	/* reset the endpoint */
+	writew(ep->num, dev->base_addr + UDC_EPINDEX);
+	tmp = readw(dev->base_addr + UDC_EPDIR);
+	writew(tmp & ~(1<<ep->num), dev->base_addr + UDC_EPDIR);
+	tmp = readw(dev->base_addr + UDC_DCR);
+	writew(tmp & ~(1<<DEN), dev->base_addr + UDC_DCR);
+	writew((1<<FLUSH)|(1<<CDP)|(3<<TNPMF), dev->base_addr + UDC_EPCTL);
+	writew(0, dev->base_addr + UDC_EPCTL);
+
+	/* set type, direction, address; reset fifo counters */
+	if (desc->bEndpointAddress & USB_DIR_IN) {
+		tmp = readw(dev->base_addr + UDC_EPDIR);
+		writew(tmp | 1<<ep->num, dev->base_addr + UDC_EPDIR);
+		ep->is_in = 1;
+	} else {
+		tmp = readw(dev->base_addr + UDC_EPDIR);
+		writew(tmp & ~(1<<ep->num), dev->base_addr + UDC_EPDIR);
+		ep->is_in = 0;
+	}
+
+	tmp = readw(dev->base_addr + UDC_EPCTL);
+	writew(tmp | (1<<FLUSH), dev->base_addr + UDC_EPCTL);
+
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_ISOC:
+		tmp = readw(dev->base_addr + UDC_EPCTL);
+		tmp |= (1<<IME)|(3<<TNPMF);
+		writew(tmp, dev->base_addr + UDC_EPCTL);
+		break;
+
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+	default:
+		tmp = readw(dev->base_addr + UDC_EPCTL);
+		writew(tmp & ~(1<<IME), dev->base_addr + UDC_EPCTL);
+	}
+
+	writew(max, dev->base_addr + UDC_MPR);
+
+	clear_ep_stall(dev, ep->num);
+
+	/* clear any pending interrupts, and enable */
+	tmp = (1<<FUDR)|(1<<FOVF)|(1<<OSD)|(1<<DTCZ)|(1<<SPT)|(1<<FFS);
+	tmp |= (1<<FSC)|(1<<TPS);
+	/* I think we should clear this, but ME recommends otherwise. */
+	/* tmp |= (1<<RPS); */
+	set_mask(dev, tmp, UDC_EPSTAT);
+
+	/* enable interrupts */
+	set_mask(dev, (1<<ep->num), UDC_EPINT);
+	set_mask(dev, (1<<ep->num), UDC_EPINTEN);
+
+	/* print some debug message */
+	tmp = desc->bEndpointAddress;
+	dprintk (DEBUG_NORMAL, "enable %s(%d) ep%x%s-blk max %02x\n",
+		_ep->name,ep->num, tmp, desc->bEndpointAddress & USB_DIR_IN ? "in" : "out", max);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int lf1000_ep_disable(struct usb_ep *_ep)
+{
+	struct lf1000_ep *ep = container_of(_ep, struct lf1000_ep, ep);
+	unsigned long tmp, flags;
+
+	if (!_ep || !ep->desc) {
+		dprintk(DEBUG_NORMAL, "%s not enabled\n",
+			_ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	local_irq_save(flags);
+
+	dprintk(DEBUG_NORMAL, "ep_disable: %s\n", _ep->name);
+
+	ep->desc = NULL;
+	ep->halted = 1;
+
+	nuke(ep, -ESHUTDOWN);
+
+	/* disable irqs */
+	tmp = readw(ep->dev + UDC_EPINTEN);
+	writew(tmp & ~(1<<ep->num), ep->dev + UDC_EPINTEN);
+
+	dprintk(DEBUG_NORMAL, "%s disabled\n", _ep->name);
+
+	local_irq_save(flags);
+	return 0;
+}
+
+static struct usb_request *lf1000_alloc_request (struct usb_ep *_ep,
+		gfp_t mem_flags)
+{
+	struct lf1000_ep	*ep;
+	struct lf1000_request	*req;
+
+    	dprintk(DEBUG_VERBOSE,"lf1000_alloc_request(ep=%p,flags=%d)\n", _ep, mem_flags);
+
+	ep = container_of (_ep, struct lf1000_ep, ep);
+	if (!_ep)
+		return NULL;
+
+	req = kzalloc (sizeof *req, mem_flags);
+	if (!req)
+		return NULL;
+	INIT_LIST_HEAD (&req->queue);
+	return &req->req;
+}
+
+static void lf1000_free_request (struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct lf1000_ep	*ep;
+	struct lf1000_request	*req;
+
+	dprintk(DEBUG_VERBOSE, "lf1000_free_request(ep=%p,req=%p)\n", _ep, _req);
+
+	ep = container_of (_ep, struct lf1000_ep, ep);
+	if (!ep || !_req || (!ep->desc && _ep->name != ep0name))
+		return;
+
+	req = container_of (_req, struct lf1000_request, req);
+	WARN_ON (!list_empty (&req->queue));
+	kfree(req);
+}
+
+static int lf1000_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gf)
+{
+	struct lf1000_request	*req;
+	struct lf1000_ep	*ep;
+	struct lf1000_udc	*udc;
+	int			launch = 0;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct lf1000_ep, ep);
+	if (unlikely (!_req || !_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		dprintk(DEBUG_NORMAL, "lf1000_queue: invalid arguments.\n");
+		return -EINVAL;
+	}
+	req = container_of(_req, struct lf1000_request, req);
+
+	udc = ep->dev;
+	if(unlikely (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		return -ESHUTDOWN;
+	}
+
+	if (unlikely(!_req->buf)) {
+		dprintk(DEBUG_NORMAL, "lf1000_queue: Buffer not allocated!\n");
+		return -EINVAL;
+	}
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	local_irq_save(flags);
+
+	dprintk(DEBUG_VERBOSE,"lf1000_queue: ep%x len %d\n",
+		ep->bEndpointAddress, _req->length);
+
+	/* pio or dma irq handler advances the queue.  Don't bother with
+	 * zero-length packets.  Those are handled automatically by our
+	 * hardware.
+	 */
+	if(_req->length == 0) {
+		if(_req->complete) {
+			_req->status = 0;
+			_req->complete(_ep, _req);
+		}
+	} else {
+		if(list_empty(&ep->queue) &&
+		   (ep->bEndpointAddress != 0)) {
+			/* In this case we must launch the first tranfer.
+			 * Otherwise, the interrupts that result from other
+			 * transfers will launch ours.
+			 */
+			launch = 1;
+		}
+		list_add_tail(&req->queue, &ep->queue);
+		if(launch == 1) {
+			if(ep->bEndpointAddress & USB_DIR_IN) {
+				write_req(ep, req);
+			} else {
+				read_req(ep, req);
+			}
+		}
+	}
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int lf1000_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	int retval = -EINVAL;
+	struct lf1000_ep *ep = container_of(_ep, struct lf1000_ep, ep);
+	struct lf1000_udc *udc = ep->dev;
+	struct lf1000_request *req = NULL;
+
+    	dprintk(DEBUG_VERBOSE,"lf1000_dequeue(ep=%p,req=%p)\n", _ep, _req);
+
+	if (!udc->driver)
+		return -ESHUTDOWN;
+
+	if (!_ep || !_req)
+		return retval;
+
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req) {
+			list_del_init (&req->queue);
+			_req->status = -ECONNRESET;
+			retval = 0;
+			break;
+		}
+	}
+
+	if (retval == 0) {
+		dprintk(DEBUG_VERBOSE, "dequeued req %p from %s, len %d buf %p\n",
+				req, _ep->name, _req->length, _req->buf);
+
+		done(ep, req, -ECONNRESET);
+	}
+
+	return retval;
+}
+
+static int lf1000_set_halt(struct usb_ep *_ep, int value)
+{
+	int ret = 0;
+	struct lf1000_ep *ep;
+	struct lf1000_udc *udc;
+	unsigned long len, flags;
+
+	WARN_ON(!_ep);
+	if (!_ep)
+		return -EINVAL;
+	ep = container_of(_ep, struct lf1000_ep, ep);
+
+	WARN_ON(!ep->gadget);
+	if (!ep->gadget)
+		return -EINVAL;
+	udc = container_of(ep->gadget, struct lf1000_udc, gadget);
+	
+	WARN_ON(!udc->driver);
+	if (!udc->driver)
+		return -ESHUTDOWN;
+
+	local_irq_save(flags);
+
+	ep->halted = value;
+
+	writew(ep->num, udc->base_addr + UDC_EPINDEX);
+	len = 2*readw(udc->base_addr +UDC_BRCR);
+
+	if(ep->is_in && (!list_empty(&ep->queue) || len))
+		ret = -EAGAIN;
+	else {
+		if (value) {
+			dprintk(DEBUG_VERBOSE, "setting halt on ep%d\n",
+				ep->num);
+			set_ep_stall(udc, ep->num);
+		} else {
+			dprintk(DEBUG_VERBOSE, "clearing halt on ep%d\n",
+				ep->num);
+			clear_ep_stall(udc, ep->num);
+		}
+	}
+	
+	local_irq_restore(flags);
+	return ret;
+}
+
+static const struct usb_ep_ops lf1000_ep_ops = {
+	.enable         = lf1000_ep_enable,
+	.disable        = lf1000_ep_disable,
+
+	.alloc_request  = lf1000_alloc_request,
+	.free_request   = lf1000_free_request,
+
+
+	.queue          = lf1000_queue,
+	.dequeue        = lf1000_dequeue,
+
+	.set_halt       = lf1000_set_halt,
+};
+
+/*------------------------- usb_gadget_ops ----------------------------------*/
+
+static int lf1000_get_frame(struct usb_gadget *_gadget)
+{
+	struct lf1000_udc *udc;
+       
+	udc = container_of(_gadget, struct lf1000_udc, gadget);
+	
+	return (int)(readw(udc->base_addr + UDC_FRAMENUM) & 0x7ff);
+}
+
+static int lf1000_wakeup(struct usb_gadget *_gadget)
+{
+	return 0;
+}
+
+static int lf1000_set_selfpowered(struct usb_gadget *_gadget, int value)
+{
+	struct lf1000_udc  *udc;
+	unsigned long flags;
+
+	dprintk(DEBUG_NORMAL, "lf1000_set_selfpowered()\n");
+
+	udc = container_of (_gadget, struct lf1000_udc, gadget);
+
+	local_irq_save(flags);
+
+	if (value)
+		udc->devstatus |= (1 << USB_DEVICE_SELF_POWERED);
+	else
+		udc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);
+	
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops lf1000_ops = {
+	.get_frame          = lf1000_get_frame,
+	.wakeup             = lf1000_wakeup,
+	.set_selfpowered    = lf1000_set_selfpowered,
+	.vbus_session	    = lf1000_udc_vbus_session,
+};
+
+/*------------------------- gadget driver handling---------------------------*/
+/*
+ * udc_disable
+ */
+static void udc_disable(struct lf1000_udc *dev)
+{
+	int tmp;
+	int i;
+
+	dprintk(DEBUG_NORMAL, "udc_disable called\n");
+
+	lf1000_vbus_command(dev, LF1000_UDC_VBUS_DISABLE);
+
+	/* disable phy block */
+	tmp = readw(dev->base_addr + UDC_PCR) | (1<<PCE);
+	writew(tmp, dev->base_addr + UDC_PCR);
+
+	/* Disable all interrupts */
+	writew(1<<RRDE, dev->base_addr + UDC_SYSCTL);
+	writew(0, dev->base_addr + UDC_EPINTEN);
+
+	/* Clear the interrupt registers */
+	writew(0xFFFF, dev->base_addr + UDC_SYSSTAT);
+	writew(0xFFFF, dev->base_addr + UDC_EPINT);
+	tmp = readw(dev->base_addr + UDC_TEST);
+	writew(tmp, dev->base_addr + UDC_TEST);
+
+	/* Reset endpoint 0 */
+	writew((1<<RSR)|(1<<TST)|(1<<SHT), dev->base_addr + UDC_EP0STAT);
+	writew(1<<TTS, dev->base_addr + UDC_EP0CTL); /* TODO: Why? */
+	writew(dev->ep[0].ep.maxpacket & 0x7ff, dev->base_addr + UDC_MPR);
+
+	/* Reset endpoints */
+	writew(0, dev->base_addr + UDC_EPINTEN);
+	writew(0xFFFF, dev->base_addr + UDC_EPINT);
+	writew(0, dev->base_addr + UDC_EPDIR);
+	for (i = 1; i < LF1000_ENDPOINTS; i++) {
+		writew(i, dev->base_addr + UDC_EPINDEX);
+		tmp = readw(dev->base_addr + UDC_DCR) & ~(1<<DEN);
+		writew(tmp, dev->base_addr + UDC_DCR);
+		writew((1<<FLUSH)|(1<<CDP)|(3<<TNPMF),
+				dev->base_addr + UDC_EPCTL);
+	}
+
+	/* Set speed to unknown */
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+}
+
+static void udc_reinit(struct lf1000_udc *dev)
+{
+	int i;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD (&dev->gadget.ep_list);
+	INIT_LIST_HEAD (&dev->gadget.ep0->ep_list);
+	dev->ep0state = EP0_IDLE;
+
+	for (i = 0; i < LF1000_ENDPOINTS; i++) {
+		struct lf1000_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->dev = dev;
+		ep->desc = NULL;
+		ep->halted = 1;
+		INIT_LIST_HEAD (&ep->queue);
+	}
+}
+
+/*
+ * udc_enable
+ */
+static void udc_enable(struct lf1000_udc *dev)
+{
+	int i;
+	int tmp;
+
+	dprintk(DEBUG_NORMAL, "udc_enable called\n");
+
+	/* dev->gadget.speed = USB_SPEED_UNKNOWN; */
+	dev->gadget.speed = USB_SPEED_FULL;
+
+	/* Reverse byte order */
+	tmp = readw(dev->base_addr + UDC_SYSCTL) | (1<<RRDE);
+	writew(tmp, dev->base_addr + UDC_SYSCTL);
+
+	/* Set MAXP for all endpoints */
+	for (i = 0; i < LF1000_ENDPOINTS; i++) {
+		writew(i, dev->base_addr + UDC_EPINDEX);
+		if (i == 0) {
+			writew((1<<RSR)|(1<<TST)|(1<<SHT),
+					dev->base_addr + UDC_EP0STAT);
+		} else {
+			tmp = readw(dev->base_addr + UDC_DCR);
+			BIT_CLR(tmp, DEN);
+			writew(tmp, dev->base_addr + UDC_DCR);
+			writew((1<<CDP)|(1<<FLUSH)|(3<<TNPMF),
+					dev->base_addr + UDC_EPCTL);
+		}
+		writew(dev->ep[i].ep.maxpacket & 0x7FF,
+				dev->base_addr + UDC_MPR);
+	}
+
+	/* disable phy block */
+	tmp = readw(dev->base_addr + UDC_PCR) | (1<<PCE);
+	writew(tmp, dev->base_addr + UDC_PCR);
+
+	/* enable phy block */
+	tmp = readw(dev->base_addr + UDC_PCR) & ~(1<<PCE);
+	writew(tmp, dev->base_addr + UDC_PCR);
+
+	/* Clear and enable reset and suspend interrupt interrupts */
+	writew(0xFF, dev->base_addr + UDC_SYSSTAT);
+	tmp = readw(dev->base_addr + UDC_SYSCTL);
+	tmp |= (1<<HSUSPE)|(1<<HRESE)|(1<<SPDEN);
+	writew(tmp, dev->base_addr + UDC_SYSCTL);
+
+	/* Clear and enable ep0 interrupt */
+	writew(0xFF, dev->base_addr + UDC_EPINT);
+	tmp = readw(dev->base_addr + UDC_EPINTEN) | (1<<EP0INTEN);
+	writew(tmp, dev->base_addr + UDC_EPINTEN);
+
+	/* enable the vbus interrupt and let the vbus signal through */
+	lf1000_vbus_command(dev, LF1000_UDC_VBUS_ENABLE);
+}
+
+static void lf1000_udc_setup_drvdata(struct lf1000_udc *udc)
+{
+	udc->gadget.ops			= &lf1000_ops;
+	udc->gadget.ep0			= &udc->ep[0].ep;
+	udc->gadget.name		= gadget_name;
+	udc->gadget.dev.init_name	= "gadget";
+
+	/* control endpoint */
+	udc->ep[0].num			= 0;
+	udc->ep[0].ep.name		= ep0name;
+	udc->ep[0].ep.ops		= &lf1000_ep_ops;
+	udc->ep[0].ep.maxpacket		= EP0_FIFO_SIZE;
+	udc->ep[0].dev 			= udc;
+	udc->ep[0].is_in 		= 1;
+
+	udc->ep[1].num			= 1;
+	udc->ep[1].ep.name		= "ep1";
+	udc->ep[1].ep.ops		= &lf1000_ep_ops;
+	udc->ep[1].ep.maxpacket		= EP_FIFO_SIZE;
+	udc->ep[1].dev			= udc;
+	udc->ep[1].fifo_size		= EP_FIFO_SIZE;
+	udc->ep[1].bEndpointAddress	= 1;
+	udc->ep[1].bmAttributes		= USB_ENDPOINT_XFER_BULK;
+
+	udc->ep[2].num			= 2;
+	udc->ep[2].ep.name		= "ep2";
+	udc->ep[2].ep.ops		= &lf1000_ep_ops;
+	udc->ep[2].ep.maxpacket		= EP_FIFO_SIZE;
+	udc->ep[2].dev			= udc;
+	udc->ep[2].fifo_size		= EP_FIFO_SIZE;
+	udc->ep[2].bEndpointAddress	= 2;
+	udc->ep[2].bmAttributes		= USB_ENDPOINT_XFER_BULK;
+};
+
+static struct lf1000_udc *udc_dev = NULL;
+
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct lf1000_udc *udc = udc_dev;
+	int retval;
+
+	/* Sanity checks */
+	if (!udc)
+		return -ENODEV;
+	if (udc->driver)
+		return -EBUSY;
+
+	dev_info(&udc->pdev->dev, "%s '%s'\n", __FUNCTION__,
+			driver->driver.name);
+
+	if (!driver->bind || !driver->setup
+			|| driver->speed < USB_SPEED_FULL) {
+		dev_err(&udc->pdev->dev,
+			"invalid driver: bind %p setup %p speed %d\n",
+			driver->bind, driver->setup, driver->speed);
+		return -EINVAL;
+	}
+
+#if defined(MODULE)
+	if (!driver->unbind) {
+		dev_err(&udc->pdev->dev, "invalid driver: no unbind method\n");
+		return -EINVAL;
+	}
+#endif
+
+	/* Hook the driver */
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+
+	/* Bind the driver */
+	if ((retval = device_add(&udc->gadget.dev)) != 0) {
+		dev_err(&udc->pdev->dev, "failed to add device: %d\n", retval);
+		goto register_error;
+	}
+	
+	dev_info(&udc->pdev->dev, "binding gadget driver '%s'\n",
+			driver->driver.name);
+
+	if ((retval = driver->bind (&udc->gadget)) != 0) {
+		device_del(&udc->gadget.dev);
+		goto register_error;
+	}
+
+	/* Enable udc */
+	udc_enable(udc);
+
+	return 0;
+
+register_error:
+	udc->driver = NULL;
+	udc->gadget.dev.driver = NULL;
+	return retval;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct lf1000_udc *udc = udc_dev;
+
+	if (!udc)
+		return -ENODEV;
+
+	if (!driver || driver != udc->driver || !driver->unbind)
+		return -EINVAL;
+
+	dev_info(&udc->pdev->dev, "%s '%s'\n", __FUNCTION__,
+		driver->driver.name);
+
+	if (driver->disconnect)
+		driver->disconnect(&udc->gadget);
+
+	driver->unbind(&udc->gadget);
+
+	device_del(&udc->gadget.dev);
+	udc->driver = NULL;
+
+	/* Disable udc */
+	udc_disable(udc);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+static int lf1000_udc_remove(struct platform_device *pdev)
+{
+	struct lf1000_udc *udc = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "remove\n");
+
+	if (udc->debug)
+		debugfs_remove(udc->debug);
+
+	device_remove_file(&pdev->dev, &dev_attr_vbus);
+
+	if(udc->input > 0)
+		input_unregister_device(udc->input);
+	
+	lf1000_vbus_command(udc, LF1000_UDC_VBUS_SHUTDOWN);
+
+	if(udc->base_addr) {
+		writew(0, udc->base_addr + UDC_CLKEN);
+		iounmap(udc->base_addr);
+		release_mem_region(udc->res->start, RESSIZE(udc->res));
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	usb_gadget_unregister_driver(udc->driver);
+
+	free_irq(udc->irq, udc);
+
+	kfree(udc);
+	udc_dev = NULL;
+
+	return 0;
+}
+
+static int lf1000_udc_probe(struct platform_device *pdev)
+{
+	struct lf1000_udc *udc;
+	int retval = 0;
+
+	dev_info(&pdev->dev, "probe\n");
+
+	udc = kzalloc(sizeof(struct lf1000_udc), GFP_KERNEL);
+	if (!udc) {
+		dev_err(&pdev->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	lf1000_udc_setup_drvdata(udc);
+	platform_set_drvdata(pdev, udc);
+	udc->pdev = pdev;
+	udc_dev = udc;
+
+	udc->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(!udc->res) {
+		dev_err(&pdev->dev, "failed to get resource\n");
+		retval = -ENXIO;
+		goto fail;
+	}
+
+	if(!request_mem_region(udc->res->start, RESSIZE(udc->res),
+				"lf1000_udc")) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		retval = -ENXIO;
+		retval = -EBUSY;
+		goto fail;
+	}
+
+	udc->base_addr = ioremap(udc->res->start, RESSIZE(udc->res));
+	if(!udc->base_addr) {
+		dev_err(&pdev->dev, "failed to ioremap\n");
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	/* initialize vbus sensing stats */
+	udc->vbus_int_high = 0;
+	udc->vbus_int_high_low = 0;
+	udc->vbus_int_low = 0;
+	udc->vbus_report_high = 0;
+	udc->vbus_report_low = 0;
+
+	/* Set up clock */
+	writew((0<<UDC_CLKDIV)|(0x3<<UDC_CLKSRCSEL),
+			udc->base_addr + UDC_CLKGEN);
+	writew((1<<UDC_PCLKMODE)|(1<<UDC_CLKGENENB)|(3<<UDC_CLKENB),
+			udc->base_addr + UDC_CLKEN);
+
+	/* Add the usb gadget bus */
+	device_initialize(&udc->gadget.dev);
+	udc->gadget.dev.parent = &pdev->dev;
+	udc->gadget.dev.dma_mask = pdev->dev.dma_mask;
+	udc->gadget.is_dualspeed = 1;
+	udc->devstatus = 0;
+
+	udc_disable(udc);
+	udc_reinit(udc);
+
+	/* irq setup after old hardware state is cleaned up */
+	udc->irq = platform_get_irq(pdev, 0);
+	if(udc->irq < 0) {
+		dev_err(&pdev->dev, "can't get IRQ\n");
+		retval = udc->irq;
+		goto fail;
+	}
+	retval = request_irq(udc->irq, lf1000_udc_irq,
+			IRQF_DISABLED, gadget_name, udc);
+
+	if (retval != 0) {
+		dev_err(&pdev->dev, "can't get irq %i, err %d\n",
+				udc->irq, retval);
+		retval = -EBUSY;
+		goto fail;
+	}
+	dprintk(DEBUG_VERBOSE, "%s: got irq %i\n", gadget_name, udc->irq);
+
+	/* init the vbus signal */
+	retval = lf1000_vbus_command(udc, LF1000_UDC_VBUS_INIT);
+	if(retval != 0) {
+		dev_err(&pdev->dev, "failed to initialize vbus pin");
+		goto fail;
+	}
+
+	/* set up input device for reporting VBUS */
+	udc->input = input_allocate_device();
+	if(!udc->input) {
+		dev_err(&pdev->dev, "can't get device for vbus key hack\n");
+		retval = -ENOMEM;
+		goto fail;
+	}
+	udc->input->name = "LF1000 USB";
+	udc->input->phys = "lf1000/usb";
+	udc->input->id.bustype = BUS_HOST;
+	udc->input->id.vendor = 0x0001;
+	udc->input->id.product = 0x0001;
+	udc->input->id.version = 0x0001;
+
+	/* we only support a 'switch' event */
+	udc->input->evbit[0] = BIT(EV_SW);
+	/* we don't offer any keys */
+	udc->input->keycode = NULL;
+	udc->input->keycodesize = 0;
+	udc->input->keycodemax = 0;
+	
+	/* reusing 'lid' for our switch */
+	set_bit(SW_LID, udc->input->swbit);
+
+	retval = input_register_device(udc->input);
+	if(retval) {
+		dev_err(&pdev->dev, "can't register dev for vbus key hack\n");
+		goto fail;
+	}
+
+	device_create_file(&pdev->dev, &dev_attr_vbus);
+
+	udc->debug = debugfs_create_dir("lf1000-usb-gadget", NULL);
+	if (udc->debug && udc->debug != ERR_PTR(-ENODEV)) {
+		debugfs_create_bool("vbus", S_IRUGO, udc->debug,
+				(u32 *)&udc->vbus);
+		debugfs_create_u32("vbus_int_high", S_IRUGO, udc->debug,
+				&udc->vbus_int_high);
+		debugfs_create_u32("vbus_int_low", S_IRUGO, udc->debug,
+				&udc->vbus_int_low);
+		debugfs_create_u32("vbus_int_high_low", S_IRUGO, udc->debug,
+				&udc->vbus_int_high_low);
+		debugfs_create_u32("vbus_report_high", S_IRUGO, udc->debug,
+				&udc->vbus_report_high);
+		debugfs_create_u32("vbus_report_low", S_IRUGO, udc->debug,
+				&udc->vbus_report_low);
+		debugfs_create_file("regs", S_IRUGO, udc->debug, udc,
+				&lf1000_udc_regs_fops);
+	} else {
+		dev_err(&pdev->dev, "can't create debugfs files\n");
+		udc->debug = NULL;
+	}
+
+	return 0;
+
+fail:
+	lf1000_udc_remove(pdev);
+	return retval;
+}
+
+#ifdef CONFIG_PM
+static int lf1000_udc_suspend(struct platform_device *pdev, pm_message_t message)
+{
+#if 0
+	struct lf1000_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(LF1000_UDC_P_DISABLE);
+#endif
+	return 0;
+}
+
+static int lf1000_udc_resume(struct platform_device *pdev)
+{
+#if 0
+	struct lf1000_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc_info && udc_info->udc_command)
+		udc_info->udc_command(LF1000_UDC_P_ENABLE);
+#endif
+	return 0;
+}
+#else
+#define lf1000_udc_suspend      NULL
+#define lf1000_udc_resume       NULL
+#endif
+
+static struct platform_driver lf1000_udc_driver = {
+	.driver		= {
+		.name 	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe          = lf1000_udc_probe,
+	.remove         = lf1000_udc_remove,
+	.suspend	= lf1000_udc_suspend,
+	.resume		= lf1000_udc_resume,
+};
+
+static int __init udc_init(void)
+{
+	return platform_driver_register(&lf1000_udc_driver);
+}
+
+static void __exit udc_exit(void)
+{
+	platform_driver_unregister(&lf1000_udc_driver);
+}
+
+
+module_init(udc_init);
+module_exit(udc_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("LF1000 USB Device Controller Gadget");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lf1000_udc");
diff -ruaN linux-2.6.31/drivers/usb/gadget/lf1000_udc.h linux-2.6/drivers/usb/gadget/lf1000_udc.h
--- linux-2.6.31/drivers/usb/gadget/lf1000_udc.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/usb/gadget/lf1000_udc.h	2011-01-04 14:27:44.000000000 -0800
@@ -0,0 +1,356 @@
+#ifndef _LF1000_UDC_H
+#define _LF1000_UDC_H
+
+/* Hardware register, offset, and value definitions */
+#define UDC_EPINDEX		(0x0)
+
+#define UDC_EPINT		(0x2)
+#define EP3INT			(3)
+#define EP2INT			(2)
+#define EP1INT			(1)
+#define EP0INT			(0)
+
+#define UDC_EPINTEN		(0x4)
+#define EP3INTEN		(3)
+#define EP2INTEN		(2)
+#define EP1INTEN		(1)
+#define EP0INTEN		(0)
+
+#define UDC_FUNCADDR		(0x6)
+#define UDC_FRAMENUM		(0x8)
+
+#define UDC_EPDIR		(0xA)
+#define EP1DS			(0x1)
+#define EP2DS			(0x2)
+#define EP3DS			(0x3)
+
+#define UDC_TEST		(0xC)
+#define VBUS			(15)
+#define EUERR			(13)
+#define PERR			(12)
+#define FDWR			(11)
+#define SPDSEL			(6)
+#define TMD			(4)
+#define TEST_TPS		(3)
+#define TKS			(2)
+#define TJS			(1)
+#define TSNS			(0)
+
+#define UDC_SYSSTAT		(0xE)
+#define BAERR			(15)
+#define TMERR			(14)
+#define BSERR			(13)
+#define TCERR			(12)
+#define DCERR			(11)
+#define EOERR			(10)
+#define VBUSOFF			(9)
+#define VBUSON			(8)
+#define TBM			(7)
+#define DP			(6)
+#define DM			(5)
+#define HSP			(4)
+#define SDE			(3)
+#define HFRM			(2)
+#define HFSUSP			(1)
+#define HFRES			(0)
+
+#define UDC_SYSCTL		(0x10)
+#define DTZIEN			(14)
+#define DIEN			(12)
+#define VBUSOFFEN		(11)
+#define VBUSONEN		(10)
+#define RWDE			(9)
+#define EIE			(8)
+#define BIS			(7)
+#define SPDEN			(6)
+#define RRDE			(5)
+#define IPS			(4)
+#define MFRM			(2)
+#define HSUSPE			(1)
+#define HRESE			(0)
+
+#define UDC_EP0STAT		(0x12)
+#define EP0LWO			(6)
+#define SHT			(4)
+#define TST			(1)
+#define RSR			(0)
+
+#define UDC_EP0CTL		(0x14)
+#define EP0TTE			(3)
+#define EP0TTS			(2)
+#define EP0ESS			(1)
+#define EP0TZLS			(0)
+
+#define UDC_EPSTAT		(0x16)
+#define FUDR			(15)
+#define FOVF			(14)
+#define FPID			(11)
+#define OSD			(10)
+#define DTCZ			(9)
+#define SPT			(8)
+#define DOM			(7)
+#define FFS			(6)
+#define FSC			(5)
+#define EPLWO			(4)
+#define PSIF			(2)
+#define TPS			(1)
+#define RPS			(0)
+
+#define UDC_EPCTL		(0x18)
+#define SRE			(15)
+#define INPKTHLD		(12)
+#define OUTPKTHLD		(11)
+#define TNPMF			(9)
+#define IME			(8)
+#define DUEN			(7)
+#define FLUSH			(6)
+#define TTE			(5)
+#define TTS			(3)
+#define CDP			(2)
+#define ESS			(1)
+
+/* IEMS=interrupt endpoint mode set.  Does this mean that interrupt endpoints
+ * were not supported until now?
+ */
+#define IEMS			(0)
+
+#define UDC_BRCR		(0x1A)
+#define UDC_BWCR		(0x1C)
+#define UDC_MPR			(0x1E)
+
+#define UDC_DCR			(0x20)
+#define ARDRD			(5)
+#define FMDE			(4)
+#define DMDE			(3)
+#define TDR			(2)
+#define RDR			(1)
+#define DEN			(0)
+
+#define UDC_DTCR		(0x22)
+#define UDC_DFCR		(0x24)
+#define UDC_DTTCR		(0x26)
+
+/* This buffer has one 16-bit entry per EP? Do we DMA to here? */
+#define UDC_EPBUFS		(0x30)
+
+/* New registers in the USB */
+#define UDC_PLICR		(0x50)
+#define PLC			(8)
+#define LPC			(4)
+
+#define UDC_PCR			(0x52)
+#define URSTC			(7)
+#define SIDC			(6)
+#define OPMC			(4)
+#define TMSC			(3)
+#define XCRC			(4)
+#define SUSPC			(1)
+#define PCE			(0)
+
+/* The LF1000 CPU has some yet-undocumented registers */
+#define UDC_CIKSEL		(0x840)
+
+#define UDC_VBUSINTENB		(0x842)
+
+#define UDC_VBUSPEND		(0x844)
+#define VBUSPEND		(0)
+
+#define UDC_POR			(0x846)
+
+#define UDC_SUSPEND		(0x848)
+
+#define UDC_USER0		(0x84A)
+#define XOBLOCK_ON		(0)
+
+#define UDC_USER1		(0x84C)
+#define VBUSENB			(15)
+
+#define UDC_CLKEN		(0x8C0)
+#define UDC_PCLKMODE		(3)
+#define UDC_CLKGENENB		(2)
+#define UDC_CLKENB		(0)
+
+#define UDC_CLKGEN		(0x8C4)
+#define UDC_CLKSRCSEL		(1)
+#define UDC_CLKDIV		(4)
+
+/* The LF1000 uses one gpio pin to detect the vbus signal, and another to gate
+ * the vbus signal to the UDC's USBVBUS pin.  In response to this latter signal,
+ * the UDC pulls the D- line high to perform speed negotiation with the host.
+ * In principle, it can also be used to detect the vbus status, but that's just
+ * not how we do it.
+ */
+#include <mach/gpio.h>
+#define VBUS_DET_PIN GPIO_PIN5
+/* On the LF1000 board made by MagicEyes, the VBUS pin goes directly to the
+ * USBVBUS pin on the chip, so the GPIO pins are not used for VBUS handling.
+ */
+
+struct lf1000_ep {
+	struct list_head		queue;
+	unsigned long			last_io;	/* jiffies timestamp */
+	struct usb_gadget		*gadget;
+	struct lf1000_udc		*dev;
+	const struct usb_endpoint_descriptor *desc;
+	struct usb_ep			ep;
+	u8				num;
+
+	unsigned short			fifo_size;
+	u8				bEndpointAddress;
+	u8				bmAttributes;
+
+	unsigned			halted : 1;
+	unsigned			already_seen : 1;
+	unsigned			setup_stage : 1;
+	unsigned short			status;
+	unsigned int			is_in;
+};
+
+
+/* Warning : ep0 has a fifo of 8 bytes */
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512 /* 1024 is the max */
+#define DEFAULT_POWER_STATE	0x00
+
+static const char ep0name [] = "ep0";
+
+static const char *const ep_name[] = {
+	ep0name, /* everyone has ep0 */
+	/* lf1000 three bidirectional endpoints */
+	"ep1", "ep2",
+};
+
+#define LF1000_ENDPOINTS       ARRAY_SIZE(ep_name)
+
+struct lf1000_request {
+	struct list_head		queue;		/* ep's requests */
+	struct usb_request		req;
+};
+
+enum ep0_state {
+        EP0_IDLE,
+        EP0_IN_DATA_PHASE,
+        EP0_OUT_DATA_PHASE,
+        EP0_STATUS_PHASE,
+        EP0_STALL,
+};
+
+static const char *ep0states[]= {
+        "EP0_IDLE",
+        "EP0_IN_DATA_PHASE",
+        "EP0_OUT_DATA_PHASE",
+        "EP0_STATUS_PHASE",
+        "EP0_STALL",
+};
+
+struct lf1000_udc {
+	void __iomem            	*base_addr;
+	struct resource			*res;
+	struct platform_device		*pdev;
+
+	struct lf1000_ep		ep[LF1000_ENDPOINTS];
+	int				address;
+	int				irq;
+	struct usb_gadget		gadget;
+	struct usb_gadget_driver	*driver;
+	u8				fifo_buf[EP_FIFO_SIZE];
+	u16				devstatus;
+	u16				ifstatus;
+
+	u32				port_status;
+    	int 	    	    	    	ep0state;
+
+	bool				vbus;
+
+	// count VBUS ints, whether high, low or high and low
+	u32				vbus_int_high;		// high only
+	u32				vbus_int_high_low;	// high and low
+	u32				vbus_int_low;		// low only
+	u32				vbus_report_high;	// reported high
+	u32				vbus_report_low;	// reported low
+
+	struct lf1000_request		statreq;
+
+	struct input_dev		*input;
+
+	struct dentry			*debug;
+};
+
+/****************** MACROS ******************/
+/* #define BIT_MASK	BIT_MASK*/
+#define BIT_MASK_FF	0xFF
+
+#define maskb(base,v,m,a)      \
+	        writeb((readb(base+a) & ~(m))|((v)&(m)), (base+a))
+
+#define maskw(base,v,m,a)      \
+	        writew((readw(base+a) & ~(m))|((v)&(m)), (base+a))
+
+#define maskl(base,v,m,a)      \
+	        writel((readl(base+a) & ~(m))|((v)&(m)), (base+a))
+
+#define clear_ep0_se(base) do {				\
+    	LF1000_UDC_SETIX(base,EP0); 			\
+	maskl(base,LF1000_UDC_EP0_CSR_SSE,		\
+	    	BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG); 	\
+} while(0)
+
+#define clear_ep0_opr(base) do {			\
+   	LF1000_UDC_SETIX(base,EP0);			\
+	maskl(base,LF1000_UDC_EP0_CSR_SOPKTRDY,	\
+		BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG); 	\
+} while(0)
+
+#define set_ep0_ipr(base) do {				\
+   	LF1000_UDC_SETIX(base,EP0);			\
+	maskl(base,LF1000_UDC_EP0_CSR_IPKRDY,		\
+		BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG); 	\
+} while(0)
+
+#define set_ep0_de_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP0);			\
+	maskl(base,(LF1000_UDC_EP0_CSR_SOPKTRDY 	\
+		| LF1000_UDC_EP0_CSR_DE),		\
+		BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG);	\
+} while(0)
+
+#define set_ep0_sse_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP0);			\
+	maskl(base,(LF1000_UDC_EP0_CSR_SOPKTRDY 	\
+		| LF1000_UDC_EP0_CSR_SSE),		\
+		BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG);	\
+} while(0)
+
+#define set_ep0_de_in(base) do {			\
+   	LF1000_UDC_SETIX(base,EP0);			\
+	maskl(base,(LF1000_UDC_EP0_CSR_IPKRDY		\
+		| LF1000_UDC_EP0_CSR_DE),		\
+		BIT_MASK_FF, LF1000_UDC_EP0_CSR_REG);		\
+} while(0)
+
+
+
+#define clear_stall_ep1_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP1);			\
+	orl(0,base+LF1000_UDC_OUT_CSR1_REG);		\
+} while(0)
+
+
+#define clear_stall_ep2_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP2);			\
+	orl(0, base+LF1000_UDC_OUT_CSR1_REG);		\
+} while(0)
+
+
+#define clear_stall_ep3_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP3);			\
+	orl(0,base+LF1000_UDC_OUT_CSR1_REG);		\
+} while(0)
+
+
+#define clear_stall_ep4_out(base) do {			\
+   	LF1000_UDC_SETIX(base,EP4);			\
+	orl(0, base+LF1000_UDC_OUT_CSR1_REG);		\
+} while(0)
+
+#endif
diff -ruaN linux-2.6.31/drivers/usb/gadget/Makefile linux-2.6/drivers/usb/gadget/Makefile
--- linux-2.6.31/drivers/usb/gadget/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -27,6 +27,7 @@
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_LF1000)	+= lf1000_udc.o
 
 #
 # USB gadget drivers
diff -ruaN linux-2.6.31/drivers/usb/gadget/u_ether.c linux-2.6/drivers/usb/gadget/u_ether.c
--- linux-2.6.31/drivers/usb/gadget/u_ether.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/gadget/u_ether.c	2011-01-04 13:50:21.000000000 -0800
@@ -790,7 +790,6 @@
 
 		the_dev = dev;
 	}
-
 	return status;
 }
 
diff -ruaN linux-2.6.31/drivers/usb/host/ohci-hcd.c linux-2.6/drivers/usb/host/ohci-hcd.c
--- linux-2.6.31/drivers/usb/host/ohci-hcd.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/host/ohci-hcd.c	2011-01-04 14:39:27.000000000 -0800
@@ -1081,6 +1081,11 @@
 #define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
 #endif
 
+#if defined(CONFIG_ARCH_LF1000)
+#include "ohci-lf1000.c"
+#define PLATFORM_DRIVER		ohci_hcd_lf1000_driver
+#endif
+
 #if	!defined(PCI_DRIVER) &&		\
 	!defined(PLATFORM_DRIVER) &&	\
 	!defined(OF_PLATFORM_DRIVER) &&	\
diff -ruaN linux-2.6.31/drivers/usb/host/ohci-lf1000.c linux-2.6/drivers/usb/host/ohci-lf1000.c
--- linux-2.6.31/drivers/usb/host/ohci-lf1000.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/usb/host/ohci-lf1000.c	2011-04-22 17:24:47.000000000 -0700
@@ -0,0 +1,236 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ *
+ * USB Bus Glue for LF1000
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Russell King et al.
+ *
+ * Modified for S3C2410 from ohci-sa1111.c, ohci-omap.c and ohci-lh7a40.c
+ *	by Ben Dooks, <ben@simtec.co.uk>
+ *	Copyright (C) 2004 Simtec Electronics
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ *
+ * Modified for LF1000 from ohci-s3c2410.c and ohci-lh7a404.c
+ *
+ * This file is licenced under the GPL.
+*/
+
+#include <linux/platform_device.h>
+#include <mach/gpio.h>
+
+static void lf1000_start_hc(struct platform_device *dev, struct usb_hcd *hcd)
+{
+	int pll_divisor;
+	int enable = gpio_have_gpio_madrid() ? 1 : 0;	/* enabled on demand for Madrid */
+
+	/* start VUSB (turn on DC power to devices) */
+	gpio_set_fn(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+			GPIO_GPIOFN);
+	gpio_set_val(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+			enable);
+	gpio_set_out_en(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+			1);
+
+	/* calculate USB Host 48 Mhz divisor */
+	pll_divisor = get_pll_freq(PLL1) / 48000000;
+
+	/* start USB Host clock */
+	writew(((pll_divisor-1)<<4) | (PLL1<<1), hcd->regs + 0xC4);
+	writew(0x000F, hcd->regs + 0xC0);
+	writew(0x0018, hcd->regs + 0x80);
+}
+
+static void lf1000_stop_hc(struct platform_device *dev, struct usb_hcd *hcd)
+{
+	/* stop VUSB (turn off DC power to devices) */
+	gpio_set_fn(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+		GPIO_GPIOFN);
+	gpio_set_val(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+		1);
+	gpio_set_out_en(lf1000_l2p_port(DOCK_POWER), lf1000_l2p_pin(DOCK_POWER),
+		0);
+
+	/* stop USB Host clock */
+	writew(0, hcd->regs + 0xC0);
+	writew(0, hcd->regs + 0x80);
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/*
+ * usb_hcd_lf1000_remove - shutdown processing for HCD
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_lf1000_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+*/
+
+static void
+usb_hcd_lf1000_remove (struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	lf1000_stop_hc(dev, hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/**
+ * usb_hcd_lf1000_probe - initialize lf1000-based HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+static int usb_hcd_lf1000_probe (const struct hc_driver *driver,
+		struct platform_device *dev)
+{
+	struct usb_hcd *hcd = NULL;
+	int retval;
+
+	if (dev->resource[1].flags != IORESOURCE_IRQ) {
+		return -ENOMEM;
+	}
+
+	hcd = usb_create_hcd(driver, &dev->dev, "lf1000-usb");
+	if (hcd == NULL)
+		return -ENOMEM;
+
+	hcd->rsrc_start = dev->resource[0].start;
+	hcd->rsrc_len   = dev->resource[0].end - dev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		retval = -EBUSY;
+		goto err_put;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&dev->dev, "ioremap failed\n");
+		retval = -ENOMEM;
+		goto err_mem;
+	}
+	lf1000_start_hc(dev, hcd);
+
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	retval = usb_add_hcd(hcd, dev->resource[1].start, IRQF_DISABLED);
+
+	if (retval == 0)
+		return retval;
+
+	lf1000_stop_hc(dev, hcd);
+
+	iounmap(hcd->regs);
+
+err_mem:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+err_put:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_lf1000_start (struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	int ret;
+
+	if ((ret = ohci_init(ohci)) < 0)
+		return ret;
+
+	if ((ret = ohci_run (ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop (hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver ohci_lf1000_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"LF1000 OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start =		ohci_lf1000_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+/* device driver */
+
+static int ohci_hcd_lf1000_drv_probe(struct platform_device *pdev)
+{
+	return usb_hcd_lf1000_probe(&ohci_lf1000_hc_driver, pdev);
+}
+
+static int ohci_hcd_lf1000_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_lf1000_remove(hcd, pdev);
+	return 0;
+}
+
+static struct platform_driver ohci_hcd_lf1000_driver = {
+	.probe		= ohci_hcd_lf1000_drv_probe,
+	.remove		= ohci_hcd_lf1000_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	/*.suspend	= ohci_hcd_lf1000_drv_suspend, */
+	/*.resume	= ohci_hcd_lf1000_drv_resume, */
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "lf1000-ohci",
+	},
+};
+
+MODULE_ALIAS("platform:lf1000-ohci");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/drivers/usb/Kconfig linux-2.6/drivers/usb/Kconfig
--- linux-2.6.31/drivers/usb/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/usb/Kconfig	2011-01-04 13:50:21.000000000 -0800
@@ -23,6 +23,7 @@
 	default y if ARM				# SL-811
 	default y if SUPERH				# r8a66597-hcd
 	default y if MICROBLAZE
+	default y if ARCH_LF1000		# LF1000
 	default PCI
 
 # many non-PCI SOC chips embed OHCI
@@ -33,6 +34,7 @@
 	default y if ARCH_OMAP
 	default y if ARCH_LH7A404
 	default y if ARCH_S3C2410
+	default y if ARCH_LF1000
 	default y if PXA27x
 	default y if PXA3xx
 	default y if ARCH_EP93XX
diff -ruaN linux-2.6.31/drivers/video/backlight/Kconfig linux-2.6/drivers/video/backlight/Kconfig
--- linux-2.6.31/drivers/video/backlight/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/video/backlight/Kconfig	2011-01-04 14:33:20.000000000 -0800
@@ -132,6 +132,14 @@
 	  To compile this driver as a module, choose M here: the module will be
 	  called atmel-pwm-bl.
 
+config BACKLIGHT_LF1000_PWM
+	tristate "LF1000 PWM backlight control"
+	depends on BACKLIGHT_CLASS_DEVICE && ARCH_LF1000 && FB_LF1000
+	default y
+	help
+	  Say Y here if you want PWM backlight control on LeapFrog boards.  To
+	  compile as a module, choose M.
+
 config BACKLIGHT_GENERIC
 	tristate "Generic (aka Sharp Corgi) Backlight Driver"
 	depends on BACKLIGHT_CLASS_DEVICE
diff -ruaN linux-2.6.31/drivers/video/backlight/lf1000_bl.c linux-2.6/drivers/video/backlight/lf1000_bl.c
--- linux-2.6.31/drivers/video/backlight/lf1000_bl.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/video/backlight/lf1000_bl.c	2012-11-16 18:15:55.000000000 -0800
@@ -0,0 +1,166 @@
+/*
+ * drivers/video/backlight/lf1000_bl.c
+ *
+ * PWM backlight support for the LF1000 LeapFrog boards.
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+
+#include <mach/platform.h>
+#include <mach/pwm.h>
+#include <mach/gpio.h>
+
+#define LF1000_INITIAL_BRIGHTNESS	318	// nominal second brightest
+#define LF1000_MAX_BRIGHTNESS		511
+
+struct lf1000_bl {
+	struct platform_device	*pdev;
+	struct backlight_device *bl;
+	u32			pwmds;
+	u32			pwm_channel;
+};
+
+/* convert 9 bit intensity range to 5 bit WLED range */
+#define LFP100_WLED_ENTRIES	32
+
+static int lf1000_bl_get_brightness(struct backlight_device *bd)
+{
+	struct lf1000_bl *priv = bl_get_data(bd);
+
+	return priv->pwmds;
+}
+
+static int lf1000_bl_set_brightness(struct backlight_device *bd)
+{
+	struct lf1000_bl *priv = bl_get_data(bd);
+	int intensity = bd->props.brightness;
+
+#if 0
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+#endif
+
+	if (pwm_set_duty_cycle(priv->pwm_channel, intensity))
+			return -EINVAL;
+
+	priv->pwmds = intensity;
+
+	return 0;
+}
+
+static struct backlight_ops lf1000_bl_ops = {
+	.get_brightness	= lf1000_bl_get_brightness,
+	.update_status	= lf1000_bl_set_brightness,
+};
+
+static int lf1000_bl_probe(struct platform_device *pdev)
+{
+	int ret;
+	u8 polarity;
+	struct lf1000_bl *priv;
+
+	priv = kzalloc(sizeof(struct lf1000_bl), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "can't allocate priv data\n");
+		return -ENOMEM;
+	}
+	priv->pdev = pdev;
+
+	priv->bl = backlight_device_register("lf1000-pwm-bl",
+			&pdev->dev, priv, &lf1000_bl_ops);
+	if (IS_ERR(priv->bl)) {
+		ret = PTR_ERR(priv->bl);
+		dev_err(&pdev->dev, "failed to register backlight: %d\n", ret);
+		kfree(priv);
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->bl->props.power = FB_BLANK_UNBLANK;
+	priv->bl->props.max_brightness = LF1000_MAX_BRIGHTNESS;
+	priv->bl->props.brightness = LF1000_INITIAL_BRIGHTNESS;
+
+	if (gpio_have_gpio_madrid()) {
+		priv->pwm_channel = PWM_CHAN2;
+		polarity = POL_INV;	/* inverted PWM polarity */
+	} else {
+		priv->pwm_channel = PWM_CHAN1;
+		//On Explorer, pin A30 (PWM0) is LED_ENA and should be on
+		//The bootloader does this, but can't hurt to do it here to be safe.
+		polarity = POL_BYP;	/* normal PWM polarity */
+		gpio_set_out_en(lf1000_l2p_port(LED_ENA),
+			lf1000_l2p_pin(LED_ENA), 1);
+		gpio_set_cur(lf1000_l2p_port(LED_ENA),
+			lf1000_l2p_pin(LED_ENA), GPIO_CURRENT_8MA);
+	}
+	dev_info(&pdev->dev, "Using PWM Channel %d for backlight\n", priv->pwm_channel);
+	
+	ret = pwm_get_clock_rate();
+	if (ret < 1) {
+		dev_err(&pdev->dev, "can't get PWM rate\n");
+		priv->pwmds = 0;
+	} else {
+		dev_info(&pdev->dev, "PWM rate is %d\n", ret);
+		pwm_configure_pin(priv->pwm_channel);
+		pwm_set_prescale(priv->pwm_channel, 1);
+		pwm_set_period(priv->pwm_channel, 511);
+		pwm_set_polarity(priv->pwm_channel, polarity);
+	}
+
+	lf1000_bl_set_brightness(priv->bl);
+
+	return 0;
+}
+
+static int __exit lf1000_bl_remove(struct platform_device *pdev)
+{
+	struct lf1000_bl *priv = platform_get_drvdata(pdev);
+
+	backlight_device_unregister(priv->bl);
+	platform_set_drvdata(pdev, NULL);
+	kfree(priv);
+
+	return 0;
+}
+
+static struct platform_driver lf1000_bl_driver = {
+	.probe	= lf1000_bl_probe,
+	.remove	= __exit_p(lf1000_bl_remove),
+	.driver = {
+		.name	= "lf1000-bl",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lf1000_bl_init(void)
+{
+	return platform_driver_register(&lf1000_bl_driver);
+}
+
+static void __exit lf1000_bl_exit(void)
+{
+	platform_driver_unregister(&lf1000_bl_driver);
+}
+
+module_init(lf1000_bl_init);
+module_exit(lf1000_bl_exit);
+
+MODULE_AUTHOR("Daniel Lazzari");
+MODULE_DESCRIPTION("LF1000 backlight driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lf1000-bl");
diff -ruaN linux-2.6.31/drivers/video/backlight/Makefile linux-2.6/drivers/video/backlight/Makefile
--- linux-2.6.31/drivers/video/backlight/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/video/backlight/Makefile	2011-01-04 14:33:20.000000000 -0800
@@ -24,4 +24,4 @@
 obj-$(CONFIG_BACKLIGHT_MBP_NVIDIA) += mbp_nvidia_bl.o
 obj-$(CONFIG_BACKLIGHT_TOSA)	+= tosa_bl.o
 obj-$(CONFIG_BACKLIGHT_SAHARA)	+= kb3886_bl.o
-
+obj-$(CONFIG_BACKLIGHT_LF1000_PWM)	+= lf1000_bl.o
diff -ruaN linux-2.6.31/drivers/video/Kconfig linux-2.6/drivers/video/Kconfig
--- linux-2.6.31/drivers/video/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/video/Kconfig	2011-01-04 15:11:36.000000000 -0800
@@ -70,7 +70,7 @@
 	 suffer from this problem.
 
 config FB_DDC
-       tristate
+       tristate ""
        depends on FB
        select I2C_ALGOBIT
        select I2C
@@ -85,7 +85,7 @@
 	  of VESA video modes set at an early boot stage via the vga= parameter.
 
 config FB_CFB_FILLRECT
-	tristate
+	tristate "Software Fill Rect"
 	depends on FB
 	default n
 	---help---
@@ -94,7 +94,7 @@
 	  (accelerated) version.
 
 config FB_CFB_COPYAREA
-	tristate
+	tristate "Software Copy"
 	depends on FB
 	default n
 	---help---
@@ -103,7 +103,7 @@
 	  version.
 
 config FB_CFB_IMAGEBLIT
-	tristate
+	tristate "Software Blitter"
 	depends on FB
 	default n
 	---help---
@@ -194,12 +194,12 @@
 	  cards.
 
 config FB_MACMODES
-       tristate
+       tristate "MAC Codes"
        depends on FB
        default n
 
 config FB_BACKLIGHT
-	bool
+	bool "LCD Backlight"
 	depends on FB
 	select BACKLIGHT_LCD_SUPPORT
 	select BACKLIGHT_CLASS_DEVICE
@@ -2039,6 +2039,14 @@
 	  and 8, 15 or 16 bpp color; 90 degrees clockwise display rotation for
 	  panels <= 320 pixel horizontal resolution.
 
+config FB_LF1000
+	tristate "LF1000 SoC Framebuffer support"
+	select LF1000_SCREEN
+	depends on ARCH_LF1000 && FB
+	---help---
+	  Say Y here to enable support for the LF1000 display controller
+	  and Multi-Layer controller.  Say M to build it as a module.
+
 config FB_VIRTUAL
 	tristate "Virtual Frame Buffer support (ONLY FOR TESTING!)"
 	depends on FB
diff -ruaN linux-2.6.31/drivers/video/lf1000fb.c linux-2.6/drivers/video/lf1000fb.c
--- linux-2.6.31/drivers/video/lf1000fb.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/drivers/video/lf1000fb.c	2011-08-03 19:13:58.000000000 -0700
@@ -0,0 +1,1753 @@
+/*
+ * drivers/video/lf1000fb.c
+ *
+ * Framebuffer support for the LF1000/Pollux SoC.
+ *
+ * Copyright 2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * Parts of this are based on the CL7700 FB driver which is (C) 2009 CoreLogic 
+ * Inc. and written by Sungdae Choi.  It's also inspired by pxafb.c.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/fb.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/ioctl.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/lf1000/lf1000fb.h>
+#include <mach/platform.h>
+#include <mach/screen.h>
+#include <mach/gpio.h>
+#include <asm/uaccess.h>
+#include <asm/cputype.h>
+#include <plat/hardware.h>
+
+#define DRIVER_NAME		"lf1000-fb"
+#define RESSIZE(res)		(((res)->end - (res)->start))
+#define PALETTE_CLEAR		0x80000000
+
+/*
+ * Settings
+ */
+
+#define LF1000_FB_NUM_BUFFERS	3	/* buffers per layer */
+
+/* The YUV layer is always last.  The other layers are RGB. */
+#define IS_YUV_LAYER(l)		(l->index == l->parent->num_layers-1)
+
+struct lf1000fb_layer {
+	u8			index;
+	struct lf1000fb_info	*parent;
+	struct fb_info		*fbinfo;
+
+	bool			enabled;
+	bool			vflip;
+	u8			format;
+	u32			vstride;
+	u8			hstride;
+
+	unsigned int pseudo_pal[16];
+
+	u32			hsrc;
+	u32			vsrc;
+};
+
+struct lf1000fb_info {
+	struct platform_device		*pdev;
+	struct resource			*fbres;
+	struct resource			*mlcres;
+	struct lf1000_screen_info	*screen;
+
+	void __iomem			*fbmem;
+	void __iomem			*mlc;
+	int 				irq;
+	unsigned int			nirq;
+
+	struct fb_info			**fbs;
+	unsigned			num_layers;
+
+	struct dentry			*debug;
+
+	bool					prisec;
+	void __iomem			*mlcreg;
+};
+
+/* controller registers */
+
+#define MLCCONTROLT	0x00
+#define MLCSCREENSIZE	0x04
+#define MLCBGCOLOR	0x08
+
+#define MLCCLKENB 		0x03C0
+#define MLCSECONDARY	0x0400
+
+/* layer registers */
+
+#define RGBREGLEN	0x34
+
+#define RGBLEFTRIGHT	0x00
+#define RGBTOPBOTTOM	0x04
+#define RGBCONTROL	0x18
+#define RGBHSTRIDE	0x1C
+#define RGBVSTRIDE	0x20
+#define RGBTPCOLOR	0x24
+#define RGBADDRESS	0x2C
+#define RGBPALETTE	0x30
+
+#define YUVLEFTRIGHT	0x00
+#define YUVTOPBOTTOM	0x04
+#define YUVCONTROL	0x08
+#define YUVVSTRIDE	0x0C
+#define YUVTPCOLOR	0x10
+#define YUVADDRESS	0x18
+#define YUVADDRESSCB	0x1C
+#define YUVADDRESSCR	0x20
+#define YUVVSTRIDECB	0x24
+#define YUVVSTRIDECR	0x28
+#define YUVHSCALE	0x2C
+#define YUVVSCALE	0x30
+
+static void __iomem *mlc_reg(struct lf1000fb_layer *layer, u32 reg)
+{
+	return layer->parent->mlcreg + layer->index*RGBREGLEN + reg + 0xC;
+}
+
+static void mlc_select(struct lf1000fb_layer *layer, bool secondary)
+{
+	layer->parent->prisec = secondary;
+	layer->parent->mlcreg = (secondary) ? layer->parent->mlc + MLCSECONDARY : layer->parent->mlc;
+}
+
+static inline u32 get_fb_size(struct lf1000fb_info *info,
+		struct lf1000fb_layer *layer)
+{
+	if (IS_YUV_LAYER(layer))
+		return PAGE_ALIGN(info->screen->yres * 4096 *
+				LF1000_FB_NUM_BUFFERS);
+
+	/* at a minimum, support 640x480 video */
+	if (info->screen->xres < 640 || info->screen->yres < 480)
+		return PAGE_ALIGN(640*480*4*LF1000_FB_NUM_BUFFERS);
+	return PAGE_ALIGN(info->screen->xres * info->screen->yres * 4 *
+			LF1000_FB_NUM_BUFFERS);
+}
+
+/* debugfs */
+
+static void layer_show_reg(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct lf1000fb_layer *layer = s->private;
+
+	seq_printf(s, "%10s:\t0x%08X\n", nm, readl(mlc_reg(layer, reg)));
+}
+
+static int lf1000_layer_regs_show(struct seq_file *s, void *v)
+{
+	struct lf1000fb_layer *layer = s->private;
+	int n;
+
+	for (n = 0; n < 2; n++)
+	{
+		mlc_select(layer, n);
+
+		if (IS_YUV_LAYER(layer)) {
+			layer_show_reg(s, "LEFTRIGHT", YUVLEFTRIGHT);
+			layer_show_reg(s, "TOPBOTTOM", YUVTOPBOTTOM);
+			layer_show_reg(s, "CONTROL", YUVCONTROL);
+			layer_show_reg(s, "VSTRIDE", YUVVSTRIDE);
+			layer_show_reg(s, "TPCOLOR", YUVTPCOLOR);
+			layer_show_reg(s, "ADDRESS", YUVADDRESS);
+			layer_show_reg(s, "ADDRESSCB", YUVADDRESSCB);
+			layer_show_reg(s, "ADDRESSCR", YUVADDRESSCR);
+			layer_show_reg(s, "VSTRIDECB", YUVVSTRIDECB);
+			layer_show_reg(s, "VSTRIDECR", YUVVSTRIDECR);
+			layer_show_reg(s, "HSCALE", YUVHSCALE);
+			layer_show_reg(s, "VSCALE", YUVVSCALE);
+		} else {
+			layer_show_reg(s, "LEFTRIGHT", RGBLEFTRIGHT);
+			layer_show_reg(s, "TOPBOTTOM", RGBTOPBOTTOM);
+			layer_show_reg(s, "CONTROL", RGBCONTROL);
+			layer_show_reg(s, "HSTRIDE", RGBHSTRIDE);
+			layer_show_reg(s, "VSTRIDE", RGBVSTRIDE);
+			layer_show_reg(s, "TPCOLOR", RGBTPCOLOR);
+			layer_show_reg(s, "ADDRESS", RGBADDRESS);
+			layer_show_reg(s, "PALETTE", RGBPALETTE);
+		}
+	}
+	mlc_select(layer, 0);
+
+	return 0;
+}
+
+static int lf1000_layer_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lf1000_layer_regs_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_layer_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_layer_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void mlc_show_reg(struct seq_file *s, const char *nm, u32 reg)
+{
+	struct lf1000fb_info *info = s->private;
+	void __iomem *addr = info->mlc + reg;
+
+	seq_printf(s, "%10s:\t0x%08X\n", nm, readl(addr));
+}
+
+static int lf1000_mlc_regs_show(struct seq_file *s, void *v)
+{
+	mlc_show_reg(s, "CONTROLT", MLCCONTROLT);
+	mlc_show_reg(s, "SCREENSIZE", MLCSCREENSIZE);
+	mlc_show_reg(s, "BGCOLOR", MLCBGCOLOR);
+
+	return 0;
+}
+
+static int lf1000_mlc_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lf1000_mlc_regs_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_mlc_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_mlc_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* hardware routines */
+
+static void mlc_set_dirty(struct lf1000fb_layer *fbi)
+{
+	void __iomem *control;
+	u32 tmp;
+
+	if (IS_YUV_LAYER(fbi))
+		control = mlc_reg(fbi, YUVCONTROL);
+	else
+		control = mlc_reg(fbi, RGBCONTROL);
+
+	tmp = readl(control);
+	writel(tmp | (1<<4), control);
+}
+
+static bool mlc_is_dirty(struct lf1000fb_layer *fbi)
+{
+	void __iomem *control;
+	
+	if (IS_YUV_LAYER(fbi))
+		control = mlc_reg(fbi, YUVCONTROL);
+	else
+		control = mlc_reg(fbi, RGBCONTROL);
+
+	return !!(readl(control) & (1<<4));
+}
+
+static u32 linear_to_xy(u32 addr)
+{
+	u32 segment = addr >> 24;
+	u32 offset = addr & 0xFFFFFF;
+	u32 y = offset >> 12;
+	u32 x = offset & 0xFFF;
+
+	return 0x20000000 | (segment << 24) | (y << 12) | (x << 0);
+}
+
+static void mlc_set_address(struct lf1000fb_layer *fbi, u32 address)
+{
+	if (fbi->index >= fbi->parent->num_layers)
+		return;
+
+	if (IS_YUV_LAYER(fbi)) {
+		if (NONSTD_TO_PFOR(fbi->fbinfo->var.nonstd) ==
+				LAYER_FORMAT_YUV420) {
+			const u32 pitch = 4096;
+
+			writel(linear_to_xy(address),
+					mlc_reg(fbi, YUVADDRESS));
+			writel(linear_to_xy(address + pitch/2),
+					mlc_reg(fbi, YUVADDRESSCB));
+			writel(linear_to_xy(address + pitch/2 +
+						pitch*fbi->vsrc/2),
+					mlc_reg(fbi, YUVADDRESSCR));
+		}
+	} else {
+		writel(address, mlc_reg(fbi, RGBADDRESS));
+	}
+}
+
+static void set_invert(struct lf1000fb_layer *fbi, u8 en)
+{
+	u32 val;
+
+	val = readl(mlc_reg(fbi, RGBCONTROL));
+	if (en)
+		val |= (1<<1);
+	else
+		val &= ~(1<<1);
+
+	writel(val, mlc_reg(fbi, RGBCONTROL));
+}
+
+static void set_blend(struct lf1000fb_layer *fbi, u8 en, u8 alpha)
+{
+	void __iomem *control;
+	void __iomem *tpcolor;
+	u32 val;
+
+	if (IS_YUV_LAYER(fbi)) {
+		control = mlc_reg(fbi, YUVCONTROL);
+		tpcolor = mlc_reg(fbi, YUVTPCOLOR);
+	} else {
+		control = mlc_reg(fbi, RGBCONTROL);
+		tpcolor = mlc_reg(fbi, RGBTPCOLOR);
+	}
+
+	val = readl(tpcolor) & ~(0xF<<28);
+	writel(val | ((alpha & 0xF)<<28), tpcolor);
+
+	val = readl(control);
+	if (en)
+		writel(val | (1<<2), control);
+	else
+		writel(val & ~(1<<2), control);
+
+	mlc_set_dirty(fbi);
+}
+
+static void get_blend(struct lf1000fb_layer *fbi, u8 *en, u8 *alpha)
+{
+	void __iomem *control;
+	void __iomem *tpcolor;
+
+	if (IS_YUV_LAYER(fbi)) {
+		control = mlc_reg(fbi, YUVCONTROL);
+		tpcolor = mlc_reg(fbi, YUVTPCOLOR);
+	} else {
+		control = mlc_reg(fbi, RGBCONTROL);
+		tpcolor = mlc_reg(fbi, RGBTPCOLOR);
+	}
+
+	*alpha = (readl(tpcolor)>>28) & 0xF;
+	*en = !!(readl(control) & (1<<2));
+}
+
+static void mlc_set_locksize(struct lf1000fb_layer *fbi, u8 size)
+{
+	void __iomem *control;
+	u32 val;
+
+	if (IS_YUV_LAYER(fbi))
+		control = mlc_reg(fbi, YUVCONTROL);
+	else
+		control = mlc_reg(fbi, RGBCONTROL);
+
+	val = readl(control) & ~(3<<12);
+	writel(val | (size & 3)<<12, control);
+}
+
+/* Sets the position ("priority") of the YUV layer.  Position 0 places the
+ * layer on the top of the "stack". */
+static u8 mlc_set_yuv_position(struct lf1000fb_layer *fbi, u8 pos)
+{
+	void __iomem *mlc = fbi->parent->mlcreg;
+	u32 tmp;
+
+	if (!IS_YUV_LAYER(fbi))
+		return pos;
+
+	if (pos > fbi->parent->num_layers - 1)
+		pos = fbi->parent->num_layers - 1;
+
+	tmp = readl(mlc + MLCCONTROLT) & ~(0x3<<8);
+	writel(tmp|(1<<3)|((pos & 0x3)<<8), mlc + MLCCONTROLT);
+
+	return pos;
+}
+
+/* FB operations */
+
+static void mlc_set_rgb_format(struct fb_info *fbinfo, u16 format)
+{
+	struct lf1000fb_layer *fbi = fbinfo->par;
+	struct fb_var_screeninfo *var = &fbinfo->var;
+	u8 i = fbi->index;
+	u32 tmp;
+	u8 bpp = var->bits_per_pixel>>3;
+	u32 hstride = bpp;
+	u32 vstride = bpp*var->xres;
+
+	if (IS_YUV_LAYER(fbi))
+		return;
+
+	if (NONSTD_TO_PLANAR(var->nonstd))
+		vstride = 4096;
+	else
+		vstride = bpp*var->xres;
+
+	dev_dbg(&fbi->parent->pdev->dev,
+			"layer%d: setting BPP=%d, format=0x%X\n", i,
+			var->bits_per_pixel, format);
+
+	fbi->vstride = vstride;
+	fbi->hstride = hstride;
+
+	if (fbi->vflip) {
+		vstride = 0 - vstride;
+		hstride = 0 - hstride;
+	}
+	writel(hstride, mlc_reg(fbi, RGBHSTRIDE));
+	writel(vstride, mlc_reg(fbi, RGBVSTRIDE));
+
+	tmp = readl(mlc_reg(fbi, RGBCONTROL)) & ~(0xFFFF<<16);
+	writel(tmp | (format<<16), mlc_reg(fbi, RGBCONTROL));
+
+	fbi->format = LAYER_FORMAT_RGB;
+}
+
+static void mlc_set_yuv_format(struct lf1000fb_layer *layer, u16 format,
+		u8 bpp, u16 width)
+{
+	u32 tmp;
+	u32 stride = bpp*width;
+
+	if (!IS_YUV_LAYER(layer))
+		return;
+
+	layer->vstride = stride;
+	layer->hstride = bpp;
+
+	writel(stride, mlc_reg(layer, YUVVSTRIDE));
+	writel(stride, mlc_reg(layer, YUVVSTRIDECB));
+	writel(stride, mlc_reg(layer, YUVVSTRIDECR));
+
+	tmp = readl(mlc_reg(layer, YUVCONTROL));
+       	tmp &= ~(0xFFFF<<16);
+	writel(tmp | (format<<16), mlc_reg(layer, YUVCONTROL));
+}
+
+#define LF1000_FB_FORMAT_YUV420		0x0000
+#define LF1000_FB_FORMAT_YUV422		0x0002
+
+#define LF1000_FB_FORMAT_R5G6B5		0x4432
+#define LF1000_FB_FORMAT_B5G6R5		0xC432
+#define LF1000_FB_FORMAT_X1R5G5B5	0x4342
+#define LF1000_FB_FORMAT_X1B5G5R5	0xC342
+#define LF1000_FB_FORMAT_X4R4G4B4	0x4211
+#define LF1000_FB_FORMAT_X4B4G4R4	0xC211
+#define LF1000_FB_FORMAT_X8R3G3B2	0x4120
+#define LF1000_FB_FORMAT_X8B3G3R2	0xC120
+#define LF1000_FB_FORMAT_A1R5G5B5	0x3342
+#define LF1000_FB_FORMAT_A1B5G5R5	0xB342
+#define LF1000_FB_FORMAT_A4R4G4B4	0x2211
+#define LF1000_FB_FORMAT_A4B4G4R4 	0xA211
+#define LF1000_FB_FORMAT_A8R3G3B2	0x1120
+#define LF1000_FB_FORMAT_A8B3G3R2	0x9120
+#define LF1000_FB_FORMAT_R8G8B8		0x4653
+#define LF1000_FB_FORMAT_B8G8R8		0xC653
+#define LF1000_FB_FORMAT_X8R8G8B8	0x4653
+#define LF1000_FB_FORMAT_X8B8G8R8 	0xC653
+#define LF1000_FB_FORMAT_A8R8G8B8	0x0653
+#define LF1000_FB_FORMAT_A8B8G8R8	0x8653
+#define LF1000_FB_FORMAT_PTR5G6B5	0x443A
+
+static int set_yuv(struct fb_info *fbi, struct fb_var_screeninfo *var,
+		bool apply)
+{
+	struct lf1000fb_layer *layer = fbi->par;
+	u8 pf = NONSTD_TO_PFOR(var->nonstd);
+
+	switch (pf) {
+		case LAYER_FORMAT_YUV420:
+			if (apply) {
+				mlc_set_yuv_format(layer,
+						LF1000_FB_FORMAT_YUV420,
+						1, 4096);
+				layer->format = pf;
+			}
+			break;
+		case LAYER_FORMAT_YUV422:
+			if (apply) {
+				mlc_set_yuv_format(layer,
+						LF1000_FB_FORMAT_YUV422,
+						2, fbi->var.xres);
+				layer->format = pf;
+			}
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static u16 set_rgb332(struct fb_var_screeninfo *var)
+{
+	var->red.length = 3;
+	var->green.length = 3;
+	var->blue.length = 2;
+
+	var->red.offset = 5;
+	var->green.offset = 2;
+	var->blue.offset = 0;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X8R3G3B2;
+
+	var->transp.length = 8;
+	var->transp.offset = 8;
+
+	return LF1000_FB_FORMAT_A8R3G3B2;
+}
+
+static u16 set_bgr332(struct fb_var_screeninfo *var)
+{
+	var->red.length = 2;
+	var->green.length = 3;
+	var->blue.length = 3;
+
+	var->red.offset = 0;
+	var->green.offset = 2;
+	var->blue.offset = 5;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X8B3G3R2;
+
+	var->transp.length = 8;
+	var->transp.offset = 8;
+
+	return LF1000_FB_FORMAT_A8B3G3R2;
+}
+
+static u16 set_rgb444(struct fb_var_screeninfo *var)
+{
+	var->red.length = 4;
+	var->green.length = 4;
+	var->blue.length = 4;
+
+	var->red.offset = 8;
+	var->green.offset = 4;
+	var->blue.offset = 0;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X4R4G4B4;
+
+	var->transp.length = 4;
+	var->transp.offset = 12;
+
+	return LF1000_FB_FORMAT_A4R4G4B4;
+}
+
+static u16 set_bgr444(struct fb_var_screeninfo *var)
+{
+	var->red.length = 4;
+	var->green.length = 4;
+	var->blue.length = 4;
+
+	var->red.offset = 0;
+	var->green.offset = 4;
+	var->blue.offset = 8;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X4B4G4R4;
+
+	var->transp.length = 4;
+	var->transp.offset = 12;
+
+	return LF1000_FB_FORMAT_A4B4G4R4;
+}
+
+static u16 set_rgb555(struct fb_var_screeninfo *var)
+{
+	var->red.length = 5;
+	var->green.length = 5;
+	var->blue.length = 5;
+
+	var->red.offset = 10;
+	var->green.offset = 5;
+	var->blue.offset = 0;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X1R5G5B5;
+
+	var->transp.length = 1;
+	var->transp.offset = 15;
+
+	return LF1000_FB_FORMAT_A1R5G5B5;
+}
+
+static u16 set_bgr555(struct fb_var_screeninfo *var)
+{
+	var->red.length = 5;
+	var->green.length = 5;
+	var->blue.length = 5;
+
+	var->red.offset = 0;
+	var->green.offset = 5;
+	var->blue.offset = 10;
+
+	if (var->transp.length == 0)
+		return LF1000_FB_FORMAT_X1B5G5R5;
+
+	var->transp.length = 1;
+	var->transp.offset = 15;
+
+	return LF1000_FB_FORMAT_A1B5G5R5;
+}
+
+static u16 set_rgb565(struct fb_var_screeninfo *var)
+{
+	var->red.length = 5;
+	var->green.length = 6;
+	var->blue.length = 5;
+
+	var->red.offset = 11;
+	var->green.offset = 5;
+	var->blue.offset = 0;
+
+	var->transp.length = 0;
+	var->transp.offset = 0;
+
+	return LF1000_FB_FORMAT_R5G6B5;
+}
+
+static u16 set_bgr565(struct fb_var_screeninfo *var)
+{
+	var->red.length = 5;
+	var->green.length = 6;
+	var->blue.length = 5;
+
+	var->red.offset = 0;
+	var->green.offset = 5;
+	var->blue.offset = 11;
+
+	var->transp.length = 0;
+	var->transp.offset = 0;
+
+	return LF1000_FB_FORMAT_B5G6R5;
+}
+
+static u16 set_rgb888(struct fb_var_screeninfo *var)
+{
+	var->red.length = 8;
+	var->green.length = 8;
+	var->blue.length = 8;
+
+	var->red.offset = 16;
+	var->green.offset = 8;
+	var->blue.offset = 0;
+
+	if (var->bits_per_pixel == 32) {
+		if (var->transp.length == 0)
+			return LF1000_FB_FORMAT_X8R8G8B8;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		return LF1000_FB_FORMAT_A8R8G8B8;
+	}
+
+	var->transp.length = 0;
+	var->transp.offset = 0;
+
+	return LF1000_FB_FORMAT_R8G8B8;
+}
+
+static u16 set_bgr888(struct fb_var_screeninfo *var)
+{
+	var->red.length = 8;
+	var->green.length = 8;
+	var->blue.length = 8;
+
+	var->red.offset = 0;
+	var->green.offset = 8;
+	var->blue.offset = 16;
+
+	if (var->bits_per_pixel == 32) {
+		if (var->transp.length == 0)
+			return LF1000_FB_FORMAT_X8B8G8R8;
+		
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		return LF1000_FB_FORMAT_A8B8G8R8;
+	}
+
+	var->transp.length = 0;
+	var->transp.offset = 0;
+
+	return LF1000_FB_FORMAT_B8G8R8;
+}
+
+static int set_rgb(struct fb_info *fbi, struct fb_var_screeninfo *var,
+		bool apply)
+{
+	struct lf1000fb_layer *layer = fbi->par;
+	struct platform_device *pdev = layer->parent->pdev;
+	u16 format = 0;
+	u32 visual = FB_VISUAL_PSEUDOCOLOR;
+
+	switch (var->bits_per_pixel) {
+		case 1:
+		case 2:
+		case 4:
+		case 8:
+			var->red.length = var->bits_per_pixel;
+			var->green.length = var->bits_per_pixel;
+			var->blue.length = var->bits_per_pixel;
+
+			format = LF1000_FB_FORMAT_PTR5G6B5;
+			break;
+
+		case 16:
+			if (var->blue.offset == 0 &&
+			    var->green.offset == 5 &&
+			    var->red.offset == 11) {
+				format = set_rgb565(var);
+			} else if (var->red.offset == 0 &&
+				   var->green.offset == 5 &&
+				   var->blue.offset == 11) {
+				format = set_bgr565(var);
+			} else if (var->red.offset == 8 &&
+				   var->green.offset == 4 &&
+				   var->blue.offset == 0) {
+				format = set_rgb444(var);
+			} else if (var->red.offset == 0 &&
+				   var->green.offset == 4 &&
+				   var->blue.offset == 8) {
+				format = set_bgr444(var);
+			} else if (var->red.offset == 5 &&
+				   var->green.offset == 2 &&
+				   var->blue.offset == 0) {
+				format = set_rgb332(var);
+			} else if (var->blue.offset == 5 &&
+				   var->green.offset == 2 &&
+				   var->red.offset == 0) {
+				format = set_bgr332(var);
+			} else if (var->blue.offset == 0 &&
+				   var->green.offset == 5 &&
+				   var->red.offset == 10) {
+				format = set_rgb555(var);
+			} else if (var->blue.offset == 10 &&
+				   var->green.offset == 5 &&
+				   var->red.offset == 0) {
+				format = set_bgr555(var);
+			} else {
+				dev_info(&pdev->dev, "%s guessing RGB565\n",
+						__FUNCTION__);
+				format = set_rgb565(var);
+			}
+			break;
+
+		case 24:
+			if (var->blue.offset == 0 &&
+			    var->green.offset == 8 &&
+			    var->red.offset == 16) {
+				format = set_rgb888(var); 
+			} else if (var->red.offset == 0 &&
+				   var->green.offset == 8 &&
+				   var->blue.offset == 16) {
+				format = set_bgr888(var);
+			} else {
+				dev_info(&pdev->dev, "%s guessing RGB888\n",
+						__FUNCTION__);
+				format = set_rgb888(var);
+			}
+
+			visual = FB_VISUAL_TRUECOLOR;
+			break;
+
+		case 32:
+			if (var->red.offset == 16 &&
+			    var->green.offset == 8 &&
+			    var->blue.offset == 0) {
+				format = set_rgb888(var);
+			} else if (var->red.offset == 0 &&
+				   var->green.offset == 8 &&
+				   var->blue.offset == 16) {
+				format = set_bgr888(var);
+			} else {
+				dev_info(&pdev->dev, "%s guessing %cRGB888\n",
+					__FUNCTION__,
+					var->transp.length ? 'A' : 'X');
+				format = set_rgb888(var);
+			}
+
+			visual = FB_VISUAL_TRUECOLOR;
+			break;
+
+		default:
+			return -EINVAL;
+	}	
+
+	if (apply) {
+		mlc_set_rgb_format(fbi, format);
+		fbi->fix.visual = visual;
+	}
+
+	return 0;
+}
+
+/* The YUV layer has a scaler so we can configure it for desired resolutions */
+static int set_video_scaler(struct lf1000fb_layer *fbi, u32 xres, u32 yres,
+		bool apply)
+{
+	struct fb_var_screeninfo *var = &fbi->fbinfo->var;
+	u32 hscale, vscale, hround, vround;
+	
+	if (!IS_YUV_LAYER(fbi))
+		return -EINVAL;
+
+	fbi->hsrc = xres;
+	fbi->vsrc = yres;
+
+	/* Enable adjusted ratio with bilinear filter for upscaling or just
+	 * downscale.  The height scales independant of the width. 
+	 * Use rounding of scaler ratio to support get_video_scaler. */
+
+	if (xres < var->xres) {
+		hscale = ((xres-1)<<12)/(var->xres-1);
+		hround = hscale & 1;
+		hscale >>= 1;
+		hscale += hround;
+		writel((1<<28) | hscale, mlc_reg(fbi, YUVHSCALE));
+	} else {
+		if (xres > var->xres_virtual/2)
+			return -EINVAL;
+		writel((xres<<11)/var->xres, mlc_reg(fbi, YUVHSCALE));
+	}
+
+	if (yres < var->yres) {
+		vscale = ((yres-1)<<12)/(var->yres-1);
+		vround = vscale & 1;
+		vscale >>= 1;
+		vscale += vround;
+		writel((1<<28) | vscale, mlc_reg(fbi, YUVVSCALE));
+	} else {
+		if (yres > var->yres_virtual)
+			return -EINVAL;
+		writel((yres<<11)/var->yres, mlc_reg(fbi, YUVVSCALE));
+	}
+
+	if (apply)
+		mlc_set_dirty(fbi);
+	return 0;
+}
+
+static int get_video_scaler(struct lf1000fb_layer *fbi, u32 *xres, u32 *yres)
+{
+	struct fb_var_screeninfo *var = &fbi->fbinfo->var;
+	u32 val;
+
+	if (!IS_YUV_LAYER(fbi))
+		return -EINVAL;
+	
+	val = readl(mlc_reg(fbi, YUVHSCALE));
+	if (val & (1<<28))
+		*xres = (((val & ~(1<<28)) * (var->xres - 1))>>11) + 1;
+	else
+		*xres = ((val * var->xres) >> 11);
+		
+	val = readl(mlc_reg(fbi, YUVVSCALE));
+	if (val & (1<<28))
+		*yres = (((val & ~(1<<28)) * (var->yres - 1))>>11) + 1;
+	else
+		*yres = ((val * var->yres) >> 11);
+
+	return 0;
+}
+
+static void schedule_palette_update(struct lf1000fb_layer *fbi,
+		unsigned int regno, unsigned int val)
+{
+	if (IS_YUV_LAYER(fbi))
+		return;
+
+	writel((regno<<24)|((u16)val), mlc_reg(fbi, RGBPALETTE));
+	mlc_set_dirty(fbi);
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static int lf1000fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+		unsigned blue, unsigned transp, struct fb_info *info)
+{
+	struct lf1000fb_layer *fbi = info->par;
+
+	if (fbi->index > fbi->parent->num_layers)
+		return -EINVAL;
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		u16 val;
+		val = chan_to_field(red, &info->var.red);
+		val |= chan_to_field(green, &info->var.green);
+		val |= chan_to_field(blue, &info->var.blue);
+		
+		fbi->pseudo_pal[regno] = val;
+
+		return 0;
+	}
+	
+	if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
+		u32 col = 0;
+
+		/* pack R,G,B values into RGB565 palette format */
+		col |= (red >> (8+3)) << 11;
+		col |= (green >> (8+2)) << 5;
+		col |= (blue >> (8+3)) << 0;
+		
+		schedule_palette_update(fbi, regno, col);
+
+		return 0;
+	}
+	
+	return -EINVAL;
+}
+
+static int lf1000fb_check_var(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	struct lf1000fb_layer *layer = info->par;
+	u8 format;
+
+	if (layer->index >= layer->parent->num_layers)
+		return -EINVAL;
+
+	/* YUV formats are only allowed on the YUV layer */
+	format = NONSTD_TO_PFOR(var->nonstd);
+	if ((format == LAYER_FORMAT_YUV420 || format == LAYER_FORMAT_YUV422) &&
+			!IS_YUV_LAYER(layer))
+		return -EINVAL;
+
+	/* a hardware bug prevents us from supporting rotation/flipping in
+	 * other than 32-bit mode */
+	if (var->rotate && var->bits_per_pixel != 32)
+		return -EINVAL;
+
+	if (IS_YUV_LAYER(layer))
+		return set_yuv(info, var, 0);
+	else
+		return set_rgb(info, var, 0);
+}
+
+static void set_position(struct lf1000fb_layer *fbi, s32 left,
+		s32 top, s32 right, s32 bottom, bool apply)
+{
+	writel((((left & 0xFFF)<<16) | ((right - 1) & 0xFFF)),
+			mlc_reg(fbi, RGBLEFTRIGHT));
+
+	writel((((top & 0xFFF)<<16) | ((bottom - 1) & 0xFFF)),
+			mlc_reg(fbi, RGBTOPBOTTOM));
+
+	if (apply)
+		mlc_set_dirty(fbi);
+}
+
+static void get_position(struct lf1000fb_layer *fbi, s32 *left,
+		s32 *top, s32 *right, s32 *bottom)
+{
+	u32 val;
+
+	val = readl(mlc_reg(fbi, RGBLEFTRIGHT));
+	*left = (val>>16) & 0xFFF;
+	*right = (val & 0xFFF) + 1;
+
+	val = readl(mlc_reg(fbi, RGBTOPBOTTOM));
+	*top = (val>>16) & 0xFFF;
+	*bottom = (val & 0xFFF) + 1;
+}
+
+static void set_resolution(struct lf1000fb_layer *fbi)
+{
+	s32 left, right, top, bottom;
+	struct fb_var_screeninfo *var = &fbi->fbinfo->var;
+
+	get_position(fbi, &left, &top, &right, &bottom);
+	set_position(fbi, left, top, left + var->xres, top + var->yres, 0);
+}
+
+static void lf1000fb_set_vflip(struct lf1000fb_layer *layer, bool flip)
+{
+	u32 addr;
+
+	if (layer->vflip == flip)
+		return;
+
+	addr = readl(mlc_reg(layer, RGBADDRESS));
+	
+	if (flip) { /* normal to flipped */
+		writel(addr + layer->vstride * (layer->fbinfo->var.yres),
+				mlc_reg(layer, RGBADDRESS));
+		writel(0 - layer->vstride, mlc_reg(layer, RGBVSTRIDE));
+		set_invert(layer, 1);
+	} else { /* flipped to normal */
+		writel(addr - layer->vstride * (layer->fbinfo->var.yres),
+				mlc_reg(layer, RGBADDRESS));
+		writel(layer->vstride, mlc_reg(layer, RGBVSTRIDE));
+		set_invert(layer, 0);
+	}
+
+	layer->vflip = flip;
+}
+
+static void lf1000fb_rotate(struct fb_info *info, int rotate)
+{
+	struct lf1000fb_layer *layer = info->par;
+
+	if (IS_YUV_LAYER(layer) || layer->index >= layer->parent->num_layers)
+		return;
+
+	switch (rotate) {
+		case 0:
+			lf1000fb_set_vflip(layer, 0);
+			layer->fbinfo->var.rotate = rotate;
+			break;
+		case 180:
+			lf1000fb_set_vflip(layer, 1);
+			layer->fbinfo->var.rotate = rotate;
+			break;
+	}
+}
+
+static void lf1000fb_set_type(struct lf1000fb_layer *layer, bool planar)
+{
+	struct fb_info *info = layer->fbinfo;
+	struct fb_var_screeninfo *var = &info->var;
+	u32 addr = readl(mlc_reg(layer, RGBADDRESS));
+
+	if (planar) {
+		info->fix.line_length = 4096;
+		info->fix.type = FB_TYPE_PLANES;
+		info->fix.smem_start |= 0x20000000;
+		mlc_set_address(layer, addr | 0x20000000);
+	} else {
+		info->fix.type = FB_TYPE_PACKED_PIXELS;
+		info->fix.smem_start &= ~0x20000000;
+		writel(addr & ~0x20000000, mlc_reg(layer, RGBADDRESS));
+		info->fix.line_length = var->xres * (var->bits_per_pixel>>3);
+	}
+}
+
+static int lf1000fb_set_par(struct fb_info *info)
+{
+	struct lf1000fb_layer *layer = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	int ret = 0;
+
+	if (layer->index >= layer->parent->num_layers)
+		return -EINVAL;
+
+	set_resolution(layer);
+
+	/* a hardware bug prevents us from supporting rotation/flipping in
+	 * other than 32-bit mode */
+	if (var->bits_per_pixel == 32)
+		lf1000fb_rotate(info, var->rotate);
+	
+	if (IS_YUV_LAYER(layer)) {
+		info->fix.line_length = 4096;
+		ret = set_yuv(info, var, 1);
+	} else {
+		ret = set_rgb(info, var, 1);
+	}
+
+	if (ret)
+		goto out_set;
+
+	if (IS_YUV_LAYER(layer)) {
+		u8 pos;
+		
+		pos = mlc_set_yuv_position(layer, NONSTD_TO_POS(var->nonstd));
+		var->nonstd &=
+			~(LF1000_NONSTD_PRIORITY_MASK<<LF1000_NONSTD_PRIORITY);
+		var->nonstd |= (pos<<LF1000_NONSTD_PRIORITY);
+	} else {
+		lf1000fb_set_type(layer, NONSTD_TO_PLANAR(var->nonstd));
+		var->nonstd &=
+			~(LF1000_NONSTD_PRIORITY_MASK<<LF1000_NONSTD_PRIORITY);
+	}
+
+	/* clone secondary MLC for TV out */
+	if (gpio_have_tvout()) {
+		mlc_select(layer, 1);
+		set_resolution(layer);
+		if (IS_YUV_LAYER(layer))
+			set_yuv(info, var, 1);
+		else
+			set_rgb(info, var, 1);
+		if (IS_YUV_LAYER(layer))
+			mlc_set_yuv_position(layer, NONSTD_TO_POS(var->nonstd));
+		else
+			lf1000fb_set_type(layer, NONSTD_TO_PLANAR(var->nonstd));
+		mlc_set_dirty(layer);
+		mlc_select(layer, 0);
+	}
+
+out_set:
+	mlc_set_dirty(layer);
+	return ret;
+}
+
+static int lf1000fb_blank(int blank, struct fb_info *info)
+{
+	struct lf1000fb_layer *layer = info->par;
+	void __iomem *control;
+	u32 reg;
+	
+	if (layer->index >= layer->parent->num_layers)
+		return -EINVAL;
+
+	if (IS_YUV_LAYER(layer))
+		control = mlc_reg(layer, YUVCONTROL);
+	else
+		control = mlc_reg(layer, RGBCONTROL);
+
+	reg = readl(control);
+
+	switch (blank) {
+		case FB_BLANK_NORMAL:
+			/* make MLC background color black */
+			writel(0x000000, layer->parent->mlcreg + MLCBGCOLOR);
+			writel((1<<3) | readl(layer->parent->mlcreg + MLCCONTROLT), layer->parent->mlcreg + MLCCONTROLT);
+		case FB_BLANK_VSYNC_SUSPEND:
+		case FB_BLANK_HSYNC_SUSPEND:
+		case FB_BLANK_POWERDOWN:
+			/* disable */
+			reg &= ~(1<<5);
+			reg |= (1<<4);
+			writel(reg, control);
+			do {
+				reg = readl(control);
+			} while (reg & (1<<4));
+
+			/* enable sleep */
+			reg &= ~(1<<14);
+			writel(reg, control);
+
+			/* palette off */
+			reg &= ~(1<<15);
+			writel(reg, control);
+
+			layer->enabled = 0;
+			mlc_set_dirty(layer);
+			break;
+
+		case FB_BLANK_UNBLANK:
+			/* palette on */
+			reg |= (1<<15);
+			writel(reg, control);
+
+			/* disable sleep */
+			reg |= (1<<14);
+			writel(reg, control);
+
+			/* enable */
+			reg |= (1<<5);
+			writel(reg, control);
+			
+			layer->enabled = 1;
+			mlc_set_dirty(layer);
+			break;
+	}
+
+	/* clone secondary MLC for TV out */
+	if (gpio_have_tvout()) {
+		mlc_select(layer, 1);
+		writel(reg, control + MLCSECONDARY);
+		mlc_set_dirty(layer);
+		mlc_select(layer, 0);
+	}
+
+	return 0;
+}
+
+static int lf1000fb_pan_display(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	struct lf1000fb_layer *layer = info->par;
+	u32 address;
+	u32 offset;
+
+	if (layer->index >= layer->parent->num_layers)
+		return -EINVAL;
+	
+	address = layer->fbinfo->fix.smem_start;
+
+ 	if (IS_YUV_LAYER(layer)) {
+		offset = var->xoffset + layer->vstride * var->yoffset;
+	} else {	
+		offset = var->xoffset + layer->vstride * var->yoffset;
+		if (layer->vflip)
+			address += layer->vstride * (layer->fbinfo->var.yres);
+	}
+
+	if (address >= layer->fbinfo->fix.smem_start +
+			layer->fbinfo->fix.smem_len)
+		return -EINVAL;
+
+	layer->fbinfo->var.xoffset = var->xoffset;
+	layer->fbinfo->var.yoffset = var->yoffset;
+	mlc_set_address(layer, address+offset);
+	mlc_set_dirty(layer);
+
+	/* clone secondary MLC for TV out */
+	if (gpio_have_tvout()) {
+		mlc_select(layer, 1);
+		mlc_set_address(layer, address+offset);
+		mlc_set_dirty(layer);
+		mlc_select(layer, 0);
+	}
+
+	return 0;
+}
+
+/* This SoC has a few few features that don't fit into the standard FB API so
+ * we extend that here as needed. */
+static int lf1000fb_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	union lf1000fb_cmd c;
+	struct lf1000fb_layer *fbi = info->par;
+
+	if (fbi->index >= fbi->parent->num_layers)
+		return -EINVAL;
+
+	switch (cmd) {
+		case FBIOGET_VBLANK:
+			{
+			struct fb_vblank vblank;
+			struct lf1000fb_info *fb_info = fbi->parent;
+			vblank.flags = FB_VBLANK_HAVE_COUNT;
+			vblank.count = fb_info->nirq;
+			vblank.hcount = 0;
+			vblank.vcount = 0;
+			if (copy_to_user(argp, (void *)&vblank,
+					sizeof(struct fb_vblank)))
+				return -EFAULT;
+			}
+			break;
+
+		case FBIO_WAITFORVSYNC:
+			if (gpio_have_tvout()) {
+				int r;
+				mlc_select(fbi, 1);
+				r = mlc_is_dirty(fbi);
+				mlc_select(fbi, 0);
+				return r;
+			}
+			return mlc_is_dirty(fbi);
+
+		case LF1000FB_IOCSALPHA:
+			if (!(_IOC_DIR(cmd) & _IOC_WRITE))
+				return -EFAULT;
+			if (copy_from_user((void *)&c, argp,
+					sizeof(struct lf1000fb_blend_cmd)))
+				return -EFAULT;
+			set_blend(fbi, c.blend.enable, c.blend.alpha);
+			if (gpio_have_tvout()) {
+				mlc_select(fbi, 1);
+				set_blend(fbi, c.blend.enable, c.blend.alpha);
+				mlc_select(fbi, 0);
+			}
+			break;
+
+		case LF1000FB_IOCGALPHA:
+			if (!(_IOC_DIR(cmd) & _IOC_READ))
+				return -EFAULT;
+			get_blend(fbi, &c.blend.enable, &c.blend.alpha);
+			if (copy_to_user(argp, (void *)&c,
+					sizeof(struct lf1000fb_blend_cmd)))
+				return -EFAULT;
+			break;
+
+		case LF1000FB_IOCSPOSTION:
+			if (!(_IOC_DIR(cmd) & _IOC_WRITE))
+				return -EINVAL;
+			if (copy_from_user((void *)&c, argp,
+					sizeof(struct lf1000fb_position_cmd)))
+				return -EFAULT;
+			set_position(fbi, c.position.left, c.position.top,
+					c.position.right, c.position.bottom,
+					c.position.apply);
+			if (gpio_have_tvout()) {
+				mlc_select(fbi, 1);
+				set_position(fbi, c.position.left, c.position.top,
+						c.position.right, c.position.bottom,
+						c.position.apply);
+				mlc_select(fbi, 0);
+			}
+			break;
+
+		case LF1000FB_IOCGPOSTION:
+			if (!(_IOC_DIR(cmd) & _IOC_READ))
+				return -EINVAL;
+			get_position(fbi, &c.position.left, &c.position.top,
+					&c.position.right, &c.position.bottom);
+			if (copy_to_user(argp, (void *)&c,
+					sizeof(struct lf1000fb_position_cmd)))
+				return -EFAULT;
+			break;
+
+		case LF1000FB_IOCSVIDSCALE:
+			if (!(_IOC_DIR(cmd) & _IOC_WRITE))
+				return -EINVAL;
+			if (copy_from_user((void *)&c, argp,
+					sizeof(struct lf1000fb_vidscale_cmd)))
+				return -EFAULT;
+			if (set_video_scaler(fbi, c.vidscale.sizex,
+					c.vidscale.sizey, c.vidscale.apply))
+				return -EINVAL;
+			if (gpio_have_tvout()) {
+				mlc_select(fbi, 1);
+				set_video_scaler(fbi, c.vidscale.sizex,
+						c.vidscale.sizey, c.vidscale.apply);
+				mlc_select(fbi, 0);
+			}
+			break;
+
+		case LF1000FB_IOCGVIDSCALE:
+			if (!(_IOC_DIR(cmd) & _IOC_READ))
+				return -EINVAL;
+			if (get_video_scaler(fbi, &c.vidscale.sizex,
+					&c.vidscale.sizey))
+				return -EINVAL;
+			if (copy_to_user(argp, (void *)&c,
+					sizeof(struct lf1000fb_vidscale_cmd)))
+				return -EFAULT;
+			break;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+static struct fb_ops lf1000fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_setcolreg	= lf1000fb_setcolreg,
+	.fb_check_var	= lf1000fb_check_var,
+	.fb_set_par	= lf1000fb_set_par,
+	.fb_pan_display	= lf1000fb_pan_display,
+	.fb_rotate	= lf1000fb_rotate,
+	.fb_blank	= lf1000fb_blank,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl	= lf1000fb_ioctl,
+};
+
+static irqreturn_t lf1000fb_irq(int irq, void *dev_id)
+{
+	struct lf1000fb_info *info = dev_id;
+
+	if (lf1000_dpc_int_pending()) {
+		info->nirq++;
+		lf1000_dpc_clear_int();
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * platform device
+ */
+
+static int lf1000fb_map_resource(struct lf1000fb_info *info,
+		struct resource **res, void __iomem **mem,
+		u8 index, const char *name)
+{
+	*res = platform_get_resource(info->pdev, IORESOURCE_MEM, index);
+	if (!res) {
+		dev_err(&info->pdev->dev, "can't get %s resource\n", name);
+		return -ENXIO;
+	}
+
+	if (!request_mem_region((*res)->start, RESSIZE(*res), name)) {
+		dev_err(&info->pdev->dev, "can't request %s memory\n", name);
+		release_resource(*res);
+		*res = NULL;
+		return -EBUSY;
+	}
+
+	*mem = ioremap_nocache((*res)->start, RESSIZE(*res));
+	if(!mem) {
+		dev_err(&info->pdev->dev, "can't remap %s memory\n", name);
+		release_mem_region((*res)->start, RESSIZE(*res));
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void lf1000fb_unmap_resource(struct resource **res, void __iomem **mem)
+{
+	if (*mem) {
+		iounmap(*mem);
+		*mem = NULL;
+	}
+
+	if (*res) {
+		release_mem_region((*res)->start, RESSIZE(*res));
+		release_resource(*res);
+		*res = NULL;
+	}
+}
+
+static void __init init_debugfs(struct lf1000fb_layer *layer)
+{
+	struct dentry *dir;
+	char name[4];
+
+	snprintf(name, 4, "fb%u", layer->index);
+	dir = debugfs_create_dir(name, layer->parent->debug);
+	if (!dir || IS_ERR(dir))
+		return;
+
+	debugfs_create_file("registers", S_IRUSR, dir, layer,
+			&lf1000_layer_regs_fops);
+	debugfs_create_bool("enabled", S_IRUSR, dir, (u32 *)&layer->enabled);
+	debugfs_create_bool("vflip", S_IRUSR, dir, (u32 *)&layer->vflip);
+	debugfs_create_u8("format", S_IRUSR, dir, (u8 *)&layer->format);
+	debugfs_create_u32("vstride", S_IRUSR, dir, &layer->vstride);
+	debugfs_create_u8("hstride", S_IRUSR, dir, &layer->hstride);
+}
+
+static int __init lf1000fb_probe_layer(struct lf1000fb_info *info, u8 index)
+{
+	int ret;
+	struct fb_info *fbi;
+	struct lf1000fb_layer *layer;
+	u32 fb_size;
+
+	if (index >= info->num_layers)
+		return -EINVAL;
+
+	fbi = framebuffer_alloc(sizeof(struct lf1000fb_layer),
+			&info->pdev->dev);
+	if (fbi == NULL) {
+		dev_err(&info->pdev->dev, "can't allocate layer %d\n", index);
+		return -ENOMEM;
+	}
+
+	layer = fbi->par;
+	layer->index = index;
+	layer->parent = info;
+	layer->fbinfo = fbi;
+	layer->vflip = 0;
+	fbi->pseudo_palette = layer->pseudo_pal;
+	fb_size = get_fb_size(info, layer);
+
+	memset(layer->pseudo_pal, PALETTE_CLEAR,
+			ARRAY_SIZE(layer->pseudo_pal));
+
+	info->fbs[index] = fbi;
+
+	layer->fbinfo->fix.smem_start = info->fbres->start;
+	layer->fbinfo->fix.smem_len = RESSIZE(info->fbres);
+	layer->fbinfo->fix.accel = FB_ACCEL_NONE;
+	layer->fbinfo->fix.ywrapstep = 0;
+	snprintf(&layer->fbinfo->fix.id[0], 16, DRIVER_NAME "%d", index);
+
+	fbi->var.xres		= info->screen->xres;
+	fbi->var.yres		= info->screen->yres;
+	fbi->var.xoffset	= 0;
+	fbi->var.yoffset	= 0;
+	fbi->var.left_margin	= info->screen->hfp;
+	fbi->var.right_margin	= info->screen->hbp;
+	fbi->var.upper_margin	= info->screen->vfp;
+	fbi->var.lower_margin	= info->screen->vbp;
+	fbi->var.hsync_len		= info->screen->hsw;
+	fbi->var.vsync_len		= info->screen->vsw;
+	fbi->var.pixclock		= (1000000000/(info->screen->clk_hz/1000));	/* pico second */
+
+	/* Preserve top layer with bootloader settings */
+	if (index == 0) {
+		u32 left, top, right, bottom;
+		get_position(layer, &left, &top, &right, &bottom);
+		fbi->var.xres	= right - left;
+		fbi->var.yres	= bottom - top;
+	}
+
+	dev_info(&info->pdev->dev, "layer=%d, xyres=%dx%d\n",
+			index, fbi->var.xres, fbi->var.yres);
+
+	if (IS_YUV_LAYER(layer)) {
+		fbi->var.nonstd =
+			((info->num_layers - 1)<<LF1000_NONSTD_PRIORITY)|
+			(LAYER_FORMAT_YUV420<<LF1000_NONSTD_FORMAT);
+		layer->fbinfo->fix.type = FB_TYPE_PLANES;
+		layer->fbinfo->fix.smem_start |= 0x20000000;
+		layer->fbinfo->fix.xpanstep = 1;
+		layer->fbinfo->fix.ypanstep = 1;
+		layer->fbinfo->fix.line_length = 4096;
+		fbi->var.xres_virtual = 4096;
+		fbi->var.yres_virtual = layer->fbinfo->fix.smem_len / 4096;
+		mlc_set_yuv_position(layer, info->num_layers - 1);
+		set_video_scaler(layer, fbi->var.xres, fbi->var.yres, 0);
+	} else {
+		fbi->var.nonstd = (LAYER_FORMAT_RGB<<LF1000_NONSTD_FORMAT);
+		layer->fbinfo->fix.type = FB_TYPE_PACKED_PIXELS;
+		layer->fbinfo->fix.xpanstep = 1;
+		layer->fbinfo->fix.ypanstep = 1;
+		fbi->var.xres_virtual = 4096;
+		fbi->var.yres_virtual = layer->fbinfo->fix.smem_len / 4096;
+
+		/* use ABGR888 initially */
+		fbi->var.bits_per_pixel	= 32;
+		fbi->var.transp.length	= 8;
+		fbi->var.transp.offset	= 24;
+		set_bgr888(&fbi->var);
+	}
+
+	mlc_set_address(layer, info->fbres->start);
+	mlc_set_locksize(layer, 0);
+
+	fbi->var.activate = FB_ACTIVATE_FORCE | FB_ACTIVATE_NOW;
+
+	fbi->fbops = &lf1000fb_ops;
+	fbi->flags = FBINFO_DEFAULT;
+	fbi->node = -1;
+
+	fbi->screen_size = RESSIZE(info->fbres);
+	fbi->screen_base = info->fbmem;
+
+	ret = fb_alloc_cmap(&fbi->cmap, 256, 0);
+	if (ret) {
+		dev_err(&info->pdev->dev, "failed to allocate FB%d cmap\n",
+				index);
+		goto out_layer;
+	}
+
+	/* setup secondary MLC to clone primary MLC for TV out */
+	if (gpio_have_tvout()) {
+		mlc_select(layer, 1);
+		mlc_set_address(layer, info->fbres->start);
+		set_position(layer, 0, 0, fbi->var.xres, fbi->var.yres, 1);
+		mlc_select(layer, 0);
+	}
+
+	lf1000fb_set_par(fbi); /* set up the hardware */
+
+	ret = register_framebuffer(fbi);
+	if (ret) {
+		dev_err(&info->pdev->dev, "failed to register FB%d device\n",
+				index);
+		goto out_layer;
+	}
+
+	/* Only top layer should be visible */
+	if (index > 0)
+		lf1000fb_blank(FB_BLANK_POWERDOWN, fbi);
+	else
+		lf1000fb_blank(FB_BLANK_UNBLANK, fbi);
+
+	if (info->debug)
+		init_debugfs(layer);
+
+	return 0;
+
+out_layer:
+	framebuffer_release(fbi);
+	info->fbs[index] = NULL;
+
+	return ret;
+}
+
+static int __init lf1000fb_probe(struct platform_device *pdev)
+{
+	struct lf1000fb_info *info = NULL;
+	struct fb_info *fbinfo;
+	int i;
+	u32 reg;
+	struct dentry *dir;
+	int ret = 0;
+
+	fbinfo = framebuffer_alloc(sizeof(struct lf1000fb_info), &pdev->dev);
+	if (!fbinfo) {
+		dev_err(&pdev->dev, "can't allocate FB\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, info);
+
+	info = fbinfo->par;
+	info->pdev = pdev;
+	info->screen = lf1000_get_screen_info();
+	
+	info->num_layers = 3;
+
+	dev_info(&info->pdev->dev, "layers=%d, screen=%dx%d\n",
+			info->num_layers, info->screen->xres, info->screen->yres);
+
+	info->fbs = kzalloc(sizeof(struct fb_info)*info->num_layers,
+			GFP_KERNEL);
+	if (!info->fbs) {
+		dev_err(&pdev->dev, "can't allocate layer data\n");
+		goto out_layers;
+	}
+
+	info->irq = platform_get_irq(pdev, 0);
+	if (info->irq < 0) {
+		dev_err(&pdev->dev, "failed to get an IRQ number\n");
+		ret = info->irq;
+		goto out_irq;
+	}
+
+	ret = request_irq(info->irq, lf1000fb_irq, IRQF_SHARED,
+			DRIVER_NAME, info);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get DPC IRQ\n");
+		ret = -ENOENT;
+		goto out_irq;
+	}
+	dev_info(&pdev->dev, "got IRQ %d\n", info->irq);
+
+	ret = lf1000fb_map_resource(info, &info->fbres, &info->fbmem, 0,
+			DRIVER_NAME);
+	if (ret)
+		goto out_fbmem;
+
+	ret = lf1000fb_map_resource(info, &info->mlcres, &info->mlc, 1,
+			DRIVER_NAME "-mlc");
+	if (ret) {
+		lf1000fb_unmap_resource(&info->fbres, &info->fbmem);
+		goto out_mlc;
+	}
+
+	dir = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (!dir || IS_ERR(dir))
+		info->debug = NULL;
+	else {
+		info->debug = dir;
+		debugfs_create_u32("nirq", S_IRUSR, dir, (u32 *)&info->nirq);
+		debugfs_create_file("registers", S_IRUSR, dir, info,
+			&lf1000_mlc_regs_fops);
+	}
+
+	/* set primary MLC register base address */
+	info->mlcreg = info->mlc;
+	info->prisec = false;
+
+	/* set MLC screen size */
+	writel((info->screen->xres-1) | ((info->screen->yres-1)<<16),
+	       info->mlc + MLCSCREENSIZE);
+
+	for (i = 0; i < info->num_layers; i++) {
+		dev_dbg(&info->pdev->dev, "adding FB%d\n", i);
+		ret = lf1000fb_probe_layer(info, i);
+		if (ret)
+			goto out_fb;
+	}
+
+	/* apply changes and make sure MLC is enabled */
+	reg = readl(info->mlc + MLCCONTROLT);
+	writel(reg | (1<<3)|(1<<1), info->mlc + MLCCONTROLT);
+
+	/* clone secondary MLC for TV out dual display */
+	if (gpio_have_tvout()) {
+		reg = readl(info->mlc + MLCCLKENB);
+		writel(reg, info->mlc + MLCCLKENB + MLCSECONDARY);
+		reg = readl(info->mlc + MLCSCREENSIZE);
+		writel(reg, info->mlc + MLCSCREENSIZE + MLCSECONDARY);
+		reg = readl(info->mlc + MLCBGCOLOR);
+		writel(reg, info->mlc + MLCBGCOLOR + MLCSECONDARY);
+		reg = readl(info->mlc + MLCCONTROLT);
+		writel(reg, info->mlc + MLCCONTROLT + MLCSECONDARY);
+	}
+
+	info->nirq = 0;
+	lf1000_dpc_enable_int(1);
+
+	return 0;
+
+out_fb:
+	lf1000fb_unmap_resource(&info->mlcres, &info->mlc);
+out_mlc:
+	lf1000fb_unmap_resource(&info->fbres, &info->fbmem);
+out_fbmem:
+out_irq:
+	kfree(info->fbs);
+out_layers:
+	framebuffer_release(fbinfo);
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static int lf1000fb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(pdev);
+	struct lf1000fb_info *info = fbinfo->par;
+	struct lf1000fb_layer *layer;
+	int i;
+
+	if (info->debug)
+		debugfs_remove_recursive(info->debug);
+
+	for (i = 0; i < info->num_layers; i++) {
+		if (info->fbs[i]) {
+			dev_dbg(&info->pdev->dev, "removing FB%d\n", i);
+			layer = (info->fbs[i])->par;
+			fb_dealloc_cmap(&layer->fbinfo->cmap);
+			unregister_framebuffer(layer->fbinfo);
+			framebuffer_release(layer->fbinfo);
+		}
+	}
+
+	lf1000fb_unmap_resource(&info->mlcres, &info->mlc);
+	lf1000fb_unmap_resource(&info->fbres, &info->fbmem);
+
+	kfree(info->fbs);
+	framebuffer_release(fbinfo);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver lf1000fb_driver = {
+	.probe		= lf1000fb_probe,
+	.remove		= lf1000fb_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int lf1000fb_init(void)
+{
+	return platform_driver_register(&lf1000fb_driver);
+}
+
+static void __exit lf1000fb_exit(void)
+{
+	platform_driver_unregister(&lf1000fb_driver);
+}
+
+module_init(lf1000fb_init);
+module_exit(lf1000fb_exit);
+
+MODULE_DESCRIPTION("LF1000 Frame Buffer Driver");
+MODULE_AUTHOR("Andrey Yurovsky");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lf1000-fb");
diff -ruaN linux-2.6.31/drivers/video/Makefile linux-2.6/drivers/video/Makefile
--- linux-2.6.31/drivers/video/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/video/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -126,6 +126,7 @@
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
+obj-$(CONFIG_FB_LF1000)		  += lf1000fb.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
diff -ruaN linux-2.6.31/drivers/watchdog/softdog.c linux-2.6/drivers/watchdog/softdog.c
--- linux-2.6.31/drivers/watchdog/softdog.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/drivers/watchdog/softdog.c	2011-01-04 13:50:21.000000000 -0800
@@ -49,6 +49,8 @@
 #include <linux/jiffies.h>
 #include <linux/uaccess.h>
 
+asmlinkage void sys_sync(void); /* it's really int */
+
 #define PFX "SoftDog: "
 
 #define TIMER_MARGIN	60		/* Default is 60 seconds */
@@ -100,6 +102,7 @@
 		printk(KERN_CRIT PFX "Triggered - Reboot ignored.\n");
 	else {
 		printk(KERN_CRIT PFX "Initiating system reboot.\n");
+		sys_sync();
 		emergency_restart();
 		printk(KERN_CRIT PFX "Reboot didn't ?????\n");
 	}
diff -ruaN linux-2.6.31/fs/ubifs/budget.c linux-2.6/fs/ubifs/budget.c
--- linux-2.6.31/fs/ubifs/budget.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/budget.c	2011-01-04 14:54:25.000000000 -0800
@@ -741,7 +741,7 @@
  * ubifs_get_free_space - return amount of free space.
  * @c: UBIFS file-system description object
  *
- * This function calculates and retuns amount of free space to report to
+ * This function calculates and returns amount of free space to report to
  * user-space.
  */
 long long ubifs_get_free_space(struct ubifs_info *c)
diff -ruaN linux-2.6.31/fs/ubifs/commit.c linux-2.6/fs/ubifs/commit.c
--- linux-2.6.31/fs/ubifs/commit.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/commit.c	2011-01-04 14:54:25.000000000 -0800
@@ -510,7 +510,7 @@
 	int lnum, offs, len, err = 0, uninitialized_var(last_level), child_cnt;
 	int first = 1, iip;
 	struct ubifs_debug_info *d = c->dbg;
-	union ubifs_key lower_key, upper_key, l_key, u_key;
+	union ubifs_key uninitialized_var(lower_key), upper_key, l_key, u_key;
 	unsigned long long uninitialized_var(last_sqnum);
 	struct ubifs_idx_node *idx;
 	struct list_head list;
diff -ruaN linux-2.6.31/fs/ubifs/debug.c linux-2.6/fs/ubifs/debug.c
--- linux-2.6.31/fs/ubifs/debug.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/debug.c	2011-01-04 14:54:25.000000000 -0800
@@ -210,6 +210,20 @@
 	}
 }
 
+const char *dbg_jhead(int jhead)
+{
+	switch (jhead) {
+	case GCHD:
+		return "0 (GC)";
+	case BASEHD:
+		return "1 (base)";
+	case DATAHD:
+		return "2 (data)";
+	default:
+		return "unknown journal head";
+	}
+}
+
 static void dump_ch(const struct ubifs_ch *ch)
 {
 	printk(KERN_DEBUG "\tmagic          %#x\n", le32_to_cpu(ch->magic));
@@ -623,8 +637,9 @@
 	/* If we are in R/O mode, journal heads do not exist */
 	if (c->jheads)
 		for (i = 0; i < c->jhead_cnt; i++)
-			printk(KERN_DEBUG "\tjhead %d\t LEB %d\n",
-			       c->jheads[i].wbuf.jhead, c->jheads[i].wbuf.lnum);
+			printk(KERN_DEBUG "\tjhead %s\t LEB %d\n",
+			       dbg_jhead(c->jheads[i].wbuf.jhead),
+			       c->jheads[i].wbuf.lnum);
 	for (rb = rb_first(&c->buds); rb; rb = rb_next(rb)) {
 		bud = rb_entry(rb, struct ubifs_bud, rb);
 		printk(KERN_DEBUG "\tbud LEB %d\n", bud->lnum);
@@ -648,9 +663,90 @@
 
 void dbg_dump_lprop(const struct ubifs_info *c, const struct ubifs_lprops *lp)
 {
-	printk(KERN_DEBUG "LEB %d lprops: free %d, dirty %d (used %d), "
-	       "flags %#x\n", lp->lnum, lp->free, lp->dirty,
-	       c->leb_size - lp->free - lp->dirty, lp->flags);
+	int i, spc, dark = 0, dead = 0;
+	struct rb_node *rb;
+	struct ubifs_bud *bud;
+
+	spc = lp->free + lp->dirty;
+	if (spc < c->dead_wm)
+		dead = spc;
+	else
+		dark = ubifs_calc_dark(c, spc);
+
+	if (lp->flags & LPROPS_INDEX)
+		printk(KERN_DEBUG "LEB %-7d free %-8d dirty %-8d used %-8d "
+		       "free + dirty %-8d flags %#x (", lp->lnum, lp->free,
+		       lp->dirty, c->leb_size - spc, spc, lp->flags);
+	else
+		printk(KERN_DEBUG "LEB %-7d free %-8d dirty %-8d used %-8d "
+		       "free + dirty %-8d dark %-4d dead %-4d nodes fit %-3d "
+		       "flags %#-4x (", lp->lnum, lp->free, lp->dirty,
+		       c->leb_size - spc, spc, dark, dead,
+		       (int)(spc / UBIFS_MAX_NODE_SZ), lp->flags);
+
+	if (lp->flags & LPROPS_TAKEN) {
+		if (lp->flags & LPROPS_INDEX)
+			printk(KERN_CONT "index, taken");
+		else
+			printk(KERN_CONT "taken");
+	} else {
+		const char *s;
+
+		if (lp->flags & LPROPS_INDEX) {
+			switch (lp->flags & LPROPS_CAT_MASK) {
+			case LPROPS_DIRTY_IDX:
+				s = "dirty index";
+				break;
+			case LPROPS_FRDI_IDX:
+				s = "freeable index";
+				break;
+			default:
+				s = "index";
+			}
+		} else {
+			switch (lp->flags & LPROPS_CAT_MASK) {
+			case LPROPS_UNCAT:
+				s = "not categorized";
+				break;
+			case LPROPS_DIRTY:
+				s = "dirty";
+				break;
+			case LPROPS_FREE:
+				s = "free";
+				break;
+			case LPROPS_EMPTY:
+				s = "empty";
+				break;
+			case LPROPS_FREEABLE:
+				s = "freeable";
+				break;
+			default:
+				s = NULL;
+				break;
+			}
+		}
+		printk(KERN_CONT "%s", s);
+	}
+
+	for (rb = rb_first((struct rb_root *)&c->buds); rb; rb = rb_next(rb)) {
+		bud = rb_entry(rb, struct ubifs_bud, rb);
+		if (bud->lnum == lp->lnum) {
+			int head = 0;
+			for (i = 0; i < c->jhead_cnt; i++) {
+				if (lp->lnum == c->jheads[i].wbuf.lnum) {
+					printk(KERN_CONT ", jhead %s",
+					       dbg_jhead(i));
+					head = 1;
+				}
+			}
+			if (!head)
+				printk(KERN_CONT ", bud of jhead %s",
+				       dbg_jhead(bud->jhead));
+		}
+	}
+	if (lp->lnum == c->gc_lnum)
+		printk(KERN_CONT ", GC LEB");
+	printk(KERN_CONT ")\n");
 }
 
 void dbg_dump_lprops(struct ubifs_info *c)
@@ -724,7 +820,7 @@
 
 	printk(KERN_DEBUG "(pid %d) start dumping LEB %d\n",
 	       current->pid, lnum);
-	sleb = ubifs_scan(c, lnum, 0, c->dbg->buf);
+	sleb = ubifs_scan(c, lnum, 0, c->dbg->buf, 0);
 	if (IS_ERR(sleb)) {
 		ubifs_err("scan error %d", (int)PTR_ERR(sleb));
 		return;
@@ -909,8 +1005,10 @@
 	ubifs_msg("saved lprops statistics dump");
 	dbg_dump_lstats(&d->saved_lst);
 	ubifs_get_lp_stats(c, &lst);
+
 	ubifs_msg("current lprops statistics dump");
-	dbg_dump_lstats(&d->saved_lst);
+	dbg_dump_lstats(&lst);
+
 	spin_lock(&c->space_lock);
 	dbg_dump_budg(c);
 	spin_unlock(&c->space_lock);
diff -ruaN linux-2.6.31/fs/ubifs/debug.h linux-2.6/fs/ubifs/debug.h
--- linux-2.6.31/fs/ubifs/debug.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/debug.h	2011-01-04 14:54:25.000000000 -0800
@@ -271,6 +271,7 @@
 /* Dump functions */
 const char *dbg_ntype(int type);
 const char *dbg_cstate(int cmt_state);
+const char *dbg_jhead(int jhead);
 const char *dbg_get_key_dump(const struct ubifs_info *c,
 			     const union ubifs_key *key);
 void dbg_dump_inode(const struct ubifs_info *c, const struct inode *inode);
@@ -321,6 +322,8 @@
 int dbg_check_lprops(struct ubifs_info *c);
 int dbg_check_lpt_nodes(struct ubifs_info *c, struct ubifs_cnode *cnode,
 			int row, int col);
+int dbg_check_inode_size(struct ubifs_info *c, const struct inode *inode,
+			 loff_t size);
 
 /* Force the use of in-the-gaps method for testing */
 
@@ -425,6 +428,7 @@
 
 #define dbg_ntype(type)                        ""
 #define dbg_cstate(cmt_state)                  ""
+#define dbg_jhead(jhead)                       ""
 #define dbg_get_key_dump(c, key)               ({})
 #define dbg_dump_inode(c, inode)               ({})
 #define dbg_dump_node(c, node)                 ({})
@@ -460,6 +464,7 @@
 #define dbg_check_heap(c, heap, cat, add_pos)      ({})
 #define dbg_check_lprops(c)                        0
 #define dbg_check_lpt_nodes(c, cnode, row, col)    0
+#define dbg_check_inode_size(c, inode, size)       0
 #define dbg_force_in_the_gaps_enabled              0
 #define dbg_force_in_the_gaps()                    0
 #define dbg_failure_mode                           0
diff -ruaN linux-2.6.31/fs/ubifs/file.c linux-2.6/fs/ubifs/file.c
--- linux-2.6.31/fs/ubifs/file.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/file.c	2011-01-04 14:54:25.000000000 -0800
@@ -21,34 +21,32 @@
  */
 
 /*
- * This file implements VFS file and inode operations of regular files, device
+ * This file implements VFS file and inode operations for regular files, device
  * nodes and symlinks as well as address space operations.
  *
- * UBIFS uses 2 page flags: PG_private and PG_checked. PG_private is set if the
- * page is dirty and is used for budgeting purposes - dirty pages should not be
- * budgeted. The PG_checked flag is set if full budgeting is required for the
- * page e.g., when it corresponds to a file hole or it is just beyond the file
- * size. The budgeting is done in 'ubifs_write_begin()', because it is OK to
- * fail in this function, and the budget is released in 'ubifs_write_end()'. So
- * the PG_private and PG_checked flags carry the information about how the page
- * was budgeted, to make it possible to release the budget properly.
+ * UBIFS uses 2 page flags: @PG_private and @PG_checked. @PG_private is set if
+ * the page is dirty and is used for optimization purposes - dirty pages are
+ * not budgeted so the flag shows that 'ubifs_write_end()' should not release
+ * the budget for this page. The @PG_checked flag is set if full budgeting is
+ * required for the page e.g., when it corresponds to a file hole or it is
+ * beyond the file size. The budgeting is done in 'ubifs_write_begin()', because
+ * it is OK to fail in this function, and the budget is released in
+ * 'ubifs_write_end()'. So the @PG_private and @PG_checked flags carry
+ * information about how the page was budgeted, to make it possible to release
+ * the budget properly.
  *
- * A thing to keep in mind: inode's 'i_mutex' is locked in most VFS operations
- * we implement. However, this is not true for '->writepage()', which might be
- * called with 'i_mutex' unlocked. For example, when pdflush is performing
- * write-back, it calls 'writepage()' with unlocked 'i_mutex', although the
- * inode has 'I_LOCK' flag in this case. At "normal" work-paths 'i_mutex' is
- * locked in '->writepage', e.g. in "sys_write -> alloc_pages -> direct reclaim
- * path'. So, in '->writepage()' we are only guaranteed that the page is
- * locked.
+ * A thing to keep in mind: inode @i_mutex is locked in most VFS operations we
+ * implement. However, this is not true for 'ubifs_writepage()', which may be
+ * called with @i_mutex unlocked. For example, when pdflush is doing background
+ * write-back, it calls 'ubifs_writepage()' with unlocked @i_mutex. At "normal"
+ * work-paths the @i_mutex is locked in 'ubifs_writepage()', e.g. in the
+ * "sys_write -> alloc_pages -> direct reclaim path". So, in 'ubifs_writepage()'
+ * we are only guaranteed that the page is locked.
  *
- * Similarly, 'i_mutex' does not have to be locked in readpage(), e.g.,
- * readahead path does not have it locked ("sys_read -> generic_file_aio_read
- * -> ondemand_readahead -> readpage"). In case of readahead, 'I_LOCK' flag is
- * not set as well. However, UBIFS disables readahead.
- *
- * This, for example means that there might be 2 concurrent '->writepage()'
- * calls for the same inode, but different inode dirty pages.
+ * Similarly, @i_mutex is not always locked in 'ubifs_readpage()', e.g., the
+ * read-ahead path does not lock it ("sys_read -> generic_file_aio_read ->
+ * ondemand_readahead -> readpage"). In case of readahead, @I_LOCK flag is not
+ * set as well. However, UBIFS disables readahead.
  */
 
 #include "ubifs.h"
@@ -449,9 +447,9 @@
 			/*
 			 * We change whole page so no need to load it. But we
 			 * have to set the @PG_checked flag to make the further
-			 * code the page is new. This might be not true, but it
-			 * is better to budget more that to read the page from
-			 * the media.
+			 * code know that the page is new. This might be not
+			 * true, but it is better to budget more than to read
+			 * the page from the media.
 			 */
 			SetPageChecked(page);
 			skipped_read = 1;
@@ -497,8 +495,8 @@
 	}
 
 	/*
-	 * Whee, we aquired budgeting quickly - without involving
-	 * garbage-collection, committing or forceing write-back. We return
+	 * Whee, we acquired budgeting quickly - without involving
+	 * garbage-collection, committing or forcing write-back. We return
 	 * with @ui->ui_mutex locked if we are appending pages, and unlocked
 	 * otherwise. This is an optimization (slightly hacky though).
 	 */
@@ -562,7 +560,7 @@
 
 		/*
 		 * Return 0 to force VFS to repeat the whole operation, or the
-		 * error code if 'do_readpage()' failes.
+		 * error code if 'do_readpage()' fails.
 		 */
 		copied = do_readpage(page);
 		goto out;
@@ -1175,11 +1173,11 @@
 	ui->ui_size = inode->i_size;
 	/* Truncation changes inode [mc]time */
 	inode->i_mtime = inode->i_ctime = ubifs_current_time(inode);
-	/* The other attributes may be changed at the same time as well */
+	/* Other attributes may be changed at the same time as well */
 	do_attr_changes(inode, attr);
-
 	err = ubifs_jnl_truncate(c, inode, old_size, new_size);
 	mutex_unlock(&ui->ui_mutex);
+
 out_budg:
 	if (budgeted)
 		ubifs_release_budget(c, &req);
diff -ruaN linux-2.6.31/fs/ubifs/gc.c linux-2.6/fs/ubifs/gc.c
--- linux-2.6.31/fs/ubifs/gc.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/gc.c	2011-01-04 14:54:25.000000000 -0800
@@ -529,7 +529,7 @@
 	 * We scan the entire LEB even though we only really need to scan up to
 	 * (c->leb_size - lp->free).
 	 */
-	sleb = ubifs_scan(c, lnum, 0, c->sbuf);
+	sleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);
 	if (IS_ERR(sleb))
 		return PTR_ERR(sleb);
 
diff -ruaN linux-2.6.31/fs/ubifs/io.c linux-2.6/fs/ubifs/io.c
--- linux-2.6.31/fs/ubifs/io.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/io.c	2011-01-04 14:54:25.000000000 -0800
@@ -63,6 +63,7 @@
 	if (!c->ro_media) {
 		c->ro_media = 1;
 		c->no_chk_data_crc = 0;
+		c->vfs_sb->s_flags |= MS_RDONLY;
 		ubifs_warn("switched to read-only mode, error %d", err);
 		dbg_dump_stack();
 	}
@@ -297,7 +298,7 @@
 {
 	struct ubifs_wbuf *wbuf = container_of(timer, struct ubifs_wbuf, timer);
 
-	dbg_io("jhead %d", wbuf->jhead);
+	dbg_io("jhead %s", dbg_jhead(wbuf->jhead));
 	wbuf->need_sync = 1;
 	wbuf->c->need_wbuf_sync = 1;
 	ubifs_wake_up_bgt(wbuf->c);
@@ -314,7 +315,8 @@
 
 	if (wbuf->no_timer)
 		return;
-	dbg_io("set timer for jhead %d, %llu-%llu millisecs", wbuf->jhead,
+	dbg_io("set timer for jhead %s, %llu-%llu millisecs",
+	       dbg_jhead(wbuf->jhead),
 	       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),
 	       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,
 		       USEC_PER_SEC));
@@ -351,8 +353,8 @@
 		/* Write-buffer is empty or not seeked */
 		return 0;
 
-	dbg_io("LEB %d:%d, %d bytes, jhead %d",
-	       wbuf->lnum, wbuf->offs, wbuf->used, wbuf->jhead);
+	dbg_io("LEB %d:%d, %d bytes, jhead %s",
+	       wbuf->lnum, wbuf->offs, wbuf->used, dbg_jhead(wbuf->jhead));
 	ubifs_assert(!(c->vfs_sb->s_flags & MS_RDONLY));
 	ubifs_assert(!(wbuf->avail & 7));
 	ubifs_assert(wbuf->offs + c->min_io_size <= c->leb_size);
@@ -401,7 +403,7 @@
 {
 	const struct ubifs_info *c = wbuf->c;
 
-	dbg_io("LEB %d:%d, jhead %d", lnum, offs, wbuf->jhead);
+	dbg_io("LEB %d:%d, jhead %s", lnum, offs, dbg_jhead(wbuf->jhead));
 	ubifs_assert(lnum >= 0 && lnum < c->leb_cnt);
 	ubifs_assert(offs >= 0 && offs <= c->leb_size);
 	ubifs_assert(offs % c->min_io_size == 0 && !(offs & 7));
@@ -508,9 +510,9 @@
 	struct ubifs_info *c = wbuf->c;
 	int err, written, n, aligned_len = ALIGN(len, 8), offs;
 
-	dbg_io("%d bytes (%s) to jhead %d wbuf at LEB %d:%d", len,
-	       dbg_ntype(((struct ubifs_ch *)buf)->node_type), wbuf->jhead,
-	       wbuf->lnum, wbuf->offs + wbuf->used);
+	dbg_io("%d bytes (%s) to jhead %s wbuf at LEB %d:%d", len,
+	       dbg_ntype(((struct ubifs_ch *)buf)->node_type),
+	       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs + wbuf->used);
 	ubifs_assert(len > 0 && wbuf->lnum >= 0 && wbuf->lnum < c->leb_cnt);
 	ubifs_assert(wbuf->offs >= 0 && wbuf->offs % c->min_io_size == 0);
 	ubifs_assert(!(wbuf->offs & 7) && wbuf->offs <= c->leb_size);
@@ -535,8 +537,8 @@
 		memcpy(wbuf->buf + wbuf->used, buf, len);
 
 		if (aligned_len == wbuf->avail) {
-			dbg_io("flush jhead %d wbuf to LEB %d:%d",
-			       wbuf->jhead, wbuf->lnum, wbuf->offs);
+			dbg_io("flush jhead %s wbuf to LEB %d:%d",
+			       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);
 			err = ubi_leb_write(c->ubi, wbuf->lnum, wbuf->buf,
 					    wbuf->offs, c->min_io_size,
 					    wbuf->dtype);
@@ -564,8 +566,8 @@
 	 * minimal I/O unit. We have to fill and flush write-buffer and switch
 	 * to the next min. I/O unit.
 	 */
-	dbg_io("flush jhead %d wbuf to LEB %d:%d",
-	       wbuf->jhead, wbuf->lnum, wbuf->offs);
+	dbg_io("flush jhead %s wbuf to LEB %d:%d",
+	       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);
 	memcpy(wbuf->buf + wbuf->used, buf, wbuf->avail);
 	err = ubi_leb_write(c->ubi, wbuf->lnum, wbuf->buf, wbuf->offs,
 			    c->min_io_size, wbuf->dtype);
@@ -698,8 +700,8 @@
 	int err, rlen, overlap;
 	struct ubifs_ch *ch = buf;
 
-	dbg_io("LEB %d:%d, %s, length %d, jhead %d", lnum, offs,
-	       dbg_ntype(type), len, wbuf->jhead);
+	dbg_io("LEB %d:%d, %s, length %d, jhead %s", lnum, offs,
+	       dbg_ntype(type), len, dbg_jhead(wbuf->jhead));
 	ubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);
 	ubifs_assert(!(offs & 7) && offs < c->leb_size);
 	ubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);
diff -ruaN linux-2.6.31/fs/ubifs/journal.c linux-2.6/fs/ubifs/journal.c
--- linux-2.6.31/fs/ubifs/journal.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/journal.c	2011-01-04 14:54:25.000000000 -0800
@@ -158,7 +158,7 @@
 	 * some. But the write-buffer mutex has to be unlocked because
 	 * GC also takes it.
 	 */
-	dbg_jnl("no free space  jhead %d, run GC", jhead);
+	dbg_jnl("no free space in jhead %s, run GC", dbg_jhead(jhead));
 	mutex_unlock(&wbuf->io_mutex);
 
 	lnum = ubifs_garbage_collect(c, 0);
@@ -173,7 +173,8 @@
 		 * because we dropped @wbuf->io_mutex, so try once
 		 * again.
 		 */
-		dbg_jnl("GC couldn't make a free LEB for jhead %d", jhead);
+		dbg_jnl("GC couldn't make a free LEB for jhead %s",
+			dbg_jhead(jhead));
 		if (retries++ < 2) {
 			dbg_jnl("retry (%d)", retries);
 			goto again;
@@ -184,7 +185,7 @@
 	}
 
 	mutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);
-	dbg_jnl("got LEB %d for jhead %d", lnum, jhead);
+	dbg_jnl("got LEB %d for jhead %s", lnum, dbg_jhead(jhead));
 	avail = c->leb_size - wbuf->offs - wbuf->used;
 
 	if (wbuf->lnum != -1 && avail >= len) {
@@ -255,7 +256,8 @@
 	*lnum = c->jheads[jhead].wbuf.lnum;
 	*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;
 
-	dbg_jnl("jhead %d, LEB %d:%d, len %d", jhead, *lnum, *offs, len);
+	dbg_jnl("jhead %s, LEB %d:%d, len %d",
+		dbg_jhead(jhead), *lnum, *offs, len);
 	ubifs_prepare_node(c, node, len, 0);
 
 	return ubifs_wbuf_write_nolock(wbuf, node, len);
@@ -285,7 +287,8 @@
 
 	*lnum = c->jheads[jhead].wbuf.lnum;
 	*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;
-	dbg_jnl("jhead %d, LEB %d:%d, len %d", jhead, *lnum, *offs, len);
+	dbg_jnl("jhead %s, LEB %d:%d, len %d",
+		dbg_jhead(jhead), *lnum, *offs, len);
 
 	err = ubifs_wbuf_write_nolock(wbuf, buf, len);
 	if (err)
diff -ruaN linux-2.6.31/fs/ubifs/key.h linux-2.6/fs/ubifs/key.h
--- linux-2.6.31/fs/ubifs/key.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/key.h	2011-01-04 14:54:25.000000000 -0800
@@ -229,23 +229,6 @@
 }
 
 /**
- * xent_key_init_hash - initialize extended attribute entry key without
- *                      re-calculating hash function.
- * @c: UBIFS file-system description object
- * @key: key to initialize
- * @inum: host inode number
- * @hash: extended attribute entry name hash
- */
-static inline void xent_key_init_hash(const struct ubifs_info *c,
-				      union ubifs_key *key, ino_t inum,
-				      uint32_t hash)
-{
-	ubifs_assert(!(hash & ~UBIFS_S_KEY_HASH_MASK));
-	key->u32[0] = inum;
-	key->u32[1] = hash | (UBIFS_XENT_KEY << UBIFS_S_KEY_HASH_BITS);
-}
-
-/**
  * xent_key_init_flash - initialize on-flash extended attribute entry key.
  * @c: UBIFS file-system description object
  * @k: key to initialize
@@ -295,22 +278,15 @@
 }
 
 /**
- * data_key_init_flash - initialize on-flash data key.
+ * highest_data_key - get the highest possible data key for an inode.
  * @c: UBIFS file-system description object
- * @k: key to initialize
+ * @key: key to initialize
  * @inum: inode number
- * @block: block number
  */
-static inline void data_key_init_flash(const struct ubifs_info *c, void *k,
-				       ino_t inum, unsigned int block)
+static inline void highest_data_key(const struct ubifs_info *c,
+				   union ubifs_key *key, ino_t inum)
 {
-	union ubifs_key *key = k;
-
-	ubifs_assert(!(block & ~UBIFS_S_KEY_BLOCK_MASK));
-	key->j32[0] = cpu_to_le32(inum);
-	key->j32[1] = cpu_to_le32(block |
-				  (UBIFS_DATA_KEY << UBIFS_S_KEY_BLOCK_BITS));
-	memset(k + 8, 0, UBIFS_MAX_KEY_LEN - 8);
+	data_key_init(c, key, inum, UBIFS_S_KEY_BLOCK_MASK);
 }
 
 /**
@@ -554,4 +530,5 @@
 		return 0;
 	}
 }
+
 #endif /* !__UBIFS_KEY_H__ */
diff -ruaN linux-2.6.31/fs/ubifs/log.c linux-2.6/fs/ubifs/log.c
--- linux-2.6.31/fs/ubifs/log.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/log.c	2011-01-04 14:54:25.000000000 -0800
@@ -169,8 +169,8 @@
 	 */
 	c->bud_bytes += c->leb_size - bud->start;
 
-	dbg_log("LEB %d:%d, jhead %d, bud_bytes %lld", bud->lnum,
-		bud->start, bud->jhead, c->bud_bytes);
+	dbg_log("LEB %d:%d, jhead %s, bud_bytes %lld", bud->lnum,
+		bud->start, dbg_jhead(bud->jhead), c->bud_bytes);
 	spin_unlock(&c->buds_lock);
 }
 
@@ -355,16 +355,16 @@
 			 * heads (non-closed buds).
 			 */
 			c->cmt_bud_bytes += wbuf->offs - bud->start;
-			dbg_log("preserve %d:%d, jhead %d, bud bytes %d, "
+			dbg_log("preserve %d:%d, jhead %s, bud bytes %d, "
 				"cmt_bud_bytes %lld", bud->lnum, bud->start,
-				bud->jhead, wbuf->offs - bud->start,
+				dbg_jhead(bud->jhead), wbuf->offs - bud->start,
 				c->cmt_bud_bytes);
 			bud->start = wbuf->offs;
 		} else {
 			c->cmt_bud_bytes += c->leb_size - bud->start;
-			dbg_log("remove %d:%d, jhead %d, bud bytes %d, "
+			dbg_log("remove %d:%d, jhead %s, bud bytes %d, "
 				"cmt_bud_bytes %lld", bud->lnum, bud->start,
-				bud->jhead, c->leb_size - bud->start,
+				dbg_jhead(bud->jhead), c->leb_size - bud->start,
 				c->cmt_bud_bytes);
 			rb_erase(p1, &c->buds);
 			/*
@@ -429,7 +429,8 @@
 		if (lnum == -1 || offs == c->leb_size)
 			continue;
 
-		dbg_log("add ref to LEB %d:%d for jhead %d", lnum, offs, i);
+		dbg_log("add ref to LEB %d:%d for jhead %s",
+			lnum, offs, dbg_jhead(i));
 		ref = buf + len;
 		ref->ch.node_type = UBIFS_REF_NODE;
 		ref->lnum = cpu_to_le32(lnum);
@@ -695,7 +696,7 @@
 	lnum = c->ltail_lnum;
 	write_lnum = lnum;
 	while (1) {
-		sleb = ubifs_scan(c, lnum, 0, c->sbuf);
+		sleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);
 		if (IS_ERR(sleb)) {
 			err = PTR_ERR(sleb);
 			goto out_free;
diff -ruaN linux-2.6.31/fs/ubifs/lprops.c linux-2.6/fs/ubifs/lprops.c
--- linux-2.6.31/fs/ubifs/lprops.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/lprops.c	2011-01-04 14:54:25.000000000 -0800
@@ -281,7 +281,7 @@
 	case LPROPS_FREE:
 		if (add_to_lpt_heap(c, lprops, cat))
 			break;
-		/* No more room on heap so make it uncategorized */
+		/* No more room on heap so make it un-categorized */
 		cat = LPROPS_UNCAT;
 		/* Fall through */
 	case LPROPS_UNCAT:
@@ -375,8 +375,8 @@
  * @lprops: LEB properties
  *
  * A LEB may have fallen off of the bottom of a heap, and ended up as
- * uncategorized even though it has enough space for us now. If that is the case
- * this function will put the LEB back onto a heap.
+ * un-categorized even though it has enough space for us now. If that is the
+ * case this function will put the LEB back onto a heap.
  */
 void ubifs_ensure_cat(struct ubifs_info *c, struct ubifs_lprops *lprops)
 {
@@ -436,10 +436,10 @@
 /**
  * change_category - change LEB properties category.
  * @c: UBIFS file-system description object
- * @lprops: LEB properties to recategorize
+ * @lprops: LEB properties to re-categorize
  *
  * LEB properties are categorized to enable fast find operations. When the LEB
- * properties change they must be recategorized.
+ * properties change they must be re-categorized.
  */
 static void change_category(struct ubifs_info *c, struct ubifs_lprops *lprops)
 {
@@ -461,21 +461,18 @@
 }
 
 /**
- * calc_dark - calculate LEB dark space size.
+ * ubifs_calc_dark - calculate LEB dark space size.
  * @c: the UBIFS file-system description object
  * @spc: amount of free and dirty space in the LEB
  *
- * This function calculates amount of dark space in an LEB which has @spc bytes
- * of free and dirty space. Returns the calculations result.
+ * This function calculates and returns amount of dark space in an LEB which
+ * has @spc bytes of free and dirty space.
  *
- * Dark space is the space which is not always usable - it depends on which
- * nodes are written in which order. E.g., if an LEB has only 512 free bytes,
- * it is dark space, because it cannot fit a large data node. So UBIFS cannot
- * count on this LEB and treat these 512 bytes as usable because it is not true
- * if, for example, only big chunks of uncompressible data will be written to
- * the FS.
+ * UBIFS is trying to account the space which might not be usable, and this
+ * space is called "dark space". For example, if an LEB has only %512 free
+ * bytes, it is dark space, because it cannot fit a large data node.
  */
-static int calc_dark(struct ubifs_info *c, int spc)
+int ubifs_calc_dark(const struct ubifs_info *c, int spc)
 {
 	ubifs_assert(!(spc & 7));
 
@@ -518,7 +515,7 @@
  * @free: new free space amount
  * @dirty: new dirty space amount
  * @flags: new flags
- * @idx_gc_cnt: change to the count of idx_gc list
+ * @idx_gc_cnt: change to the count of @idx_gc list
  *
  * This function changes LEB properties (@free, @dirty or @flag). However, the
  * property which has the %LPROPS_NC value is not changed. Returns a pointer to
@@ -535,7 +532,7 @@
 {
 	/*
 	 * This is the only function that is allowed to change lprops, so we
-	 * discard the const qualifier.
+	 * discard the "const" qualifier.
 	 */
 	struct ubifs_lprops *lprops = (struct ubifs_lprops *)lp;
 
@@ -575,7 +572,7 @@
 		if (old_spc < c->dead_wm)
 			c->lst.total_dead -= old_spc;
 		else
-			c->lst.total_dark -= calc_dark(c, old_spc);
+			c->lst.total_dark -= ubifs_calc_dark(c, old_spc);
 
 		c->lst.total_used -= c->leb_size - old_spc;
 	}
@@ -616,7 +613,7 @@
 		if (new_spc < c->dead_wm)
 			c->lst.total_dead += new_spc;
 		else
-			c->lst.total_dark += calc_dark(c, new_spc);
+			c->lst.total_dark += ubifs_calc_dark(c, new_spc);
 
 		c->lst.total_used += c->leb_size - new_spc;
 	}
@@ -1096,7 +1093,7 @@
 		}
 	}
 
-	sleb = ubifs_scan(c, lnum, 0, c->dbg->buf);
+	sleb = ubifs_scan(c, lnum, 0, c->dbg->buf, 0);
 	if (IS_ERR(sleb)) {
 		/*
 		 * After an unclean unmount, empty and freeable LEBs
@@ -1107,7 +1104,7 @@
 				  "- continuing checking");
 			lst->empty_lebs += 1;
 			lst->total_free += c->leb_size;
-			lst->total_dark += calc_dark(c, c->leb_size);
+			lst->total_dark += ubifs_calc_dark(c, c->leb_size);
 			return LPT_SCAN_CONTINUE;
 		}
 
@@ -1117,7 +1114,7 @@
 				  "- continuing checking");
 			lst->total_free  += lp->free;
 			lst->total_dirty += lp->dirty;
-			lst->total_dark  +=  calc_dark(c, c->leb_size);
+			lst->total_dark  +=  ubifs_calc_dark(c, c->leb_size);
 			return LPT_SCAN_CONTINUE;
 		}
 		data->err = PTR_ERR(sleb);
@@ -1235,7 +1232,7 @@
 		if (spc < c->dead_wm)
 			lst->total_dead += spc;
 		else
-			lst->total_dark += calc_dark(c, spc);
+			lst->total_dark += ubifs_calc_dark(c, spc);
 	}
 
 	ubifs_scan_destroy(sleb);
diff -ruaN linux-2.6.31/fs/ubifs/lpt.c linux-2.6/fs/ubifs/lpt.c
--- linux-2.6.31/fs/ubifs/lpt.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/lpt.c	2011-01-04 14:54:25.000000000 -0800
@@ -1456,13 +1456,13 @@
 		shft -= UBIFS_LPT_FANOUT_SHIFT;
 		nnode = ubifs_get_nnode(c, nnode, iip);
 		if (IS_ERR(nnode))
-			return ERR_PTR(PTR_ERR(nnode));
+			return ERR_CAST(nnode);
 	}
 	iip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));
 	shft -= UBIFS_LPT_FANOUT_SHIFT;
 	pnode = ubifs_get_pnode(c, nnode, iip);
 	if (IS_ERR(pnode))
-		return ERR_PTR(PTR_ERR(pnode));
+		return ERR_CAST(pnode);
 	iip = (i & (UBIFS_LPT_FANOUT - 1));
 	dbg_lp("LEB %d, free %d, dirty %d, flags %d", lnum,
 	       pnode->lprops[iip].free, pnode->lprops[iip].dirty,
@@ -1585,7 +1585,7 @@
 	nnode = c->nroot;
 	nnode = dirty_cow_nnode(c, nnode);
 	if (IS_ERR(nnode))
-		return ERR_PTR(PTR_ERR(nnode));
+		return ERR_CAST(nnode);
 	i = lnum - c->main_first;
 	shft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;
 	for (h = 1; h < c->lpt_hght; h++) {
@@ -1593,19 +1593,19 @@
 		shft -= UBIFS_LPT_FANOUT_SHIFT;
 		nnode = ubifs_get_nnode(c, nnode, iip);
 		if (IS_ERR(nnode))
-			return ERR_PTR(PTR_ERR(nnode));
+			return ERR_CAST(nnode);
 		nnode = dirty_cow_nnode(c, nnode);
 		if (IS_ERR(nnode))
-			return ERR_PTR(PTR_ERR(nnode));
+			return ERR_CAST(nnode);
 	}
 	iip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));
 	shft -= UBIFS_LPT_FANOUT_SHIFT;
 	pnode = ubifs_get_pnode(c, nnode, iip);
 	if (IS_ERR(pnode))
-		return ERR_PTR(PTR_ERR(pnode));
+		return ERR_CAST(pnode);
 	pnode = dirty_cow_pnode(c, pnode);
 	if (IS_ERR(pnode))
-		return ERR_PTR(PTR_ERR(pnode));
+		return ERR_CAST(pnode);
 	iip = (i & (UBIFS_LPT_FANOUT - 1));
 	dbg_lp("LEB %d, free %d, dirty %d, flags %d", lnum,
 	       pnode->lprops[iip].free, pnode->lprops[iip].dirty,
diff -ruaN linux-2.6.31/fs/ubifs/lpt_commit.c linux-2.6/fs/ubifs/lpt_commit.c
--- linux-2.6.31/fs/ubifs/lpt_commit.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/lpt_commit.c	2011-01-04 14:54:25.000000000 -0800
@@ -645,7 +645,7 @@
 		shft -= UBIFS_LPT_FANOUT_SHIFT;
 		nnode = ubifs_get_nnode(c, nnode, iip);
 		if (IS_ERR(nnode))
-			return ERR_PTR(PTR_ERR(nnode));
+			return ERR_CAST(nnode);
 	}
 	iip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));
 	return ubifs_get_pnode(c, nnode, iip);
diff -ruaN linux-2.6.31/fs/ubifs/master.c linux-2.6/fs/ubifs/master.c
--- linux-2.6.31/fs/ubifs/master.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/master.c	2011-01-04 14:54:25.000000000 -0800
@@ -29,7 +29,8 @@
  * @c: UBIFS file-system description object
  *
  * This function scans the master node LEBs and search for the latest master
- * node. Returns zero in case of success and a negative error code in case of
+ * node. Returns zero in case of success, %-EUCLEAN if there master area is
+ * corrupted and requires recovery, and a negative error code in case of
  * failure.
  */
 static int scan_for_master(struct ubifs_info *c)
@@ -40,7 +41,7 @@
 
 	lnum = UBIFS_MST_LNUM;
 
-	sleb = ubifs_scan(c, lnum, 0, c->sbuf);
+	sleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);
 	if (IS_ERR(sleb))
 		return PTR_ERR(sleb);
 	nodes_cnt = sleb->nodes_cnt;
@@ -48,7 +49,7 @@
 		snod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,
 				  list);
 		if (snod->type != UBIFS_MST_NODE)
-			goto out;
+			goto out_dump;
 		memcpy(c->mst_node, snod->node, snod->len);
 		offs = snod->offs;
 	}
@@ -56,7 +57,7 @@
 
 	lnum += 1;
 
-	sleb = ubifs_scan(c, lnum, 0, c->sbuf);
+	sleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);
 	if (IS_ERR(sleb))
 		return PTR_ERR(sleb);
 	if (sleb->nodes_cnt != nodes_cnt)
@@ -65,7 +66,7 @@
 		goto out;
 	snod = list_entry(sleb->nodes.prev, struct ubifs_scan_node, list);
 	if (snod->type != UBIFS_MST_NODE)
-		goto out;
+		goto out_dump;
 	if (snod->offs != offs)
 		goto out;
 	if (memcmp((void *)c->mst_node + UBIFS_CH_SZ,
@@ -78,6 +79,12 @@
 
 out:
 	ubifs_scan_destroy(sleb);
+	return -EUCLEAN;
+
+out_dump:
+	ubifs_err("unexpected node type %d master LEB %d:%d",
+		  snod->type, lnum, snod->offs);
+	ubifs_scan_destroy(sleb);
 	return -EINVAL;
 }
 
@@ -256,7 +263,8 @@
 
 	err = scan_for_master(c);
 	if (err) {
-		err = ubifs_recover_master_node(c);
+		if (err == -EUCLEAN)
+			err = ubifs_recover_master_node(c);
 		if (err)
 			/*
 			 * Note, we do not free 'c->mst_node' here because the
diff -ruaN linux-2.6.31/fs/ubifs/orphan.c linux-2.6/fs/ubifs/orphan.c
--- linux-2.6.31/fs/ubifs/orphan.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/orphan.c	2011-01-04 14:54:25.000000000 -0800
@@ -670,9 +670,10 @@
 		struct ubifs_scan_leb *sleb;
 
 		dbg_rcvry("LEB %d", lnum);
-		sleb = ubifs_scan(c, lnum, 0, c->sbuf);
+		sleb = ubifs_scan(c, lnum, 0, c->sbuf, 1);
 		if (IS_ERR(sleb)) {
-			sleb = ubifs_recover_leb(c, lnum, 0, c->sbuf, 0);
+			if (PTR_ERR(sleb) == -EUCLEAN)
+				sleb = ubifs_recover_leb(c, lnum, 0, c->sbuf, 0);
 			if (IS_ERR(sleb)) {
 				err = PTR_ERR(sleb);
 				break;
@@ -899,7 +900,7 @@
 	for (lnum = c->orph_first; lnum <= c->orph_last; lnum++) {
 		struct ubifs_scan_leb *sleb;
 
-		sleb = ubifs_scan(c, lnum, 0, c->dbg->buf);
+		sleb = ubifs_scan(c, lnum, 0, c->dbg->buf, 0);
 		if (IS_ERR(sleb)) {
 			err = PTR_ERR(sleb);
 			break;
diff -ruaN linux-2.6.31/fs/ubifs/recovery.c linux-2.6/fs/ubifs/recovery.c
--- linux-2.6.31/fs/ubifs/recovery.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/recovery.c	2011-01-04 14:54:25.000000000 -0800
@@ -24,7 +24,7 @@
  * This file implements functions needed to recover from unclean un-mounts.
  * When UBIFS is mounted, it checks a flag on the master node to determine if
  * an un-mount was completed sucessfully. If not, the process of mounting
- * incorparates additional checking and fixing of on-flash data structures.
+ * incorporates additional checking and fixing of on-flash data structures.
  * UBIFS always cleans away all remnants of an unclean un-mount, so that
  * errors do not accumulate. However UBIFS defers recovery if it is mounted
  * read-only, and the flash is not modified in that case.
@@ -286,7 +286,7 @@
 		mst = mst2;
 	}
 
-	dbg_rcvry("recovered master node from LEB %d",
+	ubifs_msg("recovered master node from LEB %d",
 		  (mst == mst1 ? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));
 
 	memcpy(c->mst_node, mst, UBIFS_MST_NODE_SZ);
@@ -790,7 +790,7 @@
 		 * We can only recover at the end of the log, so check that the
 		 * next log LEB is empty or out of date.
 		 */
-		sleb = ubifs_scan(c, next_lnum, 0, sbuf);
+		sleb = ubifs_scan(c, next_lnum, 0, sbuf, 0);
 		if (IS_ERR(sleb))
 			return sleb;
 		if (sleb->nodes_cnt) {
@@ -1062,8 +1062,21 @@
 	}
 	err = ubifs_find_dirty_leb(c, &lp, wbuf->offs, 2);
 	if (err) {
-		if (err == -ENOSPC)
-			dbg_err("could not find a dirty LEB");
+		/*
+		 * There are no dirty or empty LEBs subject to here being
+		 * enough for the index. Try to use
+		 * 'ubifs_find_free_leb_for_idx()', which will return any empty
+		 * LEBs (ignoring index requirements). If the index then
+		 * doesn't have enough LEBs the recovery commit will fail -
+		 * which is the  same result anyway i.e. recovery fails. So
+		 * there is no problem ignoring index  requirements and just
+		 * grabbing a free LEB since we have already established there
+		 * is not a dirty LEB we could have used instead.
+		 */
+		if (err == -ENOSPC) {
+			dbg_rcvry("could not find a dirty LEB");
+			goto find_free;
+		}
 		return err;
 	}
 	ubifs_assert(!(lp.flags & LPROPS_INDEX));
@@ -1138,8 +1151,8 @@
 find_free:
 	/*
 	 * There is no GC head LEB or the free space in the GC head LEB is too
-	 * small. Allocate gc_lnum by calling 'ubifs_find_free_leb_for_idx()' so
-	 * GC is not run.
+	 * small, or there are not dirty LEBs. Allocate gc_lnum by calling
+	 * 'ubifs_find_free_leb_for_idx()' so GC is not run.
 	 */
 	lnum = ubifs_find_free_leb_for_idx(c);
 	if (lnum < 0) {
diff -ruaN linux-2.6.31/fs/ubifs/replay.c linux-2.6/fs/ubifs/replay.c
--- linux-2.6.31/fs/ubifs/replay.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/replay.c	2011-01-04 14:54:25.000000000 -0800
@@ -506,7 +506,7 @@
 	if (c->need_recovery)
 		sleb = ubifs_recover_leb(c, lnum, offs, c->sbuf, jhead != GCHD);
 	else
-		sleb = ubifs_scan(c, lnum, offs, c->sbuf);
+		sleb = ubifs_scan(c, lnum, offs, c->sbuf, 0);
 	if (IS_ERR(sleb))
 		return PTR_ERR(sleb);
 
@@ -836,8 +836,8 @@
 	const struct ubifs_cs_node *node;
 
 	dbg_mnt("replay log LEB %d:%d", lnum, offs);
-	sleb = ubifs_scan(c, lnum, offs, sbuf);
-	if (IS_ERR(sleb) ) {
+	sleb = ubifs_scan(c, lnum, offs, sbuf, c->need_recovery);
+	if (IS_ERR(sleb)) {
 		if (PTR_ERR(sleb) != -EUCLEAN || !c->need_recovery)
 			return PTR_ERR(sleb);
 		sleb = ubifs_recover_log_leb(c, lnum, offs, sbuf);
diff -ruaN linux-2.6.31/fs/ubifs/scan.c linux-2.6/fs/ubifs/scan.c
--- linux-2.6.31/fs/ubifs/scan.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/scan.c	2011-01-04 14:54:25.000000000 -0800
@@ -108,10 +108,9 @@
 
 		/* Make the node pads to 8-byte boundary */
 		if ((node_len + pad_len) & 7) {
-			if (!quiet) {
+			if (!quiet)
 				dbg_err("bad padding length %d - %d",
 					offs, offs + node_len + pad_len);
-			}
 			return SCANNED_A_BAD_PAD_NODE;
 		}
 
@@ -253,15 +252,19 @@
  * @c: UBIFS file-system description object
  * @lnum: logical eraseblock number
  * @offs: offset to start at (usually zero)
- * @sbuf: scan buffer (must be c->leb_size)
+ * @sbuf: scan buffer (must be of @c->leb_size bytes in size)
+ * @quiet: print no messages
  *
  * This function scans LEB number @lnum and returns complete information about
  * its contents. Returns the scaned information in case of success and,
  * %-EUCLEAN if the LEB neads recovery, and other negative error codes in case
  * of failure.
+ *
+ * If @quiet is non-zero, this function does not print large and scary
+ * error messages and flash dumps in case of errors.
  */
 struct ubifs_scan_leb *ubifs_scan(const struct ubifs_info *c, int lnum,
-				  int offs, void *sbuf)
+				  int offs, void *sbuf, int quiet)
 {
 	void *buf = sbuf + offs;
 	int err, len = c->leb_size - offs;
@@ -280,7 +283,7 @@
 
 		cond_resched();
 
-		ret = ubifs_scan_a_node(c, buf, len, lnum, offs, 0);
+		ret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);
 		if (ret > 0) {
 			/* Padding bytes or a valid padding node */
 			offs += ret;
@@ -320,7 +323,9 @@
 	}
 
 	if (offs % c->min_io_size) {
-		ubifs_err("empty space starts at non-aligned offset %d", offs);
+		if (!quiet)
+			ubifs_err("empty space starts at non-aligned offset %d",
+				  offs);
 		goto corrupted;;
 	}
 
@@ -331,18 +336,25 @@
 			break;
 	for (; len; offs++, buf++, len--)
 		if (*(uint8_t *)buf != 0xff) {
-			ubifs_err("corrupt empty space at LEB %d:%d",
-				  lnum, offs);
+			if (!quiet)
+				ubifs_err("corrupt empty space at LEB %d:%d",
+					  lnum, offs);
 			goto corrupted;
 		}
 
 	return sleb;
 
 corrupted:
-	ubifs_scanned_corruption(c, lnum, offs, buf);
+	if (!quiet) {
+		ubifs_scanned_corruption(c, lnum, offs, buf);
+		ubifs_err("LEB %d scanning failed", lnum);
+	}
 	err = -EUCLEAN;
+	ubifs_scan_destroy(sleb);
+	return ERR_PTR(err);
+
 error:
-	ubifs_err("LEB %d scanning failed", lnum);
+	ubifs_err("LEB %d scanning failed, error %d", lnum, err);
 	ubifs_scan_destroy(sleb);
 	return ERR_PTR(err);
 }
diff -ruaN linux-2.6.31/fs/ubifs/super.c linux-2.6/fs/ubifs/super.c
--- linux-2.6.31/fs/ubifs/super.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/super.c	2011-01-04 14:54:25.000000000 -0800
@@ -36,7 +36,6 @@
 #include <linux/mount.h>
 #include <linux/math64.h>
 #include <linux/writeback.h>
-#include <linux/smp_lock.h>
 #include "ubifs.h"
 
 /*
@@ -318,6 +317,8 @@
 		if (err)
 			ubifs_err("can't write inode %lu, error %d",
 				  inode->i_ino, err);
+		else
+			err = dbg_check_inode_size(c, inode, ui->ui_size);
 	}
 
 	ui->dirty = 0;
@@ -438,12 +439,6 @@
 {
 	int i, err;
 	struct ubifs_info *c = sb->s_fs_info;
-	struct writeback_control wbc = {
-		.sync_mode   = WB_SYNC_ALL,
-		.range_start = 0,
-		.range_end   = LLONG_MAX,
-		.nr_to_write = LONG_MAX,
-	};
 
 	/*
 	 * Zero @wait is just an advisory thing to help the file system shove
@@ -454,17 +449,6 @@
 		return 0;
 
 	/*
-	 * VFS calls '->sync_fs()' before synchronizing all dirty inodes and
-	 * pages, so synchronize them first, then commit the journal. Strictly
-	 * speaking, it is not necessary to commit the journal here,
-	 * synchronizing write-buffers would be enough. But committing makes
-	 * UBIFS free space predictions much more accurate, so we want to let
-	 * the user be able to get more accurate results of 'statfs()' after
-	 * they synchronize the file system.
-	 */
-	generic_sync_sb_inodes(sb, &wbc);
-
-	/*
 	 * Synchronize write buffers, because 'ubifs_run_commit()' does not
 	 * do this if it waits for an already running commit.
 	 */
@@ -474,6 +458,13 @@
 			return err;
 	}
 
+	/*
+	 * Strictly speaking, it is not necessary to commit the journal here,
+	 * synchronizing write-buffers would be enough. But committing makes
+	 * UBIFS free space predictions much more accurate, so we want to let
+	 * the user be able to get more accurate results of 'statfs()' after
+	 * they synchronize the file system.
+	 */
 	err = ubifs_run_commit(c);
 	if (err)
 		return err;
@@ -1316,6 +1307,8 @@
 			if (err)
 				goto out_orphans;
 			err = ubifs_rcvry_gc_commit(c);
+			if (err)
+				goto out_orphans;
 		} else {
 			err = take_gc_lnum(c);
 			if (err)
@@ -1327,7 +1320,7 @@
 			 */
 			err = ubifs_leb_unmap(c, c->gc_lnum);
 			if (err)
-				return err;
+				goto out_orphans;
 		}
 
 		err = dbg_check_lprops(c);
@@ -1726,8 +1719,6 @@
 	ubifs_msg("un-mount UBI device %d, volume %d", c->vi.ubi_num,
 		  c->vi.vol_id);
 
-	lock_kernel();
-
 	/*
 	 * The following asserts are only valid if there has not been a failure
 	 * of the media. For example, there will be dirty inodes if we failed
@@ -1792,8 +1783,6 @@
 	ubi_close_volume(c->ubi);
 	mutex_unlock(&c->umount_mutex);
 	kfree(c);
-
-	unlock_kernel();
 }
 
 static int ubifs_remount_fs(struct super_block *sb, int *flags, char *data)
@@ -1809,22 +1798,17 @@
 		return err;
 	}
 
-	lock_kernel();
 	if ((sb->s_flags & MS_RDONLY) && !(*flags & MS_RDONLY)) {
 		if (c->ro_media) {
 			ubifs_msg("cannot re-mount due to prior errors");
-			unlock_kernel();
 			return -EROFS;
 		}
 		err = ubifs_remount_rw(c);
-		if (err) {
-			unlock_kernel();
+		if (err)
 			return err;
-		}
 	} else if (!(sb->s_flags & MS_RDONLY) && (*flags & MS_RDONLY)) {
 		if (c->ro_media) {
 			ubifs_msg("cannot re-mount due to prior errors");
-			unlock_kernel();
 			return -EROFS;
 		}
 		ubifs_remount_ro(c);
@@ -1839,7 +1823,6 @@
 	}
 
 	ubifs_assert(c->lst.taken_empty_lebs > 0);
-	unlock_kernel();
 	return 0;
 }
 
@@ -1861,22 +1844,32 @@
  * @name: UBI volume name
  * @mode: UBI volume open mode
  *
- * There are several ways to specify UBI volumes when mounting UBIFS:
- * o ubiX_Y    - UBI device number X, volume Y;
- * o ubiY      - UBI device number 0, volume Y;
+ * The primary method of mounting UBIFS is by specifying the UBI volume
+ * character device node path. However, UBIFS may also be mounted withoug any
+ * character device node using one of the following methods:
+ *
+ * o ubiX_Y    - mount UBI device number X, volume Y;
+ * o ubiY      - mount UBI device number 0, volume Y;
  * o ubiX:NAME - mount UBI device X, volume with name NAME;
  * o ubi:NAME  - mount UBI device 0, volume with name NAME.
  *
  * Alternative '!' separator may be used instead of ':' (because some shells
  * like busybox may interpret ':' as an NFS host name separator). This function
- * returns ubi volume object in case of success and a negative error code in
- * case of failure.
+ * returns UBI volume description object in case of success and a negative
+ * error code in case of failure.
  */
 static struct ubi_volume_desc *open_ubi(const char *name, int mode)
 {
+	struct ubi_volume_desc *ubi;
 	int dev, vol;
 	char *endptr;
 
+	/* First, try to open using the device node path method */
+	ubi = ubi_open_volume_path(name, mode);
+	if (!IS_ERR(ubi))
+		return ubi;
+
+	/* Try the "nodev" method */
 	if (name[0] != 'u' || name[1] != 'b' || name[2] != 'i')
 		return ERR_PTR(-EINVAL);
 
diff -ruaN linux-2.6.31/fs/ubifs/tnc.c linux-2.6/fs/ubifs/tnc.c
--- linux-2.6.31/fs/ubifs/tnc.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/tnc.c	2011-01-04 14:54:25.000000000 -0800
@@ -1159,8 +1159,8 @@
  *   o exact match, i.e. the found zero-level znode contains key @key, then %1
  *     is returned and slot number of the matched branch is stored in @n;
  *   o not exact match, which means that zero-level znode does not contain
- *     @key, then %0 is returned and slot number of the closed branch is stored
- *     in  @n;
+ *     @key, then %0 is returned and slot number of the closest branch is stored
+ *     in @n;
  *   o @key is so small that it is even less than the lowest key of the
  *     leftmost zero-level node, then %0 is returned and %0 is stored in @n.
  *
@@ -1433,7 +1433,7 @@
  * @lnum: LEB number is returned here
  * @offs: offset is returned here
  *
- * This function look up and reads node with key @key. The caller has to make
+ * This function looks up and reads node with key @key. The caller has to make
  * sure the @node buffer is large enough to fit the node. Returns zero in case
  * of success, %-ENOENT if the node was not found, and a negative error code in
  * case of failure. The node location can be returned in @lnum and @offs.
@@ -3268,3 +3268,73 @@
 	mutex_unlock(&c->tnc_mutex);
 	return err;
 }
+
+#ifdef CONFIG_UBIFS_FS_DEBUG
+
+/**
+ * dbg_check_inode_size - check if inode size is correct.
+ * @c: UBIFS file-system description object
+ * @inum: inode number
+ * @size: inode size
+ *
+ * This function makes sure that the inode size (@size) is correct and it does
+ * not have any pages beyond @size. Returns zero if the inode is OK, %-EINVAL
+ * if it has a data page beyond @size, and other negative error code in case of
+ * other errors.
+ */
+int dbg_check_inode_size(struct ubifs_info *c, const struct inode *inode,
+			 loff_t size)
+{
+	int err, n;
+	union ubifs_key from_key, to_key, *key;
+	struct ubifs_znode *znode;
+	unsigned int block;
+
+	if (!S_ISREG(inode->i_mode))
+		return 0;
+	if (!(ubifs_chk_flags & UBIFS_CHK_GEN))
+		return 0;
+
+	block = (size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;
+	data_key_init(c, &from_key, inode->i_ino, block);
+	highest_data_key(c, &to_key, inode->i_ino);
+
+	mutex_lock(&c->tnc_mutex);
+	err = ubifs_lookup_level0(c, &from_key, &znode, &n);
+	if (err < 0)
+		goto out_unlock;
+
+	if (err) {
+		err = -EINVAL;
+		key = &from_key;
+		goto out_dump;
+	}
+
+	err = tnc_next(c, &znode, &n);
+	if (err == -ENOENT) {
+		err = 0;
+		goto out_unlock;
+	}
+	if (err < 0)
+		goto out_unlock;
+
+	ubifs_assert(err == 0);
+	key = &znode->zbranch[n].key;
+	if (!key_in_range(c, key, &from_key, &to_key))
+		goto out_unlock;
+
+out_dump:
+	block = key_block(c, key);
+	ubifs_err("inode %lu has size %lld, but there are data at offset %lld "
+		  "(data key %s)", (unsigned long)inode->i_ino, size,
+		  ((loff_t)block) << UBIFS_BLOCK_SHIFT, DBGKEY(key));
+	dbg_dump_inode(c, inode);
+	dbg_dump_stack();
+	err = -EINVAL;
+
+out_unlock:
+	mutex_unlock(&c->tnc_mutex);
+	return err;
+}
+
+#endif /* CONFIG_UBIFS_FS_DEBUG */
diff -ruaN linux-2.6.31/fs/ubifs/tnc_commit.c linux-2.6/fs/ubifs/tnc_commit.c
--- linux-2.6.31/fs/ubifs/tnc_commit.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/tnc_commit.c	2011-01-04 14:54:25.000000000 -0800
@@ -245,7 +245,7 @@
 	 * it is more comprehensive and less efficient than is needed for this
 	 * purpose.
 	 */
-	sleb = ubifs_scan(c, lnum, 0, c->ileb_buf);
+	sleb = ubifs_scan(c, lnum, 0, c->ileb_buf, 0);
 	c->ileb_len = 0;
 	if (IS_ERR(sleb))
 		return PTR_ERR(sleb);
diff -ruaN linux-2.6.31/fs/ubifs/ubifs.h linux-2.6/fs/ubifs/ubifs.h
--- linux-2.6.31/fs/ubifs/ubifs.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/ubifs.h	2011-01-04 14:54:25.000000000 -0800
@@ -105,12 +105,10 @@
 /* Number of non-data journal heads */
 #define NONDATA_JHEADS_CNT 2
 
-/* Garbage collector head */
-#define GCHD   0
-/* Base journal head number */
-#define BASEHD 1
-/* First "general purpose" journal head */
-#define DATAHD 2
+/* Shorter names for journal head numbers for internal usage */
+#define GCHD   UBIFS_GC_HEAD
+#define BASEHD UBIFS_BASE_HEAD
+#define DATAHD UBIFS_DATA_HEAD
 
 /* 'No change' value for 'ubifs_change_lp()' */
 #define LPROPS_NC 0x80000001
@@ -1451,7 +1449,7 @@
 
 /* scan.c */
 struct ubifs_scan_leb *ubifs_scan(const struct ubifs_info *c, int lnum,
-				  int offs, void *sbuf);
+				  int offs, void *sbuf, int quiet);
 void ubifs_scan_destroy(struct ubifs_scan_leb *sleb);
 int ubifs_scan_a_node(const struct ubifs_info *c, void *buf, int len, int lnum,
 		      int offs, int quiet);
@@ -1676,6 +1674,7 @@
 const struct ubifs_lprops *ubifs_fast_find_empty(struct ubifs_info *c);
 const struct ubifs_lprops *ubifs_fast_find_freeable(struct ubifs_info *c);
 const struct ubifs_lprops *ubifs_fast_find_frdi_idx(struct ubifs_info *c);
+int ubifs_calc_dark(const struct ubifs_info *c, int spc);
 
 /* file.c */
 int ubifs_fsync(struct file *file, struct dentry *dentry, int datasync);
diff -ruaN linux-2.6.31/fs/ubifs/ubifs-media.h linux-2.6/fs/ubifs/ubifs-media.h
--- linux-2.6.31/fs/ubifs/ubifs-media.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/ubifs-media.h	2011-01-04 14:54:25.000000000 -0800
@@ -135,6 +135,13 @@
 /* The key is always at the same position in all keyed nodes */
 #define UBIFS_KEY_OFFSET offsetof(struct ubifs_ino_node, key)
 
+/* Garbage collector journal head number */
+#define UBIFS_GC_HEAD   0
+/* Base journal head number */
+#define UBIFS_BASE_HEAD 1
+/* Data journal head number */
+#define UBIFS_DATA_HEAD 2
+
 /*
  * LEB Properties Tree node types.
  *
diff -ruaN linux-2.6.31/fs/ubifs/xattr.c linux-2.6/fs/ubifs/xattr.c
--- linux-2.6.31/fs/ubifs/xattr.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/fs/ubifs/xattr.c	2011-01-04 14:54:25.000000000 -0800
@@ -78,9 +78,9 @@
 	SECURITY_XATTR,
 };
 
-static struct inode_operations none_inode_operations;
+static const struct inode_operations none_inode_operations;
 static struct address_space_operations none_address_operations;
-static struct file_operations none_file_operations;
+static const struct file_operations none_file_operations;
 
 /**
  * create_xattr - create an extended attribute.
diff -ruaN linux-2.6.31/include/linux/compiler-gcc4.h linux-2.6/include/linux/compiler-gcc4.h
--- linux-2.6.31/include/linux/compiler-gcc4.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/compiler-gcc4.h	2011-01-04 13:50:21.000000000 -0800
@@ -3,11 +3,11 @@
 #endif
 
 /* GCC 4.1.[01] miscompiles __weak */
-#ifdef __KERNEL__
-# if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
-#  error Your version of gcc miscompiles the __weak directive
-# endif
+/* sesters: removed
+#if __GNUC_MINOR__ == 1 && __GNUC_PATCHLEVEL__ <= 1
+# error Your version of gcc miscompiles the __weak directive
 #endif
+*/
 
 #define __used			__attribute__((__used__))
 #define __must_check 		__attribute__((warn_unused_result))
diff -ruaN linux-2.6.31/include/linux/g2100.h linux-2.6/include/linux/g2100.h
--- linux-2.6.31/include/linux/g2100.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/g2100.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,11 @@
+#ifndef __G2100_H__
+#define __G2100_H__
+
+void g2100_reset(void);
+int g2100_request(unsigned int irq, irq_handler_t handler,
+	               unsigned long flags, const char *name, void *dev);
+void g2100_free(unsigned int, void *);
+void g2100_enable(unsigned int irq);
+irqreturn_t g2100_disable(unsigned int irq);
+
+#endif /* __G2100_H__ */
diff -ruaN linux-2.6.31/include/linux/Kbuild linux-2.6/include/linux/Kbuild
--- linux-2.6.31/include/linux/Kbuild	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/Kbuild	2011-01-04 13:50:21.000000000 -0800
@@ -3,6 +3,7 @@
 header-y += dvb/
 header-y += hdlc/
 header-y += isdn/
+header-y += lf1000/
 header-y += nfsd/
 header-y += raid/
 header-y += spi/
diff -ruaN linux-2.6.31/include/linux/lf1000/dpc_ioctl.h linux-2.6/include/linux/lf1000/dpc_ioctl.h
--- linux-2.6.31/include/linux/lf1000/dpc_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/dpc_ioctl.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,81 @@
+/* LF1000 Display Controller (DPC) Driver
+ *
+ * dpc_ioctl.h -- Supported ioctl commands.
+ *
+ * Andrey Yurovsky <andrey@cozybit.com> */
+
+#ifndef DPC_IOCTL_H
+#define DPC_IOCTL_H
+
+#define DPC_IOC_MAGIC	'd'
+
+struct hsync_cmd {
+	unsigned int avwidth;
+	unsigned int hsw, hfp, hbp;
+	unsigned char inv_hsync;
+};
+
+struct vsync_cmd {
+	unsigned int avheight;
+	unsigned int vsw, vfp, vbp;
+	unsigned char inv_vsync;
+	unsigned int eavheight;
+    unsigned int evsw, evfp, evbp;
+};
+
+struct mode_cmd {
+	unsigned char format;
+    unsigned char interlace;
+    unsigned char invert_field;
+    unsigned char rgb_mode;
+    unsigned char swap_rb;
+    unsigned char ycorder;
+    unsigned char clip_yc;
+    unsigned char embedded_sync;
+    unsigned char clock;
+    unsigned char inverted_clock;
+};
+
+struct clock0_cmd {
+	unsigned char source;
+	unsigned char div;
+	unsigned char delay;
+	unsigned char out_inv;
+	unsigned char out_en;
+};
+
+struct clock1_cmd {
+	unsigned char source;
+	unsigned char div;
+	unsigned char delay;
+	unsigned char out_inv;
+};
+
+union dpc_cmd {
+	struct hsync_cmd hsync;
+	struct vsync_cmd vsync;
+	struct clock0_cmd clock0; 
+	struct clock1_cmd clock1; 
+	struct mode_cmd mode;
+};
+
+
+/* supported ioctls */
+
+#define DPC_IOCTINTENB	_IOW(DPC_IOC_MAGIC, 0, unsigned int)
+#define DPC_IOCSHSYNC	_IOW(DPC_IOC_MAGIC, 1, struct hsync_cmd)
+#define DPC_IOCSVSYNC	_IOW(DPC_IOC_MAGIC, 2, struct vsync_cmd *)
+#define DPC_IOCSCLOCK0  _IOW(DPC_IOC_MAGIC, 3, struct clock0_cmd)
+#define DPC_IOCSCLOCK1  _IOW(DPC_IOC_MAGIC, 4, struct clock1_cmd *)
+#define DPC_IOCSMODE	_IOW(DPC_IOC_MAGIC, 5, struct mode_cmd *)
+#define DPC_IOCTSWAPRB	_IOW(DPC_IOC_MAGIC, 6, unsigned int)
+#define DPC_IOCTCONTRAST _IOW(DPC_IOC_MAGIC, 7, unsigned int)
+#define DPC_IOCTBRIGHTNESS _IOW(DPC_IOC_MAGIC, 8, unsigned int)
+#define DPC_IOCTBACKLIGHT _IOW(DPC_IOC_MAGIC, 10, unsigned int)
+#define DPC_IOCQBACKLIGHT _IOR(DPC_IOC_MAGIC, 11, unsigned int)
+#define DPC_IOCQBRIGHTNESS _IOR(DPC_IOC_MAGIC, 12, unsigned int)
+#define DPC_IOCQCONTRAST  _IOR(DPC_IOC_MAGIC, 13, unsigned int)
+#define DPC_IOCTBACKLIGHTVIRT _IOW(DPC_IOC_MAGIC, 14, int)
+#define DPC_IOCQBACKLIGHTVIRT _IOR(DPC_IOC_MAGIC, 15, int)
+
+#endif
diff -ruaN linux-2.6.31/include/linux/lf1000/gpio_ioctl.h linux-2.6/include/linux/lf1000/gpio_ioctl.h
--- linux-2.6.31/include/linux/lf1000/gpio_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/gpio_ioctl.h	2011-01-27 15:15:19.000000000 -0800
@@ -0,0 +1,62 @@
+#ifndef GPIO_IOCTL_H
+#define GPIO_IOCTL_H
+
+#define GPIO_IOC_MAGIC   'g'
+
+/* port can be 0 for A, 1 for B, 2 for C */
+struct outvalue_cmd {
+	unsigned char port;
+	unsigned int pin;
+	unsigned char value;
+};
+
+struct outenb_cmd {
+	unsigned char port;
+	unsigned int pin;
+	unsigned char value;
+};
+
+struct invalue_cmd {
+	unsigned char port;
+	unsigned int pin;
+	unsigned int value;
+};
+
+/* func can be 0 for gpio, 1 for alt1, or 2 for alt2 */
+struct func_cmd {
+	unsigned char port;
+	unsigned int pin;
+	unsigned int func;
+};
+
+union gpio_cmd {
+	struct outvalue_cmd outvalue;
+	struct outenb_cmd outenb;
+	struct invalue_cmd invalue;
+	struct func_cmd func;
+};
+
+/* supported ioctls */
+
+/* set pin output value */
+#define GPIO_IOCSOUTVAL		_IOW(GPIO_IOC_MAGIC,  0, struct outvalue_cmd *)
+/* set pin output enable */
+#define GPIO_IOCSOUTENB		_IOW(GPIO_IOC_MAGIC,  1, struct outenb_cmd *)
+/* get pin input value */
+#define GPIO_IOCXINVAL		_IOWR(GPIO_IOC_MAGIC, 2, struct invalue_cmd *)
+/* set pin function */
+#define GPIO_IOCSFUNC		_IOW(GPIO_IOC_MAGIC,  3, struct func_cmd *)
+/* get pin function */
+#define GPIO_IOCXFUNC		_IOWR(GPIO_IOC_MAGIC, 4, struct func_cmd *)
+/* set pin DRIVE */
+#define GPIO_IOCSDRIVE		_IOW(GPIO_IOC_MAGIC,  5, struct func_cmd *)
+/* get pin DRIVE */
+#define GPIO_IOCXDRIVE		_IOWR(GPIO_IOC_MAGIC, 6, struct func_cmd *)
+/* set pin PULLUP */
+#define GPIO_IOCSPULLUP		_IOW(GPIO_IOC_MAGIC,  7, struct func_cmd *)
+/* get pin DRIVE */
+#define GPIO_IOCXPULLUP		_IOWR(GPIO_IOC_MAGIC, 8, struct func_cmd *)
+/* get pin output enable */
+#define GPIO_IOCXOUTENB		_IOW(GPIO_IOC_MAGIC,  9, struct outenb_cmd *)
+
+#endif
diff -ruaN linux-2.6.31/include/linux/lf1000/Kbuild linux-2.6/include/linux/lf1000/Kbuild
--- linux-2.6.31/include/linux/lf1000/Kbuild	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/Kbuild	2011-01-04 14:54:30.000000000 -0800
@@ -0,0 +1,5 @@
+header-y += dpc_ioctl.h
+header-y += gpio_ioctl.h
+header-y += mlc_ioctl.h
+header-y += spi_ioctl.h
+header-y += lf1000fb.h
diff -ruaN linux-2.6.31/include/linux/lf1000/lf1000fb.h linux-2.6/include/linux/lf1000/lf1000fb.h
--- linux-2.6.31/include/linux/lf1000/lf1000fb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/lf1000fb.h	2011-01-04 15:05:02.000000000 -0800
@@ -0,0 +1,93 @@
+/* 
+ * Additional commands for the LF1000/Pollux frame buffer interface.
+ *
+ * Copyright (c) 2010 LeapFrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_LF1000_FB_H__
+#define __ASM_LF1000_FB_H__
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/* We use the nonstd field to pack in some layer information.  The contents
+ * need to be defined such that nothing unusual happens if nonstd is zero. */
+
+#define LF1000_NONSTD_PLANAR		23
+#define LF1000_NONSTD_PLANAR_MASK	1
+#define LF1000_NONSTD_PRIORITY		24
+#define LF1000_NONSTD_PRIORITY_MASK	0x3
+#define LF1000_NONSTD_FORMAT		20
+#define LF1000_NONSTD_FORMAT_MASK	0x7
+
+#define NONSTD_TO_PLANAR(x)	(((x) >> LF1000_NONSTD_PLANAR) & \
+				LF1000_NONSTD_PLANAR_MASK)
+
+#define NONSTD_TO_PFOR(x)       (((x) >> LF1000_NONSTD_FORMAT) & \
+				LF1000_NONSTD_FORMAT_MASK)
+#define NONSTD_TO_POS(x)        (((x) >> LF1000_NONSTD_PRIORITY) & \
+				LF1000_NONSTD_PRIORITY_MASK)
+
+enum {
+	LAYER_FORMAT_RGB        = 0,
+	LAYER_FORMAT_YUV420     = 1,
+	LAYER_FORMAT_YUV422     = 2,
+};
+
+/* lf1000fb_blend_cmd: get/set full-layer blending. */
+struct lf1000fb_blend_cmd {
+	unsigned char	enable;
+	unsigned char	alpha;
+};
+
+/* lf1000fb_position_cmd: get/set the location of the upper-left corner of the
+ * layer. */
+struct lf1000fb_position_cmd {
+	int		left;
+	int		top;
+	unsigned	apply : 1;	/* on set: apply right away */
+	int		right;
+	int		bottom;
+};
+
+/* lf1000fb_vidscale_cmd: get/set the origin size for the video scaler.  Only
+ * valid for the YUV layer. */
+struct lf1000fb_vidscale_cmd {
+	unsigned int	sizex;
+	unsigned int	sizey;
+	unsigned	apply : 1;	/* on set: apply right away */
+};
+
+union lf1000fb_cmd {
+	struct lf1000fb_blend_cmd	blend;
+	struct lf1000fb_position_cmd	position;
+	struct lf1000fb_vidscale_cmd	vidscale;
+};
+
+#define LF1000FB_IOCSALPHA	_IOW('m', 1, struct lf1000fb_alpha_cmd  *)
+#define LF1000FB_IOCGALPHA	_IOR('m', 2, struct lf1000fb_alpha_cmd  *)
+#define LF1000FB_IOCSPOSTION	_IOW('m', 3, struct lf1000fb_position_cmd *)
+#define LF1000FB_IOCGPOSTION	_IOR('m', 4, struct lf1000fb_position_cmd *)
+#define LF1000FB_IOCSVIDSCALE	_IOW('m', 5, struct lf1000fb_vidscale_cmd *)
+#define LF1000FB_IOCGVIDSCALE	_IOR('m', 6, struct lf1000fb_vidscale_cmd *)
+
+#ifndef FBIO_WAITFORVSYNC
+#define FBIO_WAITFORVSYNC	 _IOW('F', 0x20, __u32)
+#endif
+
+#endif /* __ASM_LF1000_FB_H__ */
diff -ruaN linux-2.6.31/include/linux/lf1000/mlc_ioctl.h linux-2.6/include/linux/lf1000/mlc_ioctl.h
--- linux-2.6.31/include/linux/lf1000/mlc_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/mlc_ioctl.h	2011-01-04 14:31:24.000000000 -0800
@@ -0,0 +1,78 @@
+#ifndef MLC_IOCTL_H
+#define MLC_IOCTL_H
+
+#define MLC_IOC_MAGIC   'm'
+
+struct position_cmd {
+	unsigned int top;
+   	unsigned int left;
+	unsigned int right;
+	unsigned int bottom;
+};
+
+struct screensize_cmd {
+	unsigned int width;
+	unsigned int height;
+};
+
+struct overlaysize_cmd {
+	unsigned int srcwidth;
+	unsigned int srcheight;
+	unsigned int dstwidth;
+	unsigned int dstheight;
+};
+
+union mlc_cmd {
+	struct position_cmd position;
+	struct screensize_cmd screensize;
+	struct overlaysize_cmd overlaysize;
+};
+
+/* supported ioctls */
+
+#define MLC_IOCTENABLE		_IO(MLC_IOC_MAGIC,  0)
+#define MLC_IOCTBACKGND		_IO(MLC_IOC_MAGIC,  1)
+#define MLC_IOCQBACKGND		_IO(MLC_IOC_MAGIC,  2)
+#define MLC_IOCTPRIORITY	_IO(MLC_IOC_MAGIC,  3)
+#define MLC_IOCQPRIORITY	_IO(MLC_IOC_MAGIC,  4)
+#define MLC_IOCTTOPDIRTY	_IO(MLC_IOC_MAGIC,  5)
+#define MLC_IOCSSCREENSIZE	_IOW(MLC_IOC_MAGIC, 6, struct screensize_cmd *)
+#define MLC_IOCGSCREENSIZE	_IOR(MLC_IOC_MAGIC, 7, struct screensize_cmd *)
+
+#define MLC_IOCTLAYEREN		_IO(MLC_IOC_MAGIC,  8)
+#define MLC_IOCTADDRESS		_IO(MLC_IOC_MAGIC,  9)
+#define MLC_IOCQADDRESS		_IO(MLC_IOC_MAGIC,  25)
+#define MLC_IOCTHSTRIDE		_IO(MLC_IOC_MAGIC,  10)
+#define MLC_IOCQHSTRIDE		_IO(MLC_IOC_MAGIC,  26)
+#define MLC_IOCTVSTRIDE		_IO(MLC_IOC_MAGIC,  11)
+#define MLC_IOCQVSTRIDE		_IO(MLC_IOC_MAGIC,  27)
+#define MLC_IOCTLOCKSIZE	_IO(MLC_IOC_MAGIC,  12)
+#define MLC_IOCSPOSITION	_IOW(MLC_IOC_MAGIC, 13, struct position_cmd *)
+#define MLC_IOCGPOSITION	_IOR(MLC_IOC_MAGIC, 14, struct position_cmd *)
+#define MLC_IOCTFORMAT		_IO(MLC_IOC_MAGIC,  15)
+#define MLC_IOCQFORMAT		_IO(MLC_IOC_MAGIC,  16)
+#define MLC_IOCTDIRTY		_IO(MLC_IOC_MAGIC,  17)
+#define MLC_IOCQDIRTY		_IO(MLC_IOC_MAGIC,  32)
+#define MLC_IOCT3DENB		_IO(MLC_IOC_MAGIC,  18)
+#define MLC_IOCQ3DENB		_IO(MLC_IOC_MAGIC,  33)
+#define MLC_IOCTALPHA		_IO(MLC_IOC_MAGIC,  19)
+#define MLC_IOCQALPHA		_IO(MLC_IOC_MAGIC,  28)
+#define MLC_IOCTTPCOLOR		_IO(MLC_IOC_MAGIC,  20)
+#define MLC_IOCTBLEND		_IO(MLC_IOC_MAGIC,  21)
+#define MLC_IOCTTRANSP		_IO(MLC_IOC_MAGIC,  22)
+#define MLC_IOCTINVERT		_IO(MLC_IOC_MAGIC,  23)
+#define MLC_IOCTINVCOLOR	_IO(MLC_IOC_MAGIC,  24)
+#define MLC_IOCQFBSIZE		_IO(MLC_IOC_MAGIC,  29)
+#define MLC_IOCSOVERLAYSIZE	_IOW(MLC_IOC_MAGIC, 30, struct overlaysize_cmd *)
+#define MLC_IOCGOVERLAYSIZE	_IOR(MLC_IOC_MAGIC, 31, struct overlaysize_cmd *)
+/* LF1000-only */
+#define MLC_IOCTINVISIBLE	_IO(MLC_IOC_MAGIC,  34)
+#define MLC_IOCQINVISIBLE	_IO(MLC_IOC_MAGIC,  35)
+#define MLC_IOCSINVISIBLEAREA	_IOW(MLC_IOC_MAGIC, 36, struct position_cmd *)
+#define MLC_IOCGINVISIBLEAREA	_IOR(MLC_IOC_MAGIC, 37, struct position_cmd *)
+
+#define MLC_IOCTADDRESSCB	_IO(MLC_IOC_MAGIC,  38)
+#define MLC_IOCTADDRESSCR	_IO(MLC_IOC_MAGIC,  39)
+
+#define MLC_IOCQLAYEREN		_IO(MLC_IOC_MAGIC,  40)
+#endif
diff -ruaN linux-2.6.31/include/linux/lf1000/spi_ioctl.h linux-2.6/include/linux/lf1000/spi_ioctl.h
--- linux-2.6.31/include/linux/lf1000/spi_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/lf1000/spi_ioctl.h	2011-01-04 13:50:21.000000000 -0800
@@ -0,0 +1,19 @@
+/*
+ * spi_ioctl.h
+ * SPI supported IOCTL calls
+ *
+ * Scott Esters
+ * LeapFrog Enterprises
+ */
+
+#ifndef SPI_IOCTL_H
+#define SPI_IOCTL_H
+
+#define SPI_IOC_MAGIC   'S'
+
+/* supported ioctls */
+#define SPI_IOCTQ_GETWORD	_IO(SPI_IOC_MAGIC,  1)	// get word
+
+#define SPI_IOC_MAXNR		1			// last IOCTL command
+
+#endif
diff -ruaN linux-2.6.31/include/linux/mmc/card.h linux-2.6/include/linux/mmc/card.h
--- linux-2.6.31/include/linux/mmc/card.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/card.h	2011-01-04 14:03:00.000000000 -0800
@@ -40,6 +40,8 @@
 };
 
 struct mmc_ext_csd {
+	u8			rev;
+	unsigned int		sa_timeout;		/* Units: 100ns */
 	unsigned int		hs_max_dtr;
 	unsigned int		sectors;
 };
@@ -62,7 +64,8 @@
 				low_speed:1,
 				wide_bus:1,
 				high_power:1,
-				high_speed:1;
+				high_speed:1,
+				disable_cd:1;
 };
 
 struct sdio_cis {
@@ -94,6 +97,8 @@
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
+	unsigned int		quirks; 	/* card quirks */
+#define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
@@ -129,6 +134,11 @@
 #define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
 
+static inline int mmc_card_lenient_fn0(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_LENIENT_FN0;
+}
+
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 
diff -ruaN linux-2.6.31/include/linux/mmc/core.h linux-2.6/include/linux/mmc/core.h
--- linux-2.6.31/include/linux/mmc/core.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/core.h	2011-01-04 14:03:00.000000000 -0800
@@ -139,6 +139,7 @@
 
 extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
 extern void mmc_release_host(struct mmc_host *host);
+extern int mmc_try_claim_host(struct mmc_host *host);
 
 /**
  *	mmc_claim_host - exclusively claim a host
diff -ruaN linux-2.6.31/include/linux/mmc/host.h linux-2.6/include/linux/mmc/host.h
--- linux-2.6.31/include/linux/mmc/host.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/host.h	2011-01-04 14:03:00.000000000 -0800
@@ -11,6 +11,7 @@
 #define LINUX_MMC_HOST_H
 
 #include <linux/leds.h>
+#include <linux/sched.h>
 
 #include <linux/mmc/core.h>
 
@@ -51,6 +52,35 @@
 };
 
 struct mmc_host_ops {
+	/*
+	 * Hosts that support power saving can use the 'enable' and 'disable'
+	 * methods to exit and enter power saving states. 'enable' is called
+	 * when the host is claimed and 'disable' is called (or scheduled with
+	 * a delay) when the host is released. The 'disable' is scheduled if
+	 * the disable delay set by 'mmc_set_disable_delay()' is non-zero,
+	 * otherwise 'disable' is called immediately. 'disable' may be
+	 * scheduled repeatedly, to permit ever greater power saving at the
+	 * expense of ever greater latency to re-enable. Rescheduling is
+	 * determined by the return value of the 'disable' method. A positive
+	 * value gives the delay in milliseconds.
+	 *
+	 * In the case where a host function (like set_ios) may be called
+	 * with or without the host claimed, enabling and disabling can be
+	 * done directly and will nest correctly. Call 'mmc_host_enable()' and
+	 * 'mmc_host_lazy_disable()' for this purpose, but note that these
+	 * functions must be paired.
+	 *
+	 * Alternatively, 'mmc_host_enable()' may be paired with
+	 * 'mmc_host_disable()' which calls 'disable' immediately.  In this
+	 * case the 'disable' method will be called with 'lazy' set to 0.
+	 * This is mainly useful for error paths.
+	 *
+	 * Because lazy disable may be called from a work queue, the 'disable'
+	 * method must claim the host when 'lazy' != 0, which will work
+	 * correctly because recursion is detected and handled.
+	 */
+	int (*enable)(struct mmc_host *host);
+	int (*disable)(struct mmc_host *host, int lazy);
 	void	(*request)(struct mmc_host *host, struct mmc_request *req);
 	/*
 	 * Avoid calling these three functions too often or in a "fast path",
@@ -118,6 +148,9 @@
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
 #define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
+#define MMC_CAP_DISABLE		(1 << 7)	/* Can the host be disabled */
+#define MMC_CAP_NONREMOVABLE	(1 << 8)	/* Nonremovable e.g. eMMC */
+#define MMC_CAP_WAIT_WHILE_BUSY	(1 << 9)	/* Waits while card is busy */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -142,9 +175,18 @@
 	unsigned int		removed:1;	/* host is being removed */
 #endif
 
+	/* Only used with MMC_CAP_DISABLE */
+	int			enabled;	/* host is enabled */
+	int			nesting_cnt;	/* "enable" nesting count */
+	int			en_dis_recurs;	/* detect recursion */
+	unsigned int		disable_delay;	/* disable delay in msecs */
+	struct delayed_work	disable;	/* disabling work */
+
 	struct mmc_card		*card;		/* device attached to this host */
 
 	wait_queue_head_t	wq;
+	struct task_struct	*claimer;	/* task that has host claimed */
+	int			claim_cnt;	/* "claim" nesting count */
 
 	struct delayed_work	detect;
 
@@ -183,6 +225,9 @@
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
 
+extern void mmc_power_save_host(struct mmc_host *host);
+extern void mmc_power_restore_host(struct mmc_host *host);
+
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
@@ -197,5 +242,19 @@
 int mmc_regulator_get_ocrmask(struct regulator *supply);
 int mmc_regulator_set_ocr(struct regulator *supply, unsigned short vdd_bit);
 
+int mmc_card_awake(struct mmc_host *host);
+int mmc_card_sleep(struct mmc_host *host);
+int mmc_card_can_sleep(struct mmc_host *host);
+
+int mmc_host_enable(struct mmc_host *host);
+int mmc_host_disable(struct mmc_host *host);
+int mmc_host_lazy_disable(struct mmc_host *host);
+
+static inline void mmc_set_disable_delay(struct mmc_host *host,
+					 unsigned int disable_delay)
+{
+	host->disable_delay = disable_delay;
+}
+
 #endif
 
diff -ruaN linux-2.6.31/include/linux/mmc/mmc.h linux-2.6/include/linux/mmc/mmc.h
--- linux-2.6.31/include/linux/mmc/mmc.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/mmc.h	2011-01-04 14:03:00.000000000 -0800
@@ -31,6 +31,7 @@
 #define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
 #define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
 #define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
+#define MMC_SLEEP_AWAKE		  5   /* ac   [31:16] RCA 15:flg R1b */
 #define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
 #define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
 #define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
@@ -127,6 +128,7 @@
 #define R1_STATUS(x)            (x & 0xFFFFE000)
 #define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
+#define R1_SWITCH_ERROR		(1 << 7)	/* sx, c */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
 /*
@@ -254,6 +256,7 @@
 #define EXT_CSD_CARD_TYPE	196	/* RO */
 #define EXT_CSD_REV		192	/* RO */
 #define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
+#define EXT_CSD_S_A_TIMEOUT	217
 
 /*
  * EXT_CSD field definitions
diff -ruaN linux-2.6.31/include/linux/mmc/sdio_func.h linux-2.6/include/linux/mmc/sdio_func.h
--- linux-2.6.31/include/linux/mmc/sdio_func.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/sdio_func.h	2011-01-04 14:03:00.000000000 -0800
@@ -67,6 +67,7 @@
 
 #define sdio_get_drvdata(f)	dev_get_drvdata(&(f)->dev)
 #define sdio_set_drvdata(f,d)	dev_set_drvdata(&(f)->dev, d)
+#define dev_to_sdio_func(d)	container_of(d, struct sdio_func, dev)
 
 /*
  * SDIO function device driver
@@ -81,6 +82,8 @@
 	struct device_driver drv;
 };
 
+#define to_sdio_driver(d)	container_of(d, struct sdio_driver, drv)
+
 /**
  * SDIO_DEVICE - macro used to describe a specific SDIO device
  * @vend: the 16 bit manufacturer code
diff -ruaN linux-2.6.31/include/linux/mmc/sdio_ids.h linux-2.6/include/linux/mmc/sdio_ids.h
--- linux-2.6.31/include/linux/mmc/sdio_ids.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mmc/sdio_ids.h	2011-01-04 14:03:00.000000000 -0800
@@ -22,6 +22,13 @@
 /*
  * Vendors and devices.  Sort key: vendor first, device next.
  */
+#define SDIO_VENDOR_ID_INTEL			0x0089
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIFI	0x1403
+#define SDIO_DEVICE_ID_INTEL_IWMC3200TOP	0x1404
+#define SDIO_DEVICE_ID_INTEL_IWMC3200GPS	0x1405
+#define SDIO_DEVICE_ID_INTEL_IWMC3200BT		0x1406
+#define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX_2G5	0x1407
 
 #define SDIO_VENDOR_ID_MARVELL			0x02df
 #define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
diff -ruaN linux-2.6.31/include/linux/mmc/sm2683lt_ioctl.h linux-2.6/include/linux/mmc/sm2683lt_ioctl.h
--- linux-2.6.31/include/linux/mmc/sm2683lt_ioctl.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/mmc/sm2683lt_ioctl.h	2011-02-04 12:25:28.000000000 -0800
@@ -0,0 +1,92 @@
+#ifndef SM2683LT_IOCTL_H
+#define SM2683LT_IOCTL_H
+
+#include <asm/types.h>
+/*
+ * User-space can't include linux/mmc/core.h, so define a simple command
+ * struct that can be used to populate the real struct mmc_command
+ */
+
+#define SM2683LT_IOC_MAGIC   's'
+
+struct sd_command {
+	__u32		opcode;
+	__u32		arg;
+	__u32		resp[4];
+	unsigned int	flags;	/* expected response type */
+
+#ifndef __KERNEL__
+#define MMC_RSP_PRESENT (1 << 0)
+#define MMC_RSP_136     (1 << 1)                /* 136 bit response */
+#define MMC_RSP_CRC     (1 << 2)                /* expect valid crc */
+#define MMC_RSP_BUSY    (1 << 3)                /* card may send busy */
+#define MMC_RSP_OPCODE  (1 << 4)                /* response contains opcode */
+
+#define MMC_CMD_MASK    (3 << 5)                /* non-SPI command type */
+#define MMC_CMD_AC      (0 << 5)
+#define MMC_CMD_ADTC    (1 << 5)
+#define MMC_CMD_BC      (2 << 5)
+#define MMC_CMD_BCR     (3 << 5)
+
+#define MMC_RSP_SPI_S1  (1 << 7)                /* one status byte */
+#define MMC_RSP_SPI_S2  (1 << 8)                /* second byte */
+#define MMC_RSP_SPI_B4  (1 << 9)                /* four data bytes */
+#define MMC_RSP_SPI_BUSY (1 << 10)              /* card may send busy */
+
+/*
+ * These are the native response types, and correspond to valid bit
+ * patterns of the above flags.  One additional valid pattern
+ * is all zeros, which means we don't expect a response.
+ */
+#define MMC_RSP_NONE    (0)
+#define MMC_RSP_R1      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1B     (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
+#define MMC_RSP_R2      (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3      (MMC_RSP_PRESENT)
+#define MMC_RSP_R4      (MMC_RSP_PRESENT)
+#define MMC_RSP_R5      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7      (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+
+#define mmc_resp_type(cmd)      ((cmd)->flags & (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC|MMC_RSP_BUSY|MMC_RSP_OPCODE))
+/*
+ * These are the SPI response types for MMC, SD, and SDIO cards.
+ * Commands return R1, with maybe more info.  Zero is an error type;
+ * callers must always provide the appropriate MMC_RSP_SPI_Rx flags.
+ */
+#define MMC_RSP_SPI_R1  (MMC_RSP_SPI_S1)
+#define MMC_RSP_SPI_R1B (MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY)
+#define MMC_RSP_SPI_R2  (MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
+#define MMC_RSP_SPI_R3  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
+#define MMC_RSP_SPI_R4  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
+#define MMC_RSP_SPI_R5  (MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
+#define MMC_RSP_SPI_R7  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
+
+#define mmc_spi_resp_type(cmd)  ((cmd)->flags & \
+                (MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY|MMC_RSP_SPI_S2|MMC_RSP_SPI_B4))
+
+/*
+ * These are the command types.
+ */
+#define mmc_cmd_type(cmd)       ((cmd)->flags & MMC_CMD_MASK)
+
+#endif /* __KERNEL__ */
+
+	unsigned int	retries;
+	unsigned int	error;
+
+	/* not present in mmc_command - for data xfer */
+	union
+	{
+	void *		read_data;
+	const void *	write_data;
+	} data;
+	int		data_len;
+};
+
+/* supported ioctls */
+
+#define SM2683LT_SD_COMMAND	_IOWR(SM2683LT_IOC_MAGIC,  0, struct sd_command *)	// SD command pass-through
+#define SM2683LT_SET_POWER	_IOW(SM2683LT_IOC_MAGIC,  1, int)	// Cut clock / tri-state bus / cut power
+
+#endif /* SM2683LT_IOCTL_H */
diff -ruaN linux-2.6.31/include/linux/mtd/ubi.h linux-2.6/include/linux/mtd/ubi.h
--- linux-2.6.31/include/linux/mtd/ubi.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/mtd/ubi.h	2011-01-04 14:54:25.000000000 -0800
@@ -174,6 +174,8 @@
 struct ubi_volume_desc *ubi_open_volume(int ubi_num, int vol_id, int mode);
 struct ubi_volume_desc *ubi_open_volume_nm(int ubi_num, const char *name,
 					   int mode);
+struct ubi_volume_desc *ubi_open_volume_path(const char *pathname, int mode);
+
 int ubi_register_volume_notifier(struct notifier_block *nb,
 				 int ignore_existing);
 int ubi_unregister_volume_notifier(struct notifier_block *nb);
diff -ruaN linux-2.6.31/include/linux/spi/libertas_spi.h linux-2.6/include/linux/spi/libertas_spi.h
--- linux-2.6.31/include/linux/spi/libertas_spi.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/spi/libertas_spi.h	2011-01-04 13:50:21.000000000 -0800
@@ -22,6 +22,9 @@
 	 * speed, you may want to use 0 here. */
 	u16 use_dummy_writes;
 
+	/* GPIO number to use as chip select */
+	u16 gpio_cs;
+
 	/* Board specific setup/teardown */
 	int (*setup)(struct spi_device *spi);
 	int (*teardown)(struct spi_device *spi);
diff -ruaN linux-2.6.31/include/linux/usb/gadget.h linux-2.6/include/linux/usb/gadget.h
--- linux-2.6.31/include/linux/usb/gadget.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/linux/usb/gadget.h	2011-01-04 13:50:21.000000000 -0800
@@ -778,6 +778,10 @@
 
 	/* FIXME support safe rmmod */
 	struct device_driver	driver;
+	/* These functions are here for supporting obscure features required by
+	 * leapfrog. */
+	void			(*vbus_session)(struct usb_gadget *, int is_active);
+	int			(*is_enabled)(struct usb_gadget *);
 };
 
 
@@ -817,7 +821,12 @@
  * finally returns.  It's expected that the unbind() functions
  * will in in exit sections, so may not be linked in some kernels.
  */
-int usb_gadget_unregister_driver(struct usb_gadget_driver *driver);
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver);
+
+/**
+ * Obscure feature required by leapfrog
+ */
+void usb_gadget_watchdog_cancel(void);
 
 /*-------------------------------------------------------------------------*/
 
diff -ruaN linux-2.6.31/include/linux/usb/video.h linux-2.6/include/linux/usb/video.h
--- linux-2.6.31/include/linux/usb/video.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/include/linux/usb/video.h	2011-01-04 14:35:10.000000000 -0800
@@ -0,0 +1,164 @@
+/*
+ * USB Video Class definitions.
+ *
+ * Copyright (C) 2009 Laurent Pinchart <laurent.pinchart@skynet.be>
+ *
+ * This file holds USB constants and structures defined by the USB Device
+ * Class Definition for Video Devices. Unless otherwise stated, comments
+ * below reference relevant sections of the USB Video Class 1.1 specification
+ * available at
+ *
+ * http://www.usb.org/developers/devclass_docs/USB_Video_Class_1_1.zip
+ */
+
+#ifndef __LINUX_USB_VIDEO_H
+#define __LINUX_USB_VIDEO_H
+
+#include <linux/types.h>
+
+/* --------------------------------------------------------------------------
+ * UVC constants
+ */
+
+/* A.2. Video Interface Subclass Codes */
+#define UVC_SC_UNDEFINED				0x00
+#define UVC_SC_VIDEOCONTROL				0x01
+#define UVC_SC_VIDEOSTREAMING				0x02
+#define UVC_SC_VIDEO_INTERFACE_COLLECTION		0x03
+
+/* A.3. Video Interface Protocol Codes */
+#define UVC_PC_PROTOCOL_UNDEFINED			0x00
+
+/* A.5. Video Class-Specific VC Interface Descriptor Subtypes */
+#define UVC_VC_DESCRIPTOR_UNDEFINED			0x00
+#define UVC_VC_HEADER					0x01
+#define UVC_VC_INPUT_TERMINAL				0x02
+#define UVC_VC_OUTPUT_TERMINAL				0x03
+#define UVC_VC_SELECTOR_UNIT				0x04
+#define UVC_VC_PROCESSING_UNIT				0x05
+#define UVC_VC_EXTENSION_UNIT				0x06
+
+/* A.6. Video Class-Specific VS Interface Descriptor Subtypes */
+#define UVC_VS_UNDEFINED				0x00
+#define UVC_VS_INPUT_HEADER				0x01
+#define UVC_VS_OUTPUT_HEADER				0x02
+#define UVC_VS_STILL_IMAGE_FRAME			0x03
+#define UVC_VS_FORMAT_UNCOMPRESSED			0x04
+#define UVC_VS_FRAME_UNCOMPRESSED			0x05
+#define UVC_VS_FORMAT_MJPEG				0x06
+#define UVC_VS_FRAME_MJPEG				0x07
+#define UVC_VS_FORMAT_MPEG2TS				0x0a
+#define UVC_VS_FORMAT_DV				0x0c
+#define UVC_VS_COLORFORMAT				0x0d
+#define UVC_VS_FORMAT_FRAME_BASED			0x10
+#define UVC_VS_FRAME_FRAME_BASED			0x11
+#define UVC_VS_FORMAT_STREAM_BASED			0x12
+
+/* A.7. Video Class-Specific Endpoint Descriptor Subtypes */
+#define UVC_EP_UNDEFINED				0x00
+#define UVC_EP_GENERAL					0x01
+#define UVC_EP_ENDPOINT					0x02
+#define UVC_EP_INTERRUPT				0x03
+
+/* A.8. Video Class-Specific Request Codes */
+#define UVC_RC_UNDEFINED				0x00
+#define UVC_SET_CUR					0x01
+#define UVC_GET_CUR					0x81
+#define UVC_GET_MIN					0x82
+#define UVC_GET_MAX					0x83
+#define UVC_GET_RES					0x84
+#define UVC_GET_LEN					0x85
+#define UVC_GET_INFO					0x86
+#define UVC_GET_DEF					0x87
+
+/* A.9.1. VideoControl Interface Control Selectors */
+#define UVC_VC_CONTROL_UNDEFINED			0x00
+#define UVC_VC_VIDEO_POWER_MODE_CONTROL			0x01
+#define UVC_VC_REQUEST_ERROR_CODE_CONTROL		0x02
+
+/* A.9.2. Terminal Control Selectors */
+#define UVC_TE_CONTROL_UNDEFINED			0x00
+
+/* A.9.3. Selector Unit Control Selectors */
+#define UVC_SU_CONTROL_UNDEFINED			0x00
+#define UVC_SU_INPUT_SELECT_CONTROL			0x01
+
+/* A.9.4. Camera Terminal Control Selectors */
+#define UVC_CT_CONTROL_UNDEFINED			0x00
+#define UVC_CT_SCANNING_MODE_CONTROL			0x01
+#define UVC_CT_AE_MODE_CONTROL				0x02
+#define UVC_CT_AE_PRIORITY_CONTROL			0x03
+#define UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL		0x04
+#define UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL		0x05
+#define UVC_CT_FOCUS_ABSOLUTE_CONTROL			0x06
+#define UVC_CT_FOCUS_RELATIVE_CONTROL			0x07
+#define UVC_CT_FOCUS_AUTO_CONTROL			0x08
+#define UVC_CT_IRIS_ABSOLUTE_CONTROL			0x09
+#define UVC_CT_IRIS_RELATIVE_CONTROL			0x0a
+#define UVC_CT_ZOOM_ABSOLUTE_CONTROL			0x0b
+#define UVC_CT_ZOOM_RELATIVE_CONTROL			0x0c
+#define UVC_CT_PANTILT_ABSOLUTE_CONTROL			0x0d
+#define UVC_CT_PANTILT_RELATIVE_CONTROL			0x0e
+#define UVC_CT_ROLL_ABSOLUTE_CONTROL			0x0f
+#define UVC_CT_ROLL_RELATIVE_CONTROL			0x10
+#define UVC_CT_PRIVACY_CONTROL				0x11
+
+/* A.9.5. Processing Unit Control Selectors */
+#define UVC_PU_CONTROL_UNDEFINED			0x00
+#define UVC_PU_BACKLIGHT_COMPENSATION_CONTROL		0x01
+#define UVC_PU_BRIGHTNESS_CONTROL			0x02
+#define UVC_PU_CONTRAST_CONTROL				0x03
+#define UVC_PU_GAIN_CONTROL				0x04
+#define UVC_PU_POWER_LINE_FREQUENCY_CONTROL		0x05
+#define UVC_PU_HUE_CONTROL				0x06
+#define UVC_PU_SATURATION_CONTROL			0x07
+#define UVC_PU_SHARPNESS_CONTROL			0x08
+#define UVC_PU_GAMMA_CONTROL				0x09
+#define UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL	0x0a
+#define UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL	0x0b
+#define UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL		0x0c
+#define UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL	0x0d
+#define UVC_PU_DIGITAL_MULTIPLIER_CONTROL		0x0e
+#define UVC_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL		0x0f
+#define UVC_PU_HUE_AUTO_CONTROL				0x10
+#define UVC_PU_ANALOG_VIDEO_STANDARD_CONTROL		0x11
+#define UVC_PU_ANALOG_LOCK_STATUS_CONTROL		0x12
+
+/* A.9.7. VideoStreaming Interface Control Selectors */
+#define UVC_VS_CONTROL_UNDEFINED			0x00
+#define UVC_VS_PROBE_CONTROL				0x01
+#define UVC_VS_COMMIT_CONTROL				0x02
+#define UVC_VS_STILL_PROBE_CONTROL			0x03
+#define UVC_VS_STILL_COMMIT_CONTROL			0x04
+#define UVC_VS_STILL_IMAGE_TRIGGER_CONTROL		0x05
+#define UVC_VS_STREAM_ERROR_CODE_CONTROL		0x06
+#define UVC_VS_GENERATE_KEY_FRAME_CONTROL		0x07
+#define UVC_VS_UPDATE_FRAME_SEGMENT_CONTROL		0x08
+#define UVC_VS_SYNC_DELAY_CONTROL			0x09
+
+/* B.1. USB Terminal Types */
+#define UVC_TT_VENDOR_SPECIFIC				0x0100
+#define UVC_TT_STREAMING				0x0101
+
+/* B.2. Input Terminal Types */
+#define UVC_ITT_VENDOR_SPECIFIC				0x0200
+#define UVC_ITT_CAMERA					0x0201
+#define UVC_ITT_MEDIA_TRANSPORT_INPUT			0x0202
+
+/* B.3. Output Terminal Types */
+#define UVC_OTT_VENDOR_SPECIFIC				0x0300
+#define UVC_OTT_DISPLAY					0x0301
+#define UVC_OTT_MEDIA_TRANSPORT_OUTPUT			0x0302
+
+/* B.4. External Terminal Types */
+#define UVC_EXTERNAL_VENDOR_SPECIFIC			0x0400
+#define UVC_COMPOSITE_CONNECTOR				0x0401
+#define UVC_SVIDEO_CONNECTOR				0x0402
+#define UVC_COMPONENT_CONNECTOR				0x0403
+
+/* 2.4.2.2. Status Packet Type */
+#define UVC_STATUS_TYPE_CONTROL				1
+#define UVC_STATUS_TYPE_STREAMING			2
+
+#endif /* __LINUX_USB_VIDEO_H */
+
diff -ruaN linux-2.6.31/include/mtd/mtd-abi.h linux-2.6/include/mtd/mtd-abi.h
--- linux-2.6.31/include/mtd/mtd-abi.h	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/include/mtd/mtd-abi.h	2011-01-04 13:50:21.000000000 -0800
@@ -110,7 +110,9 @@
 #define MEMERASE64		_IOW('M', 20, struct erase_info_user64)
 #define MEMWRITEOOB64		_IOWR('M', 21, struct mtd_oob_buf64)
 #define MEMREADOOB64		_IOWR('M', 22, struct mtd_oob_buf64)
-
+#define BBTERASE		_IO('M', 23)
+#define BBTSCAN			_IO('M', 24)
+#define SDOTPPREP		_IO('M', 25)
 /*
  * Obsolete legacy interface. Keep it in order not to break userspace
  * interfaces
diff -ruaN linux-2.6.31/init/calibrate.c linux-2.6/init/calibrate.c
--- linux-2.6.31/init/calibrate.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/init/calibrate.c	2011-03-15 17:35:54.000000000 -0700
@@ -9,6 +9,7 @@
 #include <linux/init.h>
 #include <linux/timex.h>
 #include <linux/smp.h>
+#include <mach/platform.h>
 
 unsigned long lpj_fine;
 unsigned long preset_lpj;
@@ -124,6 +125,9 @@
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
 
+#ifdef CONFIG_ARCH_LF1000
+	preset_lpj = get_pll_freq(CPU_PLL)/100;
+#endif
 	if (preset_lpj) {
 		loops_per_jiffy = preset_lpj;
 		printk(KERN_INFO
diff -ruaN linux-2.6.31/init/main.c linux-2.6/init/main.c
--- linux-2.6.31/init/main.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/init/main.c	2011-01-04 13:50:21.000000000 -0800
@@ -82,6 +82,8 @@
 
 static int kernel_init(void *);
 
+extern void printascii(char *);
+
 extern void init_IRQ(void);
 extern void fork_init(unsigned long);
 extern void mca_init(void);
@@ -552,6 +554,7 @@
 	char * command_line;
 	extern struct kernel_param __start___param[], __stop___param[];
 
+	printascii("\r");
 	smp_setup_processor_id();
 
 	/*
diff -ruaN linux-2.6.31/install.sh linux-2.6/install.sh
--- linux-2.6.31/install.sh	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/install.sh	2012-11-19 20:59:56.000000000 -0800
@@ -0,0 +1,88 @@
+#!/bin/bash
+
+# check if we can use sparse
+which sparse > /dev/null
+if [ "$?" = "0" ]; then
+	SPARSE_CHECK="C=1"
+else
+	echo "**** WARNING: you do not have sparse installed"
+	echo "**** run: \"sudo apt-get install sparse\" to install it"
+	echo ""
+	SPARSE_CHECK=""
+fi
+
+# count number of CPUs for make
+
+if [ -z "$CPUS" ]
+then
+  export CPUS=$[$(echo /sys/devices/system/cpu/cpu[0-9]* | wc -w)+0]
+  [ "$CPUS" -lt 1 ] && CPUS=1
+fi
+
+set -e
+
+. $PROJECT_PATH/scripts/functions
+
+# make sure all of the environment variables are good
+check_vars
+
+# exit if the user is root
+check_user
+
+# parse args
+set_standard_opts $*
+
+pushd $PROJECT_PATH/linux-2.6/
+
+# check for .config.  Use defconfig if it's not there.
+if [ ! -e ".config" ]; then
+	if  [ "$TARGET_MACH" == "LF_TS_LF1000" ]; then
+		echo "*** Using default LF1000 form factor Board with touchscreen configuration."
+		make -j $CPUS lf1000_ts_defconfig
+	else
+		echo "Unsupported machine 'TARGET_MACH=$TARGET_MACH', expected one of the following:"
+		echo "   LF_TS_LF1000        -- Normal Form Factor board with Touchscreen"
+		exit 1
+	fi
+fi
+
+# Apply patches; -N ignore already applied, -r - don't make rejects file
+set +e
+patch -r - -p0 -N < default-log-level.patch &> /dev/null
+set -e
+
+make $SPARSE_CHECK -j $CPUS zImage
+cp arch/arm/boot/zImage $TFTP_PATH
+
+MODS=`grep CONFIG_MODULES include/config/auto.conf`
+if [ "$MODS" != "" ]; then
+	make -j $CPUS modules
+	echo INSTALL_MOD_PATH=$ROOTFS_PATH
+	make -j $CPUS modules_install INSTALL_MOD_PATH=$ROOTFS_PATH
+fi
+
+# create linux headers
+make headers_install ARCH=arm INSTALL_HDR_PATH=$ROOTFS_PATH/usr
+
+if [ $EMBEDDED -eq 0 ]; then
+	cp vmlinux $ROOTFS_PATH
+fi
+
+popd
+
+#### Don't do most device node creation now ###
+#### See /etc/init.d/rcS and /usr/bin/make_device_nodes.sh; 
+#### We do most of this at run time now.  
+#### Exception is /dev/console, which init wants to grab before rcS runs, so
+#### if we want to watch it boot, we'll have to have a /dev/console before
+#### /dev is mounted
+mkdir -p $ROOTFS_PATH/dev
+pushd $ROOTFS_PATH/dev
+rm -f ttyS0
+sudo mknod -m 600 ttyS0 c 4 64
+ln -sf ttyS0 console
+popd
+
+# stash copies of this build
+echo "Saving build specific copy as $TFTP_PATH/zImage.ff_bd"
+cp $TFTP_PATH/zImage $TFTP_PATH/zImage.ff_bd
diff -ruaN linux-2.6.31/kernel/panic.c linux-2.6/kernel/panic.c
--- linux-2.6.31/kernel/panic.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/kernel/panic.c	2011-01-04 13:50:21.000000000 -0800
@@ -29,7 +29,7 @@
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+int panic_timeout = 1;
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
 
@@ -74,6 +74,14 @@
 	dump_stack();
 #endif
 
+	/* Bump panic counter */
+	extern int gpio_get_panic_config();
+	extern void gpio_set_panic_config(int value);
+	i = 1 + gpio_get_panic_config();
+	if (i > 3)
+		i = 3;
+	gpio_set_panic_config(i);
+
 	/*
 	 * If we have crashed and we have a crash kernel loaded let it handle
 	 * everything else.
diff -ruaN linux-2.6.31/kernel/printk.c linux-2.6/kernel/printk.c
--- linux-2.6.31/kernel/printk.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/kernel/printk.c	2011-01-04 14:19:30.000000000 -0800
@@ -36,6 +36,8 @@
 
 #include <asm/uaccess.h>
 
+extern void printascii(char *);
+
 /*
  * Architectures can override it:
  */
@@ -50,7 +52,7 @@
 
 /* We show everything that is MORE important than this.. */
 #define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
-#define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */
+#define DEFAULT_CONSOLE_LOGLEVEL 2 /* anything MORE serious than KERN_DEBUG */
 
 DECLARE_WAIT_QUEUE_HEAD(log_wait);
 
@@ -640,6 +642,7 @@
 static int new_text_line = 1;
 static char printk_buf[1024];
 
+
 asmlinkage int vprintk(const char *fmt, va_list args)
 {
 	int printed_len = 0;
@@ -686,6 +689,8 @@
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
 
+	/* enable when debugging Linux boot code */
+	//printascii(printk_buf);
 
 	p = printk_buf;
 
diff -ruaN linux-2.6.31/latency-timing-hacks.tar.gz linux-2.6/latency-timing-hacks.tar.gz
--- linux-2.6.31/latency-timing-hacks.tar.gz	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/latency-timing-hacks.tar.gz	2011-01-04 13:57:43.000000000 -0800
@@ -0,0 +1,40 @@
+ dK <kw6*
+=Pl=Y+NW[_$5~gS,ow$03 f k=EvagV/kORof/W>_v_(g+=]fm}@$
+M=s.#8{xwv
+[|{6X|.|{3w/}[p5{qboj-!-9@}
+#0mSs&i`V^Le>l$86`+mkqhm!7[v]	'mE&D1Fj6#p>Wc	*2Q~cZ5?7.Bcu,a*0qI,sdkf-t&xpbwkm:jcD,lN>bn P?ms6!g0l; 5=pfw LX9)rq.lzpywa(Pu@k2LH`X|jWzRygh;~nn{ys1:%WjKc)6Bh:liT+XP:t26SzCW3vpg`xm(`JbGcWd<>,(J\_;{	yaD"xMzICl1U-Z6Tp~Rsq/+a`P"$8k~MV#S 15vlicqQ>I+pI/{:n=@PWzwJhH4EBOObDnq"1N_^@?.K1BbBil4,@/2C&s4JM|9n"HT iHKJ	..6Ap
+DBMKIsnX7yCGPz4r>l5C#x^i? E_^1{$V	WyK]:l$dR>g2@OhQS<'O:9{Epsc}Zyx0KnC41BHg~'Jd/2k(3js="\"i%&\k i>eWWn]HAKI+_98t#qq:mo.%VDCST|B?aa- ]=Mu5,Vs)nH<f:H4id"66 gA<>uI5;foYJ7p}^P*0@H"6jMj4%w- IGI5[yPW	_NCpz{*Cc,y]gY`!q|4a M[
+.EOh*S%(*XauE[z[a?pE>VD{A?rjc!x9;cn%mB!FVOc!{5JV\p@=4X2de5@'}A>(XB& m\`q'*IdI*]L<7VMF83+T`;jj>fr7QczX#wL()tiHcf>{djqfK>A<Rm3P!p''"T`WE7]`oYi;%v9Y`,yph4Yj1i3jH,qIn-IiiXiQS swA+2-J1buhqGuo{kGR'wV	r(:k)_LD<\]&)C}yiN!|Yw( \9dbWEan.A<R4wLa/<l'7!l@035't$
+T/8L&T?GVj:b#p2HD4'HhKhvP`4W/zeZ~N$M"<Q
+s*]+*N{jsRDD3c[P~~=N =	V}4B)lR EEZiul'QtAd{dCB9yRYV=''6"\bw~bx
+}2k(^Y>uC +S1SZ9"@C<0Ur*:d@_g pM /&Ux^""$$PQ|rngQtjUBd2jVW*Z 32a	>k^Gdav9|(e[	BMt"L$ca:DeiB1sbXEYy QXV-ke)MXsr,zLVkFf<s,y'XtNW;j\`3S8eJDK'srpKCDk%p44FM:R}>eZ*_0;c>{{w#ox-{/_rw%VSR^IDIbHL7{:}4e*ml:SN+rh7j	+^ENDEX3=pGh9"=G10<b"p?(hj ;D8@cI.w9\;%M4;Y.(L"1%1i>)SYwrbOh^nIKp#N"f%yM/5l}J+|e;eJ2|rX\*BEX&wNk:
+Fj<|eaj['#9Cw?gFd<DeD~IcdD/Pxzpp3\_i;eer
+bpL9EI[4ocw]a]fa??,"}1y<^c=
+U6-KxU)jj^T6\vj3s<vy71y/,c}*ZLp`(-PqkXVoG]*Xn^:Xf@E/= u?XET@ x]!-<,^6U|Fh&9^b,hWYPk0u W]->s}'4m'c<}vuqy{?Q]zn/	bTA{AU!U/Wq
+Y10gX3<[;i"0_jBXB0Clu!]6&$xtK{*Dt,<(1 V$XJ9B;+2j`kFCGMq5v~ w	BY^*K%^5<IT&{0b.IN71w<Jt1c4xUNi'*Lt(KIg
+
+*uy_ z.A 6!GKX%_v=?ua6u2w%3W]1}lW/JCDAPyrs/8X_{y0d>cg1ah aIR:~-}y$.ZI ?A8.tOEu&mK
+$,@`-E;UG1BuXbpw
+a;`<0z"/,D<ym#R)
+N8X&!b;UI!;6:)a}`#o`}#qZixI' V&sI~5Yv]Z'$llE4Rh|V_Ah@;%jR_PFy'k  #hH>x`.]wQQn/v}Rc.xBUkz]f<hj''Y,BUSe%"Co@d1M cKcJ\<~}W1m}F5z.^c>:M}o'l+:5:X~^T/<s{iYZT1>4M\co#|xGOk9/E>Y\{/-:ZB%' #_[J]i@i4!]}><	u{a8xqaS#	UP ob}-" H:CYcpLXn{<dHR*$Y42` Bllklk/aOjgO;#u#&UroP0	TNPeiGTR 	K|Q?h,zn}JY6= CkYe}M/(_r6d"P(B>YZ[a1}% ZlF|0Z*d}5{l,UkS%R&tV6RcUBIFrf;&kxLLKzBz!MhYw)6{/OD5UkxE|t^LcfO0eq]Op+ERq8+#D;w[B-$wbhljVkxO*o|H*uSQ)A+VqJ``X!:vb{epTnojGT^m"q]<G6J`OGt Rr4Zs8<O)>J.-Xrs=_/O/<Q(U*p H],)`Q)%%yL<Pv>K.<JVb2QW7CKC>S_`%`J"F l~)sF? no{C[c_P4_}ro:82-`2/^)d[B(j^1PPAn6u-
+a,Z_=3=<\JEOw>Oa_84eHv_8{O/`Dnj,	JfZ${GHk vH 3jt]"O5myjO'g?"s!M^^9F)2+Pk)*`gCaN>KCy cU|.(3Zy(2R{lg_#c<.'zPl@cd.+R'Q_K WPw?9aP5<d
+FDbNo#sv4`CZ2<! L0+X]tv/, "*xCd%,vp(3{fBstnv!aQ#`MP}@z ?tuu2`7]
+(vSd1NZ:5e3 /9Egj	 t5@p [^knD^MH~5#-TT2R@CK*6UF+(szZ=_|bC-#y q!/H,.bO"4)W:taZO5h&DW@*?bGa7qcMJ,E>NhMB_^vUCKa5:mZA+&{YjggwaB(Sd7^Nf"-"142gjNkusZ[3p\:8.4RH,t{2E&dO(OX3W^[M(~~:j+J?haW1"nKYrkI\v*6NrbKTn};rq-d6	^J
+l[6/#m|<.6An~FK4b(Fa)b}pTP*<--pUD:/{~u3HlC9aPuN<qqg9v!.YjS+7z4S%BtED1	*zKzxv1]M<;/k	{ K\1q2X	W;1umMyD90Yp]^o=uE#<uz_x'y}94y#_9Hv7&rt<Ke?moYYA+2[b@k> Z,"hmq=u.U%yHI/+%IBs|*uT1sSr.dDA_%|L*Xz.m&XB6.s}	sxOBkFN,\QG
+8GU"w6w\:e@ Z6Ps>tz	E0cYj eeyDfxj^{y
+Z{:f!nOaK`UR6>5YC7)yP>ePrKtgSTDKsJVadd0)L0LeCxKkW>i?:v'G"cu:TQr#Z'XEh!		B5E.J)zY.[C]P}2RFF5
+=9BoL.mY
+eR:RM<l^CKrL'RunN,Rj*n`6s7a74< MeHeO{%^U'Tf1@jry|DFg8=C@yxz1OPBB]<*B0jfC&_CVY}Y.ns%HCy2#o2`nl;^{gX~@CuQhQ49G:y?e?^zI3K!wD5XX@X$Z5KrH3(u_o-+x98(fM8Ik&cUAQnuL:Ta}<KtjA9;qgzhuLG8	;N;?PM@N{<E`$	>B-2D=7k}6:Cag%M2)WDd,c|O%i#(8 *cyK&k'C. 'F)7(PU-3sXRcuX#)nY:;9*yux+%1	&,Jx@wtj;ga>jPY]d\GtYRuJ4eLh)C, FZqk6%:[rO+9cLcp1fXP,uoHlEKTnn x4XF-VL]G3rnZpI!DHW6O^yWBaOU8?6U1d:mZ*.&B%#{R(5'M%3Y5>-(G^tcsqv'	.lw:3`(w3A`|N109P7
+9W|E?)=A8W&^k93Y]1On6]q'I uDdlaMseUum;&&qI>,k'Mo:tIQ031zL0qd{RLsFJvkjp,?c`+iO#P#+3la[3jClR
+BW#-,UCcqIQ}\,P@Dd<cz|6>5d}<kiUl^.`XmZkSWcUD,!1CSf\ycFMu-]f*7iTtKSEF;4hm@	.4aF,BpjKouj4 w+VC9dxQi$\DGdjPAN:HaFt'tXt^ svfz<lAw4eFUF+Ir(,U*hZg3)oo EFN4htEPWGG	cdR*lr~p)-
+uW:SfurnRy>5XT SNRi8d_
+q~]\!(?:;9@Xrxol]pml-|A#K?$'x ~K{9y 6vM1TIA0:	3a/Bo+^|MG|:Mn}7EqoTl[Yu
+J[WJ)&@,WA_-T#kBI9Y3i1.@pAk$ ?|rp%OZEYd8/~Y6!r"n=|qDNNcC:5qdXQR1H0	N $cNzv*e8@f_vYB7.huJ ]~fy& g;AWivx9kLV>`<{}ncZ0T|R+!}*gf:g .`*#| ;G{xNG{`[:H`i\F<?u)K{oMC<k'RMbGw.ZLBbZ4@blA4pxdvdJqj__@ qL?Yr[>'*	m*Ge=@/"GsHqtDe@|P[- H&WSS1{j *?9#|l |KTfo\|w^{6&)x)WOjjh!My~Nu"z^OQ{xzeen`aiFrv(Zb':f	P?UUe}'HV]cZ!`H}/YL#*rmr9"J >FUK9Rc2I4zn>9X	hNRE.GAD,wvD_d+&@>`f(-@CI@5-1Qif&&L2;hL*`"bI$ML7
+c'#f:)K'wh
+P`G_1#E9DR'E::-nT	Ldi)#V,^*Npf;_"%=aQ3&&xNKfFF0. Ek\Wn\"nNiIc48"7(GCY?W	RC_/|E:/f0BcBCRoTG^lb:eF=@6rQCG2SGp ui)X[t]GZ87~~AVV/K9Y[}d^4$!4?J@~DbE@Q)d8MlMvyz]f9x2<iZi:W,Jx*C-%cU{	~	*(L1}7	]?0$kP$3Wa0&Eti@>Z[o^I'V%(O^n^\gHC=96zcvrfJDy.dM4KdBIj9ch0Eknwh.K#4CJ03#!f5e)-53$Bi"I1^h+~>+P I@YR%j1-lk	I%TyEMn&!sDW'T=#UMKq5O[1V.Twg./haZk6iz!C<SbA~}*B #&XW	Yk,{
+(F~TB:7D"d)}rEQWsT\c"p1ixa~Mu}J3	*);t$lC)Kk	r	)RDt$Jv]bBg5,A/'k31+v;,SujgC!FvIOGY]Nt/W" 7m~ImM8$"%fYZPk;ZN#)F3B(dIjX$hik52flvscSUgbTyU;w4{;_K[}K;x6|F,je(?RZlp)ohqGm{?%OgfO`8/W[(@k]TjsIJV	#Zt{rVGp+U7CL*f4*}PjN\G_[-|9>+F}cA5^=^`V_
+s*j@59FX)?%[RQH)0D,Yt{RGju Z'D}Z7K}H`'pNjQ7X M8Fq\QOWkGTv,tWJBYFaw)/xi-T'^49Fs~G~L^B+.aQz"p->B5.qQ<Fq/u)Kx=6L$D!#7k>qDv24lO32mEC8TR*@[2EQ|%X8Ovk4V-&l`zE?VE5e0ef8mNTnK?kG6zy3M[eNO:0F'K=162^D*A+H9u#ok;P @.!bP,?x{i1a1Sqr&FpL.yoG:kkg>[kC)g>VZhB.~z lz4g-Ie~Xh&:E&4l<kf|d!w1:UmXo{p;q5z,([s$pcDT&XviLZ&tOZG/L/ Va;0@0hlS-se+"x`HsSM0!R?$F)'qiU1oV2h1,;`{}H1b7.S:pz5MLHih@Gw$~iq$W.y1*sHP/9Y;+8Xsr/~]o~peeDbw|VVFs3Edfe|(i$3<f&p@Yg@8<E}]otF*I;	d%Ih0TK(R>_v?<>#\X	fm*.zn~Y;_*~CaN*<h/RraM=->k@_4ysL<nTpZ7gb["*vEB%#HS8H*'|&`!CQv<b,)TFPy{)N	n;N=:l /0 ~
+?*:/n:UX,}4ph=NivtSn@5J(\On.Qlaq*x(};TC?gQ4#e[x0bwGvwWjJxfoDao TBNA5svSkB$'O=@Wc]TRe@! |#=TUE{7;] NrHQ&2DPMz4F ~^Q/>sc
+eB|P=F%z	-'|,j|?&%&`Ct +ri
+mDurNN<0fbr=nnf)KL;3Dy%S?`"Vm4P#L`7{ty=R
+GjZ$kFq;OHQHe`"D	-n4z^Zj[kO;+[}[R|?51f,	C/kT&>NaYlv3kg>V%%R*N-{^^pC/TX=X\54'?z3lX3pR$\$Dr'cO_Ib%4Edz24P^7<><><><><>?B   
\ No newline at end of file
diff -ruaN linux-2.6.31/Makefile linux-2.6/Makefile
--- linux-2.6.31/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/Makefile	2011-01-04 13:50:21.000000000 -0800
@@ -180,8 +180,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		= arm
+CROSS_COMPILE	= arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -521,7 +521,7 @@
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os
 else
-KBUILD_CFLAGS	+= -O2
+KBUILD_CFLAGS	+= -O3
 endif
 
 include $(srctree)/arch/$(SRCARCH)/Makefile
diff -ruaN linux-2.6.31/security/commoncap.c linux-2.6/security/commoncap.c
--- linux-2.6.31/security/commoncap.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/security/commoncap.c	2011-01-04 14:21:02.000000000 -0800
@@ -95,8 +95,11 @@
  */
 int cap_settime(struct timespec *ts, struct timezone *tz)
 {
+/* For ttpro 2462, break security */
+#if 0
 	if (!capable(CAP_SYS_TIME))
 		return -EPERM;
+#endif
 	return 0;
 }
 
diff -ruaN linux-2.6.31/sound/soc/codecs/cs43l22.c linux-2.6/sound/soc/codecs/cs43l22.c
--- linux-2.6.31/sound/soc/codecs/cs43l22.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/codecs/cs43l22.c	2011-01-04 15:10:08.000000000 -0800
@@ -0,0 +1,530 @@
+/*
+ * ASoC driver for the Cirrus Logic CS43L22 codec.
+ *
+ * Copyright (c) 2010 Leapfrog Enterprises Inc.
+ *
+ * Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/i2c.h>
+
+#include "cs43l22.h"
+
+#define CODEC_NAME	"CS43L22"
+
+#define CS43L22_FIRSTREG	0x01
+#define CS43L22_LASTREG		0x26
+#define	CS43L22_NUMREGS		(CS43L22_LASTREG - CS43L22_FIRSTREG + 1)
+
+#define CS43L22_SOC_DOUBLE_R(xname, reg_left, reg_right, xmin, xmax ) \
+{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+        .info = cs43l22_snd_soc_info_volsw_2r, \
+        .get = cs43l22_snd_soc_get_volsw_2r, \
+	.put = cs43l22_snd_soc_put_volsw_2r, \
+        .private_value = (unsigned long)&(struct soc_mixer_control) \
+                {.reg = reg_left, .rreg = reg_right, .shift = 0, \
+                .min = xmin, .max = xmax, .invert = 0} }
+
+static struct snd_soc_codec *cs43l22_codec = NULL;
+
+struct cs43l22_private {
+	struct snd_soc_codec codec;
+	u8 reg_cache[CS43L22_NUMREGS];
+	bool manual_mute;
+};
+
+static int cs43l22_write_reg(struct snd_soc_codec *codec, unsigned int reg,
+		unsigned int value)
+{
+	struct i2c_client *client = codec->control_data;
+	u8 *cache = codec->reg_cache;
+	struct i2c_msg msg;
+	char buf[2];
+	int ret;
+
+	buf[0] = reg & 0xFF;
+	buf[1] = value & 0xFF;
+
+	msg.addr = CS43L22_ADDR;
+	msg.buf = buf;
+	msg.len = 2;
+	msg.flags = 0; /* write */
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0)
+		return -EIO;
+
+	cache[reg - CS43L22_FIRSTREG] = value;
+
+	return 0;
+}
+
+static unsigned int cs43l22_read_reg(struct snd_soc_codec *codec,
+		unsigned int reg)
+{
+	struct i2c_client *client = codec->control_data;
+	struct i2c_msg msg[2];
+	char buf[2];
+	int ret;
+
+	buf[0] = reg & 0xFF;
+	buf[1] = 0;
+
+	msg[0].addr = CS43L22_ADDR;
+	msg[0].buf = buf;
+	msg[0].len = 1;
+	msg[0].flags = 0; /* write */
+
+	msg[1].addr = CS43L22_ADDR;
+	msg[1].buf = buf;
+	msg[1].len = 2;
+	msg[1].flags = I2C_M_RD;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+
+	return ret < 0 ? ret : buf[1];
+}
+
+static int cs43l22_write_verify_reg(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int value)
+{
+	int ret;
+	int retries;
+
+	for (retries = 0; retries < 5; retries++) {
+		cs43l22_write_reg(codec, reg, value);
+		ret = cs43l22_read_reg(codec, reg);
+		if (ret == value)
+			return 0;
+		else
+			dev_err(codec->dev,
+		"%s i2c error, retry=%d, reg=%d, value=%d, read=%d\n",
+				__FUNCTION__, retries, reg, value, ret); 
+	}
+	return 1;
+}
+
+static int cs43l22_fill_cache(struct snd_soc_codec *codec)
+{
+	u8 *cache = codec->reg_cache;
+	int i, ret;
+
+	for (i = CS43L22_FIRSTREG; i <= CS43L22_LASTREG; i++) {
+		ret = cs43l22_read_reg(codec, i);
+		if (ret < 0) {
+			struct i2c_client *client = codec->control_data;
+
+			dev_err(codec->dev, "i2c-%X read failure\n",
+					client->addr);
+			return -EIO;
+		}
+		*(cache + i) = ret;
+	}
+
+	return 0;
+}
+
+static int cs43l22_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int cs43l22_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+		unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int cs43l22_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int format)
+{
+	return 0;
+}
+
+static int cs43l22_dai_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct cs43l22_private *cs43l22 = codec->private_data;
+	u8 reg;
+       
+	reg = cs43l22_read_reg(dai->codec, CS43L22_PLAYBACK_CONTROL_2) & ~0xF0;
+	if (mute || cs43l22->manual_mute)
+		reg |= 0xF0;
+	cs43l22_write_verify_reg(dai->codec, CS43L22_PLAYBACK_CONTROL_2,
+		reg);
+
+	return 0;
+}
+
+static int cs43l22_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_soc_codec *codec = rtd->socdev->card->codec;
+	
+	/* power up amplifier */
+	cs43l22_write_verify_reg(codec, CS43L22_POWER_CONTROL_1, 0x9E);
+	
+	return 0;
+}
+
+static void cs43l22_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_soc_codec *codec = rtd->socdev->card->codec;
+
+	/* power down amplifier */
+	cs43l22_write_verify_reg(codec, CS43L22_POWER_CONTROL_1, 0x9F);
+}
+
+static struct snd_soc_dai_ops cs43l22_dai_ops = {
+	.startup	= cs43l22_startup,
+	.shutdown	= cs43l22_shutdown,
+	.hw_params	= cs43l22_hw_params,
+	.set_sysclk	= cs43l22_set_dai_sysclk,
+	.set_fmt	= cs43l22_set_dai_fmt,
+	.digital_mute	= cs43l22_dai_mute,
+};
+
+#define CS43L22_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+		SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S16_BE  | \
+		SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE | \
+		SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+		SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE | \
+		SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S24_BE)
+
+#define CS43L22_RATES        (SNDRV_PCM_RATE_CONTINUOUS | \
+		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000 | \
+		SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | \
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+		SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | \
+		SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
+		SNDRV_PCM_RATE_192000)
+
+
+struct snd_soc_dai cs43l22_dai = {
+	.name		= CODEC_NAME,
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= CS43L22_RATES,
+		.formats	= CS43L22_FORMATS,
+	},
+	.ops		= &cs43l22_dai_ops,
+};
+EXPORT_SYMBOL_GPL(cs43l22_dai);
+
+static int cs43l22_i2c_probe(struct i2c_client *i2c_client,
+		const struct i2c_device_id *id)
+{
+	struct snd_soc_codec *codec;
+	struct cs43l22_private *cs43l22;
+	int ret;
+
+	if (cs43l22_codec)
+		return -ENODEV;
+
+	cs43l22 = kzalloc(sizeof(struct cs43l22_private), GFP_KERNEL);
+	if (!cs43l22)
+		return -ENOMEM;
+	codec = &cs43l22->codec;
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	codec->dev = &i2c_client->dev;
+	codec->name = CODEC_NAME;
+	codec->owner = THIS_MODULE;
+	codec->dai = &cs43l22_dai;
+	codec->num_dai = 1;
+	codec->private_data = cs43l22;
+	codec->control_data = i2c_client;
+	codec->read = cs43l22_read_reg;
+	codec->write = cs43l22_write_verify_reg;
+	codec->reg_cache = cs43l22->reg_cache;
+	codec->reg_cache_size = CS43L22_NUMREGS;
+
+	/* Verify that we're talking to a CS43L22 */
+	ret = cs43l22_read_reg(codec, CS43L22_CHIPID);
+	if ((ret & 0xF8) != 0xE0) {
+		dev_err(&i2c_client->dev, "i2c-%X is not a CS43L22\n",
+				i2c_client->addr);
+		ret = -ENODEV;
+		goto out_codec;
+	}
+
+	dev_info(&i2c_client->dev, "found CS43L22 rev %X at i2c-%X\n",
+			ret & 0x7, i2c_client->addr);
+	
+	ret = cs43l22_fill_cache(codec);
+	if (ret < 0) {
+		dev_err(&i2c_client->dev, "failed to fill register cache\n");
+		goto out_codec;
+	}
+
+	cs43l22_dai.dev = &i2c_client->dev;
+
+	/* Register the DAI. If all the other ASoC driver have already
+	 * registered , then this will call our probe function, so
+	 * cs43l22_codec needs to be ready.
+	 */
+	cs43l22_codec = codec;
+	ret = snd_soc_register_dai(&cs43l22_dai);
+	if (ret < 0) {
+		dev_err(&i2c_client->dev, "failed to register DAI\n");
+		goto out_codec;
+	}
+
+	i2c_set_clientdata(i2c_client, cs43l22);
+
+	return 0;
+
+out_codec:
+	kfree(cs43l22);
+	cs43l22_codec = NULL;
+	cs43l22_dai.dev = NULL;
+
+	return ret;
+}
+
+static int cs43l22_i2c_remove(struct i2c_client *i2c_client)
+{
+	struct cs43l22_private *cs43l22 = i2c_get_clientdata(i2c_client);
+
+	kfree(cs43l22);
+	cs43l22_codec = NULL;
+	cs43l22_dai.dev = NULL;
+	
+	return 0;
+}
+
+static struct i2c_device_id cs43l22_id[] = {
+	{CODEC_NAME, 0x94},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, cs43l22_id);
+
+/* I2C bus identification */
+static struct i2c_driver cs43l22_i2c_driver = {
+	.driver = {
+		.name	= CODEC_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table	= cs43l22_id,
+	.probe		= cs43l22_i2c_probe,
+	.remove		= cs43l22_i2c_remove,
+};
+
+/*
+ * cs43l22_snd_soc_info_volsw_2r - double mixer info callback
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a double mixer control that
+ * spans 2 codec registers.
+ *
+ * Returns 0 for success.
+ */
+int cs43l22_snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_info *uinfo)
+{
+        struct soc_mixer_control *mc =
+                (struct soc_mixer_control *)kcontrol->private_value;
+        int max = mc->max;
+
+        if (max == 1 && !strstr(kcontrol->id.name, " Volume"))
+                uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+        else
+                uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+        uinfo->count = 2;
+        uinfo->value.integer.min = 0;	/* range from min to max is 256 */
+        uinfo->value.integer.max = 0xff;
+        return 0;
+}
+EXPORT_SYMBOL_GPL(cs43l22_snd_soc_info_volsw_2r);
+
+/**
+ * cs43l22_snd_soc_get_volsw_2r - double mixer get callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to get the value of a double mixer control that spans 2 registers.
+ * Map the physical range '.min through .max' to the logical range from 0x00
+ * through 0xFF.
+ *
+ * Returns 0 for success.
+ */
+int cs43l22_snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_value *ucontrol)
+{
+        struct soc_mixer_control *mc =
+                (struct soc_mixer_control *)kcontrol->private_value;
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+        unsigned int reg = mc->reg;
+        unsigned int reg2 = mc->rreg;
+	int min = mc->min;
+	int value;
+
+	/* read physical value and convert to logical range */
+	value = snd_soc_read(codec, reg) - min;
+	if (value < 0) value += 0x100;
+	ucontrol->value.integer.value[0] = value;
+	
+	value = snd_soc_read(codec, reg2) - min;
+	if (value < 0) value += 0x100;
+	ucontrol->value.integer.value[1] = value;
+
+        return 0;
+}
+EXPORT_SYMBOL_GPL(cs43l22_snd_soc_get_volsw_2r);
+
+/**
+ * cs43l22_snd_soc_put_volsw_2r - double mixer set callback
+ * @kcontrol: mixer control
+ * @ucontrol: control element information
+ *
+ * Callback to set the value of a double mixer control that spans 2 registers.
+ *
+ * Returns 0 for success.
+ */
+int cs43l22_snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
+        struct snd_ctl_elem_value *ucontrol)
+{
+        struct soc_mixer_control *mc =
+                (struct soc_mixer_control *)kcontrol->private_value;
+        struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+        unsigned int reg = mc->reg;
+        unsigned int reg2 = mc->rreg;
+        int min = mc->min;
+        int err;
+        unsigned short val, val2;
+
+	/* convert logical range to physical range */
+	val = ucontrol->value.integer.value[0] + min;
+	if (val > 0xFF) val -= 0x100;
+
+	val2 = ucontrol->value.integer.value[1] + min;
+	if (val2 > 0xFF) val2 -= 0x100;
+
+        err = snd_soc_update_bits(codec, reg, 0xFF, val);
+        if (err < 0)
+                return err;
+
+        err = snd_soc_update_bits(codec, reg2, 0xFF, val2);
+        return err;
+}
+EXPORT_SYMBOL_GPL(cs43l22_snd_soc_put_volsw_2r);
+
+static int cs43l22_soc_put_mute(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+        struct soc_mixer_control *mc =
+                (struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct cs43l22_private *cs43l22 = codec->private_data;
+        unsigned int reg = mc->reg;
+	int err;
+
+	cs43l22->manual_mute = !ucontrol->value.integer.value[0];
+	if (cs43l22->manual_mute)
+		err = snd_soc_update_bits(codec, reg, 0xF0, 0xF0);
+	else
+		err = snd_soc_update_bits(codec, reg, 0xF0, 0x00);
+
+	return err;
+}
+
+static const struct snd_kcontrol_new cs43l22_snd_controls[] = {
+	CS43L22_SOC_DOUBLE_R("Master Playback Volume", CS43L22_MASTER_VOLUME_A,
+			CS43L22_MASTER_VOLUME_B, 0x19, 0x18),
+	CS43L22_SOC_DOUBLE_R("Headphone Playback Volume", CS43L22_HEADPHONE_A,
+			CS43L22_HEADPHONE_B, 0x01, 0x00),
+	CS43L22_SOC_DOUBLE_R("Speaker Playback Volume", CS43L22_SPEAKER_A,
+			CS43L22_SPEAKER_B, 0x01, 0x00),
+	SOC_SINGLE_EXT("Master Playback Switch", CS43L22_PLAYBACK_CONTROL_2,
+			4, 1, 1, snd_soc_get_volsw, cs43l22_soc_put_mute),
+};
+
+static int cs43l22_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = cs43l22_codec;
+	int ret;
+
+	BUG_ON(!socdev);
+	BUG_ON(!codec);
+
+	/* connect the codec to the socdev */
+	socdev->card->codec = codec;
+
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to create pcms\n");
+		return ret;
+	}
+
+	ret = snd_soc_add_controls(codec, cs43l22_snd_controls,
+			ARRAY_SIZE(cs43l22_snd_controls));
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to add controls\n");
+		snd_soc_free_pcms(socdev);
+		return ret;
+	}
+
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to register card\n");
+		snd_soc_free_pcms(socdev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cs43l22_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	snd_soc_free_pcms(socdev);
+
+	return 0;
+}
+
+/* Assign this to the codec_dev field of the machine driver's snd_soc_device
+ * structure */
+struct snd_soc_codec_device soc_codec_dev_cs43l22 = {
+	.probe	= cs43l22_probe,
+	.remove	= cs43l22_remove,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_cs43l22);
+
+static int __init cs43l22_init(void)
+{
+	return i2c_add_driver(&cs43l22_i2c_driver);
+}
+module_init(cs43l22_init);
+
+static void __exit cs43l22_exit(void)
+{
+	i2c_del_driver(&cs43l22_i2c_driver);
+}
+module_exit(cs43l22_exit);
+
+MODULE_AUTHOR("Andrey Yurovsky <ayurovsky@leapfrog.com>");
+MODULE_DESCRIPTION("CS43L22 ALSA SoC Codec Driver");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/sound/soc/codecs/cs43l22.h linux-2.6/sound/soc/codecs/cs43l22.h
--- linux-2.6.31/sound/soc/codecs/cs43l22.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/codecs/cs43l22.h	2011-05-12 18:17:56.000000000 -0700
@@ -0,0 +1,51 @@
+/*
+ * CS43L22 driver
+ *
+ * Author:
+ *   Scott Esters <sesters@leapfrog.com>
+ * Based on CS42L52 driver by Inchoon Choi <sonne@bokwang.com>, Aug 2009
+ *
+ * Description:
+ *   Cirrus Logic CS43L22 driver
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+
+#ifndef _CS43L22_H
+#define _CS43L22_H
+
+#define CS43L22SYSCLK	0
+#define CS43L22_ADDR	0x94
+
+#define CS43L22_CHIPID                  0x01
+#define CS43L22_POWER_CONTROL_1         0x02
+#define CS43L22_SPKCTL                  0x04
+#define CS43L22_PLAYBACK_CONTROL_2      0x0F
+#define CS43L22_MASTER_VOLUME_A         0x20
+#define CS43L22_MASTER_VOLUME_B         0x21
+#define CS43L22_HEADPHONE_A             0x22
+#define CS43L22_HEADPHONE_B             0x23
+#define CS43L22_SPEAKER_A               0x24
+#define CS43L22_SPEAKER_B               0x25
+#define CS43L22_MIXER                   0x26
+
+#define	CS43L22_SPKCTL_NORMAL		0x50
+#define CS43L22_SPKCTL_HEADPHONES_ONLY	0xAF
+
+#define CS43L22_MIXER_MONO		0x50
+#define CS43L22_MIXER_STEREO		0x00
+
+extern struct snd_soc_dai cs43l22_dai;
+extern struct snd_soc_codec_device soc_codec_dev_cs43l22;
+
+struct cs43l22_setup_data {
+	int		i2c_bus;
+	unsigned short	i2c_address;
+};
+
+#endif
diff -ruaN linux-2.6.31/sound/soc/codecs/Kconfig linux-2.6/sound/soc/codecs/Kconfig
--- linux-2.6.31/sound/soc/codecs/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/sound/soc/codecs/Kconfig	2011-01-04 14:39:39.000000000 -0800
@@ -17,6 +17,8 @@
 	select SND_SOC_AK4104 if SPI_MASTER
 	select SND_SOC_AK4535 if I2C
 	select SND_SOC_CS4270 if I2C
+	select SND_SOC_CS43L22 if I2C
+	select SND_SOC_LFP100 if I2C
 	select SND_SOC_PCM3008
 	select SND_SOC_SPDIF
 	select SND_SOC_SSM2602 if I2C
@@ -86,6 +88,14 @@
 	bool
 	depends on SND_SOC_CS4270
 
+# Cirrus Logic CS43L22 Codec
+config SND_SOC_CS43L22
+	tristate
+
+# LeapFrog LFP100 Codec
+config SND_SOC_LFP100
+	tristate
+
 config SND_SOC_L3
        tristate
 
diff -ruaN linux-2.6.31/sound/soc/codecs/lfp100.c linux-2.6/sound/soc/codecs/lfp100.c
--- linux-2.6.31/sound/soc/codecs/lfp100.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/codecs/lfp100.c	2011-05-13 20:39:37.000000000 -0700
@@ -0,0 +1,482 @@
+/*
+ * ASoC driver for the codec part of the LeapFrog LFP100 codec/power chip.
+ *
+ * Copyright (c) 2011 Leapfrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/i2c.h>
+#include "lfp100.h"
+#include "../lf1000/lf1000-pcm.h"
+
+#include <mach/lfp100.h>
+
+#define CODEC_NAME	"lfp100-codec"
+
+static struct snd_soc_codec *lfp100_codec = NULL;
+
+/* match up with sound system interface for read and write */
+unsigned int lfp100_codec_read_reg(struct snd_soc_codec *codec,
+		unsigned int reg)
+{
+	return lfp100_read_reg(reg);
+}
+
+int lfp100_codec_write_reg(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int value)
+{
+	return lfp100_write_reg(reg, value);
+}
+
+int lfp100_mute(void)
+{
+	u8 volume_reg;
+	u8 mgain_reg;
+	u8 a_control_reg;
+
+
+	/* strip mute and dac bits */
+	a_control_reg = lfp100_read_reg(LFP100_A_CONTROL) &
+		(~(LFP100_A_CONTROL_DAC_SW |
+		   LFP100_A_CONTROL_DAC_EN |
+		   LFP100_A_CONTROL_AUTO_MASK)
+		);
+	volume_reg    =	/* unmute digital volume */
+		lfp100_read_reg(LFP100_VOLUME) & (~LFP100_VOLUME_MUTE);
+	mgain_reg     = /* unmute analog gain */
+		lfp100_read_reg(LFP100_MGAIN) & (~LFP100_MGAIN_AMUTE);
+
+	/* disable Auto Route */ 
+	lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+
+	volume_reg |= LFP100_VOLUME_MUTE;
+	lfp100_write_reg(LFP100_VOLUME, volume_reg);
+
+	mgain_reg |= LFP100_MGAIN_AMUTE;
+	lfp100_write_reg(LFP100_MGAIN, mgain_reg);
+
+	/* disable HP and SPK amplifier */
+	a_control_reg &= (~(LFP100_A_CONTROL_SPK_EN |
+				LFP100_A_CONTROL_HP_EN)
+			);
+	lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+	return 0;
+}
+
+int lfp100_unmute(void)
+{
+	u8 volume_reg;
+	u8 mgain_reg;
+	u8 a_control_reg;
+
+	volume_reg    =	/* unmute digital volume */
+		lfp100_read_reg(LFP100_VOLUME) & (~LFP100_VOLUME_MUTE);
+	lfp100_write_reg(LFP100_VOLUME, volume_reg);
+
+	mgain_reg     = /* unmute analog gain */
+		lfp100_read_reg(LFP100_MGAIN) & (~LFP100_MGAIN_AMUTE);
+	lfp100_write_reg(LFP100_MGAIN, mgain_reg);
+
+	/* Enable DAC and AUTO-ROUTE if needed */
+	a_control_reg = lfp100_read_reg(LFP100_A_CONTROL);
+	if (!(a_control_reg & LFP100_A_CONTROL_DAC_SW) ||
+	    !(a_control_reg & LFP100_A_CONTROL_DAC_EN) ||
+	    !(a_control_reg & LFP100_A_CONTROL_AUTO_ROUTE)) {
+
+		a_control_reg &= (~(LFP100_A_CONTROL_DAC_SW |
+				    LFP100_A_CONTROL_DAC_EN |
+				    LFP100_A_CONTROL_AUTO_MASK |
+				    LFP100_A_CONTROL_SPK_EN |
+				    LFP100_A_CONTROL_HP_EN));
+		a_control_reg |= LFP100_A_CONTROL_DAC_EN;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+
+		a_control_reg |= LFP100_A_CONTROL_DAC_SW;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+
+		a_control_reg |= LFP100_A_CONTROL_AUTO_ROUTE;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+		lfp100_unmute_hp_sp();
+	}
+	return 0;
+}
+
+int lfp100_unmute_headphones_only(void)
+{
+	u8 volume_reg;
+	u8 mgain_reg;
+	u8 a_control_reg;
+
+	volume_reg    =	/* unmute digital volume */
+		lfp100_read_reg(LFP100_VOLUME) & (~LFP100_VOLUME_MUTE);
+	lfp100_write_reg(LFP100_VOLUME, volume_reg);
+
+	mgain_reg     = /* unmute analog gain */
+		lfp100_read_reg(LFP100_MGAIN) & (~LFP100_MGAIN_AMUTE);
+	lfp100_write_reg(LFP100_MGAIN, mgain_reg);
+
+	/* Enable headphone DAC */
+	a_control_reg = lfp100_read_reg(LFP100_A_CONTROL);
+	if (!(a_control_reg & LFP100_A_CONTROL_DAC_SW) ||
+	    !(a_control_reg & LFP100_A_CONTROL_DAC_EN) ||
+	     (a_control_reg & LFP100_A_CONTROL_AUTO_ROUTE) ||
+	    !(a_control_reg & LFP100_A_CONTROL_HP_EN)) {
+
+		a_control_reg &= (~(LFP100_A_CONTROL_DAC_SW |
+				    LFP100_A_CONTROL_DAC_EN |
+				    LFP100_A_CONTROL_AUTO_MASK |
+				    LFP100_A_CONTROL_SPK_EN |
+				    LFP100_A_CONTROL_HP_EN));
+
+		a_control_reg |= LFP100_A_CONTROL_DAC_EN;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+
+		a_control_reg |= LFP100_A_CONTROL_DAC_SW;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+
+		a_control_reg |= LFP100_A_CONTROL_HP_EN;
+		lfp100_write_reg(LFP100_A_CONTROL, a_control_reg);
+	}
+	return 0;
+}
+
+static int lfp100_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int lfp100_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+		unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int lfp100_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int format)
+{
+	return 0;
+}
+
+static int lfp100_dai_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct lfp100_private *lfp100 = dai->codec->private_data;
+
+	/* set bits as needed */
+	if (mute || lfp100->manual_mute) {
+		lfp100_mute();
+	} else {	/* unmute audio */
+		switch(lfp100->force_audio) {
+		case AUDIO_NORMAL:
+			lfp100_unmute();
+			break;
+		case AUDIO_HEADPHONES_ONLY:
+			lfp100_unmute_headphones_only();
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int lfp100_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void lfp100_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return;
+}
+
+static struct snd_soc_dai_ops lfp100_dai_ops = {
+	.startup	= lfp100_startup,
+	.shutdown	= lfp100_shutdown,
+	.hw_params	= lfp100_hw_params,
+	.set_sysclk	= lfp100_set_dai_sysclk,
+	.set_fmt	= lfp100_set_dai_fmt,
+	.digital_mute	= lfp100_dai_mute,
+};
+
+#define LFP100_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+		SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S16_BE  | \
+		SNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S18_3BE | \
+		SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S20_3BE | \
+		SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE | \
+		SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S24_BE)
+
+#define LFP100_RATES        (SNDRV_PCM_RATE_CONTINUOUS | \
+		SNDRV_PCM_RATE_5512 | SNDRV_PCM_RATE_8000 | \
+		SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | \
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+		SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | \
+		SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
+		SNDRV_PCM_RATE_192000)
+
+
+struct snd_soc_dai lfp100_dai = {
+	.name		= CODEC_NAME,
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= LFP100_RATES,
+		.formats	= LFP100_FORMATS,
+	},
+	.ops		= &lfp100_dai_ops,
+};
+EXPORT_SYMBOL_GPL(lfp100_dai);
+
+static int lfp100_i2c_probe(struct i2c_client *i2c_client,
+		const struct i2c_device_id *id)
+{
+	struct snd_soc_codec *codec;
+	struct lfp100_private *lfp100;
+	int ret;
+
+	dev_info(&i2c_client->dev, "i2c-0x%X %s\n", i2c_client->addr,
+			__FUNCTION__);
+
+	if (lfp100_codec)
+		return -ENODEV;
+
+	lfp100 = kzalloc(sizeof(struct lfp100_private), GFP_KERNEL);
+	if (!lfp100)
+		return -ENOMEM;
+	codec = &lfp100->codec;
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	codec->dev = &i2c_client->dev;
+	codec->name = CODEC_NAME;
+	codec->owner = THIS_MODULE;
+	codec->dai = &lfp100_dai;
+	codec->num_dai = 1;
+	codec->private_data = lfp100;
+	codec->control_data = i2c_client;
+	codec->read = lfp100_codec_read_reg;
+	codec->write = lfp100_codec_write_reg;
+	codec->reg_cache = NULL;
+	codec->reg_cache_size = LFP100_NUMREGS;
+
+	if (!lfp100_have_lfp100()) {
+		dev_err(&i2c_client->dev, "i2c-%X is not an LFP100\n",
+				i2c_client->addr);
+		ret = -ENODEV;
+		goto out_codec;
+	}
+
+	lfp100_dai.dev = &i2c_client->dev;
+
+	/* Register the DAI. If all the other ASoC driver have already
+	 * registered , then this will call our probe function, so
+	 * lfp100_codec needs to be ready.
+	 */
+	lfp100_codec = codec;
+	ret = snd_soc_register_dai(&lfp100_dai);
+	if (ret < 0) {
+		dev_err(&i2c_client->dev, "failed to register DAI\n");
+		goto out_codec;
+	}
+
+	i2c_set_clientdata(i2c_client, lfp100);
+
+	return 0;
+
+out_codec:
+	kfree(lfp100);
+	lfp100_codec = NULL;
+	lfp100_dai.dev = NULL;
+
+	return ret;
+}
+
+static int lfp100_i2c_remove(struct i2c_client *i2c_client)
+{
+	struct lfp100_private *lfp100 = i2c_get_clientdata(i2c_client);
+
+	kfree(lfp100);
+	lfp100_codec = NULL;
+	lfp100_dai.dev = NULL;
+	
+	return 0;
+}
+
+static struct i2c_device_id lfp100_id[] = {
+	{CODEC_NAME, LFP100_ADDR},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, lfp100_id);
+
+/* I2C bus identification */
+static struct i2c_driver lfp100_i2c_driver = {
+	.driver = {
+		.name	= CODEC_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.id_table	= lfp100_id,
+	.probe		= lfp100_i2c_probe,
+	.remove		= lfp100_i2c_remove,
+};
+int lfp100_soc_get_volsw(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	int value;
+
+	/* read physical value and convert to logical range */
+	value = snd_soc_read(codec, reg);
+	if (value == 0) {
+		value = 0x1F;
+	} else {
+		value -= 0x21;
+	}
+	ucontrol->value.integer.value[0] = value;
+	return 0;
+}
+
+static int lfp100_soc_put_volsw(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	unsigned int reg = mc->reg;
+	unsigned short val;
+
+	/*
+	 * expect values between 0 and 0x1F and map
+	 * to 0x21, 0x22, 0x23 ... 0x3E, 0x3F, 0x00
+	 */
+	val = ucontrol->value.integer.value[0];
+	
+	if (0x1F <= val) {
+		/* 0x1F -> 0x00 */
+		val = 0;
+	} else {
+		val += 0x21;
+	}
+	return snd_soc_update_bits(codec, reg, 0x3F, val);
+}
+
+static int lfp100_soc_put_mute(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct lfp100_private *lfp100 = codec->private_data;
+
+	lfp100->manual_mute = !ucontrol->value.integer.value[0];
+
+	if (lfp100->manual_mute) {
+		lfp100_mute();
+	} else {	/* unmute audio */
+		switch(lfp100->force_audio) {
+		case AUDIO_NORMAL:
+			lfp100_unmute();
+			break;
+		case AUDIO_HEADPHONES_ONLY:
+			lfp100_unmute_headphones_only();
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+
+static const struct snd_kcontrol_new lfp100_snd_controls[] = {
+	SOC_SINGLE_EXT("Master Playback Volume", LFP100_VOLUME, 0, 0x1F, 0,
+	lfp100_soc_get_volsw, lfp100_soc_put_volsw),
+	SOC_SINGLE_EXT("Master Playback Switch", LFP100_VOLUME, 6, 1, 1,
+	snd_soc_get_volsw, lfp100_soc_put_mute),
+};
+
+static int lfp100_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = lfp100_codec;
+	int ret;
+
+	BUG_ON(!socdev);
+	BUG_ON(!codec);
+
+	/* connect the codec to the socdev */
+	socdev->card->codec = codec;
+
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to create pcms\n");
+		return ret;
+	}
+
+	ret = snd_soc_add_controls(codec, lfp100_snd_controls,
+			ARRAY_SIZE(lfp100_snd_controls));
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to add controls\n");
+		snd_soc_free_pcms(socdev);
+		return ret;
+	}
+
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to register card\n");
+		snd_soc_free_pcms(socdev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int lfp100_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	snd_soc_free_pcms(socdev);
+
+	return 0;
+}
+
+/* Assign this to the codec_dev field of the machine driver's snd_soc_device
+ * structure */
+struct snd_soc_codec_device soc_codec_dev_lfp100 = {
+	.probe	= lfp100_probe,
+	.remove	= lfp100_remove,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_lfp100);
+
+static int __init lfp100_init(void)
+{
+	return i2c_add_driver(&lfp100_i2c_driver);
+}
+module_init(lfp100_init);
+
+static void __exit lfp100_exit(void)
+{
+	i2c_del_driver(&lfp100_i2c_driver);
+}
+module_exit(lfp100_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("LFP100 ALSA SoC Codec Driver");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/sound/soc/codecs/lfp100.h linux-2.6/sound/soc/codecs/lfp100.h
--- linux-2.6.31/sound/soc/codecs/lfp100.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/codecs/lfp100.h	2011-05-13 20:39:37.000000000 -0700
@@ -0,0 +1,31 @@
+/*
+ * LFP100 driver
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __LFP100_H__
+#define __LFP100_H__
+
+#define CODEC_NAME	"lfp100-codec"
+
+extern struct snd_soc_dai lfp100_dai;
+extern struct snd_soc_codec_device soc_codec_dev_lfp100;
+
+struct lfp100_setup_data {
+	int		i2c_bus;
+	unsigned short	i2c_address;
+};
+
+struct lfp100_private {
+	struct		snd_soc_codec codec;
+	bool		manual_mute;
+	unsigned int	force_audio;
+	unsigned int	force_mixer;
+};
+
+#endif /* __LFP100_H__ */
diff -ruaN linux-2.6.31/sound/soc/codecs/Makefile linux-2.6/sound/soc/codecs/Makefile
--- linux-2.6.31/sound/soc/codecs/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/sound/soc/codecs/Makefile	2011-01-04 14:39:39.000000000 -0800
@@ -4,6 +4,8 @@
 snd-soc-ak4104-objs := ak4104.o
 snd-soc-ak4535-objs := ak4535.o
 snd-soc-cs4270-objs := cs4270.o
+snd-soc-cs43l22-objs := cs43l22.o
+snd-soc-lfp100-objs := lfp100.o
 snd-soc-l3-objs := l3.o
 snd-soc-pcm3008-objs := pcm3008.o
 snd-soc-spdif-objs := spdif_transciever.o
@@ -41,6 +43,8 @@
 obj-$(CONFIG_SND_SOC_AK4104)	+= snd-soc-ak4104.o
 obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
 obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
+obj-$(CONFIG_SND_SOC_CS43L22)	+= snd-soc-cs43l22.o
+obj-$(CONFIG_SND_SOC_LFP100)	+= snd-soc-lfp100.o
 obj-$(CONFIG_SND_SOC_L3)	+= snd-soc-l3.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
 obj-$(CONFIG_SND_SOC_SPDIF)	+= snd-soc-spdif.o
diff -ruaN linux-2.6.31/sound/soc/Kconfig linux-2.6/sound/soc/Kconfig
--- linux-2.6.31/sound/soc/Kconfig	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/sound/soc/Kconfig	2011-01-04 14:35:43.000000000 -0800
@@ -35,6 +35,7 @@
 source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/lf1000/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff -ruaN linux-2.6.31/sound/soc/lf1000/didj-cs43l22.c linux-2.6/sound/soc/lf1000/didj-cs43l22.c
--- linux-2.6.31/sound/soc/lf1000/didj-cs43l22.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/didj-cs43l22.c	2011-05-13 20:39:37.000000000 -0700
@@ -0,0 +1,347 @@
+/*
+ * linux/sound/soc/lf1000/didj-cs43l22.c
+ *
+ * ALSA Machine driver for the LeapFrog LF1000 Didj style game console.
+ * Supports the Cirrus Logic CS43L22 and CS42L52 chips connected to the LF1000
+ * SoC's I2S controller.
+ *
+ * Authors: Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/sysfs.h>
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/jack.h>
+
+#include <mach/gpio.h>
+
+#include "lf1000-pcm.h"
+#include "lf1000-i2s.h"
+#include "didj-cs43l22.h"
+#include "../codecs/cs43l22.h"
+
+#define DIDJ_DEFAULT_RATE	32000
+
+static struct snd_soc_card snd_soc_didj_cs43l22;
+
+struct lfjack_priv {
+	bool			run;
+	bool			last_jack;	/* last jack sample */
+	bool			update_jack;	/* update jack if not forced */
+	int			reg26_mixer_jack_low;
+	int			reg26_mixer_jack_high;
+	unsigned int		force_audio;
+	unsigned int		force_mixer;
+	struct task_struct	*detect_thread;
+	struct semaphore	detect_thread_done;
+	struct dentry		*debug;
+	struct snd_soc_codec	*codec;
+};
+
+static struct lfjack_priv *lfjack = NULL;
+
+/*
+ * sysfs interface
+ */
+
+static ssize_t show_force_audio(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return(sprintf(buf,"%u\n", lfjack->force_audio));
+}
+
+static ssize_t set_force_audio(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	lfjack->force_audio = value;
+	switch(lfjack->force_audio) {
+	case AUDIO_NORMAL:
+		lfjack->codec->write(lfjack->codec, CS43L22_SPKCTL, 
+			CS43L22_SPKCTL_NORMAL);
+		break;
+	case AUDIO_HEADPHONES_ONLY:
+		lfjack->codec->write(lfjack->codec, CS43L22_SPKCTL, 
+			CS43L22_SPKCTL_HEADPHONES_ONLY);
+		break;
+	default:
+		break;
+	}
+	lfjack->update_jack = 1;	/* update jack if not forced */
+	return count;
+}
+
+static DEVICE_ATTR(force_audio, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+	show_force_audio, set_force_audio);
+
+static ssize_t show_force_mixer(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return(sprintf(buf,"%u\n", lfjack->force_mixer));
+}
+
+static ssize_t set_force_mixer(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int value;
+
+	if (sscanf(buf, "%x", &value) != 1)
+		return -EINVAL;
+
+	lfjack->force_mixer = value;
+	switch(lfjack->force_mixer) {
+	case MIXER_NORMAL:
+		break;
+	case MIXER_MONO:
+		lfjack->codec->write(lfjack->codec, CS43L22_MIXER,
+				CS43L22_MIXER_MONO);
+		break;
+	default:
+		break;
+	}
+
+	lfjack->update_jack = 1;	/* update jack if not forced */
+	return count;
+}
+
+static DEVICE_ATTR(force_mixer, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+	show_force_mixer, set_force_mixer);
+
+static struct attribute *cs43l22_attributes[] = {
+	&dev_attr_force_audio.attr,
+	&dev_attr_force_mixer.attr,
+	NULL
+};
+
+static struct attribute_group cs43l22_attr_group = {
+	.attrs = cs43l22_attributes
+};
+
+
+/*
+ * Board ops
+ */
+
+static int didj_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, DIDJ_DEFAULT_RATE, 1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int didj_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params), 1);
+	
+	return 0;
+}
+
+static struct snd_soc_ops didj_ops = {
+	.startup	= didj_startup,
+	.hw_params	= didj_hw_params,
+};
+
+/* didj digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link didj_dai_cs43l22[] = {
+	{
+		.name = "CS43L22",
+		.stream_name = "CS43L22",
+		.cpu_dai = &lf1000_i2s_dai,
+		.codec_dai = &cs43l22_dai,
+		.ops = &didj_ops,
+	},
+};
+
+/* didj audio machine driver */
+static struct snd_soc_card snd_soc_didj_cs43l22 = {
+	.name = "Didj-CS43L22",
+	.platform = &lf1000_soc_platform,
+	.dai_link = didj_dai_cs43l22,
+	.num_links = ARRAY_SIZE(didj_dai_cs43l22),
+};
+
+/* didj audio private data */
+static struct cs43l22_setup_data didj_cs43l22_setup = {
+	.i2c_bus	= 0,
+	.i2c_address	= CS43L22_ADDR,
+};
+
+/* didj audio subsystem */
+static struct snd_soc_device didj_snd_devdata_cs43l22 = {
+	.card = &snd_soc_didj_cs43l22,
+	.codec_dev = &soc_codec_dev_cs43l22,
+	.codec_data = &didj_cs43l22_setup,
+	.dev = NULL, /* set in didj_audio_probe */
+};
+
+static int lfjack_detect(void *data)
+{
+	struct lfjack_priv *priv = (struct lfjack_priv *)data;
+	int cur_jack;
+
+	while (1) {
+		if (!priv->run) {
+			up(&priv->detect_thread_done);
+			do_exit(0);
+		}
+
+		cur_jack = gpio_get_val(lf1000_l2p_port(HEADPHONE_JACK),
+			lf1000_l2p_pin(HEADPHONE_JACK));
+
+		/* ignore if mixer forced already */
+		if (priv->force_mixer == MIXER_NORMAL &&
+		    priv->force_mixer == MIXER_NORMAL &&
+		    (cur_jack != priv->last_jack || priv->update_jack)) {
+			/* change in status? */
+			if (!cur_jack) {
+				priv->codec->write(priv->codec, CS43L22_MIXER,
+					priv->reg26_mixer_jack_low);
+			} else {
+				priv->codec->write(priv->codec, CS43L22_MIXER,
+					priv->reg26_mixer_jack_high);
+			}
+			priv->last_jack = cur_jack;
+			priv->update_jack = 0;
+		}
+		msleep(250);	/* sample 4 times a second */
+	}
+
+}
+
+static struct platform_device *didj_snd_device = NULL;
+
+static int didj_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_codec *codec;
+	int ret;
+	int i;
+
+	dev_info(&pdev->dev, "%s\n", __FUNCTION__);
+
+	didj_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!didj_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(didj_snd_device, &didj_snd_devdata_cs43l22);
+	didj_snd_devdata_cs43l22.dev = &didj_snd_device->dev;
+	
+	ret = platform_device_add(didj_snd_device);
+	if (ret) {
+		dev_err(&pdev->dev, "can't add sound device\n");
+		platform_device_put(didj_snd_device);
+		return ret;
+	}
+
+	/* program codec defaults */
+	codec = didj_snd_devdata_cs43l22.card->codec;
+	for (i = 0; i < ARRAY_SIZE(cs43L22_settings); i++)
+		codec->write(codec, cs43L22_settings[i][0],
+				cs43L22_settings[i][1]);
+
+	/* setup headphone jack monitoring */
+	lfjack = kzalloc(sizeof(struct lfjack_priv), GFP_KERNEL);
+	if (!lfjack)
+		return -ENOMEM;
+
+	lfjack->codec = codec;	/* point at codec */
+
+	/* configure_pin(PORT, PIN, FUNCTION IN=0, PULLUP=1, VALUE) */
+	gpio_configure_pin(lf1000_l2p_port(HEADPHONE_JACK),
+		lf1000_l2p_pin(HEADPHONE_JACK), GPIO_GPIOFN, 0, 1, 0);
+
+	/* initialize headphone state */
+	lfjack->last_jack = (gpio_get_val(lf1000_l2p_port(HEADPHONE_JACK),
+		lf1000_l2p_pin(HEADPHONE_JACK)) == 1);
+
+	lfjack->update_jack = 1;	/* update headphone/mixer setting */
+
+	/* set cs43L22 register control values */
+	lfjack->reg26_mixer_jack_low = CS43L22_MIXER_MONO;
+	lfjack->reg26_mixer_jack_high = CS43L22_MIXER_STEREO;
+
+	lfjack->debug = debugfs_create_dir("lfjack", NULL);
+	if (IS_ERR(lfjack->debug))
+		lfjack->debug = NULL;
+
+	if (lfjack->debug) {
+		debugfs_create_bool("last_jack", S_IRUGO, lfjack->debug,
+			(u32 *)&lfjack->last_jack);
+	}
+
+	/* start jack thread */
+	sema_init(&lfjack->detect_thread_done, 0);
+	lfjack->run = 1;
+	lfjack->detect_thread = kthread_run(lfjack_detect, (void *)lfjack,
+		"lfjack-detect");
+
+	sysfs_create_group(&pdev->dev.kobj, &cs43l22_attr_group);
+	return 0;
+}
+
+static int __devexit didj_audio_remove(struct platform_device *pdev)
+{
+	lfjack->run = 0;
+	down(&lfjack->detect_thread_done);
+	if (lfjack->debug)
+		debugfs_remove(lfjack->debug);
+	kfree(lfjack);
+	sysfs_remove_group(&pdev->dev.kobj, &cs43l22_attr_group);
+	platform_device_unregister(didj_snd_device);
+	didj_snd_device = NULL;
+
+	return 0;
+}
+
+static struct platform_driver didj_audio_driver = {
+	.probe	= didj_audio_probe,
+	.remove	= didj_audio_remove,
+	.driver	= {
+		.name	= "didj-asoc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init didj_audio_init(void)
+{
+	return platform_driver_register(&didj_audio_driver);
+}
+module_init(didj_audio_init);
+
+static void __exit didj_audio_exit(void)
+{
+	platform_driver_unregister(&didj_audio_driver);
+}
+module_exit(didj_audio_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_DESCRIPTION("ALSA SoC Didj Consoles");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/sound/soc/lf1000/didj-cs43l22.h linux-2.6/sound/soc/lf1000/didj-cs43l22.h
--- linux-2.6.31/sound/soc/lf1000/didj-cs43l22.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/didj-cs43l22.h	2011-01-04 14:39:45.000000000 -0800
@@ -0,0 +1,57 @@
+#ifndef __DIDJ_CS43L22_H__
+#define __DIDJ_CS43L22_H__
+
+/* register to value */
+u8 cs43L22_settings[][2] = {
+	{0x02, 0x01}, /* Power Control 1 */
+	{0x03, 0x07}, /* Power Control 2 */
+	{0x05, 0xA0}, /* Clocking Control */
+	{0x06, 0x27}, /* Interface Control 1, Slave, I2S */
+	{0x07, 0x00}, /* Interface Control 2 */
+	{0x08, 0x81}, /* Input A Select ADCA and PGAA */
+	{0x09, 0x81}, /* Input B Select ADCB and PGAB */
+	{0x0A, 0xA5}, /* Analog & HPF Control */
+	{0x0B, 0x00}, /* ADC HPF Corner Frequency */
+	{0x0C, 0x00}, /* Misc ADC Control */
+	{0x0D, 0x10}, /* Playback Control 1 */
+	{0x0E, 0x02}, /* Passthru Analog, adjust volume at zero-crossings */
+	{0x0F, 0xFA}, /* Playback Control 2, mute headphone and speaker */
+	{0x10, 0x00}, /* MIC A */
+	{0x11, 0x00}, /* MIC B */
+	{0x12, 0x00}, /* ALC, PGA A */
+	{0x13, 0x00}, /* ALC, PGA B */
+	{0x14, 0x00}, /* Passthru A Volume */
+	{0x15, 0x00}, /* Passthru B Volume */
+	{0x16, 0x00}, /* ADC A Volume */
+	{0x17, 0x00}, /* ADC B Volume */
+	{0x18, 0x80}, /* ADC Mixer Channel A Mute */
+	{0x19, 0x80}, /* ADC Mixer Channel B Mute */
+	{0x1A, 0x00}, /* PCMA Mixer Volume */
+	{0x1B, 0x00}, /* PCMB Mixer Volume */
+	{0x1C, 0x00}, /* Beep Frequency */
+	{0x1D, 0x00}, /* Beep On Time */
+	{0x1E, 0x3F}, /* Beep & Tone Configuration */
+	{0x1F, 0xFF}, /* Tone Control */
+	{0x20, 0x06}, /* Master Volume Control MSTA */
+	{0x21, 0x06}, /* Master Volume Control MSTB */
+	{0x22, 0x90}, /* Headphone Volume Control HPA */
+	{0x23, 0x90}, /* Headphone Volume Control HPB */
+	{0x24, 0xD3}, /* Speaker Volume Control SPKA */
+	{0x25, 0xD3}, /* Speaker Volume Control SPKB */
+	{0x26, 0x50}, /* ADC & PCM Channel Mixer */
+	{0x27, 0x04}, /* Limiter Control 1 */
+	{0x28, 0x8A}, /* Limiter Control 2 */
+	{0x29, 0xC3}, /* Limiter Attack Rate */
+	{0x2A, 0x00}, /* ALC Enable & Attack Rate */
+	{0x2B, 0x00}, /* ALC Release Rate */
+	{0x2C, 0x00}, /* ALC Threshold */
+	{0x2D, 0x00}, /* Noise Gate Control */
+	{0x2F, 0x00}, /* Battery Compensation */
+	{0x32, 0x00}, /* Temperature monitor Control */
+	{0x33, 0x00}, /* Thermal Foldback */
+	{0x34, 0x5F}, /* Charge Pump Frequency */
+	{0x02, 0x9E}, /* Power Control 1 */
+	{0x04, 0x50}, /* Power Control 3 (speaker control) */
+};
+
+#endif /* __DIDJ_CS43L22_H__ */
diff -ruaN linux-2.6.31/sound/soc/lf1000/didj-lfp100.c linux-2.6/sound/soc/lf1000/didj-lfp100.c
--- linux-2.6.31/sound/soc/lf1000/didj-lfp100.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/didj-lfp100.c	2011-05-16 18:39:22.000000000 -0700
@@ -0,0 +1,210 @@
+/*
+ * linux/sound/soc/lf1000/didj-lfp100.c
+ *
+ * ALSA Machine driver for the LeapFrog LF1000 Didj style game console.
+ * Supports the audio codec part of the LeapFrog LFP100 power/codec chip,
+ * connected to the LF1000 SoC's I2S controller.
+ *
+ * Authors: Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/sysfs.h>
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+
+#include <mach/gpio.h>
+
+#include "lf1000-pcm.h"
+#include "lf1000-i2s.h"
+#include "didj-lfp100.h"
+#include "../codecs/lfp100.h"
+
+#define DIDJ_DEFAULT_RATE	32000
+
+static struct platform_device *didj_snd_device = NULL;
+
+/*
+ * Board ops
+ */
+
+static int didj_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, DIDJ_DEFAULT_RATE, 1);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int didj_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	return snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params), 1);
+
+	return 0;
+}
+
+static struct snd_soc_ops didj_ops = {
+	.startup	= didj_startup,
+	.hw_params	= didj_hw_params,
+};
+
+/* didj digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link didj_dai_lfp100[] = {
+	{
+		.name = "LFP100",
+		.stream_name = "LFP100",
+		.cpu_dai = &lf1000_i2s_dai,
+		.codec_dai = &lfp100_dai,
+		.ops = &didj_ops,
+	},
+};
+
+/* didj audio machine driver */
+static struct snd_soc_card snd_soc_didj_lfp100 = {
+	.name = "Didj-LFP100",
+	.platform = &lf1000_soc_platform,
+	.dai_link = didj_dai_lfp100,
+	.num_links = ARRAY_SIZE(didj_dai_lfp100),
+};
+
+/* didj audio private data */
+static struct lfp100_setup_data didj_lfp100_setup = {
+	.i2c_bus	= 0,
+	.i2c_address	= LFP100_ADDR,
+};
+
+/* didj audio subsystem */
+static struct snd_soc_device didj_snd_devdata_lfp100 = {
+	.card = &snd_soc_didj_lfp100,
+	.codec_dev = &soc_codec_dev_lfp100,
+	.codec_data = &didj_lfp100_setup,
+	.dev = NULL, /* set in didj_audio_probe */
+};
+
+/*
+ * sysfs interface
+ */
+
+static ssize_t show_force_audio(struct device *dev,
+                struct device_attribute *attr, char *buf)
+{
+	struct lfp100_private *lfp100 = didj_dai_lfp100->codec_dai->codec->private_data;
+
+        return(sprintf(buf,"%u\n", lfp100->force_audio));
+}
+
+static ssize_t set_force_audio(struct device *dev,
+                struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lfp100_private *lfp100 = didj_dai_lfp100->codec_dai->codec->private_data;
+        unsigned int value;
+
+        if (sscanf(buf, "%x", &value) != 1)
+                return -EINVAL;
+
+        lfp100->force_audio = value;
+        return count;
+}
+
+static DEVICE_ATTR(force_audio, S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH,
+        show_force_audio, set_force_audio);
+
+static struct attribute *lfp100_attributes[] = {
+        &dev_attr_force_audio.attr,
+        NULL
+};
+
+static struct attribute_group lfp100_attr_group = {
+	.attrs = lfp100_attributes
+};
+
+static int didj_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_codec *codec;
+	int ret;
+	int i;
+
+	dev_info(&pdev->dev, "%s.%d\n", __FUNCTION__, __LINE__);
+
+	didj_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!didj_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(didj_snd_device, &didj_snd_devdata_lfp100);
+	didj_snd_devdata_lfp100.dev = &didj_snd_device->dev;
+	
+	ret = platform_device_add(didj_snd_device);
+	if (ret) {
+		dev_err(&pdev->dev, "can't add sound device\n");
+		platform_device_put(didj_snd_device);
+		return ret;
+	}
+
+	/* program codec defaults */
+	codec = didj_snd_devdata_lfp100.card->codec;
+	for (i = 0; i < ARRAY_SIZE(lfp100_settings); i++) {
+		codec->write(codec, lfp100_settings[i][0],
+			lfp100_settings[i][1]);
+	}
+
+	sysfs_create_group(&pdev->dev.kobj, &lfp100_attr_group);
+	return 0;
+}
+
+static int __devexit didj_audio_remove(struct platform_device *pdev)
+{
+	platform_device_unregister(didj_snd_device);
+	sysfs_remove_group(&pdev->dev.kobj, &lfp100_attr_group);
+	didj_snd_device = NULL;
+
+	return 0;
+}
+
+static struct platform_driver didj_audio_driver = {
+	.probe	= didj_audio_probe,
+	.remove	= didj_audio_remove,
+	.driver	= {
+		.name	= "didj-asoc",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init didj_audio_init(void)
+{
+	return platform_driver_register(&didj_audio_driver);
+}
+module_init(didj_audio_init);
+
+static void __exit didj_audio_exit(void)
+{
+	platform_driver_unregister(&didj_audio_driver);
+}
+module_exit(didj_audio_exit);
+
+MODULE_AUTHOR("Scott Esters <sesters@leapfrog.com>");
+MODULE_AUTHOR("Andrey Yurovsky <ayurovsky@leapfrog.com>");
+MODULE_DESCRIPTION("ALSA SoC Didj Consoles");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/sound/soc/lf1000/didj-lfp100.h linux-2.6/sound/soc/lf1000/didj-lfp100.h
--- linux-2.6.31/sound/soc/lf1000/didj-lfp100.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/didj-lfp100.h	2011-03-11 14:13:40.000000000 -0800
@@ -0,0 +1,22 @@
+#ifndef __DIDJ_LFP100_H__
+#define __DIDJ_LFP100_H__
+
+#include <mach/lfp100.h>
+
+/* register to value */
+u8 lfp100_settings[][2] = {
+	{LFP100_A_CONTROL, 0x00},
+	{LFP100_FORMAT_PW, 0xE6},  /* I2S Format Register, 64 bit frame   */
+	{LFP100_MGAIN, 0x80},	   /* set master gain to 0dB and mute	  */
+	{LFP100_VLIMIT_PW, 0x00},  /* allow full volume range */
+	{LFP100_GAINADJ_PW, 0x2B}, /* bump speaker gain up 6 db */
+	{LFP100_SLEW_PW, 0x5E},	   /* force DCDC1 and DCDC2 to PWM mode */
+	/*
+	 * FIXME for 1p2 change to CHMOD=1 (per Ivo)
+	 * this should speed the switching between headphone and speaker
+	 */
+	{LFP100_A_APOP_PW, 0x1D},  /* CHMOD=0, CHTIM=1200ms, RPOP=20K */
+	{LFP100_FILTER, 0x01},     /* disable clipping PGA_CLIP=0 */
+};
+
+#endif /* __DIDJ_LFP100_H__ */
diff -ruaN linux-2.6.31/sound/soc/lf1000/Kconfig linux-2.6/sound/soc/lf1000/Kconfig
--- linux-2.6.31/sound/soc/lf1000/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/Kconfig	2011-01-04 14:39:04.000000000 -0800
@@ -0,0 +1,36 @@
+config SND_LF1000_SOC
+	tristate "SoC Audio for the LeapFrog LF1000 chips"
+	depends on ARCH_LF1000
+	select LF1000_DMA_CONTROLLER
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the LF1000 I2S interface.
+
+config SND_LF1000_SOC_DEBUG
+	bool "Additional debugging for the LF1000 SoC Audio"
+	default N
+	depends on ARCH_LF1000 && SND_LF1000_SOC
+	help
+	  Say Y here to see additional debug statements from the LF1000 SoC
+	  drivers.  They may affect timing.  If unsure, say N.
+
+config SND_LF1000_SOC_I2S
+	tristate
+
+config SND_LF1000_SOC_DIDJ_CS43L22
+	tristate "SoC Audio support for LeapFrog Didj with Cirrus Logic codec"
+	depends on SND_LF1000_SOC && ARCH_LF1000
+	select SND_LF1000_SOC_I2S
+	select SND_SOC_CS43L22
+	help
+	  Say Y or M if you want to enable support for audio on a Didj with the
+	  Cirrus Logic codec.  If unsure, say M.
+
+config SND_LF1000_SOC_DIDJ_LFP100
+	tristate "SoC Audio support for LeapFrog Didj with LFP100 codec"
+	depends on SND_LF1000_SOC && ARCH_LF1000
+	select SND_LF1000_SOC_I2S
+	select SND_SOC_LFP100
+	help
+	  Say Y or M if you want to enable support for audio on a Didj with the
+	  LFP100 codec.  If unusre, say M.
diff -ruaN linux-2.6.31/sound/soc/lf1000/lf1000-i2s.c linux-2.6/sound/soc/lf1000/lf1000-i2s.c
--- linux-2.6.31/sound/soc/lf1000/lf1000-i2s.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/lf1000-i2s.c	2012-11-16 18:20:36.000000000 -0800
@@ -0,0 +1,630 @@
+/* sound/soc/lf1000/lf1000-i2s.c
+ *
+ * ALSA SoC Audio Layer - LF1000 I2S driver
+ *
+ * Copyright (c) 2010 LeapFrog Enterprises Inc.
+ * 	Andrey Yurovsky <ayurovsky@leapfrog.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/platform.h>
+#include <mach/gpio.h>
+
+#include "lf1000-pcm.h"
+
+#define DRIVER_NAME	"lf1000-i2s"
+
+#ifdef CONFIG_SND_LF1000_SOC_DEBUG
+#define dbg(x...)	printk(KERN_ALERT DRIVER_NAME ": " x)
+#else
+#define dbg(x...)
+#endif
+
+#define LF1000_I2S_RATES	(SNDRV_PCM_RATE_CONTINUOUS | \
+		SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | \
+		SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \
+		SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | \
+		SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \
+		SNDRV_PCM_RATE_192000)
+
+
+/* registers */
+#define I2S_CTRL			0x04
+#define I2S_CONFIG			0x06
+#define AUDIO_BUFF_CTRL			0x08
+#define AUDIO_BUFF_CONFIG		0x0A
+#define AUDIO_IRQ_ENA			0x0C
+#define AUDIO_IRQ_PEND			0x0E
+#define AUDIO_STATUS1			0x18
+#define CLKENB				0x3C0	/* u32 */
+#define CLKGEN0				0x3C4
+#define CLKGEN1				0x3C8
+
+/* I2S control register (I2S_CTRL) */
+#define I2SLINK_RUN			(0x1 << 1)
+#define I2S_EN				(0x1)
+#define I2S_RESET			(0)
+
+/* I2S config register (I2S_CONFIG) */
+#define IFMODE_I2S			(0x0)
+#define IFMODE_LJ			(0x2 << 6)
+#define IFMODE_RJ			(0x3 << 6)
+#define IFMODE_MASK			(0x3 << 6)
+#define SYNC_32FS			(0x0)
+#define SYNC_48FS			(0x1 << 4)
+#define SYNC_64FS			(0x2 << 4)
+#define SYNC_MASK			(0x3 << 4)
+#define LOOP_BACK			(0x1 << 3)
+#define I2SI_EN				(0x1 << 2)
+#define I2SO_EN				(0x1 << 1)
+#define CTL_MST				(0)
+#define CTL_SLV				(0x1)
+
+/* Buffer control register (AUDIO_BUFF_CTRL) */
+#define PCMIBUF_EN			(0x1 << 1)
+#define PCMOBUF_EN			(0x1)
+
+/* Buffer config register (AUDIO_BUFF_CONFIG) */
+#define PI_WIDTH_MASK			(0x3 << 4)
+#define PO_WIDTH_MASK			(0x3)
+
+#define BUF_WIDTH_16BIT			(0x0)
+#define BUF_WIDTH_18BIT			(0x3)
+
+/* IRQ enable/status register (AUDIO_IRQ_ENA/AUDIO_IRQ_PEND) */
+#define IRQ_PIOVER			(0x1 << 1)
+#define IRQ_POUDR			(0x1)
+
+/* CLKENB register (I2S_CLKENB) */
+#define PCLKMODE_DYNAMIC	(0)
+#define PCLKMODE_ALWAYS		(0x1 << 3)
+#define CLKGENENB		(0x1 << 2)
+
+/* CLKGEN0 register */
+#define CLKDIV_MASK		(0x3F << 4)
+#define set_clk_div(reg, x)	(reg |= ((x - 1) << 4))
+#define clear_clk_div(reg)	(reg &= ~CLKDIV_MASK)
+#define CLKSRC_PLL0		(0)
+#define CLKSRC_PLL1		(0x1 << 1)
+#define CLKSRC_BCLK		(0x3 << 1)
+#define CLKSRC_IBCLK		(0x4 << 1)
+#define CLKSRC_AVCLK		(0x5 << 1)
+#define CLKSRC_IAVCLK		(0x6 << 1)
+
+#define CLKSRC_MASK		(0x7 << 1)
+        
+#define OUTCLKINV		(0x1 << 0)
+#define OUTCLKENB		(0x1 << 15)     // 0: Output, 1: Input
+
+/* CLKGEN1 register */
+#define CLKSRC_CLKGEN0		(0x7 << 1) 
+
+const static struct lf1000_pcm_dma_params lf1000_i2s_pcm_stereo_out = {
+	.name		= "I2S PCM Stereo out",
+	.dma_addr	= LF1000_AUDIO_BASE,
+	.dma_size	= 4,
+};
+
+const static struct lf1000_pcm_dma_params lf1000_i2s_pcm_stereo_in = {
+	.name		= "I2S PCM Stereo in",
+	.dma_addr	= LF1000_AUDIO_BASE,
+	.dma_size	= 4,
+};
+
+struct lf1000_i2s_info {
+	void __iomem *adi_base;
+	u32 rate;
+	u32 div;
+	unsigned short	bitwidth;
+	unsigned int i2s_format;
+	u32 underruns;
+	u32 overruns;
+
+	int irq;
+
+	struct dentry	*debug;
+};
+
+static struct lf1000_i2s_info lf1000_i2s;
+
+static void lf1000_i2s_show_u16(struct seq_file *s, const char *nm, u32 reg)
+{	
+	struct lf1000_i2s_info *lf1000_i2s = s->private;
+
+	seq_printf(s, "%17s:  0x%04X\n", nm, readw(lf1000_i2s->adi_base + reg));
+}
+
+static void lf1000_i2s_show_u32(struct seq_file *s, const char *nm, u32 reg)
+{	
+	struct lf1000_i2s_info *lf1000_i2s = s->private;
+
+	seq_printf(s, "%17s:  0x%08X\n", nm, readl(lf1000_i2s->adi_base + reg));
+}
+
+static int lf1000_i2s_regs_show(struct seq_file *s, void *v)
+{
+	lf1000_i2s_show_u16(s, "I2S_CTRL", I2S_CTRL);
+	lf1000_i2s_show_u16(s, "I2S_CONFIG", I2S_CONFIG);
+	lf1000_i2s_show_u16(s, "AUDIO_BUFF_CTRL", AUDIO_BUFF_CTRL);
+	lf1000_i2s_show_u16(s, "AUDIO_BUFF_CONFIG", AUDIO_BUFF_CONFIG);
+	lf1000_i2s_show_u16(s, "AUDIO_IRQ_ENA", AUDIO_IRQ_ENA);
+	lf1000_i2s_show_u16(s, "AUDIO_IRQ_PEND", AUDIO_IRQ_PEND);
+	lf1000_i2s_show_u16(s, "AUDIO_STATUS1", AUDIO_STATUS1);
+	lf1000_i2s_show_u32(s, "CLKENB", CLKENB);
+	lf1000_i2s_show_u16(s, "CLKGEN0", CLKGEN0);
+	lf1000_i2s_show_u16(s, "CLKGEN1", CLKGEN1);
+
+	return 0;
+}
+
+static int lf1000_i2s_regs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, lf1000_i2s_regs_show, inode->i_private);
+}
+
+static const struct file_operations lf1000_i2s_regs_fops = {
+	.owner		= THIS_MODULE,
+	.open		= lf1000_i2s_regs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static irqreturn_t lf1000_i2s_irq(int irq, void *dev_id)
+{
+	struct lf1000_i2s_info *lf1000_i2s = dev_id;
+	u16 reg = readw(lf1000_i2s->adi_base + AUDIO_IRQ_PEND);
+
+	if (reg & IRQ_POUDR)
+		lf1000_i2s->underruns++;
+
+	if (reg & IRQ_PIOVER)
+		lf1000_i2s->overruns++;
+	
+	writew(IRQ_POUDR | IRQ_PIOVER, lf1000_i2s->adi_base + AUDIO_IRQ_PEND);
+
+	return IRQ_HANDLED;
+}
+
+/* Set the I2S format: we support data in I2S, left, and right justified format
+ * as well as inverting the signals or not. */
+
+static int lf1000_i2s_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	unsigned int regs;
+
+	dbg("%s.%d entered\n", __FUNCTION__, __LINE__);
+
+	/* set the I2S format */
+	regs = readw(lf1000_i2s.adi_base + I2S_CONFIG);
+	regs &= ~IFMODE_MASK;
+
+	dev_dbg(dai->dev, "changing I2S format to 0x%X",
+			fmt & SND_SOC_DAIFMT_FORMAT_MASK);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SND_SOC_DAIFMT_I2S:
+			// 00b is I2S
+			break;
+		case SND_SOC_DAIFMT_RIGHT_J:
+			regs |= IFMODE_RJ;
+			break;
+		case SND_SOC_DAIFMT_LEFT_J:
+			regs |= IFMODE_LJ;
+			break;
+		default:
+			return -EINVAL;
+	}
+	writew(regs, lf1000_i2s.adi_base + I2S_CONFIG);
+
+	/* set invert mode */
+	regs = readw(lf1000_i2s.adi_base + CLKGEN1);
+
+	dev_dbg(dai->dev, "changing I2S invert to: %d\n",
+			fmt & SND_SOC_DAIFMT_INV_MASK);
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+			regs &= ~OUTCLKINV;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			regs |= OUTCLKINV;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	writew(regs, lf1000_i2s.adi_base + CLKGEN1);
+	
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
+		unsigned int freq, int dir)
+{
+	unsigned int regs;
+	int pll = get_pll_freq(PLL0);
+
+	dbg("%s.%d entered\n", __FUNCTION__, __LINE__);
+	lf1000_i2s.div = lf1000_CalcDivider(pll, 256 * freq);
+	if (lf1000_i2s.div <= 0 || lf1000_i2s.div > 64) {
+		dev_err(dai->dev, "invalid clock div: %d (freq=%d)\n",
+				lf1000_i2s.div, freq);
+		lf1000_i2s.div = 64;
+	}
+
+	lf1000_i2s.rate = get_pll_freq(PLL0)/lf1000_i2s.div/256;
+
+	if (lf1000_i2s.rate != freq)
+		dev_info(dai->dev, "setting %dHz instead of %dHz\n",
+				lf1000_i2s.rate, freq);
+
+	/* use PLL0/lf1000_i2s.div, don't invert clock */
+	regs = readw(lf1000_i2s.adi_base + CLKGEN0);
+
+	clear_clk_div(regs);
+	set_clk_div(regs, lf1000_i2s.div);
+	writew(regs | CLKSRC_PLL0, lf1000_i2s.adi_base + CLKGEN0);
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_set_dai_clkdiv(struct snd_soc_dai *dai, int div_id,
+		int div)
+{
+	unsigned int regs;
+
+	dbg("%s.%d entered\n", __FUNCTION__, __LINE__);
+ 
+	if (div <= 0 || div > 64)
+		return -EINVAL;
+
+	lf1000_i2s.div = div;
+	lf1000_i2s.rate = get_pll_freq(PLL0)/lf1000_i2s.div/256;
+
+	regs = readw(lf1000_i2s.adi_base + CLKGEN0);
+
+	clear_clk_div(regs);
+	set_clk_div(regs, div);
+	writew(regs | CLKSRC_PLL0, lf1000_i2s.adi_base + CLKGEN0);
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	unsigned int regs, bitwidth, rate, channels;
+
+	bitwidth = params_format(params);
+	dbg("%s.%d entered  - %p(%d)-%p,%d\n",
+		__FUNCTION__, __LINE__, substream,
+		substream->stream, rtd->dai->cpu_dai->dma_data, bitwidth);
+
+	// check parameter
+	if (bitwidth != SNDRV_PCM_FORMAT_S16) {
+		dev_err(dai->dev, "wrong format: %X\n", bitwidth);
+		return -EINVAL;
+	}
+
+	channels = params_channels(params);
+	rate = params_rate(params);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		rtd->dai->cpu_dai->dma_data =
+					(void *)&lf1000_i2s_pcm_stereo_out;
+	else
+		rtd->dai->cpu_dai->dma_data =
+					(void *)&lf1000_i2s_pcm_stereo_in;
+
+	regs = readw(lf1000_i2s.adi_base + AUDIO_BUFF_CONFIG);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regs &= ~PO_WIDTH_MASK;
+		regs |= BUF_WIDTH_16BIT;
+	} else {
+		regs &= ~PI_WIDTH_MASK;
+		regs |= (BUF_WIDTH_16BIT << 4);
+	}
+
+	writew(regs, lf1000_i2s.adi_base + AUDIO_BUFF_CONFIG);
+	lf1000_i2s.bitwidth = bitwidth;
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	unsigned int regs;
+
+	dbg("%s.%d entered substream->stream=%d\n",
+		__FUNCTION__, __LINE__, substream->stream);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* enable PCM output buffer */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_BUFF_CTRL);
+		regs |= PCMOBUF_EN;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_BUFF_CTRL);
+
+		/* clear IRQ pending */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_IRQ_PEND);
+		regs |= IRQ_POUDR;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_IRQ_PEND);
+
+		/* Enable IRQ */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_IRQ_ENA);
+		regs |= IRQ_POUDR;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_IRQ_ENA);
+	} else {
+		/* enable PCM input buffer */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_BUFF_CTRL);
+		regs |= PCMIBUF_EN;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_BUFF_CTRL);
+
+		/* clear IRQ pending */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_IRQ_PEND);
+		regs |= IRQ_PIOVER;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_IRQ_PEND);
+
+		/* Enable IRQ */
+		regs = readw(lf1000_i2s.adi_base + AUDIO_IRQ_ENA);
+		regs |= IRQ_PIOVER;
+		writew(regs, lf1000_i2s.adi_base + AUDIO_IRQ_ENA);
+	}
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+	unsigned int regs;
+
+	dbg("%s.%d Entered cmd=%d\n", __FUNCTION__, __LINE__, cmd);
+	switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+
+			/* Link Run */
+			regs = readw(lf1000_i2s.adi_base + I2S_CTRL);
+			regs |= I2SLINK_RUN;
+			writew(regs, lf1000_i2s.adi_base + I2S_CTRL);
+
+			/* Enable I/O */
+			regs = readw(lf1000_i2s.adi_base + I2S_CONFIG);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				regs |= I2SO_EN;
+			else
+				regs |= I2SI_EN;
+			writew(regs, lf1000_i2s.adi_base + I2S_CONFIG);
+		break;
+
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		
+			/* Link Stop */
+			regs = readw(lf1000_i2s.adi_base + I2S_CTRL);
+			regs &= ~I2SLINK_RUN;
+			writew(regs, lf1000_i2s.adi_base + I2S_CTRL);
+			
+			/* Disable I/O */
+			regs = readw(lf1000_i2s.adi_base + I2S_CONFIG);
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				regs &= ~I2SO_EN;
+			else
+				regs &= ~I2SI_EN;
+			writew(regs, lf1000_i2s.adi_base + I2S_CONFIG);
+		break;
+
+		default:
+			return -EINVAL;
+			break;
+	}
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_register_init(struct lf1000_i2s_info *i2sdev)
+{
+	unsigned int regs;
+
+	dbg("%s.%d entered\n", __FUNCTION__, __LINE__);
+	/* I2S Control */
+	regs = I2S_RESET;
+	writew(regs, i2sdev->adi_base + I2S_CTRL);
+
+	/* clock enable */
+	regs = PCLKMODE_ALWAYS | CLKGENENB;
+	writew(regs, i2sdev->adi_base + CLKENB);
+
+	/* I2S Control */
+	regs = I2S_EN;
+	writew(regs, i2sdev->adi_base + I2S_CTRL);
+
+	/* I2S Config */
+	regs = IFMODE_I2S | SYNC_64FS | CTL_MST;
+	writew(regs, i2sdev->adi_base + I2S_CONFIG);
+
+	/* calculate master clock initially for 32KHz */
+	i2sdev->div = lf1000_CalcDivider(get_pll_freq(PLL0), 256 * 32000);
+	if (i2sdev->div <= 0 || i2sdev->div > 64) {
+		dbg("invalid clock div: %d (freq=%d)\n",
+				i2sdev->div, 32000);
+		i2sdev->div=64;
+	}
+
+	/* Turn on Master Clock */
+	regs = readw(i2sdev->adi_base + CLKGEN0);
+	clear_clk_div(regs);
+	set_clk_div(regs, i2sdev->div);
+	regs |= CLKSRC_PLL0;
+
+	/* invert i2s MCLK on LFP100 only */
+	regs &= ~OUTCLKINV;
+
+	writew(regs, i2sdev->adi_base + CLKGEN0);
+
+	/* start bit clock too */
+	regs = readw(i2sdev->adi_base + CLKGEN1);
+	clear_clk_div(regs);
+	set_clk_div(regs, 4);
+	writew(regs | CLKSRC_CLKGEN0, i2sdev->adi_base + CLKGEN1);
+	
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_i2s_probe(struct platform_device *pdev,
+			    struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	dbg("Entered %s.%d\n", __FUNCTION__, __LINE__);
+
+	if (!pdev)
+		dbg("pdev is NULL\n");
+	else {
+		dbg("pdev->name is '%s'\n", pdev->name);
+		dai->dev = &pdev->dev; /* for debug messages -- Doh! */
+	}
+
+	memset(&lf1000_i2s, 0, sizeof(struct lf1000_i2s_info));
+
+	lf1000_i2s.adi_base = (void __iomem*)IO_ADDRESS(LF1000_AUDIO_BASE);
+	if (!lf1000_i2s.adi_base) {
+		dev_err(&pdev->dev, "lf1000 ADI ioremap error\n");
+		ret = -ENOENT;
+		goto out_remap;
+	}
+
+	lf1000_i2s.irq = LF1000_AUDIO_IRQ;
+
+	/* I2S Data Bus (ALT1: I2S, ALT2: AC97)*/
+	gpio_configure_pin(GPIO_PORT_A, GPIO_PIN21, GPIO_ALT1, 1, 0, 0);
+	gpio_configure_pin(GPIO_PORT_A, GPIO_PIN22, GPIO_ALT1, 1, 0, 0);
+	gpio_configure_pin(GPIO_PORT_A, GPIO_PIN23, GPIO_ALT1, 1, 0, 0);
+	gpio_configure_pin(GPIO_PORT_A, GPIO_PIN24, GPIO_ALT1, 1, 0, 0);
+	gpio_configure_pin(GPIO_PORT_A, GPIO_PIN25, GPIO_ALT1, 1, 0, 0);
+
+	ret = request_irq(lf1000_i2s.irq, lf1000_i2s_irq, 0, DRIVER_NAME,
+		&lf1000_i2s);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request IRQ\n");
+		goto out_irq;
+	}
+
+	lf1000_i2s_register_init(&lf1000_i2s);
+
+	lf1000_i2s.debug = debugfs_create_dir("lf1000-i2s", NULL);
+	if (!lf1000_i2s.debug || IS_ERR(lf1000_i2s.debug))
+		lf1000_i2s.debug = NULL;
+	
+	if (lf1000_i2s.debug) {
+		debugfs_create_file("registers", S_IRUSR, lf1000_i2s.debug,
+			&lf1000_i2s, &lf1000_i2s_regs_fops);
+		debugfs_create_u32("underruns", S_IRUSR, lf1000_i2s.debug,
+				&lf1000_i2s.underruns);
+		debugfs_create_u32("overruns", S_IRUSR, lf1000_i2s.debug,
+				&lf1000_i2s.overruns);
+		debugfs_create_u32("rate", S_IRUSR, lf1000_i2s.debug,
+				&lf1000_i2s.rate);
+		debugfs_create_u32("div", S_IRUSR, lf1000_i2s.debug,
+				&lf1000_i2s.div);
+	}
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+
+/* error condition exit */
+out_irq:
+	free_irq(lf1000_i2s.irq, &lf1000_i2s);
+out_remap:
+	return ret;
+}
+
+static void lf1000_i2s_remove(struct platform_device *pdev,
+			     struct snd_soc_dai *dai)
+{
+	dbg("Entered: %s.%d\n", __FUNCTION__, __LINE__);
+
+	if (lf1000_i2s.debug)
+		debugfs_remove_recursive(lf1000_i2s.debug);
+
+	free_irq(lf1000_i2s.irq, &lf1000_i2s);
+
+	memset(&lf1000_i2s, 0, sizeof(struct lf1000_i2s_info));
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+}
+
+static struct snd_soc_dai_ops lf1000_i2s_dai_ops = {
+	.set_sysclk	= lf1000_i2s_set_dai_sysclk,
+	.set_clkdiv	= lf1000_i2s_set_dai_clkdiv,
+	.set_fmt	= lf1000_i2s_set_dai_fmt,
+	.prepare	= lf1000_i2s_prepare,
+	.trigger	= lf1000_i2s_trigger,
+	.hw_params	= lf1000_i2s_hw_params,
+};
+
+
+struct snd_soc_dai lf1000_i2s_dai = {
+	.name		= DRIVER_NAME,
+	.id		= 0,
+	.probe		= lf1000_i2s_probe,
+	.remove		= lf1000_i2s_remove,
+	.playback	= {
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= LF1000_I2S_RATES,
+		.formats	= SNDRV_PCM_FMTBIT_S16,
+	},
+	.capture	= {
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= LF1000_I2S_RATES,
+		.formats	= SNDRV_PCM_FMTBIT_S16,
+	},
+	.ops = &lf1000_i2s_dai_ops,
+};
+
+EXPORT_SYMBOL_GPL(lf1000_i2s_dai);
+
+static int __init lf1000_i2s_init(void)
+{
+	return snd_soc_register_dai(&lf1000_i2s_dai);
+}
+
+static void __exit lf1000_i2s_exit(void)
+{
+	snd_soc_unregister_dai(&lf1000_i2s_dai);
+}
+
+module_init(lf1000_i2s_init);
+module_exit(lf1000_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("Scott Esters");
+MODULE_DESCRIPTION("LF1000 I2S SoC Interface");
+MODULE_LICENSE("GPL");
diff -ruaN linux-2.6.31/sound/soc/lf1000/lf1000-i2s.h linux-2.6/sound/soc/lf1000/lf1000-i2s.h
--- linux-2.6.31/sound/soc/lf1000/lf1000-i2s.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/lf1000-i2s.h	2011-01-04 14:37:00.000000000 -0800
@@ -0,0 +1,6 @@
+#ifndef __LF1000_I2S_H__
+#define __LF1000_I2S_H__
+
+extern struct snd_soc_dai lf1000_i2s_dai;
+
+#endif
diff -ruaN linux-2.6.31/sound/soc/lf1000/lf1000-pcm.c linux-2.6/sound/soc/lf1000/lf1000-pcm.c
--- linux-2.6.31/sound/soc/lf1000/lf1000-pcm.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/lf1000-pcm.c	2011-01-12 09:50:45.000000000 -0800
@@ -0,0 +1,475 @@
+/* 
+ * sound/soc/lf1000/lf1000-pcm.c
+ *
+ * ALSA SoC PCM/DMA interface for the LF1000 SoC.
+ *
+ * Copyright (c) 2010 LeapFrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include <sound/soc.h>
+
+#include <linux/module.h>
+
+#include <mach/platform.h>
+#include <mach/common.h>
+#include <mach/dma.h>
+#include <mach/memory.h>
+
+#include "lf1000-pcm.h"
+
+#define LF1000_PCM_NUM_STREAMS	2
+
+#define DRIVER_NAME	"lf1000-pcm"
+
+#ifdef CONFIG_SND_LF1000_SOC_DEBUG
+#define dbg(x...)	printk(KERN_ALERT DRIVER_NAME ": " x)
+#else
+#define dbg(x...)
+#endif
+
+struct lf1000_runtime_data {
+	spinlock_t lock;
+	unsigned int dma_ch;
+	dma_addr_t dma_buf;
+	struct lf1000_pcm_dma_params *params;
+};
+
+static const struct snd_pcm_hardware lf1000_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_BLOCK_TRANSFER |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE | 
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 1,
+	.channels_max		= LF1000_PCM_NUM_STREAMS,
+	.period_bytes_min	= 64,
+	.period_bytes_max	= 1024 * 16,
+	.periods_min		= 1,
+	.periods_max		= 32,
+	.buffer_bytes_max	= 64 * 1024,
+	.fifo_size		= 16,
+};
+
+static irqreturn_t lf1000_pcm_irqhandler(int ch, void *data)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	if (substream)
+		snd_pcm_period_elapsed(substream);
+	
+	return IRQ_HANDLED;
+}
+
+static int lf1000_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lf1000_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lf1000_pcm_dma_params *dma = rtd->dai->cpu_dai->dma_data;
+	unsigned long totbytes = params_buffer_bytes(params);
+	int ret = 0;
+  
+	dbg("%s.%d enter %p(%d)\n", __FUNCTION__, __LINE__, substream,
+		substream->stream);
+
+	if (!dma) {
+		dbg("%s.%d no dma\n", __FUNCTION__, __LINE__);
+		return 0;
+	}
+
+	/* this may get called several times by oss emulation with different params -HW */
+	if (prtd->params == NULL) {
+
+		ret = dma_request("ASoC", DMA_PRIORITY_LV1,
+				lf1000_pcm_irqhandler, substream, &prtd->dma_ch);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	prtd->params = dma;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	runtime->dma_bytes = totbytes;
+
+	spin_lock_irq(&prtd->lock);
+	prtd->dma_buf = runtime->dma_addr;
+	spin_unlock_irq(&prtd->lock);
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lf1000_runtime_data *prtd = substream->runtime->private_data;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+	if (prtd->dma_ch) {
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		dma_release(prtd->dma_ch);
+		prtd->dma_ch = 0;
+	}
+	return 0;
+}
+
+static int lf1000_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lf1000_runtime_data *prtd = runtime->private_data;
+	struct dma_control ctrl;
+	dma_addr_t addr_list[256], buf_addr;
+	int ret = 0;
+	int size, i;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	if (!prtd || !prtd->params) {
+		dbg("%s invalid params\n", __FUNCTION__);
+		return 0;
+	}
+
+	// get one frame size (bytes)
+	size = frames_to_bytes(runtime, runtime->period_size);
+	/* insert data */
+	dbg("%d %d %d %d %d %d\n",
+		(int)runtime->buffer_size,
+		(int)runtime->periods,
+		(int)runtime->period_size,
+		(int)runtime->period_step,
+		runtime->frame_bits, size);
+
+	buf_addr = prtd->dma_buf;
+
+	for (i = 0; i < runtime->periods; i++) {
+		addr_list[i] = buf_addr;
+		buf_addr += size;
+	}
+
+	memset(&ctrl, 0, sizeof(struct dma_control));
+
+	dma_transfer_init(prtd->dma_ch, DMA_MEM_MAPPED);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		ctrl.transfer = DMA_MEM_TO_IO;
+		ctrl.interrupt = DMA_INT_EVERY_BLOCK;
+		ctrl.request_id = DMA_PERI_PCMOUT;
+		ctrl.io_addr_inc = 0;
+		ctrl.src_width = runtime->frame_bits / 8;
+		ctrl.dest_width = runtime->frame_bits / 8;
+
+		dbg("%s DMA circular write from %X to %X, %d bufs of %d\n",
+				__FUNCTION__, runtime->dma_addr,
+				prtd->params->dma_addr, runtime->periods,
+				size);
+
+		ret = dma_circ_write(prtd->dma_ch, (unsigned int *)addr_list,
+				prtd->params->dma_addr, runtime->periods, size,
+				&ctrl);
+	} else {
+		ctrl.transfer = DMA_IO_TO_MEM;
+		ctrl.interrupt = DMA_INT_EVERY_BLOCK;
+		ctrl.request_id = DMA_PERI_PCMIN;
+		ctrl.io_addr_inc = 0;
+		ctrl.src_width = runtime->frame_bits / 8;
+		ctrl.dest_width = runtime->frame_bits / 8;
+		
+		
+		dbg("%s DMA circular read from %X to %X, %d bufs of 0x%X\n",
+				__FUNCTION__, prtd->params->dma_addr,
+				runtime->dma_addr, runtime->periods,
+				size);
+
+		ret = dma_circ_read(prtd->dma_ch, prtd->params->dma_addr,
+				(unsigned int *)addr_list, runtime->periods, size,
+				&ctrl);
+	}
+
+	dbg("%s.%d leaving (ret=%d)\n", __FUNCTION__, __LINE__, ret);
+	return ret;
+}
+
+static int lf1000_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct lf1000_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	spin_lock(&prtd->lock);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		ret = dma_start(prtd->dma_ch);
+		dbg("%s dma_start ret=%d\n", __FUNCTION__, ret);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		ret = dma_stop(prtd->dma_ch);
+		dbg("%s dma_stop ret=%d\n", __FUNCTION__, ret);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&prtd->lock);
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return ret;
+}
+
+static snd_pcm_uframes_t lf1000_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lf1000_runtime_data *prtd = runtime->private_data;
+	u32 ptr;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	spin_lock(&prtd->lock);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ptr = dma_get_write_addr(prtd->dma_ch) - prtd->dma_buf;
+	else
+		ptr = dma_get_read_addr(prtd->dma_ch) - prtd->dma_buf;
+
+	spin_unlock(&prtd->lock);
+
+	if (ptr >= snd_pcm_lib_buffer_bytes(substream)) {
+		ptr = 0;
+	}
+
+	dbg("%s.%d leaving ptr=%u frames=%u\n", __FUNCTION__, __LINE__, ptr,
+		bytes_to_frames(runtime, ptr));
+	return bytes_to_frames(runtime, ptr);
+}
+
+static int lf1000_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lf1000_runtime_data *prtd;
+
+	dbg("%s.%d enter", __FUNCTION__, __LINE__);
+
+	snd_soc_set_runtime_hwparams(substream, &lf1000_pcm_hardware);
+
+	snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+
+	prtd = kzalloc(sizeof(struct lf1000_runtime_data), GFP_KERNEL);
+
+	if (prtd == NULL) {
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&prtd->lock);
+
+	runtime->private_data = prtd;
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static int lf1000_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lf1000_runtime_data *prtd = substream->runtime->private_data;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	WARN_ON(!prtd);
+
+	kfree(prtd);
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+
+
+static int lf1000_pcm_mmap(struct snd_pcm_substream *substream,
+		struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+	
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+struct snd_pcm_ops lf1000_pcm_ops = {
+	.open		= lf1000_pcm_open,
+	.close		= lf1000_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= lf1000_pcm_hw_params,
+	.hw_free	= lf1000_pcm_hw_free,
+	.prepare	= lf1000_pcm_prepare,
+	.trigger	= lf1000_pcm_trigger,
+	.pointer	= lf1000_pcm_pointer,
+	.mmap		= lf1000_pcm_mmap,
+};
+
+static int lf1000_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = lf1000_pcm_hardware.buffer_bytes_max;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_writecombine(pcm->card->dev, size, &buf->addr,
+			GFP_KERNEL | GFP_DMA);
+	if (!buf->area)
+		return -ENOMEM;
+	
+	if (!lf1000_is_shadow())
+		buf->addr |= PHYS_OFFSET_NO_SHADOW;
+
+	buf->bytes = size;
+
+	dbg("%s leaving dma_buffer = 0x%X\n", __FUNCTION__, buf->addr);
+	return 0;
+}
+
+static void lf1000_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+	for (stream = 0; stream < LF1000_PCM_NUM_STREAMS; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes, buf->area,
+				buf->addr);
+		buf->area = NULL;
+	}
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+}
+
+static u64 lf1000_pcm_dmamask = DMA_BIT_MASK(32);
+
+static int lf1000_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+		struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lf1000_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	if (dai->playback.channels_min) {
+		ret = lf1000_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			return ret;
+	}
+	
+	if (dai->capture.channels_min) {
+		ret = lf1000_pcm_preallocate_dma_buffer(pcm,
+				SNDRV_PCM_STREAM_CAPTURE);
+	}
+
+	dbg("%s.%d leaving\n", __FUNCTION__, __LINE__);
+	return ret;
+}
+
+
+int lf1000_pcm_probe(struct platform_device *pdev)
+{
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+int lf1000_pcm_remove(struct platform_device *pdev)
+{
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+int lf1000_pcm_suspend(struct snd_soc_dai *dai)
+{
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+int lf1000_pcm_resume(struct snd_soc_dai *dai)
+{
+	dbg("%s.%d enter\n", __FUNCTION__, __LINE__);
+
+	return 0;
+}
+
+struct snd_soc_platform lf1000_soc_platform = {
+	.name		= DRIVER_NAME,
+	.probe		= lf1000_pcm_probe,
+	.remove		= lf1000_pcm_remove,
+	.suspend	= lf1000_pcm_suspend,
+	.resume		= lf1000_pcm_resume,
+	.pcm_ops	= &lf1000_pcm_ops,
+	.pcm_new	= lf1000_pcm_new,
+	.pcm_free	= lf1000_pcm_free_dma_buffers,
+};
+
+EXPORT_SYMBOL_GPL(lf1000_soc_platform);
+
+static int __init lf1000_soc_platform_init(void)
+{
+	return snd_soc_register_platform(&lf1000_soc_platform);
+}
+
+static void __exit lf1000_soc_platform_exit(void)
+{
+	snd_soc_unregister_platform(&lf1000_soc_platform);
+}
+
+module_init(lf1000_soc_platform_init);
+module_exit(lf1000_soc_platform_exit);
+
+
+MODULE_AUTHOR("Scott Esters");
+MODULE_DESCRIPTION("LF1000 SoC driver");
+MODULE_LICENSE("GPL");
+
diff -ruaN linux-2.6.31/sound/soc/lf1000/lf1000-pcm.h linux-2.6/sound/soc/lf1000/lf1000-pcm.h
--- linux-2.6.31/sound/soc/lf1000/lf1000-pcm.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/lf1000-pcm.h	2011-05-13 20:39:37.000000000 -0700
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2011 Leapfrog Enterprises Inc.
+ *
+ * Scott Esters <sesters@leapfrog.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifndef __LF1000_PCM_H__
+#define __LF1000_PCM_H__
+enum {
+        AUDIO_NORMAL          = 0,      /* normal audio operation */
+        AUDIO_HEADPHONES_ONLY = 1,      /* headphones only on     */
+};
+
+enum {
+        MIXER_NORMAL          = 0,      /* normal mixer operation */
+        MIXER_MONO            = 1,      /* mixer always mono      */
+};
+
+struct lf1000_pcm_dma_params {
+	char *name;		/* device name */
+	dma_addr_t dma_addr;	/* physical address */
+	int dma_size;		/* Source / Dest width */
+};
+
+extern struct snd_soc_platform lf1000_soc_platform;
+
+#endif /* __LF1000_PCM_H__ */
diff -ruaN linux-2.6.31/sound/soc/lf1000/Makefile linux-2.6/sound/soc/lf1000/Makefile
--- linux-2.6.31/sound/soc/lf1000/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6/sound/soc/lf1000/Makefile	2011-01-04 14:39:04.000000000 -0800
@@ -0,0 +1,13 @@
+# LF1000 Platform Support
+snd-soc-lf1000-objs := lf1000-pcm.o
+snd-soc-lf1000-i2s-objs := lf1000-i2s.o
+
+obj-$(CONFIG_SND_LF1000_SOC) += snd-soc-lf1000.o
+obj-$(CONFIG_SND_LF1000_SOC_I2S) += snd-soc-lf1000-i2s.o
+
+# LF1000 Machine Support
+snd-soc-didj-cs43l22-objs := didj-cs43l22.o
+snd-soc-didj-lfp100-objs := didj-lfp100.o
+
+obj-$(CONFIG_SND_LF1000_SOC_DIDJ_CS43L22) += snd-soc-didj-cs43l22.o
+obj-$(CONFIG_SND_LF1000_SOC_DIDJ_LFP100) += snd-soc-didj-lfp100.o
diff -ruaN linux-2.6.31/sound/soc/Makefile linux-2.6/sound/soc/Makefile
--- linux-2.6.31/sound/soc/Makefile	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/sound/soc/Makefile	2011-01-04 14:35:46.000000000 -0800
@@ -13,3 +13,4 @@
 obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= lf1000/
diff -ruaN linux-2.6.31/sound/sound_core.c linux-2.6/sound/sound_core.c
--- linux-2.6.31/sound/sound_core.c	2009-09-09 15:13:59.000000000 -0700
+++ linux-2.6/sound/sound_core.c	2011-01-04 14:20:40.000000000 -0800
@@ -537,6 +537,7 @@
 	
 	spin_lock(&sound_loader_lock);
 	s = __look_for_unit(chain, unit);
+	WARN_ON(!s); /* FIXME: this should never happen */
 	if (s)
 		new_fops = fops_get(s->unit_fops);
 	if (!new_fops) {
